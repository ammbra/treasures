// Generated by jextract

package org.python;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class Python_h_1 extends Python_h_2 {

    Python_h_1() {
        // Should not be called directly
    }

    private static class PyMemoryView_FromObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMemoryView_FromObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyMemoryView_FromObject(PyObject *base)
     * }
     */
    public static FunctionDescriptor PyMemoryView_FromObject$descriptor() {
        return PyMemoryView_FromObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyMemoryView_FromObject(PyObject *base)
     * }
     */
    public static MethodHandle PyMemoryView_FromObject$handle() {
        return PyMemoryView_FromObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyMemoryView_FromObject(PyObject *base)
     * }
     */
    public static MemorySegment PyMemoryView_FromObject$address() {
        return PyMemoryView_FromObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyMemoryView_FromObject(PyObject *base)
     * }
     */
    public static MemorySegment PyMemoryView_FromObject(MemorySegment base) {
        var mh$ = PyMemoryView_FromObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMemoryView_FromObject", base);
            }
            return (MemorySegment)mh$.invokeExact(base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMemoryView_FromMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMemoryView_FromMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyMemoryView_FromMemory(char *mem, Py_ssize_t size, int flags)
     * }
     */
    public static FunctionDescriptor PyMemoryView_FromMemory$descriptor() {
        return PyMemoryView_FromMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyMemoryView_FromMemory(char *mem, Py_ssize_t size, int flags)
     * }
     */
    public static MethodHandle PyMemoryView_FromMemory$handle() {
        return PyMemoryView_FromMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyMemoryView_FromMemory(char *mem, Py_ssize_t size, int flags)
     * }
     */
    public static MemorySegment PyMemoryView_FromMemory$address() {
        return PyMemoryView_FromMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyMemoryView_FromMemory(char *mem, Py_ssize_t size, int flags)
     * }
     */
    public static MemorySegment PyMemoryView_FromMemory(MemorySegment mem, long size, int flags) {
        var mh$ = PyMemoryView_FromMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMemoryView_FromMemory", mem, size, flags);
            }
            return (MemorySegment)mh$.invokeExact(mem, size, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMemoryView_FromBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMemoryView_FromBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyMemoryView_FromBuffer(const Py_buffer *info)
     * }
     */
    public static FunctionDescriptor PyMemoryView_FromBuffer$descriptor() {
        return PyMemoryView_FromBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyMemoryView_FromBuffer(const Py_buffer *info)
     * }
     */
    public static MethodHandle PyMemoryView_FromBuffer$handle() {
        return PyMemoryView_FromBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyMemoryView_FromBuffer(const Py_buffer *info)
     * }
     */
    public static MemorySegment PyMemoryView_FromBuffer$address() {
        return PyMemoryView_FromBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyMemoryView_FromBuffer(const Py_buffer *info)
     * }
     */
    public static MemorySegment PyMemoryView_FromBuffer(MemorySegment info) {
        var mh$ = PyMemoryView_FromBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMemoryView_FromBuffer", info);
            }
            return (MemorySegment)mh$.invokeExact(info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMemoryView_GetContiguous {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_CHAR
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMemoryView_GetContiguous");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyMemoryView_GetContiguous(PyObject *base, int buffertype, char order)
     * }
     */
    public static FunctionDescriptor PyMemoryView_GetContiguous$descriptor() {
        return PyMemoryView_GetContiguous.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyMemoryView_GetContiguous(PyObject *base, int buffertype, char order)
     * }
     */
    public static MethodHandle PyMemoryView_GetContiguous$handle() {
        return PyMemoryView_GetContiguous.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyMemoryView_GetContiguous(PyObject *base, int buffertype, char order)
     * }
     */
    public static MemorySegment PyMemoryView_GetContiguous$address() {
        return PyMemoryView_GetContiguous.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyMemoryView_GetContiguous(PyObject *base, int buffertype, char order)
     * }
     */
    public static MemorySegment PyMemoryView_GetContiguous(MemorySegment base, int buffertype, byte order) {
        var mh$ = PyMemoryView_GetContiguous.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMemoryView_GetContiguous", base, buffertype, order);
            }
            return (MemorySegment)mh$.invokeExact(base, buffertype, order);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyTuple_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyTuple_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyTuple_Type
     * }
     */
    public static GroupLayout PyTuple_Type$layout() {
        return PyTuple_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyTuple_Type
     * }
     */
    public static MemorySegment PyTuple_Type() {
        return PyTuple_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyTuple_Type
     * }
     */
    public static void PyTuple_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyTuple_Type$constants.SEGMENT, 0L, PyTuple_Type$constants.LAYOUT.byteSize());
    }

    private static class PyTupleIter_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyTupleIter_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyTupleIter_Type
     * }
     */
    public static GroupLayout PyTupleIter_Type$layout() {
        return PyTupleIter_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyTupleIter_Type
     * }
     */
    public static MemorySegment PyTupleIter_Type() {
        return PyTupleIter_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyTupleIter_Type
     * }
     */
    public static void PyTupleIter_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyTupleIter_Type$constants.SEGMENT, 0L, PyTupleIter_Type$constants.LAYOUT.byteSize());
    }

    private static class PyTuple_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyTuple_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyTuple_New(Py_ssize_t size)
     * }
     */
    public static FunctionDescriptor PyTuple_New$descriptor() {
        return PyTuple_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyTuple_New(Py_ssize_t size)
     * }
     */
    public static MethodHandle PyTuple_New$handle() {
        return PyTuple_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyTuple_New(Py_ssize_t size)
     * }
     */
    public static MemorySegment PyTuple_New$address() {
        return PyTuple_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyTuple_New(Py_ssize_t size)
     * }
     */
    public static MemorySegment PyTuple_New(long size) {
        var mh$ = PyTuple_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyTuple_New", size);
            }
            return (MemorySegment)mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyTuple_Size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyTuple_Size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyTuple_Size(PyObject *)
     * }
     */
    public static FunctionDescriptor PyTuple_Size$descriptor() {
        return PyTuple_Size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyTuple_Size(PyObject *)
     * }
     */
    public static MethodHandle PyTuple_Size$handle() {
        return PyTuple_Size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyTuple_Size(PyObject *)
     * }
     */
    public static MemorySegment PyTuple_Size$address() {
        return PyTuple_Size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyTuple_Size(PyObject *)
     * }
     */
    public static long PyTuple_Size(MemorySegment x0) {
        var mh$ = PyTuple_Size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyTuple_Size", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyTuple_GetItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyTuple_GetItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyTuple_GetItem(PyObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyTuple_GetItem$descriptor() {
        return PyTuple_GetItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyTuple_GetItem(PyObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyTuple_GetItem$handle() {
        return PyTuple_GetItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyTuple_GetItem(PyObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyTuple_GetItem$address() {
        return PyTuple_GetItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyTuple_GetItem(PyObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyTuple_GetItem(MemorySegment x0, long x1) {
        var mh$ = PyTuple_GetItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyTuple_GetItem", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyTuple_SetItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyTuple_SetItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyTuple_SetItem(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static FunctionDescriptor PyTuple_SetItem$descriptor() {
        return PyTuple_SetItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyTuple_SetItem(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static MethodHandle PyTuple_SetItem$handle() {
        return PyTuple_SetItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyTuple_SetItem(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static MemorySegment PyTuple_SetItem$address() {
        return PyTuple_SetItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyTuple_SetItem(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static int PyTuple_SetItem(MemorySegment x0, long x1, MemorySegment x2) {
        var mh$ = PyTuple_SetItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyTuple_SetItem", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyTuple_GetSlice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyTuple_GetSlice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyTuple_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyTuple_GetSlice$descriptor() {
        return PyTuple_GetSlice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyTuple_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t)
     * }
     */
    public static MethodHandle PyTuple_GetSlice$handle() {
        return PyTuple_GetSlice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyTuple_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t)
     * }
     */
    public static MemorySegment PyTuple_GetSlice$address() {
        return PyTuple_GetSlice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyTuple_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t)
     * }
     */
    public static MemorySegment PyTuple_GetSlice(MemorySegment x0, long x1, long x2) {
        var mh$ = PyTuple_GetSlice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyTuple_GetSlice", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *PyTuple_Pack(Py_ssize_t, ...)
     * }
     */
    public static class PyTuple_Pack {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_LONG
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyTuple_Pack");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyTuple_Pack(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *PyTuple_Pack(Py_ssize_t, ...)
         * }
         */
        public static PyTuple_Pack makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyTuple_Pack(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(long x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyTuple_Pack", x0, x1);
                }
                return (MemorySegment)spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class _PyTuple_Resize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTuple_Resize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyTuple_Resize(PyObject **, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor _PyTuple_Resize$descriptor() {
        return _PyTuple_Resize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyTuple_Resize(PyObject **, Py_ssize_t)
     * }
     */
    public static MethodHandle _PyTuple_Resize$handle() {
        return _PyTuple_Resize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyTuple_Resize(PyObject **, Py_ssize_t)
     * }
     */
    public static MemorySegment _PyTuple_Resize$address() {
        return _PyTuple_Resize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyTuple_Resize(PyObject **, Py_ssize_t)
     * }
     */
    public static int _PyTuple_Resize(MemorySegment x0, long x1) {
        var mh$ = _PyTuple_Resize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTuple_Resize", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTuple_MaybeUntrack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTuple_MaybeUntrack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyTuple_MaybeUntrack(PyObject *)
     * }
     */
    public static FunctionDescriptor _PyTuple_MaybeUntrack$descriptor() {
        return _PyTuple_MaybeUntrack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyTuple_MaybeUntrack(PyObject *)
     * }
     */
    public static MethodHandle _PyTuple_MaybeUntrack$handle() {
        return _PyTuple_MaybeUntrack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyTuple_MaybeUntrack(PyObject *)
     * }
     */
    public static MemorySegment _PyTuple_MaybeUntrack$address() {
        return _PyTuple_MaybeUntrack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyTuple_MaybeUntrack(PyObject *)
     * }
     */
    public static void _PyTuple_MaybeUntrack(MemorySegment x0) {
        var mh$ = _PyTuple_MaybeUntrack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTuple_MaybeUntrack", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTuple_DebugMallocStats {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTuple_DebugMallocStats");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyTuple_DebugMallocStats(FILE *out)
     * }
     */
    public static FunctionDescriptor _PyTuple_DebugMallocStats$descriptor() {
        return _PyTuple_DebugMallocStats.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyTuple_DebugMallocStats(FILE *out)
     * }
     */
    public static MethodHandle _PyTuple_DebugMallocStats$handle() {
        return _PyTuple_DebugMallocStats.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyTuple_DebugMallocStats(FILE *out)
     * }
     */
    public static MemorySegment _PyTuple_DebugMallocStats$address() {
        return _PyTuple_DebugMallocStats.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyTuple_DebugMallocStats(FILE *out)
     * }
     */
    public static void _PyTuple_DebugMallocStats(MemorySegment out) {
        var mh$ = _PyTuple_DebugMallocStats.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTuple_DebugMallocStats", out);
            }
            mh$.invokeExact(out);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyList_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyList_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyList_Type
     * }
     */
    public static GroupLayout PyList_Type$layout() {
        return PyList_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyList_Type
     * }
     */
    public static MemorySegment PyList_Type() {
        return PyList_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyList_Type
     * }
     */
    public static void PyList_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyList_Type$constants.SEGMENT, 0L, PyList_Type$constants.LAYOUT.byteSize());
    }

    private static class PyListIter_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyListIter_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyListIter_Type
     * }
     */
    public static GroupLayout PyListIter_Type$layout() {
        return PyListIter_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyListIter_Type
     * }
     */
    public static MemorySegment PyListIter_Type() {
        return PyListIter_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyListIter_Type
     * }
     */
    public static void PyListIter_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyListIter_Type$constants.SEGMENT, 0L, PyListIter_Type$constants.LAYOUT.byteSize());
    }

    private static class PyListRevIter_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyListRevIter_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyListRevIter_Type
     * }
     */
    public static GroupLayout PyListRevIter_Type$layout() {
        return PyListRevIter_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyListRevIter_Type
     * }
     */
    public static MemorySegment PyListRevIter_Type() {
        return PyListRevIter_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyListRevIter_Type
     * }
     */
    public static void PyListRevIter_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyListRevIter_Type$constants.SEGMENT, 0L, PyListRevIter_Type$constants.LAYOUT.byteSize());
    }

    private static class PyList_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyList_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyList_New(Py_ssize_t size)
     * }
     */
    public static FunctionDescriptor PyList_New$descriptor() {
        return PyList_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyList_New(Py_ssize_t size)
     * }
     */
    public static MethodHandle PyList_New$handle() {
        return PyList_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyList_New(Py_ssize_t size)
     * }
     */
    public static MemorySegment PyList_New$address() {
        return PyList_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyList_New(Py_ssize_t size)
     * }
     */
    public static MemorySegment PyList_New(long size) {
        var mh$ = PyList_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyList_New", size);
            }
            return (MemorySegment)mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyList_Size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyList_Size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyList_Size(PyObject *)
     * }
     */
    public static FunctionDescriptor PyList_Size$descriptor() {
        return PyList_Size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyList_Size(PyObject *)
     * }
     */
    public static MethodHandle PyList_Size$handle() {
        return PyList_Size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyList_Size(PyObject *)
     * }
     */
    public static MemorySegment PyList_Size$address() {
        return PyList_Size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyList_Size(PyObject *)
     * }
     */
    public static long PyList_Size(MemorySegment x0) {
        var mh$ = PyList_Size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyList_Size", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyList_GetItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyList_GetItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyList_GetItem(PyObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyList_GetItem$descriptor() {
        return PyList_GetItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyList_GetItem(PyObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyList_GetItem$handle() {
        return PyList_GetItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyList_GetItem(PyObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyList_GetItem$address() {
        return PyList_GetItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyList_GetItem(PyObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyList_GetItem(MemorySegment x0, long x1) {
        var mh$ = PyList_GetItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyList_GetItem", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyList_SetItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyList_SetItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyList_SetItem(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static FunctionDescriptor PyList_SetItem$descriptor() {
        return PyList_SetItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyList_SetItem(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static MethodHandle PyList_SetItem$handle() {
        return PyList_SetItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyList_SetItem(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static MemorySegment PyList_SetItem$address() {
        return PyList_SetItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyList_SetItem(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static int PyList_SetItem(MemorySegment x0, long x1, MemorySegment x2) {
        var mh$ = PyList_SetItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyList_SetItem", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyList_Insert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyList_Insert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyList_Insert(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static FunctionDescriptor PyList_Insert$descriptor() {
        return PyList_Insert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyList_Insert(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static MethodHandle PyList_Insert$handle() {
        return PyList_Insert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyList_Insert(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static MemorySegment PyList_Insert$address() {
        return PyList_Insert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyList_Insert(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static int PyList_Insert(MemorySegment x0, long x1, MemorySegment x2) {
        var mh$ = PyList_Insert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyList_Insert", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyList_Append {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyList_Append");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyList_Append(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyList_Append$descriptor() {
        return PyList_Append.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyList_Append(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyList_Append$handle() {
        return PyList_Append.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyList_Append(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyList_Append$address() {
        return PyList_Append.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyList_Append(PyObject *, PyObject *)
     * }
     */
    public static int PyList_Append(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyList_Append.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyList_Append", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyList_GetSlice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyList_GetSlice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyList_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyList_GetSlice$descriptor() {
        return PyList_GetSlice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyList_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t)
     * }
     */
    public static MethodHandle PyList_GetSlice$handle() {
        return PyList_GetSlice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyList_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t)
     * }
     */
    public static MemorySegment PyList_GetSlice$address() {
        return PyList_GetSlice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyList_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t)
     * }
     */
    public static MemorySegment PyList_GetSlice(MemorySegment x0, long x1, long x2) {
        var mh$ = PyList_GetSlice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyList_GetSlice", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyList_SetSlice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyList_SetSlice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyList_SetSlice(PyObject *, Py_ssize_t, Py_ssize_t, PyObject *)
     * }
     */
    public static FunctionDescriptor PyList_SetSlice$descriptor() {
        return PyList_SetSlice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyList_SetSlice(PyObject *, Py_ssize_t, Py_ssize_t, PyObject *)
     * }
     */
    public static MethodHandle PyList_SetSlice$handle() {
        return PyList_SetSlice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyList_SetSlice(PyObject *, Py_ssize_t, Py_ssize_t, PyObject *)
     * }
     */
    public static MemorySegment PyList_SetSlice$address() {
        return PyList_SetSlice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyList_SetSlice(PyObject *, Py_ssize_t, Py_ssize_t, PyObject *)
     * }
     */
    public static int PyList_SetSlice(MemorySegment x0, long x1, long x2, MemorySegment x3) {
        var mh$ = PyList_SetSlice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyList_SetSlice", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyList_Sort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyList_Sort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyList_Sort(PyObject *)
     * }
     */
    public static FunctionDescriptor PyList_Sort$descriptor() {
        return PyList_Sort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyList_Sort(PyObject *)
     * }
     */
    public static MethodHandle PyList_Sort$handle() {
        return PyList_Sort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyList_Sort(PyObject *)
     * }
     */
    public static MemorySegment PyList_Sort$address() {
        return PyList_Sort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyList_Sort(PyObject *)
     * }
     */
    public static int PyList_Sort(MemorySegment x0) {
        var mh$ = PyList_Sort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyList_Sort", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyList_Reverse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyList_Reverse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyList_Reverse(PyObject *)
     * }
     */
    public static FunctionDescriptor PyList_Reverse$descriptor() {
        return PyList_Reverse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyList_Reverse(PyObject *)
     * }
     */
    public static MethodHandle PyList_Reverse$handle() {
        return PyList_Reverse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyList_Reverse(PyObject *)
     * }
     */
    public static MemorySegment PyList_Reverse$address() {
        return PyList_Reverse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyList_Reverse(PyObject *)
     * }
     */
    public static int PyList_Reverse(MemorySegment x0) {
        var mh$ = PyList_Reverse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyList_Reverse", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyList_AsTuple {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyList_AsTuple");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyList_AsTuple(PyObject *)
     * }
     */
    public static FunctionDescriptor PyList_AsTuple$descriptor() {
        return PyList_AsTuple.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyList_AsTuple(PyObject *)
     * }
     */
    public static MethodHandle PyList_AsTuple$handle() {
        return PyList_AsTuple.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyList_AsTuple(PyObject *)
     * }
     */
    public static MemorySegment PyList_AsTuple$address() {
        return PyList_AsTuple.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyList_AsTuple(PyObject *)
     * }
     */
    public static MemorySegment PyList_AsTuple(MemorySegment x0) {
        var mh$ = PyList_AsTuple.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyList_AsTuple", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyList_Extend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyList_Extend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyList_Extend(PyListObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor _PyList_Extend$descriptor() {
        return _PyList_Extend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyList_Extend(PyListObject *, PyObject *)
     * }
     */
    public static MethodHandle _PyList_Extend$handle() {
        return _PyList_Extend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyList_Extend(PyListObject *, PyObject *)
     * }
     */
    public static MemorySegment _PyList_Extend$address() {
        return _PyList_Extend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyList_Extend(PyListObject *, PyObject *)
     * }
     */
    public static MemorySegment _PyList_Extend(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyList_Extend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyList_Extend", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyList_DebugMallocStats {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyList_DebugMallocStats");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyList_DebugMallocStats(FILE *out)
     * }
     */
    public static FunctionDescriptor _PyList_DebugMallocStats$descriptor() {
        return _PyList_DebugMallocStats.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyList_DebugMallocStats(FILE *out)
     * }
     */
    public static MethodHandle _PyList_DebugMallocStats$handle() {
        return _PyList_DebugMallocStats.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyList_DebugMallocStats(FILE *out)
     * }
     */
    public static MemorySegment _PyList_DebugMallocStats$address() {
        return _PyList_DebugMallocStats.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyList_DebugMallocStats(FILE *out)
     * }
     */
    public static void _PyList_DebugMallocStats(MemorySegment out) {
        var mh$ = _PyList_DebugMallocStats.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyList_DebugMallocStats", out);
            }
            mh$.invokeExact(out);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyDict_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDict_Type
     * }
     */
    public static GroupLayout PyDict_Type$layout() {
        return PyDict_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDict_Type
     * }
     */
    public static MemorySegment PyDict_Type() {
        return PyDict_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDict_Type
     * }
     */
    public static void PyDict_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyDict_Type$constants.SEGMENT, 0L, PyDict_Type$constants.LAYOUT.byteSize());
    }

    private static class PyDict_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyDict_New()
     * }
     */
    public static FunctionDescriptor PyDict_New$descriptor() {
        return PyDict_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyDict_New()
     * }
     */
    public static MethodHandle PyDict_New$handle() {
        return PyDict_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyDict_New()
     * }
     */
    public static MemorySegment PyDict_New$address() {
        return PyDict_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyDict_New()
     * }
     */
    public static MemorySegment PyDict_New() {
        var mh$ = PyDict_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_New");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_GetItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_GetItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyDict_GetItem(PyObject *mp, PyObject *key)
     * }
     */
    public static FunctionDescriptor PyDict_GetItem$descriptor() {
        return PyDict_GetItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyDict_GetItem(PyObject *mp, PyObject *key)
     * }
     */
    public static MethodHandle PyDict_GetItem$handle() {
        return PyDict_GetItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyDict_GetItem(PyObject *mp, PyObject *key)
     * }
     */
    public static MemorySegment PyDict_GetItem$address() {
        return PyDict_GetItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyDict_GetItem(PyObject *mp, PyObject *key)
     * }
     */
    public static MemorySegment PyDict_GetItem(MemorySegment mp, MemorySegment key) {
        var mh$ = PyDict_GetItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_GetItem", mp, key);
            }
            return (MemorySegment)mh$.invokeExact(mp, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_GetItemWithError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_GetItemWithError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyDict_GetItemWithError(PyObject *mp, PyObject *key)
     * }
     */
    public static FunctionDescriptor PyDict_GetItemWithError$descriptor() {
        return PyDict_GetItemWithError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyDict_GetItemWithError(PyObject *mp, PyObject *key)
     * }
     */
    public static MethodHandle PyDict_GetItemWithError$handle() {
        return PyDict_GetItemWithError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyDict_GetItemWithError(PyObject *mp, PyObject *key)
     * }
     */
    public static MemorySegment PyDict_GetItemWithError$address() {
        return PyDict_GetItemWithError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyDict_GetItemWithError(PyObject *mp, PyObject *key)
     * }
     */
    public static MemorySegment PyDict_GetItemWithError(MemorySegment mp, MemorySegment key) {
        var mh$ = PyDict_GetItemWithError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_GetItemWithError", mp, key);
            }
            return (MemorySegment)mh$.invokeExact(mp, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_SetItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_SetItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyDict_SetItem(PyObject *mp, PyObject *key, PyObject *item)
     * }
     */
    public static FunctionDescriptor PyDict_SetItem$descriptor() {
        return PyDict_SetItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyDict_SetItem(PyObject *mp, PyObject *key, PyObject *item)
     * }
     */
    public static MethodHandle PyDict_SetItem$handle() {
        return PyDict_SetItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyDict_SetItem(PyObject *mp, PyObject *key, PyObject *item)
     * }
     */
    public static MemorySegment PyDict_SetItem$address() {
        return PyDict_SetItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyDict_SetItem(PyObject *mp, PyObject *key, PyObject *item)
     * }
     */
    public static int PyDict_SetItem(MemorySegment mp, MemorySegment key, MemorySegment item) {
        var mh$ = PyDict_SetItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_SetItem", mp, key, item);
            }
            return (int)mh$.invokeExact(mp, key, item);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_DelItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_DelItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyDict_DelItem(PyObject *mp, PyObject *key)
     * }
     */
    public static FunctionDescriptor PyDict_DelItem$descriptor() {
        return PyDict_DelItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyDict_DelItem(PyObject *mp, PyObject *key)
     * }
     */
    public static MethodHandle PyDict_DelItem$handle() {
        return PyDict_DelItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyDict_DelItem(PyObject *mp, PyObject *key)
     * }
     */
    public static MemorySegment PyDict_DelItem$address() {
        return PyDict_DelItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyDict_DelItem(PyObject *mp, PyObject *key)
     * }
     */
    public static int PyDict_DelItem(MemorySegment mp, MemorySegment key) {
        var mh$ = PyDict_DelItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_DelItem", mp, key);
            }
            return (int)mh$.invokeExact(mp, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_Clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_Clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyDict_Clear(PyObject *mp)
     * }
     */
    public static FunctionDescriptor PyDict_Clear$descriptor() {
        return PyDict_Clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyDict_Clear(PyObject *mp)
     * }
     */
    public static MethodHandle PyDict_Clear$handle() {
        return PyDict_Clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyDict_Clear(PyObject *mp)
     * }
     */
    public static MemorySegment PyDict_Clear$address() {
        return PyDict_Clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyDict_Clear(PyObject *mp)
     * }
     */
    public static void PyDict_Clear(MemorySegment mp) {
        var mh$ = PyDict_Clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_Clear", mp);
            }
            mh$.invokeExact(mp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_Next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_Next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyDict_Next(PyObject *mp, Py_ssize_t *pos, PyObject **key, PyObject **value)
     * }
     */
    public static FunctionDescriptor PyDict_Next$descriptor() {
        return PyDict_Next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyDict_Next(PyObject *mp, Py_ssize_t *pos, PyObject **key, PyObject **value)
     * }
     */
    public static MethodHandle PyDict_Next$handle() {
        return PyDict_Next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyDict_Next(PyObject *mp, Py_ssize_t *pos, PyObject **key, PyObject **value)
     * }
     */
    public static MemorySegment PyDict_Next$address() {
        return PyDict_Next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyDict_Next(PyObject *mp, Py_ssize_t *pos, PyObject **key, PyObject **value)
     * }
     */
    public static int PyDict_Next(MemorySegment mp, MemorySegment pos, MemorySegment key, MemorySegment value) {
        var mh$ = PyDict_Next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_Next", mp, pos, key, value);
            }
            return (int)mh$.invokeExact(mp, pos, key, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_Keys {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_Keys");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyDict_Keys(PyObject *mp)
     * }
     */
    public static FunctionDescriptor PyDict_Keys$descriptor() {
        return PyDict_Keys.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyDict_Keys(PyObject *mp)
     * }
     */
    public static MethodHandle PyDict_Keys$handle() {
        return PyDict_Keys.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyDict_Keys(PyObject *mp)
     * }
     */
    public static MemorySegment PyDict_Keys$address() {
        return PyDict_Keys.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyDict_Keys(PyObject *mp)
     * }
     */
    public static MemorySegment PyDict_Keys(MemorySegment mp) {
        var mh$ = PyDict_Keys.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_Keys", mp);
            }
            return (MemorySegment)mh$.invokeExact(mp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_Values {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_Values");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyDict_Values(PyObject *mp)
     * }
     */
    public static FunctionDescriptor PyDict_Values$descriptor() {
        return PyDict_Values.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyDict_Values(PyObject *mp)
     * }
     */
    public static MethodHandle PyDict_Values$handle() {
        return PyDict_Values.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyDict_Values(PyObject *mp)
     * }
     */
    public static MemorySegment PyDict_Values$address() {
        return PyDict_Values.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyDict_Values(PyObject *mp)
     * }
     */
    public static MemorySegment PyDict_Values(MemorySegment mp) {
        var mh$ = PyDict_Values.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_Values", mp);
            }
            return (MemorySegment)mh$.invokeExact(mp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_Items {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_Items");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyDict_Items(PyObject *mp)
     * }
     */
    public static FunctionDescriptor PyDict_Items$descriptor() {
        return PyDict_Items.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyDict_Items(PyObject *mp)
     * }
     */
    public static MethodHandle PyDict_Items$handle() {
        return PyDict_Items.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyDict_Items(PyObject *mp)
     * }
     */
    public static MemorySegment PyDict_Items$address() {
        return PyDict_Items.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyDict_Items(PyObject *mp)
     * }
     */
    public static MemorySegment PyDict_Items(MemorySegment mp) {
        var mh$ = PyDict_Items.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_Items", mp);
            }
            return (MemorySegment)mh$.invokeExact(mp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_Size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_Size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyDict_Size(PyObject *mp)
     * }
     */
    public static FunctionDescriptor PyDict_Size$descriptor() {
        return PyDict_Size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyDict_Size(PyObject *mp)
     * }
     */
    public static MethodHandle PyDict_Size$handle() {
        return PyDict_Size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyDict_Size(PyObject *mp)
     * }
     */
    public static MemorySegment PyDict_Size$address() {
        return PyDict_Size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyDict_Size(PyObject *mp)
     * }
     */
    public static long PyDict_Size(MemorySegment mp) {
        var mh$ = PyDict_Size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_Size", mp);
            }
            return (long)mh$.invokeExact(mp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_Copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_Copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyDict_Copy(PyObject *mp)
     * }
     */
    public static FunctionDescriptor PyDict_Copy$descriptor() {
        return PyDict_Copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyDict_Copy(PyObject *mp)
     * }
     */
    public static MethodHandle PyDict_Copy$handle() {
        return PyDict_Copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyDict_Copy(PyObject *mp)
     * }
     */
    public static MemorySegment PyDict_Copy$address() {
        return PyDict_Copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyDict_Copy(PyObject *mp)
     * }
     */
    public static MemorySegment PyDict_Copy(MemorySegment mp) {
        var mh$ = PyDict_Copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_Copy", mp);
            }
            return (MemorySegment)mh$.invokeExact(mp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_Contains {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_Contains");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyDict_Contains(PyObject *mp, PyObject *key)
     * }
     */
    public static FunctionDescriptor PyDict_Contains$descriptor() {
        return PyDict_Contains.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyDict_Contains(PyObject *mp, PyObject *key)
     * }
     */
    public static MethodHandle PyDict_Contains$handle() {
        return PyDict_Contains.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyDict_Contains(PyObject *mp, PyObject *key)
     * }
     */
    public static MemorySegment PyDict_Contains$address() {
        return PyDict_Contains.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyDict_Contains(PyObject *mp, PyObject *key)
     * }
     */
    public static int PyDict_Contains(MemorySegment mp, MemorySegment key) {
        var mh$ = PyDict_Contains.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_Contains", mp, key);
            }
            return (int)mh$.invokeExact(mp, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_Update {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_Update");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyDict_Update(PyObject *mp, PyObject *other)
     * }
     */
    public static FunctionDescriptor PyDict_Update$descriptor() {
        return PyDict_Update.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyDict_Update(PyObject *mp, PyObject *other)
     * }
     */
    public static MethodHandle PyDict_Update$handle() {
        return PyDict_Update.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyDict_Update(PyObject *mp, PyObject *other)
     * }
     */
    public static MemorySegment PyDict_Update$address() {
        return PyDict_Update.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyDict_Update(PyObject *mp, PyObject *other)
     * }
     */
    public static int PyDict_Update(MemorySegment mp, MemorySegment other) {
        var mh$ = PyDict_Update.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_Update", mp, other);
            }
            return (int)mh$.invokeExact(mp, other);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_Merge {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_Merge");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyDict_Merge(PyObject *mp, PyObject *other, int override)
     * }
     */
    public static FunctionDescriptor PyDict_Merge$descriptor() {
        return PyDict_Merge.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyDict_Merge(PyObject *mp, PyObject *other, int override)
     * }
     */
    public static MethodHandle PyDict_Merge$handle() {
        return PyDict_Merge.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyDict_Merge(PyObject *mp, PyObject *other, int override)
     * }
     */
    public static MemorySegment PyDict_Merge$address() {
        return PyDict_Merge.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyDict_Merge(PyObject *mp, PyObject *other, int override)
     * }
     */
    public static int PyDict_Merge(MemorySegment mp, MemorySegment other, int override) {
        var mh$ = PyDict_Merge.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_Merge", mp, other, override);
            }
            return (int)mh$.invokeExact(mp, other, override);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_MergeFromSeq2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_MergeFromSeq2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyDict_MergeFromSeq2(PyObject *d, PyObject *seq2, int override)
     * }
     */
    public static FunctionDescriptor PyDict_MergeFromSeq2$descriptor() {
        return PyDict_MergeFromSeq2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyDict_MergeFromSeq2(PyObject *d, PyObject *seq2, int override)
     * }
     */
    public static MethodHandle PyDict_MergeFromSeq2$handle() {
        return PyDict_MergeFromSeq2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyDict_MergeFromSeq2(PyObject *d, PyObject *seq2, int override)
     * }
     */
    public static MemorySegment PyDict_MergeFromSeq2$address() {
        return PyDict_MergeFromSeq2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyDict_MergeFromSeq2(PyObject *d, PyObject *seq2, int override)
     * }
     */
    public static int PyDict_MergeFromSeq2(MemorySegment d, MemorySegment seq2, int override) {
        var mh$ = PyDict_MergeFromSeq2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_MergeFromSeq2", d, seq2, override);
            }
            return (int)mh$.invokeExact(d, seq2, override);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_GetItemString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_GetItemString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyDict_GetItemString(PyObject *dp, const char *key)
     * }
     */
    public static FunctionDescriptor PyDict_GetItemString$descriptor() {
        return PyDict_GetItemString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyDict_GetItemString(PyObject *dp, const char *key)
     * }
     */
    public static MethodHandle PyDict_GetItemString$handle() {
        return PyDict_GetItemString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyDict_GetItemString(PyObject *dp, const char *key)
     * }
     */
    public static MemorySegment PyDict_GetItemString$address() {
        return PyDict_GetItemString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyDict_GetItemString(PyObject *dp, const char *key)
     * }
     */
    public static MemorySegment PyDict_GetItemString(MemorySegment dp, MemorySegment key) {
        var mh$ = PyDict_GetItemString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_GetItemString", dp, key);
            }
            return (MemorySegment)mh$.invokeExact(dp, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_SetItemString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_SetItemString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyDict_SetItemString(PyObject *dp, const char *key, PyObject *item)
     * }
     */
    public static FunctionDescriptor PyDict_SetItemString$descriptor() {
        return PyDict_SetItemString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyDict_SetItemString(PyObject *dp, const char *key, PyObject *item)
     * }
     */
    public static MethodHandle PyDict_SetItemString$handle() {
        return PyDict_SetItemString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyDict_SetItemString(PyObject *dp, const char *key, PyObject *item)
     * }
     */
    public static MemorySegment PyDict_SetItemString$address() {
        return PyDict_SetItemString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyDict_SetItemString(PyObject *dp, const char *key, PyObject *item)
     * }
     */
    public static int PyDict_SetItemString(MemorySegment dp, MemorySegment key, MemorySegment item) {
        var mh$ = PyDict_SetItemString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_SetItemString", dp, key, item);
            }
            return (int)mh$.invokeExact(dp, key, item);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_DelItemString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_DelItemString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyDict_DelItemString(PyObject *dp, const char *key)
     * }
     */
    public static FunctionDescriptor PyDict_DelItemString$descriptor() {
        return PyDict_DelItemString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyDict_DelItemString(PyObject *dp, const char *key)
     * }
     */
    public static MethodHandle PyDict_DelItemString$handle() {
        return PyDict_DelItemString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyDict_DelItemString(PyObject *dp, const char *key)
     * }
     */
    public static MemorySegment PyDict_DelItemString$address() {
        return PyDict_DelItemString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyDict_DelItemString(PyObject *dp, const char *key)
     * }
     */
    public static int PyDict_DelItemString(MemorySegment dp, MemorySegment key) {
        var mh$ = PyDict_DelItemString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_DelItemString", dp, key);
            }
            return (int)mh$.invokeExact(dp, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GenericGetDict {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GenericGetDict");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_GenericGetDict(PyObject *, void *)
     * }
     */
    public static FunctionDescriptor PyObject_GenericGetDict$descriptor() {
        return PyObject_GenericGetDict.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_GenericGetDict(PyObject *, void *)
     * }
     */
    public static MethodHandle PyObject_GenericGetDict$handle() {
        return PyObject_GenericGetDict.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_GenericGetDict(PyObject *, void *)
     * }
     */
    public static MemorySegment PyObject_GenericGetDict$address() {
        return PyObject_GenericGetDict.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_GenericGetDict(PyObject *, void *)
     * }
     */
    public static MemorySegment PyObject_GenericGetDict(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyObject_GenericGetDict.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GenericGetDict", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDictKeys_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyDictKeys_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictKeys_Type
     * }
     */
    public static GroupLayout PyDictKeys_Type$layout() {
        return PyDictKeys_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictKeys_Type
     * }
     */
    public static MemorySegment PyDictKeys_Type() {
        return PyDictKeys_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictKeys_Type
     * }
     */
    public static void PyDictKeys_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyDictKeys_Type$constants.SEGMENT, 0L, PyDictKeys_Type$constants.LAYOUT.byteSize());
    }

    private static class PyDictValues_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyDictValues_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictValues_Type
     * }
     */
    public static GroupLayout PyDictValues_Type$layout() {
        return PyDictValues_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictValues_Type
     * }
     */
    public static MemorySegment PyDictValues_Type() {
        return PyDictValues_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictValues_Type
     * }
     */
    public static void PyDictValues_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyDictValues_Type$constants.SEGMENT, 0L, PyDictValues_Type$constants.LAYOUT.byteSize());
    }

    private static class PyDictItems_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyDictItems_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictItems_Type
     * }
     */
    public static GroupLayout PyDictItems_Type$layout() {
        return PyDictItems_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictItems_Type
     * }
     */
    public static MemorySegment PyDictItems_Type() {
        return PyDictItems_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictItems_Type
     * }
     */
    public static void PyDictItems_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyDictItems_Type$constants.SEGMENT, 0L, PyDictItems_Type$constants.LAYOUT.byteSize());
    }

    private static class PyDictIterKey_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyDictIterKey_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictIterKey_Type
     * }
     */
    public static GroupLayout PyDictIterKey_Type$layout() {
        return PyDictIterKey_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictIterKey_Type
     * }
     */
    public static MemorySegment PyDictIterKey_Type() {
        return PyDictIterKey_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictIterKey_Type
     * }
     */
    public static void PyDictIterKey_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyDictIterKey_Type$constants.SEGMENT, 0L, PyDictIterKey_Type$constants.LAYOUT.byteSize());
    }

    private static class PyDictIterValue_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyDictIterValue_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictIterValue_Type
     * }
     */
    public static GroupLayout PyDictIterValue_Type$layout() {
        return PyDictIterValue_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictIterValue_Type
     * }
     */
    public static MemorySegment PyDictIterValue_Type() {
        return PyDictIterValue_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictIterValue_Type
     * }
     */
    public static void PyDictIterValue_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyDictIterValue_Type$constants.SEGMENT, 0L, PyDictIterValue_Type$constants.LAYOUT.byteSize());
    }

    private static class PyDictIterItem_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyDictIterItem_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictIterItem_Type
     * }
     */
    public static GroupLayout PyDictIterItem_Type$layout() {
        return PyDictIterItem_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictIterItem_Type
     * }
     */
    public static MemorySegment PyDictIterItem_Type() {
        return PyDictIterItem_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictIterItem_Type
     * }
     */
    public static void PyDictIterItem_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyDictIterItem_Type$constants.SEGMENT, 0L, PyDictIterItem_Type$constants.LAYOUT.byteSize());
    }

    private static class PyDictRevIterKey_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyDictRevIterKey_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictRevIterKey_Type
     * }
     */
    public static GroupLayout PyDictRevIterKey_Type$layout() {
        return PyDictRevIterKey_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictRevIterKey_Type
     * }
     */
    public static MemorySegment PyDictRevIterKey_Type() {
        return PyDictRevIterKey_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictRevIterKey_Type
     * }
     */
    public static void PyDictRevIterKey_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyDictRevIterKey_Type$constants.SEGMENT, 0L, PyDictRevIterKey_Type$constants.LAYOUT.byteSize());
    }

    private static class PyDictRevIterItem_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyDictRevIterItem_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictRevIterItem_Type
     * }
     */
    public static GroupLayout PyDictRevIterItem_Type$layout() {
        return PyDictRevIterItem_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictRevIterItem_Type
     * }
     */
    public static MemorySegment PyDictRevIterItem_Type() {
        return PyDictRevIterItem_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictRevIterItem_Type
     * }
     */
    public static void PyDictRevIterItem_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyDictRevIterItem_Type$constants.SEGMENT, 0L, PyDictRevIterItem_Type$constants.LAYOUT.byteSize());
    }

    private static class PyDictRevIterValue_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyDictRevIterValue_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictRevIterValue_Type
     * }
     */
    public static GroupLayout PyDictRevIterValue_Type$layout() {
        return PyDictRevIterValue_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictRevIterValue_Type
     * }
     */
    public static MemorySegment PyDictRevIterValue_Type() {
        return PyDictRevIterValue_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictRevIterValue_Type
     * }
     */
    public static void PyDictRevIterValue_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyDictRevIterValue_Type$constants.SEGMENT, 0L, PyDictRevIterValue_Type$constants.LAYOUT.byteSize());
    }

    private static class _PyDict_GetItem_KnownHash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyDict_GetItem_KnownHash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyDict_GetItem_KnownHash(PyObject *mp, PyObject *key, Py_hash_t hash)
     * }
     */
    public static FunctionDescriptor _PyDict_GetItem_KnownHash$descriptor() {
        return _PyDict_GetItem_KnownHash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyDict_GetItem_KnownHash(PyObject *mp, PyObject *key, Py_hash_t hash)
     * }
     */
    public static MethodHandle _PyDict_GetItem_KnownHash$handle() {
        return _PyDict_GetItem_KnownHash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyDict_GetItem_KnownHash(PyObject *mp, PyObject *key, Py_hash_t hash)
     * }
     */
    public static MemorySegment _PyDict_GetItem_KnownHash$address() {
        return _PyDict_GetItem_KnownHash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyDict_GetItem_KnownHash(PyObject *mp, PyObject *key, Py_hash_t hash)
     * }
     */
    public static MemorySegment _PyDict_GetItem_KnownHash(MemorySegment mp, MemorySegment key, long hash) {
        var mh$ = _PyDict_GetItem_KnownHash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyDict_GetItem_KnownHash", mp, key, hash);
            }
            return (MemorySegment)mh$.invokeExact(mp, key, hash);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyDict_GetItemWithError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyDict_GetItemWithError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyDict_GetItemWithError(PyObject *dp, PyObject *key)
     * }
     */
    public static FunctionDescriptor _PyDict_GetItemWithError$descriptor() {
        return _PyDict_GetItemWithError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyDict_GetItemWithError(PyObject *dp, PyObject *key)
     * }
     */
    public static MethodHandle _PyDict_GetItemWithError$handle() {
        return _PyDict_GetItemWithError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyDict_GetItemWithError(PyObject *dp, PyObject *key)
     * }
     */
    public static MemorySegment _PyDict_GetItemWithError$address() {
        return _PyDict_GetItemWithError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyDict_GetItemWithError(PyObject *dp, PyObject *key)
     * }
     */
    public static MemorySegment _PyDict_GetItemWithError(MemorySegment dp, MemorySegment key) {
        var mh$ = _PyDict_GetItemWithError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyDict_GetItemWithError", dp, key);
            }
            return (MemorySegment)mh$.invokeExact(dp, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyDict_GetItemIdWithError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyDict_GetItemIdWithError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyDict_GetItemIdWithError(PyObject *dp, _Py_Identifier *key)
     * }
     */
    public static FunctionDescriptor _PyDict_GetItemIdWithError$descriptor() {
        return _PyDict_GetItemIdWithError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyDict_GetItemIdWithError(PyObject *dp, _Py_Identifier *key)
     * }
     */
    public static MethodHandle _PyDict_GetItemIdWithError$handle() {
        return _PyDict_GetItemIdWithError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyDict_GetItemIdWithError(PyObject *dp, _Py_Identifier *key)
     * }
     */
    public static MemorySegment _PyDict_GetItemIdWithError$address() {
        return _PyDict_GetItemIdWithError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyDict_GetItemIdWithError(PyObject *dp, _Py_Identifier *key)
     * }
     */
    public static MemorySegment _PyDict_GetItemIdWithError(MemorySegment dp, MemorySegment key) {
        var mh$ = _PyDict_GetItemIdWithError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyDict_GetItemIdWithError", dp, key);
            }
            return (MemorySegment)mh$.invokeExact(dp, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyDict_GetItemStringWithError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyDict_GetItemStringWithError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyDict_GetItemStringWithError(PyObject *, const char *)
     * }
     */
    public static FunctionDescriptor _PyDict_GetItemStringWithError$descriptor() {
        return _PyDict_GetItemStringWithError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyDict_GetItemStringWithError(PyObject *, const char *)
     * }
     */
    public static MethodHandle _PyDict_GetItemStringWithError$handle() {
        return _PyDict_GetItemStringWithError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyDict_GetItemStringWithError(PyObject *, const char *)
     * }
     */
    public static MemorySegment _PyDict_GetItemStringWithError$address() {
        return _PyDict_GetItemStringWithError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyDict_GetItemStringWithError(PyObject *, const char *)
     * }
     */
    public static MemorySegment _PyDict_GetItemStringWithError(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyDict_GetItemStringWithError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyDict_GetItemStringWithError", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDict_SetDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDict_SetDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyDict_SetDefault(PyObject *mp, PyObject *key, PyObject *defaultobj)
     * }
     */
    public static FunctionDescriptor PyDict_SetDefault$descriptor() {
        return PyDict_SetDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyDict_SetDefault(PyObject *mp, PyObject *key, PyObject *defaultobj)
     * }
     */
    public static MethodHandle PyDict_SetDefault$handle() {
        return PyDict_SetDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyDict_SetDefault(PyObject *mp, PyObject *key, PyObject *defaultobj)
     * }
     */
    public static MemorySegment PyDict_SetDefault$address() {
        return PyDict_SetDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyDict_SetDefault(PyObject *mp, PyObject *key, PyObject *defaultobj)
     * }
     */
    public static MemorySegment PyDict_SetDefault(MemorySegment mp, MemorySegment key, MemorySegment defaultobj) {
        var mh$ = PyDict_SetDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDict_SetDefault", mp, key, defaultobj);
            }
            return (MemorySegment)mh$.invokeExact(mp, key, defaultobj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyDict_SetItem_KnownHash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyDict_SetItem_KnownHash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyDict_SetItem_KnownHash(PyObject *mp, PyObject *key, PyObject *item, Py_hash_t hash)
     * }
     */
    public static FunctionDescriptor _PyDict_SetItem_KnownHash$descriptor() {
        return _PyDict_SetItem_KnownHash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyDict_SetItem_KnownHash(PyObject *mp, PyObject *key, PyObject *item, Py_hash_t hash)
     * }
     */
    public static MethodHandle _PyDict_SetItem_KnownHash$handle() {
        return _PyDict_SetItem_KnownHash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyDict_SetItem_KnownHash(PyObject *mp, PyObject *key, PyObject *item, Py_hash_t hash)
     * }
     */
    public static MemorySegment _PyDict_SetItem_KnownHash$address() {
        return _PyDict_SetItem_KnownHash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyDict_SetItem_KnownHash(PyObject *mp, PyObject *key, PyObject *item, Py_hash_t hash)
     * }
     */
    public static int _PyDict_SetItem_KnownHash(MemorySegment mp, MemorySegment key, MemorySegment item, long hash) {
        var mh$ = _PyDict_SetItem_KnownHash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyDict_SetItem_KnownHash", mp, key, item, hash);
            }
            return (int)mh$.invokeExact(mp, key, item, hash);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyDict_DelItem_KnownHash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyDict_DelItem_KnownHash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyDict_DelItem_KnownHash(PyObject *mp, PyObject *key, Py_hash_t hash)
     * }
     */
    public static FunctionDescriptor _PyDict_DelItem_KnownHash$descriptor() {
        return _PyDict_DelItem_KnownHash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyDict_DelItem_KnownHash(PyObject *mp, PyObject *key, Py_hash_t hash)
     * }
     */
    public static MethodHandle _PyDict_DelItem_KnownHash$handle() {
        return _PyDict_DelItem_KnownHash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyDict_DelItem_KnownHash(PyObject *mp, PyObject *key, Py_hash_t hash)
     * }
     */
    public static MemorySegment _PyDict_DelItem_KnownHash$address() {
        return _PyDict_DelItem_KnownHash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyDict_DelItem_KnownHash(PyObject *mp, PyObject *key, Py_hash_t hash)
     * }
     */
    public static int _PyDict_DelItem_KnownHash(MemorySegment mp, MemorySegment key, long hash) {
        var mh$ = _PyDict_DelItem_KnownHash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyDict_DelItem_KnownHash", mp, key, hash);
            }
            return (int)mh$.invokeExact(mp, key, hash);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyDict_DelItemIf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyDict_DelItemIf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyDict_DelItemIf(PyObject *mp, PyObject *key, int (*predicate)(PyObject *))
     * }
     */
    public static FunctionDescriptor _PyDict_DelItemIf$descriptor() {
        return _PyDict_DelItemIf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyDict_DelItemIf(PyObject *mp, PyObject *key, int (*predicate)(PyObject *))
     * }
     */
    public static MethodHandle _PyDict_DelItemIf$handle() {
        return _PyDict_DelItemIf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyDict_DelItemIf(PyObject *mp, PyObject *key, int (*predicate)(PyObject *))
     * }
     */
    public static MemorySegment _PyDict_DelItemIf$address() {
        return _PyDict_DelItemIf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyDict_DelItemIf(PyObject *mp, PyObject *key, int (*predicate)(PyObject *))
     * }
     */
    public static int _PyDict_DelItemIf(MemorySegment mp, MemorySegment key, MemorySegment predicate) {
        var mh$ = _PyDict_DelItemIf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyDict_DelItemIf", mp, key, predicate);
            }
            return (int)mh$.invokeExact(mp, key, predicate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyDict_Next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyDict_Next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyDict_Next(PyObject *mp, Py_ssize_t *pos, PyObject **key, PyObject **value, Py_hash_t *hash)
     * }
     */
    public static FunctionDescriptor _PyDict_Next$descriptor() {
        return _PyDict_Next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyDict_Next(PyObject *mp, Py_ssize_t *pos, PyObject **key, PyObject **value, Py_hash_t *hash)
     * }
     */
    public static MethodHandle _PyDict_Next$handle() {
        return _PyDict_Next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyDict_Next(PyObject *mp, Py_ssize_t *pos, PyObject **key, PyObject **value, Py_hash_t *hash)
     * }
     */
    public static MemorySegment _PyDict_Next$address() {
        return _PyDict_Next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyDict_Next(PyObject *mp, Py_ssize_t *pos, PyObject **key, PyObject **value, Py_hash_t *hash)
     * }
     */
    public static int _PyDict_Next(MemorySegment mp, MemorySegment pos, MemorySegment key, MemorySegment value, MemorySegment hash) {
        var mh$ = _PyDict_Next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyDict_Next", mp, pos, key, value, hash);
            }
            return (int)mh$.invokeExact(mp, pos, key, value, hash);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyDict_Contains_KnownHash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyDict_Contains_KnownHash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyDict_Contains_KnownHash(PyObject *, PyObject *, Py_hash_t)
     * }
     */
    public static FunctionDescriptor _PyDict_Contains_KnownHash$descriptor() {
        return _PyDict_Contains_KnownHash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyDict_Contains_KnownHash(PyObject *, PyObject *, Py_hash_t)
     * }
     */
    public static MethodHandle _PyDict_Contains_KnownHash$handle() {
        return _PyDict_Contains_KnownHash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyDict_Contains_KnownHash(PyObject *, PyObject *, Py_hash_t)
     * }
     */
    public static MemorySegment _PyDict_Contains_KnownHash$address() {
        return _PyDict_Contains_KnownHash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyDict_Contains_KnownHash(PyObject *, PyObject *, Py_hash_t)
     * }
     */
    public static int _PyDict_Contains_KnownHash(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = _PyDict_Contains_KnownHash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyDict_Contains_KnownHash", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyDict_ContainsId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyDict_ContainsId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyDict_ContainsId(PyObject *, _Py_Identifier *)
     * }
     */
    public static FunctionDescriptor _PyDict_ContainsId$descriptor() {
        return _PyDict_ContainsId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyDict_ContainsId(PyObject *, _Py_Identifier *)
     * }
     */
    public static MethodHandle _PyDict_ContainsId$handle() {
        return _PyDict_ContainsId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyDict_ContainsId(PyObject *, _Py_Identifier *)
     * }
     */
    public static MemorySegment _PyDict_ContainsId$address() {
        return _PyDict_ContainsId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyDict_ContainsId(PyObject *, _Py_Identifier *)
     * }
     */
    public static int _PyDict_ContainsId(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyDict_ContainsId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyDict_ContainsId", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyDict_NewPresized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyDict_NewPresized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyDict_NewPresized(Py_ssize_t minused)
     * }
     */
    public static FunctionDescriptor _PyDict_NewPresized$descriptor() {
        return _PyDict_NewPresized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyDict_NewPresized(Py_ssize_t minused)
     * }
     */
    public static MethodHandle _PyDict_NewPresized$handle() {
        return _PyDict_NewPresized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyDict_NewPresized(Py_ssize_t minused)
     * }
     */
    public static MemorySegment _PyDict_NewPresized$address() {
        return _PyDict_NewPresized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyDict_NewPresized(Py_ssize_t minused)
     * }
     */
    public static MemorySegment _PyDict_NewPresized(long minused) {
        var mh$ = _PyDict_NewPresized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyDict_NewPresized", minused);
            }
            return (MemorySegment)mh$.invokeExact(minused);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyDict_MaybeUntrack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyDict_MaybeUntrack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyDict_MaybeUntrack(PyObject *mp)
     * }
     */
    public static FunctionDescriptor _PyDict_MaybeUntrack$descriptor() {
        return _PyDict_MaybeUntrack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyDict_MaybeUntrack(PyObject *mp)
     * }
     */
    public static MethodHandle _PyDict_MaybeUntrack$handle() {
        return _PyDict_MaybeUntrack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyDict_MaybeUntrack(PyObject *mp)
     * }
     */
    public static MemorySegment _PyDict_MaybeUntrack$address() {
        return _PyDict_MaybeUntrack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyDict_MaybeUntrack(PyObject *mp)
     * }
     */
    public static void _PyDict_MaybeUntrack(MemorySegment mp) {
        var mh$ = _PyDict_MaybeUntrack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyDict_MaybeUntrack", mp);
            }
            mh$.invokeExact(mp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyDict_HasOnlyStringKeys {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyDict_HasOnlyStringKeys");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyDict_HasOnlyStringKeys(PyObject *mp)
     * }
     */
    public static FunctionDescriptor _PyDict_HasOnlyStringKeys$descriptor() {
        return _PyDict_HasOnlyStringKeys.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyDict_HasOnlyStringKeys(PyObject *mp)
     * }
     */
    public static MethodHandle _PyDict_HasOnlyStringKeys$handle() {
        return _PyDict_HasOnlyStringKeys.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyDict_HasOnlyStringKeys(PyObject *mp)
     * }
     */
    public static MemorySegment _PyDict_HasOnlyStringKeys$address() {
        return _PyDict_HasOnlyStringKeys.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyDict_HasOnlyStringKeys(PyObject *mp)
     * }
     */
    public static int _PyDict_HasOnlyStringKeys(MemorySegment mp) {
        var mh$ = _PyDict_HasOnlyStringKeys.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyDict_HasOnlyStringKeys", mp);
            }
            return (int)mh$.invokeExact(mp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyDict_SizeOf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyDict_SizeOf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t _PyDict_SizeOf(PyDictObject *)
     * }
     */
    public static FunctionDescriptor _PyDict_SizeOf$descriptor() {
        return _PyDict_SizeOf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t _PyDict_SizeOf(PyDictObject *)
     * }
     */
    public static MethodHandle _PyDict_SizeOf$handle() {
        return _PyDict_SizeOf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t _PyDict_SizeOf(PyDictObject *)
     * }
     */
    public static MemorySegment _PyDict_SizeOf$address() {
        return _PyDict_SizeOf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t _PyDict_SizeOf(PyDictObject *)
     * }
     */
    public static long _PyDict_SizeOf(MemorySegment x0) {
        var mh$ = _PyDict_SizeOf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyDict_SizeOf", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyDict_Pop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyDict_Pop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyDict_Pop(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor _PyDict_Pop$descriptor() {
        return _PyDict_Pop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyDict_Pop(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle _PyDict_Pop$handle() {
        return _PyDict_Pop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyDict_Pop(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment _PyDict_Pop$address() {
        return _PyDict_Pop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyDict_Pop(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment _PyDict_Pop(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = _PyDict_Pop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyDict_Pop", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyDict_MergeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyDict_MergeEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyDict_MergeEx(PyObject *mp, PyObject *other, int override)
     * }
     */
    public static FunctionDescriptor _PyDict_MergeEx$descriptor() {
        return _PyDict_MergeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyDict_MergeEx(PyObject *mp, PyObject *other, int override)
     * }
     */
    public static MethodHandle _PyDict_MergeEx$handle() {
        return _PyDict_MergeEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyDict_MergeEx(PyObject *mp, PyObject *other, int override)
     * }
     */
    public static MemorySegment _PyDict_MergeEx$address() {
        return _PyDict_MergeEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyDict_MergeEx(PyObject *mp, PyObject *other, int override)
     * }
     */
    public static int _PyDict_MergeEx(MemorySegment mp, MemorySegment other, int override) {
        var mh$ = _PyDict_MergeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyDict_MergeEx", mp, other, override);
            }
            return (int)mh$.invokeExact(mp, other, override);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyDict_SetItemId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyDict_SetItemId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyDict_SetItemId(PyObject *dp, _Py_Identifier *key, PyObject *item)
     * }
     */
    public static FunctionDescriptor _PyDict_SetItemId$descriptor() {
        return _PyDict_SetItemId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyDict_SetItemId(PyObject *dp, _Py_Identifier *key, PyObject *item)
     * }
     */
    public static MethodHandle _PyDict_SetItemId$handle() {
        return _PyDict_SetItemId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyDict_SetItemId(PyObject *dp, _Py_Identifier *key, PyObject *item)
     * }
     */
    public static MemorySegment _PyDict_SetItemId$address() {
        return _PyDict_SetItemId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyDict_SetItemId(PyObject *dp, _Py_Identifier *key, PyObject *item)
     * }
     */
    public static int _PyDict_SetItemId(MemorySegment dp, MemorySegment key, MemorySegment item) {
        var mh$ = _PyDict_SetItemId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyDict_SetItemId", dp, key, item);
            }
            return (int)mh$.invokeExact(dp, key, item);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyDict_DelItemId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyDict_DelItemId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyDict_DelItemId(PyObject *mp, _Py_Identifier *key)
     * }
     */
    public static FunctionDescriptor _PyDict_DelItemId$descriptor() {
        return _PyDict_DelItemId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyDict_DelItemId(PyObject *mp, _Py_Identifier *key)
     * }
     */
    public static MethodHandle _PyDict_DelItemId$handle() {
        return _PyDict_DelItemId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyDict_DelItemId(PyObject *mp, _Py_Identifier *key)
     * }
     */
    public static MemorySegment _PyDict_DelItemId$address() {
        return _PyDict_DelItemId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyDict_DelItemId(PyObject *mp, _Py_Identifier *key)
     * }
     */
    public static int _PyDict_DelItemId(MemorySegment mp, MemorySegment key) {
        var mh$ = _PyDict_DelItemId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyDict_DelItemId", mp, key);
            }
            return (int)mh$.invokeExact(mp, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyDict_DebugMallocStats {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyDict_DebugMallocStats");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyDict_DebugMallocStats(FILE *out)
     * }
     */
    public static FunctionDescriptor _PyDict_DebugMallocStats$descriptor() {
        return _PyDict_DebugMallocStats.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyDict_DebugMallocStats(FILE *out)
     * }
     */
    public static MethodHandle _PyDict_DebugMallocStats$handle() {
        return _PyDict_DebugMallocStats.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyDict_DebugMallocStats(FILE *out)
     * }
     */
    public static MemorySegment _PyDict_DebugMallocStats$address() {
        return _PyDict_DebugMallocStats.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyDict_DebugMallocStats(FILE *out)
     * }
     */
    public static void _PyDict_DebugMallocStats(MemorySegment out) {
        var mh$ = _PyDict_DebugMallocStats.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyDict_DebugMallocStats", out);
            }
            mh$.invokeExact(out);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyDictView_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyDictView_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyDictView_New(PyObject *, PyTypeObject *)
     * }
     */
    public static FunctionDescriptor _PyDictView_New$descriptor() {
        return _PyDictView_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyDictView_New(PyObject *, PyTypeObject *)
     * }
     */
    public static MethodHandle _PyDictView_New$handle() {
        return _PyDictView_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyDictView_New(PyObject *, PyTypeObject *)
     * }
     */
    public static MemorySegment _PyDictView_New$address() {
        return _PyDictView_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyDictView_New(PyObject *, PyTypeObject *)
     * }
     */
    public static MemorySegment _PyDictView_New(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyDictView_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyDictView_New", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyDictView_Intersect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyDictView_Intersect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyDictView_Intersect(PyObject *self, PyObject *other)
     * }
     */
    public static FunctionDescriptor _PyDictView_Intersect$descriptor() {
        return _PyDictView_Intersect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyDictView_Intersect(PyObject *self, PyObject *other)
     * }
     */
    public static MethodHandle _PyDictView_Intersect$handle() {
        return _PyDictView_Intersect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyDictView_Intersect(PyObject *self, PyObject *other)
     * }
     */
    public static MemorySegment _PyDictView_Intersect$address() {
        return _PyDictView_Intersect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyDictView_Intersect(PyObject *self, PyObject *other)
     * }
     */
    public static MemorySegment _PyDictView_Intersect(MemorySegment self, MemorySegment other) {
        var mh$ = _PyDictView_Intersect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyDictView_Intersect", self, other);
            }
            return (MemorySegment)mh$.invokeExact(self, other);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyODict_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyODict_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyODict_Type
     * }
     */
    public static GroupLayout PyODict_Type$layout() {
        return PyODict_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyODict_Type
     * }
     */
    public static MemorySegment PyODict_Type() {
        return PyODict_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyODict_Type
     * }
     */
    public static void PyODict_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyODict_Type$constants.SEGMENT, 0L, PyODict_Type$constants.LAYOUT.byteSize());
    }

    private static class PyODictIter_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyODictIter_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyODictIter_Type
     * }
     */
    public static GroupLayout PyODictIter_Type$layout() {
        return PyODictIter_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyODictIter_Type
     * }
     */
    public static MemorySegment PyODictIter_Type() {
        return PyODictIter_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyODictIter_Type
     * }
     */
    public static void PyODictIter_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyODictIter_Type$constants.SEGMENT, 0L, PyODictIter_Type$constants.LAYOUT.byteSize());
    }

    private static class PyODictKeys_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyODictKeys_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyODictKeys_Type
     * }
     */
    public static GroupLayout PyODictKeys_Type$layout() {
        return PyODictKeys_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyODictKeys_Type
     * }
     */
    public static MemorySegment PyODictKeys_Type() {
        return PyODictKeys_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyODictKeys_Type
     * }
     */
    public static void PyODictKeys_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyODictKeys_Type$constants.SEGMENT, 0L, PyODictKeys_Type$constants.LAYOUT.byteSize());
    }

    private static class PyODictItems_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyODictItems_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyODictItems_Type
     * }
     */
    public static GroupLayout PyODictItems_Type$layout() {
        return PyODictItems_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyODictItems_Type
     * }
     */
    public static MemorySegment PyODictItems_Type() {
        return PyODictItems_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyODictItems_Type
     * }
     */
    public static void PyODictItems_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyODictItems_Type$constants.SEGMENT, 0L, PyODictItems_Type$constants.LAYOUT.byteSize());
    }

    private static class PyODictValues_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyODictValues_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyODictValues_Type
     * }
     */
    public static GroupLayout PyODictValues_Type$layout() {
        return PyODictValues_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyODictValues_Type
     * }
     */
    public static MemorySegment PyODictValues_Type() {
        return PyODictValues_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyODictValues_Type
     * }
     */
    public static void PyODictValues_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyODictValues_Type$constants.SEGMENT, 0L, PyODictValues_Type$constants.LAYOUT.byteSize());
    }

    private static class PyODict_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyODict_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyODict_New()
     * }
     */
    public static FunctionDescriptor PyODict_New$descriptor() {
        return PyODict_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyODict_New()
     * }
     */
    public static MethodHandle PyODict_New$handle() {
        return PyODict_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyODict_New()
     * }
     */
    public static MemorySegment PyODict_New$address() {
        return PyODict_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyODict_New()
     * }
     */
    public static MemorySegment PyODict_New() {
        var mh$ = PyODict_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyODict_New");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyODict_SetItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyODict_SetItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyODict_SetItem(PyObject *od, PyObject *key, PyObject *item)
     * }
     */
    public static FunctionDescriptor PyODict_SetItem$descriptor() {
        return PyODict_SetItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyODict_SetItem(PyObject *od, PyObject *key, PyObject *item)
     * }
     */
    public static MethodHandle PyODict_SetItem$handle() {
        return PyODict_SetItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyODict_SetItem(PyObject *od, PyObject *key, PyObject *item)
     * }
     */
    public static MemorySegment PyODict_SetItem$address() {
        return PyODict_SetItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyODict_SetItem(PyObject *od, PyObject *key, PyObject *item)
     * }
     */
    public static int PyODict_SetItem(MemorySegment od, MemorySegment key, MemorySegment item) {
        var mh$ = PyODict_SetItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyODict_SetItem", od, key, item);
            }
            return (int)mh$.invokeExact(od, key, item);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyODict_DelItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyODict_DelItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyODict_DelItem(PyObject *od, PyObject *key)
     * }
     */
    public static FunctionDescriptor PyODict_DelItem$descriptor() {
        return PyODict_DelItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyODict_DelItem(PyObject *od, PyObject *key)
     * }
     */
    public static MethodHandle PyODict_DelItem$handle() {
        return PyODict_DelItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyODict_DelItem(PyObject *od, PyObject *key)
     * }
     */
    public static MemorySegment PyODict_DelItem$address() {
        return PyODict_DelItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyODict_DelItem(PyObject *od, PyObject *key)
     * }
     */
    public static int PyODict_DelItem(MemorySegment od, MemorySegment key) {
        var mh$ = PyODict_DelItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyODict_DelItem", od, key);
            }
            return (int)mh$.invokeExact(od, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEnum_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyEnum_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyEnum_Type
     * }
     */
    public static GroupLayout PyEnum_Type$layout() {
        return PyEnum_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyEnum_Type
     * }
     */
    public static MemorySegment PyEnum_Type() {
        return PyEnum_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyEnum_Type
     * }
     */
    public static void PyEnum_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyEnum_Type$constants.SEGMENT, 0L, PyEnum_Type$constants.LAYOUT.byteSize());
    }

    private static class PyReversed_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyReversed_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyReversed_Type
     * }
     */
    public static GroupLayout PyReversed_Type$layout() {
        return PyReversed_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyReversed_Type
     * }
     */
    public static MemorySegment PyReversed_Type() {
        return PyReversed_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyReversed_Type
     * }
     */
    public static void PyReversed_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyReversed_Type$constants.SEGMENT, 0L, PyReversed_Type$constants.LAYOUT.byteSize());
    }

    private static class PySet_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PySet_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySet_Type
     * }
     */
    public static GroupLayout PySet_Type$layout() {
        return PySet_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySet_Type
     * }
     */
    public static MemorySegment PySet_Type() {
        return PySet_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySet_Type
     * }
     */
    public static void PySet_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PySet_Type$constants.SEGMENT, 0L, PySet_Type$constants.LAYOUT.byteSize());
    }

    private static class PyFrozenSet_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyFrozenSet_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyFrozenSet_Type
     * }
     */
    public static GroupLayout PyFrozenSet_Type$layout() {
        return PyFrozenSet_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyFrozenSet_Type
     * }
     */
    public static MemorySegment PyFrozenSet_Type() {
        return PyFrozenSet_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyFrozenSet_Type
     * }
     */
    public static void PyFrozenSet_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyFrozenSet_Type$constants.SEGMENT, 0L, PyFrozenSet_Type$constants.LAYOUT.byteSize());
    }

    private static class PySetIter_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PySetIter_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySetIter_Type
     * }
     */
    public static GroupLayout PySetIter_Type$layout() {
        return PySetIter_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySetIter_Type
     * }
     */
    public static MemorySegment PySetIter_Type() {
        return PySetIter_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySetIter_Type
     * }
     */
    public static void PySetIter_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PySetIter_Type$constants.SEGMENT, 0L, PySetIter_Type$constants.LAYOUT.byteSize());
    }

    private static class PySet_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySet_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PySet_New(PyObject *)
     * }
     */
    public static FunctionDescriptor PySet_New$descriptor() {
        return PySet_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PySet_New(PyObject *)
     * }
     */
    public static MethodHandle PySet_New$handle() {
        return PySet_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PySet_New(PyObject *)
     * }
     */
    public static MemorySegment PySet_New$address() {
        return PySet_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PySet_New(PyObject *)
     * }
     */
    public static MemorySegment PySet_New(MemorySegment x0) {
        var mh$ = PySet_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySet_New", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFrozenSet_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFrozenSet_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFrozenSet_New(PyObject *)
     * }
     */
    public static FunctionDescriptor PyFrozenSet_New$descriptor() {
        return PyFrozenSet_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFrozenSet_New(PyObject *)
     * }
     */
    public static MethodHandle PyFrozenSet_New$handle() {
        return PyFrozenSet_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFrozenSet_New(PyObject *)
     * }
     */
    public static MemorySegment PyFrozenSet_New$address() {
        return PyFrozenSet_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFrozenSet_New(PyObject *)
     * }
     */
    public static MemorySegment PyFrozenSet_New(MemorySegment x0) {
        var mh$ = PyFrozenSet_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFrozenSet_New", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySet_Add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySet_Add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySet_Add(PyObject *set, PyObject *key)
     * }
     */
    public static FunctionDescriptor PySet_Add$descriptor() {
        return PySet_Add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySet_Add(PyObject *set, PyObject *key)
     * }
     */
    public static MethodHandle PySet_Add$handle() {
        return PySet_Add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySet_Add(PyObject *set, PyObject *key)
     * }
     */
    public static MemorySegment PySet_Add$address() {
        return PySet_Add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySet_Add(PyObject *set, PyObject *key)
     * }
     */
    public static int PySet_Add(MemorySegment set, MemorySegment key) {
        var mh$ = PySet_Add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySet_Add", set, key);
            }
            return (int)mh$.invokeExact(set, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySet_Clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySet_Clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySet_Clear(PyObject *set)
     * }
     */
    public static FunctionDescriptor PySet_Clear$descriptor() {
        return PySet_Clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySet_Clear(PyObject *set)
     * }
     */
    public static MethodHandle PySet_Clear$handle() {
        return PySet_Clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySet_Clear(PyObject *set)
     * }
     */
    public static MemorySegment PySet_Clear$address() {
        return PySet_Clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySet_Clear(PyObject *set)
     * }
     */
    public static int PySet_Clear(MemorySegment set) {
        var mh$ = PySet_Clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySet_Clear", set);
            }
            return (int)mh$.invokeExact(set);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySet_Contains {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySet_Contains");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySet_Contains(PyObject *anyset, PyObject *key)
     * }
     */
    public static FunctionDescriptor PySet_Contains$descriptor() {
        return PySet_Contains.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySet_Contains(PyObject *anyset, PyObject *key)
     * }
     */
    public static MethodHandle PySet_Contains$handle() {
        return PySet_Contains.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySet_Contains(PyObject *anyset, PyObject *key)
     * }
     */
    public static MemorySegment PySet_Contains$address() {
        return PySet_Contains.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySet_Contains(PyObject *anyset, PyObject *key)
     * }
     */
    public static int PySet_Contains(MemorySegment anyset, MemorySegment key) {
        var mh$ = PySet_Contains.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySet_Contains", anyset, key);
            }
            return (int)mh$.invokeExact(anyset, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySet_Discard {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySet_Discard");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySet_Discard(PyObject *set, PyObject *key)
     * }
     */
    public static FunctionDescriptor PySet_Discard$descriptor() {
        return PySet_Discard.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySet_Discard(PyObject *set, PyObject *key)
     * }
     */
    public static MethodHandle PySet_Discard$handle() {
        return PySet_Discard.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySet_Discard(PyObject *set, PyObject *key)
     * }
     */
    public static MemorySegment PySet_Discard$address() {
        return PySet_Discard.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySet_Discard(PyObject *set, PyObject *key)
     * }
     */
    public static int PySet_Discard(MemorySegment set, MemorySegment key) {
        var mh$ = PySet_Discard.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySet_Discard", set, key);
            }
            return (int)mh$.invokeExact(set, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySet_Pop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySet_Pop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PySet_Pop(PyObject *set)
     * }
     */
    public static FunctionDescriptor PySet_Pop$descriptor() {
        return PySet_Pop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PySet_Pop(PyObject *set)
     * }
     */
    public static MethodHandle PySet_Pop$handle() {
        return PySet_Pop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PySet_Pop(PyObject *set)
     * }
     */
    public static MemorySegment PySet_Pop$address() {
        return PySet_Pop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PySet_Pop(PyObject *set)
     * }
     */
    public static MemorySegment PySet_Pop(MemorySegment set) {
        var mh$ = PySet_Pop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySet_Pop", set);
            }
            return (MemorySegment)mh$.invokeExact(set);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySet_Size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySet_Size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PySet_Size(PyObject *anyset)
     * }
     */
    public static FunctionDescriptor PySet_Size$descriptor() {
        return PySet_Size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PySet_Size(PyObject *anyset)
     * }
     */
    public static MethodHandle PySet_Size$handle() {
        return PySet_Size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PySet_Size(PyObject *anyset)
     * }
     */
    public static MemorySegment PySet_Size$address() {
        return PySet_Size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PySet_Size(PyObject *anyset)
     * }
     */
    public static long PySet_Size(MemorySegment anyset) {
        var mh$ = PySet_Size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySet_Size", anyset);
            }
            return (long)mh$.invokeExact(anyset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PySet_Dummy$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_PySet_Dummy").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *_PySet_Dummy
     * }
     */
    public static AddressLayout _PySet_Dummy$layout() {
        return _PySet_Dummy$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *_PySet_Dummy
     * }
     */
    public static MemorySegment _PySet_Dummy$segment() {
        return _PySet_Dummy$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *_PySet_Dummy
     * }
     */
    public static MemorySegment _PySet_Dummy() {
        return _PySet_Dummy$constants.SEGMENT.get(_PySet_Dummy$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *_PySet_Dummy
     * }
     */
    public static void _PySet_Dummy(MemorySegment varValue) {
        _PySet_Dummy$constants.SEGMENT.set(_PySet_Dummy$constants.LAYOUT, 0L, varValue);
    }

    private static class _PySet_NextEntry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PySet_NextEntry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PySet_NextEntry(PyObject *set, Py_ssize_t *pos, PyObject **key, Py_hash_t *hash)
     * }
     */
    public static FunctionDescriptor _PySet_NextEntry$descriptor() {
        return _PySet_NextEntry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PySet_NextEntry(PyObject *set, Py_ssize_t *pos, PyObject **key, Py_hash_t *hash)
     * }
     */
    public static MethodHandle _PySet_NextEntry$handle() {
        return _PySet_NextEntry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PySet_NextEntry(PyObject *set, Py_ssize_t *pos, PyObject **key, Py_hash_t *hash)
     * }
     */
    public static MemorySegment _PySet_NextEntry$address() {
        return _PySet_NextEntry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PySet_NextEntry(PyObject *set, Py_ssize_t *pos, PyObject **key, Py_hash_t *hash)
     * }
     */
    public static int _PySet_NextEntry(MemorySegment set, MemorySegment pos, MemorySegment key, MemorySegment hash) {
        var mh$ = _PySet_NextEntry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PySet_NextEntry", set, pos, key, hash);
            }
            return (int)mh$.invokeExact(set, pos, key, hash);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PySet_Update {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PySet_Update");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PySet_Update(PyObject *set, PyObject *iterable)
     * }
     */
    public static FunctionDescriptor _PySet_Update$descriptor() {
        return _PySet_Update.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PySet_Update(PyObject *set, PyObject *iterable)
     * }
     */
    public static MethodHandle _PySet_Update$handle() {
        return _PySet_Update.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PySet_Update(PyObject *set, PyObject *iterable)
     * }
     */
    public static MemorySegment _PySet_Update$address() {
        return _PySet_Update.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PySet_Update(PyObject *set, PyObject *iterable)
     * }
     */
    public static int _PySet_Update(MemorySegment set, MemorySegment iterable) {
        var mh$ = _PySet_Update.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PySet_Update", set, iterable);
            }
            return (int)mh$.invokeExact(set, iterable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCFunction_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyCFunction_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCFunction_Type
     * }
     */
    public static GroupLayout PyCFunction_Type$layout() {
        return PyCFunction_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCFunction_Type
     * }
     */
    public static MemorySegment PyCFunction_Type() {
        return PyCFunction_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCFunction_Type
     * }
     */
    public static void PyCFunction_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyCFunction_Type$constants.SEGMENT, 0L, PyCFunction_Type$constants.LAYOUT.byteSize());
    }

    private static class PyCFunction_GetFunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCFunction_GetFunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyCFunction PyCFunction_GetFunction(PyObject *)
     * }
     */
    public static FunctionDescriptor PyCFunction_GetFunction$descriptor() {
        return PyCFunction_GetFunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyCFunction PyCFunction_GetFunction(PyObject *)
     * }
     */
    public static MethodHandle PyCFunction_GetFunction$handle() {
        return PyCFunction_GetFunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyCFunction PyCFunction_GetFunction(PyObject *)
     * }
     */
    public static MemorySegment PyCFunction_GetFunction$address() {
        return PyCFunction_GetFunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyCFunction PyCFunction_GetFunction(PyObject *)
     * }
     */
    public static MemorySegment PyCFunction_GetFunction(MemorySegment x0) {
        var mh$ = PyCFunction_GetFunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCFunction_GetFunction", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCFunction_GetSelf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCFunction_GetSelf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCFunction_GetSelf(PyObject *)
     * }
     */
    public static FunctionDescriptor PyCFunction_GetSelf$descriptor() {
        return PyCFunction_GetSelf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCFunction_GetSelf(PyObject *)
     * }
     */
    public static MethodHandle PyCFunction_GetSelf$handle() {
        return PyCFunction_GetSelf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCFunction_GetSelf(PyObject *)
     * }
     */
    public static MemorySegment PyCFunction_GetSelf$address() {
        return PyCFunction_GetSelf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCFunction_GetSelf(PyObject *)
     * }
     */
    public static MemorySegment PyCFunction_GetSelf(MemorySegment x0) {
        var mh$ = PyCFunction_GetSelf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCFunction_GetSelf", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCFunction_GetFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCFunction_GetFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyCFunction_GetFlags(PyObject *)
     * }
     */
    public static FunctionDescriptor PyCFunction_GetFlags$descriptor() {
        return PyCFunction_GetFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyCFunction_GetFlags(PyObject *)
     * }
     */
    public static MethodHandle PyCFunction_GetFlags$handle() {
        return PyCFunction_GetFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyCFunction_GetFlags(PyObject *)
     * }
     */
    public static MemorySegment PyCFunction_GetFlags$address() {
        return PyCFunction_GetFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyCFunction_GetFlags(PyObject *)
     * }
     */
    public static int PyCFunction_GetFlags(MemorySegment x0) {
        var mh$ = PyCFunction_GetFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCFunction_GetFlags", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCFunction_Call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCFunction_Call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCFunction_Call(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyCFunction_Call$descriptor() {
        return PyCFunction_Call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCFunction_Call(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyCFunction_Call$handle() {
        return PyCFunction_Call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCFunction_Call(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyCFunction_Call$address() {
        return PyCFunction_Call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCFunction_Call(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyCFunction_Call(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyCFunction_Call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCFunction_Call", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCFunction_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCFunction_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCFunction_New(PyMethodDef *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyCFunction_New$descriptor() {
        return PyCFunction_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCFunction_New(PyMethodDef *, PyObject *)
     * }
     */
    public static MethodHandle PyCFunction_New$handle() {
        return PyCFunction_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCFunction_New(PyMethodDef *, PyObject *)
     * }
     */
    public static MemorySegment PyCFunction_New$address() {
        return PyCFunction_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCFunction_New(PyMethodDef *, PyObject *)
     * }
     */
    public static MemorySegment PyCFunction_New(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyCFunction_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCFunction_New", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCFunction_NewEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCFunction_NewEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCFunction_NewEx(PyMethodDef *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyCFunction_NewEx$descriptor() {
        return PyCFunction_NewEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCFunction_NewEx(PyMethodDef *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyCFunction_NewEx$handle() {
        return PyCFunction_NewEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCFunction_NewEx(PyMethodDef *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyCFunction_NewEx$address() {
        return PyCFunction_NewEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCFunction_NewEx(PyMethodDef *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyCFunction_NewEx(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyCFunction_NewEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCFunction_NewEx", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCMethod_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCMethod_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCMethod_New(PyMethodDef *, PyObject *, PyObject *, PyTypeObject *)
     * }
     */
    public static FunctionDescriptor PyCMethod_New$descriptor() {
        return PyCMethod_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCMethod_New(PyMethodDef *, PyObject *, PyObject *, PyTypeObject *)
     * }
     */
    public static MethodHandle PyCMethod_New$handle() {
        return PyCMethod_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCMethod_New(PyMethodDef *, PyObject *, PyObject *, PyTypeObject *)
     * }
     */
    public static MemorySegment PyCMethod_New$address() {
        return PyCMethod_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCMethod_New(PyMethodDef *, PyObject *, PyObject *, PyTypeObject *)
     * }
     */
    public static MemorySegment PyCMethod_New(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = PyCMethod_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCMethod_New", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCMethod_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyCMethod_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCMethod_Type
     * }
     */
    public static GroupLayout PyCMethod_Type$layout() {
        return PyCMethod_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCMethod_Type
     * }
     */
    public static MemorySegment PyCMethod_Type() {
        return PyCMethod_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCMethod_Type
     * }
     */
    public static void PyCMethod_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyCMethod_Type$constants.SEGMENT, 0L, PyCMethod_Type$constants.LAYOUT.byteSize());
    }

    private static class PyModule_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyModule_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyModule_Type
     * }
     */
    public static GroupLayout PyModule_Type$layout() {
        return PyModule_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyModule_Type
     * }
     */
    public static MemorySegment PyModule_Type() {
        return PyModule_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyModule_Type
     * }
     */
    public static void PyModule_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyModule_Type$constants.SEGMENT, 0L, PyModule_Type$constants.LAYOUT.byteSize());
    }

    private static class PyModule_NewObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_NewObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyModule_NewObject(PyObject *name)
     * }
     */
    public static FunctionDescriptor PyModule_NewObject$descriptor() {
        return PyModule_NewObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyModule_NewObject(PyObject *name)
     * }
     */
    public static MethodHandle PyModule_NewObject$handle() {
        return PyModule_NewObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyModule_NewObject(PyObject *name)
     * }
     */
    public static MemorySegment PyModule_NewObject$address() {
        return PyModule_NewObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyModule_NewObject(PyObject *name)
     * }
     */
    public static MemorySegment PyModule_NewObject(MemorySegment name) {
        var mh$ = PyModule_NewObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_NewObject", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyModule_New(const char *name)
     * }
     */
    public static FunctionDescriptor PyModule_New$descriptor() {
        return PyModule_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyModule_New(const char *name)
     * }
     */
    public static MethodHandle PyModule_New$handle() {
        return PyModule_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyModule_New(const char *name)
     * }
     */
    public static MemorySegment PyModule_New$address() {
        return PyModule_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyModule_New(const char *name)
     * }
     */
    public static MemorySegment PyModule_New(MemorySegment name) {
        var mh$ = PyModule_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_New", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_GetDict {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_GetDict");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyModule_GetDict(PyObject *)
     * }
     */
    public static FunctionDescriptor PyModule_GetDict$descriptor() {
        return PyModule_GetDict.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyModule_GetDict(PyObject *)
     * }
     */
    public static MethodHandle PyModule_GetDict$handle() {
        return PyModule_GetDict.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyModule_GetDict(PyObject *)
     * }
     */
    public static MemorySegment PyModule_GetDict$address() {
        return PyModule_GetDict.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyModule_GetDict(PyObject *)
     * }
     */
    public static MemorySegment PyModule_GetDict(MemorySegment x0) {
        var mh$ = PyModule_GetDict.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_GetDict", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_GetNameObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_GetNameObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyModule_GetNameObject(PyObject *)
     * }
     */
    public static FunctionDescriptor PyModule_GetNameObject$descriptor() {
        return PyModule_GetNameObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyModule_GetNameObject(PyObject *)
     * }
     */
    public static MethodHandle PyModule_GetNameObject$handle() {
        return PyModule_GetNameObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyModule_GetNameObject(PyObject *)
     * }
     */
    public static MemorySegment PyModule_GetNameObject$address() {
        return PyModule_GetNameObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyModule_GetNameObject(PyObject *)
     * }
     */
    public static MemorySegment PyModule_GetNameObject(MemorySegment x0) {
        var mh$ = PyModule_GetNameObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_GetNameObject", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_GetName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_GetName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *PyModule_GetName(PyObject *)
     * }
     */
    public static FunctionDescriptor PyModule_GetName$descriptor() {
        return PyModule_GetName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *PyModule_GetName(PyObject *)
     * }
     */
    public static MethodHandle PyModule_GetName$handle() {
        return PyModule_GetName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *PyModule_GetName(PyObject *)
     * }
     */
    public static MemorySegment PyModule_GetName$address() {
        return PyModule_GetName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *PyModule_GetName(PyObject *)
     * }
     */
    public static MemorySegment PyModule_GetName(MemorySegment x0) {
        var mh$ = PyModule_GetName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_GetName", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_GetFilename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_GetFilename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *PyModule_GetFilename(PyObject *)
     * }
     */
    public static FunctionDescriptor PyModule_GetFilename$descriptor() {
        return PyModule_GetFilename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *PyModule_GetFilename(PyObject *)
     * }
     */
    public static MethodHandle PyModule_GetFilename$handle() {
        return PyModule_GetFilename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *PyModule_GetFilename(PyObject *)
     * }
     */
    public static MemorySegment PyModule_GetFilename$address() {
        return PyModule_GetFilename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *PyModule_GetFilename(PyObject *)
     * }
     */
    public static MemorySegment PyModule_GetFilename(MemorySegment x0) {
        var mh$ = PyModule_GetFilename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_GetFilename", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_GetFilenameObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_GetFilenameObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyModule_GetFilenameObject(PyObject *)
     * }
     */
    public static FunctionDescriptor PyModule_GetFilenameObject$descriptor() {
        return PyModule_GetFilenameObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyModule_GetFilenameObject(PyObject *)
     * }
     */
    public static MethodHandle PyModule_GetFilenameObject$handle() {
        return PyModule_GetFilenameObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyModule_GetFilenameObject(PyObject *)
     * }
     */
    public static MemorySegment PyModule_GetFilenameObject$address() {
        return PyModule_GetFilenameObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyModule_GetFilenameObject(PyObject *)
     * }
     */
    public static MemorySegment PyModule_GetFilenameObject(MemorySegment x0) {
        var mh$ = PyModule_GetFilenameObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_GetFilenameObject", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyModule_Clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyModule_Clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyModule_Clear(PyObject *)
     * }
     */
    public static FunctionDescriptor _PyModule_Clear$descriptor() {
        return _PyModule_Clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyModule_Clear(PyObject *)
     * }
     */
    public static MethodHandle _PyModule_Clear$handle() {
        return _PyModule_Clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyModule_Clear(PyObject *)
     * }
     */
    public static MemorySegment _PyModule_Clear$address() {
        return _PyModule_Clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyModule_Clear(PyObject *)
     * }
     */
    public static void _PyModule_Clear(MemorySegment x0) {
        var mh$ = _PyModule_Clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyModule_Clear", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyModule_ClearDict {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyModule_ClearDict");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyModule_ClearDict(PyObject *)
     * }
     */
    public static FunctionDescriptor _PyModule_ClearDict$descriptor() {
        return _PyModule_ClearDict.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyModule_ClearDict(PyObject *)
     * }
     */
    public static MethodHandle _PyModule_ClearDict$handle() {
        return _PyModule_ClearDict.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyModule_ClearDict(PyObject *)
     * }
     */
    public static MemorySegment _PyModule_ClearDict$address() {
        return _PyModule_ClearDict.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyModule_ClearDict(PyObject *)
     * }
     */
    public static void _PyModule_ClearDict(MemorySegment x0) {
        var mh$ = _PyModule_ClearDict.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyModule_ClearDict", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyModuleSpec_IsInitializing {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyModuleSpec_IsInitializing");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyModuleSpec_IsInitializing(PyObject *)
     * }
     */
    public static FunctionDescriptor _PyModuleSpec_IsInitializing$descriptor() {
        return _PyModuleSpec_IsInitializing.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyModuleSpec_IsInitializing(PyObject *)
     * }
     */
    public static MethodHandle _PyModuleSpec_IsInitializing$handle() {
        return _PyModuleSpec_IsInitializing.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyModuleSpec_IsInitializing(PyObject *)
     * }
     */
    public static MemorySegment _PyModuleSpec_IsInitializing$address() {
        return _PyModuleSpec_IsInitializing.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyModuleSpec_IsInitializing(PyObject *)
     * }
     */
    public static int _PyModuleSpec_IsInitializing(MemorySegment x0) {
        var mh$ = _PyModuleSpec_IsInitializing.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyModuleSpec_IsInitializing", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_GetDef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_GetDef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyModuleDef *PyModule_GetDef(PyObject *)
     * }
     */
    public static FunctionDescriptor PyModule_GetDef$descriptor() {
        return PyModule_GetDef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyModuleDef *PyModule_GetDef(PyObject *)
     * }
     */
    public static MethodHandle PyModule_GetDef$handle() {
        return PyModule_GetDef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyModuleDef *PyModule_GetDef(PyObject *)
     * }
     */
    public static MemorySegment PyModule_GetDef$address() {
        return PyModule_GetDef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyModuleDef *PyModule_GetDef(PyObject *)
     * }
     */
    public static MemorySegment PyModule_GetDef(MemorySegment x0) {
        var mh$ = PyModule_GetDef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_GetDef", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_GetState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_GetState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyModule_GetState(PyObject *)
     * }
     */
    public static FunctionDescriptor PyModule_GetState$descriptor() {
        return PyModule_GetState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyModule_GetState(PyObject *)
     * }
     */
    public static MethodHandle PyModule_GetState$handle() {
        return PyModule_GetState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyModule_GetState(PyObject *)
     * }
     */
    public static MemorySegment PyModule_GetState$address() {
        return PyModule_GetState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyModule_GetState(PyObject *)
     * }
     */
    public static MemorySegment PyModule_GetState(MemorySegment x0) {
        var mh$ = PyModule_GetState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_GetState", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModuleDef_Init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModuleDef_Init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyModuleDef_Init(PyModuleDef *)
     * }
     */
    public static FunctionDescriptor PyModuleDef_Init$descriptor() {
        return PyModuleDef_Init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyModuleDef_Init(PyModuleDef *)
     * }
     */
    public static MethodHandle PyModuleDef_Init$handle() {
        return PyModuleDef_Init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyModuleDef_Init(PyModuleDef *)
     * }
     */
    public static MemorySegment PyModuleDef_Init$address() {
        return PyModuleDef_Init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyModuleDef_Init(PyModuleDef *)
     * }
     */
    public static MemorySegment PyModuleDef_Init(MemorySegment x0) {
        var mh$ = PyModuleDef_Init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModuleDef_Init", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModuleDef_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyModuleDef_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyModuleDef_Type
     * }
     */
    public static GroupLayout PyModuleDef_Type$layout() {
        return PyModuleDef_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyModuleDef_Type
     * }
     */
    public static MemorySegment PyModuleDef_Type() {
        return PyModuleDef_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyModuleDef_Type
     * }
     */
    public static void PyModuleDef_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyModuleDef_Type$constants.SEGMENT, 0L, PyModuleDef_Type$constants.LAYOUT.byteSize());
    }

    private static class PyFunction_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyFunction_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyFunction_Type
     * }
     */
    public static GroupLayout PyFunction_Type$layout() {
        return PyFunction_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyFunction_Type
     * }
     */
    public static MemorySegment PyFunction_Type() {
        return PyFunction_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyFunction_Type
     * }
     */
    public static void PyFunction_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyFunction_Type$constants.SEGMENT, 0L, PyFunction_Type$constants.LAYOUT.byteSize());
    }

    private static class PyFunction_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFunction_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFunction_New(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyFunction_New$descriptor() {
        return PyFunction_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFunction_New(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyFunction_New$handle() {
        return PyFunction_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFunction_New(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyFunction_New$address() {
        return PyFunction_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFunction_New(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyFunction_New(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyFunction_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFunction_New", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFunction_NewWithQualName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFunction_NewWithQualName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFunction_NewWithQualName(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyFunction_NewWithQualName$descriptor() {
        return PyFunction_NewWithQualName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFunction_NewWithQualName(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyFunction_NewWithQualName$handle() {
        return PyFunction_NewWithQualName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFunction_NewWithQualName(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyFunction_NewWithQualName$address() {
        return PyFunction_NewWithQualName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFunction_NewWithQualName(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyFunction_NewWithQualName(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyFunction_NewWithQualName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFunction_NewWithQualName", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFunction_GetCode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFunction_GetCode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFunction_GetCode(PyObject *)
     * }
     */
    public static FunctionDescriptor PyFunction_GetCode$descriptor() {
        return PyFunction_GetCode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFunction_GetCode(PyObject *)
     * }
     */
    public static MethodHandle PyFunction_GetCode$handle() {
        return PyFunction_GetCode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFunction_GetCode(PyObject *)
     * }
     */
    public static MemorySegment PyFunction_GetCode$address() {
        return PyFunction_GetCode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFunction_GetCode(PyObject *)
     * }
     */
    public static MemorySegment PyFunction_GetCode(MemorySegment x0) {
        var mh$ = PyFunction_GetCode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFunction_GetCode", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFunction_GetGlobals {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFunction_GetGlobals");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFunction_GetGlobals(PyObject *)
     * }
     */
    public static FunctionDescriptor PyFunction_GetGlobals$descriptor() {
        return PyFunction_GetGlobals.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFunction_GetGlobals(PyObject *)
     * }
     */
    public static MethodHandle PyFunction_GetGlobals$handle() {
        return PyFunction_GetGlobals.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFunction_GetGlobals(PyObject *)
     * }
     */
    public static MemorySegment PyFunction_GetGlobals$address() {
        return PyFunction_GetGlobals.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFunction_GetGlobals(PyObject *)
     * }
     */
    public static MemorySegment PyFunction_GetGlobals(MemorySegment x0) {
        var mh$ = PyFunction_GetGlobals.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFunction_GetGlobals", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFunction_GetModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFunction_GetModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFunction_GetModule(PyObject *)
     * }
     */
    public static FunctionDescriptor PyFunction_GetModule$descriptor() {
        return PyFunction_GetModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFunction_GetModule(PyObject *)
     * }
     */
    public static MethodHandle PyFunction_GetModule$handle() {
        return PyFunction_GetModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFunction_GetModule(PyObject *)
     * }
     */
    public static MemorySegment PyFunction_GetModule$address() {
        return PyFunction_GetModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFunction_GetModule(PyObject *)
     * }
     */
    public static MemorySegment PyFunction_GetModule(MemorySegment x0) {
        var mh$ = PyFunction_GetModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFunction_GetModule", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFunction_GetDefaults {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFunction_GetDefaults");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFunction_GetDefaults(PyObject *)
     * }
     */
    public static FunctionDescriptor PyFunction_GetDefaults$descriptor() {
        return PyFunction_GetDefaults.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFunction_GetDefaults(PyObject *)
     * }
     */
    public static MethodHandle PyFunction_GetDefaults$handle() {
        return PyFunction_GetDefaults.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFunction_GetDefaults(PyObject *)
     * }
     */
    public static MemorySegment PyFunction_GetDefaults$address() {
        return PyFunction_GetDefaults.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFunction_GetDefaults(PyObject *)
     * }
     */
    public static MemorySegment PyFunction_GetDefaults(MemorySegment x0) {
        var mh$ = PyFunction_GetDefaults.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFunction_GetDefaults", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFunction_SetDefaults {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFunction_SetDefaults");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyFunction_SetDefaults(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyFunction_SetDefaults$descriptor() {
        return PyFunction_SetDefaults.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyFunction_SetDefaults(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyFunction_SetDefaults$handle() {
        return PyFunction_SetDefaults.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyFunction_SetDefaults(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyFunction_SetDefaults$address() {
        return PyFunction_SetDefaults.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyFunction_SetDefaults(PyObject *, PyObject *)
     * }
     */
    public static int PyFunction_SetDefaults(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyFunction_SetDefaults.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFunction_SetDefaults", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFunction_GetKwDefaults {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFunction_GetKwDefaults");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFunction_GetKwDefaults(PyObject *)
     * }
     */
    public static FunctionDescriptor PyFunction_GetKwDefaults$descriptor() {
        return PyFunction_GetKwDefaults.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFunction_GetKwDefaults(PyObject *)
     * }
     */
    public static MethodHandle PyFunction_GetKwDefaults$handle() {
        return PyFunction_GetKwDefaults.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFunction_GetKwDefaults(PyObject *)
     * }
     */
    public static MemorySegment PyFunction_GetKwDefaults$address() {
        return PyFunction_GetKwDefaults.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFunction_GetKwDefaults(PyObject *)
     * }
     */
    public static MemorySegment PyFunction_GetKwDefaults(MemorySegment x0) {
        var mh$ = PyFunction_GetKwDefaults.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFunction_GetKwDefaults", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFunction_SetKwDefaults {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFunction_SetKwDefaults");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyFunction_SetKwDefaults(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyFunction_SetKwDefaults$descriptor() {
        return PyFunction_SetKwDefaults.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyFunction_SetKwDefaults(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyFunction_SetKwDefaults$handle() {
        return PyFunction_SetKwDefaults.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyFunction_SetKwDefaults(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyFunction_SetKwDefaults$address() {
        return PyFunction_SetKwDefaults.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyFunction_SetKwDefaults(PyObject *, PyObject *)
     * }
     */
    public static int PyFunction_SetKwDefaults(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyFunction_SetKwDefaults.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFunction_SetKwDefaults", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFunction_GetClosure {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFunction_GetClosure");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFunction_GetClosure(PyObject *)
     * }
     */
    public static FunctionDescriptor PyFunction_GetClosure$descriptor() {
        return PyFunction_GetClosure.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFunction_GetClosure(PyObject *)
     * }
     */
    public static MethodHandle PyFunction_GetClosure$handle() {
        return PyFunction_GetClosure.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFunction_GetClosure(PyObject *)
     * }
     */
    public static MemorySegment PyFunction_GetClosure$address() {
        return PyFunction_GetClosure.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFunction_GetClosure(PyObject *)
     * }
     */
    public static MemorySegment PyFunction_GetClosure(MemorySegment x0) {
        var mh$ = PyFunction_GetClosure.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFunction_GetClosure", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFunction_SetClosure {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFunction_SetClosure");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyFunction_SetClosure(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyFunction_SetClosure$descriptor() {
        return PyFunction_SetClosure.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyFunction_SetClosure(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyFunction_SetClosure$handle() {
        return PyFunction_SetClosure.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyFunction_SetClosure(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyFunction_SetClosure$address() {
        return PyFunction_SetClosure.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyFunction_SetClosure(PyObject *, PyObject *)
     * }
     */
    public static int PyFunction_SetClosure(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyFunction_SetClosure.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFunction_SetClosure", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFunction_GetAnnotations {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFunction_GetAnnotations");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFunction_GetAnnotations(PyObject *)
     * }
     */
    public static FunctionDescriptor PyFunction_GetAnnotations$descriptor() {
        return PyFunction_GetAnnotations.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFunction_GetAnnotations(PyObject *)
     * }
     */
    public static MethodHandle PyFunction_GetAnnotations$handle() {
        return PyFunction_GetAnnotations.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFunction_GetAnnotations(PyObject *)
     * }
     */
    public static MemorySegment PyFunction_GetAnnotations$address() {
        return PyFunction_GetAnnotations.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFunction_GetAnnotations(PyObject *)
     * }
     */
    public static MemorySegment PyFunction_GetAnnotations(MemorySegment x0) {
        var mh$ = PyFunction_GetAnnotations.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFunction_GetAnnotations", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFunction_SetAnnotations {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFunction_SetAnnotations");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyFunction_SetAnnotations(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyFunction_SetAnnotations$descriptor() {
        return PyFunction_SetAnnotations.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyFunction_SetAnnotations(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyFunction_SetAnnotations$handle() {
        return PyFunction_SetAnnotations.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyFunction_SetAnnotations(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyFunction_SetAnnotations$address() {
        return PyFunction_SetAnnotations.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyFunction_SetAnnotations(PyObject *, PyObject *)
     * }
     */
    public static int PyFunction_SetAnnotations(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyFunction_SetAnnotations.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFunction_SetAnnotations", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyFunction_Vectorcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyFunction_Vectorcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyFunction_Vectorcall(PyObject *func, PyObject *const *stack, size_t nargsf, PyObject *kwnames)
     * }
     */
    public static FunctionDescriptor _PyFunction_Vectorcall$descriptor() {
        return _PyFunction_Vectorcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyFunction_Vectorcall(PyObject *func, PyObject *const *stack, size_t nargsf, PyObject *kwnames)
     * }
     */
    public static MethodHandle _PyFunction_Vectorcall$handle() {
        return _PyFunction_Vectorcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyFunction_Vectorcall(PyObject *func, PyObject *const *stack, size_t nargsf, PyObject *kwnames)
     * }
     */
    public static MemorySegment _PyFunction_Vectorcall$address() {
        return _PyFunction_Vectorcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyFunction_Vectorcall(PyObject *func, PyObject *const *stack, size_t nargsf, PyObject *kwnames)
     * }
     */
    public static MemorySegment _PyFunction_Vectorcall(MemorySegment func, MemorySegment stack, long nargsf, MemorySegment kwnames) {
        var mh$ = _PyFunction_Vectorcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyFunction_Vectorcall", func, stack, nargsf, kwnames);
            }
            return (MemorySegment)mh$.invokeExact(func, stack, nargsf, kwnames);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyClassMethod_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyClassMethod_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyClassMethod_Type
     * }
     */
    public static GroupLayout PyClassMethod_Type$layout() {
        return PyClassMethod_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyClassMethod_Type
     * }
     */
    public static MemorySegment PyClassMethod_Type() {
        return PyClassMethod_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyClassMethod_Type
     * }
     */
    public static void PyClassMethod_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyClassMethod_Type$constants.SEGMENT, 0L, PyClassMethod_Type$constants.LAYOUT.byteSize());
    }

    private static class PyStaticMethod_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyStaticMethod_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyStaticMethod_Type
     * }
     */
    public static GroupLayout PyStaticMethod_Type$layout() {
        return PyStaticMethod_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyStaticMethod_Type
     * }
     */
    public static MemorySegment PyStaticMethod_Type() {
        return PyStaticMethod_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyStaticMethod_Type
     * }
     */
    public static void PyStaticMethod_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyStaticMethod_Type$constants.SEGMENT, 0L, PyStaticMethod_Type$constants.LAYOUT.byteSize());
    }

    private static class PyClassMethod_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyClassMethod_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyClassMethod_New(PyObject *)
     * }
     */
    public static FunctionDescriptor PyClassMethod_New$descriptor() {
        return PyClassMethod_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyClassMethod_New(PyObject *)
     * }
     */
    public static MethodHandle PyClassMethod_New$handle() {
        return PyClassMethod_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyClassMethod_New(PyObject *)
     * }
     */
    public static MemorySegment PyClassMethod_New$address() {
        return PyClassMethod_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyClassMethod_New(PyObject *)
     * }
     */
    public static MemorySegment PyClassMethod_New(MemorySegment x0) {
        var mh$ = PyClassMethod_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyClassMethod_New", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyStaticMethod_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyStaticMethod_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyStaticMethod_New(PyObject *)
     * }
     */
    public static FunctionDescriptor PyStaticMethod_New$descriptor() {
        return PyStaticMethod_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyStaticMethod_New(PyObject *)
     * }
     */
    public static MethodHandle PyStaticMethod_New$handle() {
        return PyStaticMethod_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyStaticMethod_New(PyObject *)
     * }
     */
    public static MemorySegment PyStaticMethod_New$address() {
        return PyStaticMethod_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyStaticMethod_New(PyObject *)
     * }
     */
    public static MemorySegment PyStaticMethod_New(MemorySegment x0) {
        var mh$ = PyStaticMethod_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyStaticMethod_New", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMethod_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyMethod_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyMethod_Type
     * }
     */
    public static GroupLayout PyMethod_Type$layout() {
        return PyMethod_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyMethod_Type
     * }
     */
    public static MemorySegment PyMethod_Type() {
        return PyMethod_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyMethod_Type
     * }
     */
    public static void PyMethod_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyMethod_Type$constants.SEGMENT, 0L, PyMethod_Type$constants.LAYOUT.byteSize());
    }

    private static class PyMethod_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMethod_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyMethod_New(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyMethod_New$descriptor() {
        return PyMethod_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyMethod_New(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyMethod_New$handle() {
        return PyMethod_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyMethod_New(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyMethod_New$address() {
        return PyMethod_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyMethod_New(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyMethod_New(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyMethod_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMethod_New", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMethod_Function {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMethod_Function");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyMethod_Function(PyObject *)
     * }
     */
    public static FunctionDescriptor PyMethod_Function$descriptor() {
        return PyMethod_Function.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyMethod_Function(PyObject *)
     * }
     */
    public static MethodHandle PyMethod_Function$handle() {
        return PyMethod_Function.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyMethod_Function(PyObject *)
     * }
     */
    public static MemorySegment PyMethod_Function$address() {
        return PyMethod_Function.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyMethod_Function(PyObject *)
     * }
     */
    public static MemorySegment PyMethod_Function(MemorySegment x0) {
        var mh$ = PyMethod_Function.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMethod_Function", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMethod_Self {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMethod_Self");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyMethod_Self(PyObject *)
     * }
     */
    public static FunctionDescriptor PyMethod_Self$descriptor() {
        return PyMethod_Self.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyMethod_Self(PyObject *)
     * }
     */
    public static MethodHandle PyMethod_Self$handle() {
        return PyMethod_Self.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyMethod_Self(PyObject *)
     * }
     */
    public static MemorySegment PyMethod_Self$address() {
        return PyMethod_Self.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyMethod_Self(PyObject *)
     * }
     */
    public static MemorySegment PyMethod_Self(MemorySegment x0) {
        var mh$ = PyMethod_Self.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMethod_Self", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyInstanceMethod_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyInstanceMethod_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyInstanceMethod_Type
     * }
     */
    public static GroupLayout PyInstanceMethod_Type$layout() {
        return PyInstanceMethod_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyInstanceMethod_Type
     * }
     */
    public static MemorySegment PyInstanceMethod_Type() {
        return PyInstanceMethod_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyInstanceMethod_Type
     * }
     */
    public static void PyInstanceMethod_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyInstanceMethod_Type$constants.SEGMENT, 0L, PyInstanceMethod_Type$constants.LAYOUT.byteSize());
    }

    private static class PyInstanceMethod_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyInstanceMethod_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyInstanceMethod_New(PyObject *)
     * }
     */
    public static FunctionDescriptor PyInstanceMethod_New$descriptor() {
        return PyInstanceMethod_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyInstanceMethod_New(PyObject *)
     * }
     */
    public static MethodHandle PyInstanceMethod_New$handle() {
        return PyInstanceMethod_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyInstanceMethod_New(PyObject *)
     * }
     */
    public static MemorySegment PyInstanceMethod_New$address() {
        return PyInstanceMethod_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyInstanceMethod_New(PyObject *)
     * }
     */
    public static MemorySegment PyInstanceMethod_New(MemorySegment x0) {
        var mh$ = PyInstanceMethod_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyInstanceMethod_New", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyInstanceMethod_Function {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyInstanceMethod_Function");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyInstanceMethod_Function(PyObject *)
     * }
     */
    public static FunctionDescriptor PyInstanceMethod_Function$descriptor() {
        return PyInstanceMethod_Function.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyInstanceMethod_Function(PyObject *)
     * }
     */
    public static MethodHandle PyInstanceMethod_Function$handle() {
        return PyInstanceMethod_Function.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyInstanceMethod_Function(PyObject *)
     * }
     */
    public static MemorySegment PyInstanceMethod_Function$address() {
        return PyInstanceMethod_Function.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyInstanceMethod_Function(PyObject *)
     * }
     */
    public static MemorySegment PyInstanceMethod_Function(MemorySegment x0) {
        var mh$ = PyInstanceMethod_Function.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyInstanceMethod_Function", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFile_FromFd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFile_FromFd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFile_FromFd(int, const char *, const char *, int, const char *, const char *, const char *, int)
     * }
     */
    public static FunctionDescriptor PyFile_FromFd$descriptor() {
        return PyFile_FromFd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFile_FromFd(int, const char *, const char *, int, const char *, const char *, const char *, int)
     * }
     */
    public static MethodHandle PyFile_FromFd$handle() {
        return PyFile_FromFd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFile_FromFd(int, const char *, const char *, int, const char *, const char *, const char *, int)
     * }
     */
    public static MemorySegment PyFile_FromFd$address() {
        return PyFile_FromFd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFile_FromFd(int, const char *, const char *, int, const char *, const char *, const char *, int)
     * }
     */
    public static MemorySegment PyFile_FromFd(int x0, MemorySegment x1, MemorySegment x2, int x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, int x7) {
        var mh$ = PyFile_FromFd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFile_FromFd", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFile_GetLine {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFile_GetLine");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFile_GetLine(PyObject *, int)
     * }
     */
    public static FunctionDescriptor PyFile_GetLine$descriptor() {
        return PyFile_GetLine.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFile_GetLine(PyObject *, int)
     * }
     */
    public static MethodHandle PyFile_GetLine$handle() {
        return PyFile_GetLine.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFile_GetLine(PyObject *, int)
     * }
     */
    public static MemorySegment PyFile_GetLine$address() {
        return PyFile_GetLine.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFile_GetLine(PyObject *, int)
     * }
     */
    public static MemorySegment PyFile_GetLine(MemorySegment x0, int x1) {
        var mh$ = PyFile_GetLine.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFile_GetLine", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFile_WriteObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFile_WriteObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyFile_WriteObject(PyObject *, PyObject *, int)
     * }
     */
    public static FunctionDescriptor PyFile_WriteObject$descriptor() {
        return PyFile_WriteObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyFile_WriteObject(PyObject *, PyObject *, int)
     * }
     */
    public static MethodHandle PyFile_WriteObject$handle() {
        return PyFile_WriteObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyFile_WriteObject(PyObject *, PyObject *, int)
     * }
     */
    public static MemorySegment PyFile_WriteObject$address() {
        return PyFile_WriteObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyFile_WriteObject(PyObject *, PyObject *, int)
     * }
     */
    public static int PyFile_WriteObject(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = PyFile_WriteObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFile_WriteObject", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFile_WriteString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFile_WriteString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyFile_WriteString(const char *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyFile_WriteString$descriptor() {
        return PyFile_WriteString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyFile_WriteString(const char *, PyObject *)
     * }
     */
    public static MethodHandle PyFile_WriteString$handle() {
        return PyFile_WriteString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyFile_WriteString(const char *, PyObject *)
     * }
     */
    public static MemorySegment PyFile_WriteString$address() {
        return PyFile_WriteString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyFile_WriteString(const char *, PyObject *)
     * }
     */
    public static int PyFile_WriteString(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyFile_WriteString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFile_WriteString", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_AsFileDescriptor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_AsFileDescriptor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_AsFileDescriptor(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_AsFileDescriptor$descriptor() {
        return PyObject_AsFileDescriptor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_AsFileDescriptor(PyObject *)
     * }
     */
    public static MethodHandle PyObject_AsFileDescriptor$handle() {
        return PyObject_AsFileDescriptor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_AsFileDescriptor(PyObject *)
     * }
     */
    public static MemorySegment PyObject_AsFileDescriptor$address() {
        return PyObject_AsFileDescriptor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_AsFileDescriptor(PyObject *)
     * }
     */
    public static int PyObject_AsFileDescriptor(MemorySegment x0) {
        var mh$ = PyObject_AsFileDescriptor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_AsFileDescriptor", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_FileSystemDefaultEncoding$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_FileSystemDefaultEncoding").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const char *Py_FileSystemDefaultEncoding
     * }
     */
    public static AddressLayout Py_FileSystemDefaultEncoding$layout() {
        return Py_FileSystemDefaultEncoding$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const char *Py_FileSystemDefaultEncoding
     * }
     */
    public static MemorySegment Py_FileSystemDefaultEncoding$segment() {
        return Py_FileSystemDefaultEncoding$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const char *Py_FileSystemDefaultEncoding
     * }
     */
    public static MemorySegment Py_FileSystemDefaultEncoding() {
        return Py_FileSystemDefaultEncoding$constants.SEGMENT.get(Py_FileSystemDefaultEncoding$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const char *Py_FileSystemDefaultEncoding
     * }
     */
    public static void Py_FileSystemDefaultEncoding(MemorySegment varValue) {
        Py_FileSystemDefaultEncoding$constants.SEGMENT.set(Py_FileSystemDefaultEncoding$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_FileSystemDefaultEncodeErrors$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_FileSystemDefaultEncodeErrors").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const char *Py_FileSystemDefaultEncodeErrors
     * }
     */
    public static AddressLayout Py_FileSystemDefaultEncodeErrors$layout() {
        return Py_FileSystemDefaultEncodeErrors$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const char *Py_FileSystemDefaultEncodeErrors
     * }
     */
    public static MemorySegment Py_FileSystemDefaultEncodeErrors$segment() {
        return Py_FileSystemDefaultEncodeErrors$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const char *Py_FileSystemDefaultEncodeErrors
     * }
     */
    public static MemorySegment Py_FileSystemDefaultEncodeErrors() {
        return Py_FileSystemDefaultEncodeErrors$constants.SEGMENT.get(Py_FileSystemDefaultEncodeErrors$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const char *Py_FileSystemDefaultEncodeErrors
     * }
     */
    public static void Py_FileSystemDefaultEncodeErrors(MemorySegment varValue) {
        Py_FileSystemDefaultEncodeErrors$constants.SEGMENT.set(Py_FileSystemDefaultEncodeErrors$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_HasFileSystemDefaultEncoding$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_HasFileSystemDefaultEncoding").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_HasFileSystemDefaultEncoding
     * }
     */
    public static OfInt Py_HasFileSystemDefaultEncoding$layout() {
        return Py_HasFileSystemDefaultEncoding$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_HasFileSystemDefaultEncoding
     * }
     */
    public static MemorySegment Py_HasFileSystemDefaultEncoding$segment() {
        return Py_HasFileSystemDefaultEncoding$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_HasFileSystemDefaultEncoding
     * }
     */
    public static int Py_HasFileSystemDefaultEncoding() {
        return Py_HasFileSystemDefaultEncoding$constants.SEGMENT.get(Py_HasFileSystemDefaultEncoding$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_HasFileSystemDefaultEncoding
     * }
     */
    public static void Py_HasFileSystemDefaultEncoding(int varValue) {
        Py_HasFileSystemDefaultEncoding$constants.SEGMENT.set(Py_HasFileSystemDefaultEncoding$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_UTF8Mode$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_UTF8Mode").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_UTF8Mode
     * }
     */
    public static OfInt Py_UTF8Mode$layout() {
        return Py_UTF8Mode$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_UTF8Mode
     * }
     */
    public static MemorySegment Py_UTF8Mode$segment() {
        return Py_UTF8Mode$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_UTF8Mode
     * }
     */
    public static int Py_UTF8Mode() {
        return Py_UTF8Mode$constants.SEGMENT.get(Py_UTF8Mode$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_UTF8Mode
     * }
     */
    public static void Py_UTF8Mode(int varValue) {
        Py_UTF8Mode$constants.SEGMENT.set(Py_UTF8Mode$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_UniversalNewlineFgets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_UniversalNewlineFgets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *Py_UniversalNewlineFgets(char *, int, FILE *, PyObject *)
     * }
     */
    public static FunctionDescriptor Py_UniversalNewlineFgets$descriptor() {
        return Py_UniversalNewlineFgets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *Py_UniversalNewlineFgets(char *, int, FILE *, PyObject *)
     * }
     */
    public static MethodHandle Py_UniversalNewlineFgets$handle() {
        return Py_UniversalNewlineFgets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *Py_UniversalNewlineFgets(char *, int, FILE *, PyObject *)
     * }
     */
    public static MemorySegment Py_UniversalNewlineFgets$address() {
        return Py_UniversalNewlineFgets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *Py_UniversalNewlineFgets(char *, int, FILE *, PyObject *)
     * }
     */
    public static MemorySegment Py_UniversalNewlineFgets(MemorySegment x0, int x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = Py_UniversalNewlineFgets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_UniversalNewlineFgets", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFile_NewStdPrinter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFile_NewStdPrinter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFile_NewStdPrinter(int)
     * }
     */
    public static FunctionDescriptor PyFile_NewStdPrinter$descriptor() {
        return PyFile_NewStdPrinter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFile_NewStdPrinter(int)
     * }
     */
    public static MethodHandle PyFile_NewStdPrinter$handle() {
        return PyFile_NewStdPrinter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFile_NewStdPrinter(int)
     * }
     */
    public static MemorySegment PyFile_NewStdPrinter$address() {
        return PyFile_NewStdPrinter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFile_NewStdPrinter(int)
     * }
     */
    public static MemorySegment PyFile_NewStdPrinter(int x0) {
        var mh$ = PyFile_NewStdPrinter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFile_NewStdPrinter", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyStdPrinter_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyStdPrinter_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyStdPrinter_Type
     * }
     */
    public static GroupLayout PyStdPrinter_Type$layout() {
        return PyStdPrinter_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyStdPrinter_Type
     * }
     */
    public static MemorySegment PyStdPrinter_Type() {
        return PyStdPrinter_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyStdPrinter_Type
     * }
     */
    public static void PyStdPrinter_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyStdPrinter_Type$constants.SEGMENT, 0L, PyStdPrinter_Type$constants.LAYOUT.byteSize());
    }

    private static class PyFile_OpenCode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFile_OpenCode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFile_OpenCode(const char *utf8path)
     * }
     */
    public static FunctionDescriptor PyFile_OpenCode$descriptor() {
        return PyFile_OpenCode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFile_OpenCode(const char *utf8path)
     * }
     */
    public static MethodHandle PyFile_OpenCode$handle() {
        return PyFile_OpenCode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFile_OpenCode(const char *utf8path)
     * }
     */
    public static MemorySegment PyFile_OpenCode$address() {
        return PyFile_OpenCode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFile_OpenCode(const char *utf8path)
     * }
     */
    public static MemorySegment PyFile_OpenCode(MemorySegment utf8path) {
        var mh$ = PyFile_OpenCode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFile_OpenCode", utf8path);
            }
            return (MemorySegment)mh$.invokeExact(utf8path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFile_OpenCodeObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFile_OpenCodeObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFile_OpenCodeObject(PyObject *path)
     * }
     */
    public static FunctionDescriptor PyFile_OpenCodeObject$descriptor() {
        return PyFile_OpenCodeObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFile_OpenCodeObject(PyObject *path)
     * }
     */
    public static MethodHandle PyFile_OpenCodeObject$handle() {
        return PyFile_OpenCodeObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFile_OpenCodeObject(PyObject *path)
     * }
     */
    public static MemorySegment PyFile_OpenCodeObject$address() {
        return PyFile_OpenCodeObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFile_OpenCodeObject(PyObject *path)
     * }
     */
    public static MemorySegment PyFile_OpenCodeObject(MemorySegment path) {
        var mh$ = PyFile_OpenCodeObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFile_OpenCodeObject", path);
            }
            return (MemorySegment)mh$.invokeExact(path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFile_SetOpenCodeHook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFile_SetOpenCodeHook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyFile_SetOpenCodeHook(Py_OpenCodeHookFunction hook, void *userData)
     * }
     */
    public static FunctionDescriptor PyFile_SetOpenCodeHook$descriptor() {
        return PyFile_SetOpenCodeHook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyFile_SetOpenCodeHook(Py_OpenCodeHookFunction hook, void *userData)
     * }
     */
    public static MethodHandle PyFile_SetOpenCodeHook$handle() {
        return PyFile_SetOpenCodeHook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyFile_SetOpenCodeHook(Py_OpenCodeHookFunction hook, void *userData)
     * }
     */
    public static MemorySegment PyFile_SetOpenCodeHook$address() {
        return PyFile_SetOpenCodeHook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyFile_SetOpenCodeHook(Py_OpenCodeHookFunction hook, void *userData)
     * }
     */
    public static int PyFile_SetOpenCodeHook(MemorySegment hook, MemorySegment userData) {
        var mh$ = PyFile_SetOpenCodeHook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFile_SetOpenCodeHook", hook, userData);
            }
            return (int)mh$.invokeExact(hook, userData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyLong_FileDescriptor_Converter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyLong_FileDescriptor_Converter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyLong_FileDescriptor_Converter(PyObject *, void *)
     * }
     */
    public static FunctionDescriptor _PyLong_FileDescriptor_Converter$descriptor() {
        return _PyLong_FileDescriptor_Converter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyLong_FileDescriptor_Converter(PyObject *, void *)
     * }
     */
    public static MethodHandle _PyLong_FileDescriptor_Converter$handle() {
        return _PyLong_FileDescriptor_Converter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyLong_FileDescriptor_Converter(PyObject *, void *)
     * }
     */
    public static MemorySegment _PyLong_FileDescriptor_Converter$address() {
        return _PyLong_FileDescriptor_Converter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyLong_FileDescriptor_Converter(PyObject *, void *)
     * }
     */
    public static int _PyLong_FileDescriptor_Converter(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyLong_FileDescriptor_Converter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyLong_FileDescriptor_Converter", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCapsule_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyCapsule_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCapsule_Type
     * }
     */
    public static GroupLayout PyCapsule_Type$layout() {
        return PyCapsule_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCapsule_Type
     * }
     */
    public static MemorySegment PyCapsule_Type() {
        return PyCapsule_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCapsule_Type
     * }
     */
    public static void PyCapsule_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyCapsule_Type$constants.SEGMENT, 0L, PyCapsule_Type$constants.LAYOUT.byteSize());
    }

    private static class PyCapsule_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCapsule_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCapsule_New(void *pointer, const char *name, PyCapsule_Destructor destructor)
     * }
     */
    public static FunctionDescriptor PyCapsule_New$descriptor() {
        return PyCapsule_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCapsule_New(void *pointer, const char *name, PyCapsule_Destructor destructor)
     * }
     */
    public static MethodHandle PyCapsule_New$handle() {
        return PyCapsule_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCapsule_New(void *pointer, const char *name, PyCapsule_Destructor destructor)
     * }
     */
    public static MemorySegment PyCapsule_New$address() {
        return PyCapsule_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCapsule_New(void *pointer, const char *name, PyCapsule_Destructor destructor)
     * }
     */
    public static MemorySegment PyCapsule_New(MemorySegment pointer, MemorySegment name, MemorySegment destructor) {
        var mh$ = PyCapsule_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCapsule_New", pointer, name, destructor);
            }
            return (MemorySegment)mh$.invokeExact(pointer, name, destructor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCapsule_GetPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCapsule_GetPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyCapsule_GetPointer(PyObject *capsule, const char *name)
     * }
     */
    public static FunctionDescriptor PyCapsule_GetPointer$descriptor() {
        return PyCapsule_GetPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyCapsule_GetPointer(PyObject *capsule, const char *name)
     * }
     */
    public static MethodHandle PyCapsule_GetPointer$handle() {
        return PyCapsule_GetPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyCapsule_GetPointer(PyObject *capsule, const char *name)
     * }
     */
    public static MemorySegment PyCapsule_GetPointer$address() {
        return PyCapsule_GetPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyCapsule_GetPointer(PyObject *capsule, const char *name)
     * }
     */
    public static MemorySegment PyCapsule_GetPointer(MemorySegment capsule, MemorySegment name) {
        var mh$ = PyCapsule_GetPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCapsule_GetPointer", capsule, name);
            }
            return (MemorySegment)mh$.invokeExact(capsule, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCapsule_GetDestructor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCapsule_GetDestructor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyCapsule_Destructor PyCapsule_GetDestructor(PyObject *capsule)
     * }
     */
    public static FunctionDescriptor PyCapsule_GetDestructor$descriptor() {
        return PyCapsule_GetDestructor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyCapsule_Destructor PyCapsule_GetDestructor(PyObject *capsule)
     * }
     */
    public static MethodHandle PyCapsule_GetDestructor$handle() {
        return PyCapsule_GetDestructor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyCapsule_Destructor PyCapsule_GetDestructor(PyObject *capsule)
     * }
     */
    public static MemorySegment PyCapsule_GetDestructor$address() {
        return PyCapsule_GetDestructor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyCapsule_Destructor PyCapsule_GetDestructor(PyObject *capsule)
     * }
     */
    public static MemorySegment PyCapsule_GetDestructor(MemorySegment capsule) {
        var mh$ = PyCapsule_GetDestructor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCapsule_GetDestructor", capsule);
            }
            return (MemorySegment)mh$.invokeExact(capsule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCapsule_GetName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCapsule_GetName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *PyCapsule_GetName(PyObject *capsule)
     * }
     */
    public static FunctionDescriptor PyCapsule_GetName$descriptor() {
        return PyCapsule_GetName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *PyCapsule_GetName(PyObject *capsule)
     * }
     */
    public static MethodHandle PyCapsule_GetName$handle() {
        return PyCapsule_GetName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *PyCapsule_GetName(PyObject *capsule)
     * }
     */
    public static MemorySegment PyCapsule_GetName$address() {
        return PyCapsule_GetName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *PyCapsule_GetName(PyObject *capsule)
     * }
     */
    public static MemorySegment PyCapsule_GetName(MemorySegment capsule) {
        var mh$ = PyCapsule_GetName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCapsule_GetName", capsule);
            }
            return (MemorySegment)mh$.invokeExact(capsule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCapsule_GetContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCapsule_GetContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyCapsule_GetContext(PyObject *capsule)
     * }
     */
    public static FunctionDescriptor PyCapsule_GetContext$descriptor() {
        return PyCapsule_GetContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyCapsule_GetContext(PyObject *capsule)
     * }
     */
    public static MethodHandle PyCapsule_GetContext$handle() {
        return PyCapsule_GetContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyCapsule_GetContext(PyObject *capsule)
     * }
     */
    public static MemorySegment PyCapsule_GetContext$address() {
        return PyCapsule_GetContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyCapsule_GetContext(PyObject *capsule)
     * }
     */
    public static MemorySegment PyCapsule_GetContext(MemorySegment capsule) {
        var mh$ = PyCapsule_GetContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCapsule_GetContext", capsule);
            }
            return (MemorySegment)mh$.invokeExact(capsule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCapsule_IsValid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCapsule_IsValid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyCapsule_IsValid(PyObject *capsule, const char *name)
     * }
     */
    public static FunctionDescriptor PyCapsule_IsValid$descriptor() {
        return PyCapsule_IsValid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyCapsule_IsValid(PyObject *capsule, const char *name)
     * }
     */
    public static MethodHandle PyCapsule_IsValid$handle() {
        return PyCapsule_IsValid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyCapsule_IsValid(PyObject *capsule, const char *name)
     * }
     */
    public static MemorySegment PyCapsule_IsValid$address() {
        return PyCapsule_IsValid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyCapsule_IsValid(PyObject *capsule, const char *name)
     * }
     */
    public static int PyCapsule_IsValid(MemorySegment capsule, MemorySegment name) {
        var mh$ = PyCapsule_IsValid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCapsule_IsValid", capsule, name);
            }
            return (int)mh$.invokeExact(capsule, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCapsule_SetPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCapsule_SetPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyCapsule_SetPointer(PyObject *capsule, void *pointer)
     * }
     */
    public static FunctionDescriptor PyCapsule_SetPointer$descriptor() {
        return PyCapsule_SetPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyCapsule_SetPointer(PyObject *capsule, void *pointer)
     * }
     */
    public static MethodHandle PyCapsule_SetPointer$handle() {
        return PyCapsule_SetPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyCapsule_SetPointer(PyObject *capsule, void *pointer)
     * }
     */
    public static MemorySegment PyCapsule_SetPointer$address() {
        return PyCapsule_SetPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyCapsule_SetPointer(PyObject *capsule, void *pointer)
     * }
     */
    public static int PyCapsule_SetPointer(MemorySegment capsule, MemorySegment pointer) {
        var mh$ = PyCapsule_SetPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCapsule_SetPointer", capsule, pointer);
            }
            return (int)mh$.invokeExact(capsule, pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCapsule_SetDestructor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCapsule_SetDestructor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyCapsule_SetDestructor(PyObject *capsule, PyCapsule_Destructor destructor)
     * }
     */
    public static FunctionDescriptor PyCapsule_SetDestructor$descriptor() {
        return PyCapsule_SetDestructor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyCapsule_SetDestructor(PyObject *capsule, PyCapsule_Destructor destructor)
     * }
     */
    public static MethodHandle PyCapsule_SetDestructor$handle() {
        return PyCapsule_SetDestructor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyCapsule_SetDestructor(PyObject *capsule, PyCapsule_Destructor destructor)
     * }
     */
    public static MemorySegment PyCapsule_SetDestructor$address() {
        return PyCapsule_SetDestructor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyCapsule_SetDestructor(PyObject *capsule, PyCapsule_Destructor destructor)
     * }
     */
    public static int PyCapsule_SetDestructor(MemorySegment capsule, MemorySegment destructor) {
        var mh$ = PyCapsule_SetDestructor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCapsule_SetDestructor", capsule, destructor);
            }
            return (int)mh$.invokeExact(capsule, destructor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCapsule_SetName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCapsule_SetName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyCapsule_SetName(PyObject *capsule, const char *name)
     * }
     */
    public static FunctionDescriptor PyCapsule_SetName$descriptor() {
        return PyCapsule_SetName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyCapsule_SetName(PyObject *capsule, const char *name)
     * }
     */
    public static MethodHandle PyCapsule_SetName$handle() {
        return PyCapsule_SetName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyCapsule_SetName(PyObject *capsule, const char *name)
     * }
     */
    public static MemorySegment PyCapsule_SetName$address() {
        return PyCapsule_SetName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyCapsule_SetName(PyObject *capsule, const char *name)
     * }
     */
    public static int PyCapsule_SetName(MemorySegment capsule, MemorySegment name) {
        var mh$ = PyCapsule_SetName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCapsule_SetName", capsule, name);
            }
            return (int)mh$.invokeExact(capsule, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCapsule_SetContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCapsule_SetContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyCapsule_SetContext(PyObject *capsule, void *context)
     * }
     */
    public static FunctionDescriptor PyCapsule_SetContext$descriptor() {
        return PyCapsule_SetContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyCapsule_SetContext(PyObject *capsule, void *context)
     * }
     */
    public static MethodHandle PyCapsule_SetContext$handle() {
        return PyCapsule_SetContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyCapsule_SetContext(PyObject *capsule, void *context)
     * }
     */
    public static MemorySegment PyCapsule_SetContext$address() {
        return PyCapsule_SetContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyCapsule_SetContext(PyObject *capsule, void *context)
     * }
     */
    public static int PyCapsule_SetContext(MemorySegment capsule, MemorySegment context) {
        var mh$ = PyCapsule_SetContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCapsule_SetContext", capsule, context);
            }
            return (int)mh$.invokeExact(capsule, context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCapsule_Import {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCapsule_Import");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyCapsule_Import(const char *name, int no_block)
     * }
     */
    public static FunctionDescriptor PyCapsule_Import$descriptor() {
        return PyCapsule_Import.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyCapsule_Import(const char *name, int no_block)
     * }
     */
    public static MethodHandle PyCapsule_Import$handle() {
        return PyCapsule_Import.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyCapsule_Import(const char *name, int no_block)
     * }
     */
    public static MemorySegment PyCapsule_Import$address() {
        return PyCapsule_Import.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyCapsule_Import(const char *name, int no_block)
     * }
     */
    public static MemorySegment PyCapsule_Import(MemorySegment name, int no_block) {
        var mh$ = PyCapsule_Import.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCapsule_Import", name, no_block);
            }
            return (MemorySegment)mh$.invokeExact(name, no_block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef uint16_t _Py_CODEUNIT
     * }
     */
    public static final OfShort _Py_CODEUNIT = Python_h.C_SHORT;

    private static class PyCode_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyCode_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCode_Type
     * }
     */
    public static GroupLayout PyCode_Type$layout() {
        return PyCode_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCode_Type
     * }
     */
    public static MemorySegment PyCode_Type() {
        return PyCode_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCode_Type
     * }
     */
    public static void PyCode_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyCode_Type$constants.SEGMENT, 0L, PyCode_Type$constants.LAYOUT.byteSize());
    }

    private static class PyCode_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCode_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyCodeObject *PyCode_New(int, int, int, int, int, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, int, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyCode_New$descriptor() {
        return PyCode_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyCodeObject *PyCode_New(int, int, int, int, int, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, int, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyCode_New$handle() {
        return PyCode_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyCodeObject *PyCode_New(int, int, int, int, int, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, int, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyCode_New$address() {
        return PyCode_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyCodeObject *PyCode_New(int, int, int, int, int, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, int, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyCode_New(int x0, int x1, int x2, int x3, int x4, MemorySegment x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11, MemorySegment x12, MemorySegment x13, int x14, MemorySegment x15, MemorySegment x16) {
        var mh$ = PyCode_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCode_New", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCode_NewWithPosOnlyArgs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCode_NewWithPosOnlyArgs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyCodeObject *PyCode_NewWithPosOnlyArgs(int, int, int, int, int, int, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, int, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyCode_NewWithPosOnlyArgs$descriptor() {
        return PyCode_NewWithPosOnlyArgs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyCodeObject *PyCode_NewWithPosOnlyArgs(int, int, int, int, int, int, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, int, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyCode_NewWithPosOnlyArgs$handle() {
        return PyCode_NewWithPosOnlyArgs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyCodeObject *PyCode_NewWithPosOnlyArgs(int, int, int, int, int, int, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, int, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyCode_NewWithPosOnlyArgs$address() {
        return PyCode_NewWithPosOnlyArgs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyCodeObject *PyCode_NewWithPosOnlyArgs(int, int, int, int, int, int, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, PyObject *, int, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyCode_NewWithPosOnlyArgs(int x0, int x1, int x2, int x3, int x4, int x5, MemorySegment x6, MemorySegment x7, MemorySegment x8, MemorySegment x9, MemorySegment x10, MemorySegment x11, MemorySegment x12, MemorySegment x13, MemorySegment x14, int x15, MemorySegment x16, MemorySegment x17) {
        var mh$ = PyCode_NewWithPosOnlyArgs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCode_NewWithPosOnlyArgs", x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCode_NewEmpty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCode_NewEmpty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyCodeObject *PyCode_NewEmpty(const char *filename, const char *funcname, int firstlineno)
     * }
     */
    public static FunctionDescriptor PyCode_NewEmpty$descriptor() {
        return PyCode_NewEmpty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyCodeObject *PyCode_NewEmpty(const char *filename, const char *funcname, int firstlineno)
     * }
     */
    public static MethodHandle PyCode_NewEmpty$handle() {
        return PyCode_NewEmpty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyCodeObject *PyCode_NewEmpty(const char *filename, const char *funcname, int firstlineno)
     * }
     */
    public static MemorySegment PyCode_NewEmpty$address() {
        return PyCode_NewEmpty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyCodeObject *PyCode_NewEmpty(const char *filename, const char *funcname, int firstlineno)
     * }
     */
    public static MemorySegment PyCode_NewEmpty(MemorySegment filename, MemorySegment funcname, int firstlineno) {
        var mh$ = PyCode_NewEmpty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCode_NewEmpty", filename, funcname, firstlineno);
            }
            return (MemorySegment)mh$.invokeExact(filename, funcname, firstlineno);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCode_Addr2Line {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCode_Addr2Line");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyCode_Addr2Line(PyCodeObject *, int)
     * }
     */
    public static FunctionDescriptor PyCode_Addr2Line$descriptor() {
        return PyCode_Addr2Line.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyCode_Addr2Line(PyCodeObject *, int)
     * }
     */
    public static MethodHandle PyCode_Addr2Line$handle() {
        return PyCode_Addr2Line.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyCode_Addr2Line(PyCodeObject *, int)
     * }
     */
    public static MemorySegment PyCode_Addr2Line$address() {
        return PyCode_Addr2Line.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyCode_Addr2Line(PyCodeObject *, int)
     * }
     */
    public static int PyCode_Addr2Line(MemorySegment x0, int x1) {
        var mh$ = PyCode_Addr2Line.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCode_Addr2Line", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCode_Addr2Location {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCode_Addr2Location");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyCode_Addr2Location(PyCodeObject *, int, int *, int *, int *, int *)
     * }
     */
    public static FunctionDescriptor PyCode_Addr2Location$descriptor() {
        return PyCode_Addr2Location.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyCode_Addr2Location(PyCodeObject *, int, int *, int *, int *, int *)
     * }
     */
    public static MethodHandle PyCode_Addr2Location$handle() {
        return PyCode_Addr2Location.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyCode_Addr2Location(PyCodeObject *, int, int *, int *, int *, int *)
     * }
     */
    public static MemorySegment PyCode_Addr2Location$address() {
        return PyCode_Addr2Location.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyCode_Addr2Location(PyCodeObject *, int, int *, int *, int *, int *)
     * }
     */
    public static int PyCode_Addr2Location(MemorySegment x0, int x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = PyCode_Addr2Location.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCode_Addr2Location", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyCode_CheckLineNumber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyCode_CheckLineNumber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyCode_CheckLineNumber(int lasti, PyCodeAddressRange *bounds)
     * }
     */
    public static FunctionDescriptor _PyCode_CheckLineNumber$descriptor() {
        return _PyCode_CheckLineNumber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyCode_CheckLineNumber(int lasti, PyCodeAddressRange *bounds)
     * }
     */
    public static MethodHandle _PyCode_CheckLineNumber$handle() {
        return _PyCode_CheckLineNumber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyCode_CheckLineNumber(int lasti, PyCodeAddressRange *bounds)
     * }
     */
    public static MemorySegment _PyCode_CheckLineNumber$address() {
        return _PyCode_CheckLineNumber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyCode_CheckLineNumber(int lasti, PyCodeAddressRange *bounds)
     * }
     */
    public static int _PyCode_CheckLineNumber(int lasti, MemorySegment bounds) {
        var mh$ = _PyCode_CheckLineNumber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyCode_CheckLineNumber", lasti, bounds);
            }
            return (int)mh$.invokeExact(lasti, bounds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyCode_ConstantKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyCode_ConstantKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyCode_ConstantKey(PyObject *obj)
     * }
     */
    public static FunctionDescriptor _PyCode_ConstantKey$descriptor() {
        return _PyCode_ConstantKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyCode_ConstantKey(PyObject *obj)
     * }
     */
    public static MethodHandle _PyCode_ConstantKey$handle() {
        return _PyCode_ConstantKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyCode_ConstantKey(PyObject *obj)
     * }
     */
    public static MemorySegment _PyCode_ConstantKey$address() {
        return _PyCode_ConstantKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyCode_ConstantKey(PyObject *obj)
     * }
     */
    public static MemorySegment _PyCode_ConstantKey(MemorySegment obj) {
        var mh$ = _PyCode_ConstantKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyCode_ConstantKey", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCode_Optimize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCode_Optimize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCode_Optimize(PyObject *code, PyObject *consts, PyObject *names, PyObject *lnotab)
     * }
     */
    public static FunctionDescriptor PyCode_Optimize$descriptor() {
        return PyCode_Optimize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCode_Optimize(PyObject *code, PyObject *consts, PyObject *names, PyObject *lnotab)
     * }
     */
    public static MethodHandle PyCode_Optimize$handle() {
        return PyCode_Optimize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCode_Optimize(PyObject *code, PyObject *consts, PyObject *names, PyObject *lnotab)
     * }
     */
    public static MemorySegment PyCode_Optimize$address() {
        return PyCode_Optimize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCode_Optimize(PyObject *code, PyObject *consts, PyObject *names, PyObject *lnotab)
     * }
     */
    public static MemorySegment PyCode_Optimize(MemorySegment code, MemorySegment consts, MemorySegment names, MemorySegment lnotab) {
        var mh$ = PyCode_Optimize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCode_Optimize", code, consts, names, lnotab);
            }
            return (MemorySegment)mh$.invokeExact(code, consts, names, lnotab);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyCode_GetExtra {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyCode_GetExtra");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyCode_GetExtra(PyObject *code, Py_ssize_t index, void **extra)
     * }
     */
    public static FunctionDescriptor _PyCode_GetExtra$descriptor() {
        return _PyCode_GetExtra.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyCode_GetExtra(PyObject *code, Py_ssize_t index, void **extra)
     * }
     */
    public static MethodHandle _PyCode_GetExtra$handle() {
        return _PyCode_GetExtra.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyCode_GetExtra(PyObject *code, Py_ssize_t index, void **extra)
     * }
     */
    public static MemorySegment _PyCode_GetExtra$address() {
        return _PyCode_GetExtra.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyCode_GetExtra(PyObject *code, Py_ssize_t index, void **extra)
     * }
     */
    public static int _PyCode_GetExtra(MemorySegment code, long index, MemorySegment extra) {
        var mh$ = _PyCode_GetExtra.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyCode_GetExtra", code, index, extra);
            }
            return (int)mh$.invokeExact(code, index, extra);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyCode_SetExtra {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyCode_SetExtra");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyCode_SetExtra(PyObject *code, Py_ssize_t index, void *extra)
     * }
     */
    public static FunctionDescriptor _PyCode_SetExtra$descriptor() {
        return _PyCode_SetExtra.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyCode_SetExtra(PyObject *code, Py_ssize_t index, void *extra)
     * }
     */
    public static MethodHandle _PyCode_SetExtra$handle() {
        return _PyCode_SetExtra.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyCode_SetExtra(PyObject *code, Py_ssize_t index, void *extra)
     * }
     */
    public static MemorySegment _PyCode_SetExtra$address() {
        return _PyCode_SetExtra.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyCode_SetExtra(PyObject *code, Py_ssize_t index, void *extra)
     * }
     */
    public static int _PyCode_SetExtra(MemorySegment code, long index, MemorySegment extra) {
        var mh$ = _PyCode_SetExtra.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyCode_SetExtra", code, index, extra);
            }
            return (int)mh$.invokeExact(code, index, extra);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCode_GetCode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCode_GetCode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCode_GetCode(PyCodeObject *code)
     * }
     */
    public static FunctionDescriptor PyCode_GetCode$descriptor() {
        return PyCode_GetCode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCode_GetCode(PyCodeObject *code)
     * }
     */
    public static MethodHandle PyCode_GetCode$handle() {
        return PyCode_GetCode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCode_GetCode(PyCodeObject *code)
     * }
     */
    public static MemorySegment PyCode_GetCode$address() {
        return PyCode_GetCode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCode_GetCode(PyCodeObject *code)
     * }
     */
    public static MemorySegment PyCode_GetCode(MemorySegment code) {
        var mh$ = PyCode_GetCode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCode_GetCode", code);
            }
            return (MemorySegment)mh$.invokeExact(code);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCode_GetVarnames {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCode_GetVarnames");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCode_GetVarnames(PyCodeObject *code)
     * }
     */
    public static FunctionDescriptor PyCode_GetVarnames$descriptor() {
        return PyCode_GetVarnames.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCode_GetVarnames(PyCodeObject *code)
     * }
     */
    public static MethodHandle PyCode_GetVarnames$handle() {
        return PyCode_GetVarnames.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCode_GetVarnames(PyCodeObject *code)
     * }
     */
    public static MemorySegment PyCode_GetVarnames$address() {
        return PyCode_GetVarnames.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCode_GetVarnames(PyCodeObject *code)
     * }
     */
    public static MemorySegment PyCode_GetVarnames(MemorySegment code) {
        var mh$ = PyCode_GetVarnames.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCode_GetVarnames", code);
            }
            return (MemorySegment)mh$.invokeExact(code);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCode_GetCellvars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCode_GetCellvars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCode_GetCellvars(PyCodeObject *code)
     * }
     */
    public static FunctionDescriptor PyCode_GetCellvars$descriptor() {
        return PyCode_GetCellvars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCode_GetCellvars(PyCodeObject *code)
     * }
     */
    public static MethodHandle PyCode_GetCellvars$handle() {
        return PyCode_GetCellvars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCode_GetCellvars(PyCodeObject *code)
     * }
     */
    public static MemorySegment PyCode_GetCellvars$address() {
        return PyCode_GetCellvars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCode_GetCellvars(PyCodeObject *code)
     * }
     */
    public static MemorySegment PyCode_GetCellvars(MemorySegment code) {
        var mh$ = PyCode_GetCellvars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCode_GetCellvars", code);
            }
            return (MemorySegment)mh$.invokeExact(code);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCode_GetFreevars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCode_GetFreevars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCode_GetFreevars(PyCodeObject *code)
     * }
     */
    public static FunctionDescriptor PyCode_GetFreevars$descriptor() {
        return PyCode_GetFreevars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCode_GetFreevars(PyCodeObject *code)
     * }
     */
    public static MethodHandle PyCode_GetFreevars$handle() {
        return PyCode_GetFreevars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCode_GetFreevars(PyCodeObject *code)
     * }
     */
    public static MemorySegment PyCode_GetFreevars$address() {
        return PyCode_GetFreevars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCode_GetFreevars(PyCodeObject *code)
     * }
     */
    public static MemorySegment PyCode_GetFreevars(MemorySegment code) {
        var mh$ = PyCode_GetFreevars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCode_GetFreevars", code);
            }
            return (MemorySegment)mh$.invokeExact(code);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int PY_CODE_LOCATION_INFO_SHORT0 = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _PyCodeLocationInfoKind.PY_CODE_LOCATION_INFO_SHORT0 = 0
     * }
     */
    public static int PY_CODE_LOCATION_INFO_SHORT0() {
        return PY_CODE_LOCATION_INFO_SHORT0;
    }
    private static final int PY_CODE_LOCATION_INFO_ONE_LINE0 = (int)10L;
    /**
     * {@snippet lang=c :
     * enum _PyCodeLocationInfoKind.PY_CODE_LOCATION_INFO_ONE_LINE0 = 10
     * }
     */
    public static int PY_CODE_LOCATION_INFO_ONE_LINE0() {
        return PY_CODE_LOCATION_INFO_ONE_LINE0;
    }
    private static final int PY_CODE_LOCATION_INFO_ONE_LINE1 = (int)11L;
    /**
     * {@snippet lang=c :
     * enum _PyCodeLocationInfoKind.PY_CODE_LOCATION_INFO_ONE_LINE1 = 11
     * }
     */
    public static int PY_CODE_LOCATION_INFO_ONE_LINE1() {
        return PY_CODE_LOCATION_INFO_ONE_LINE1;
    }
    private static final int PY_CODE_LOCATION_INFO_ONE_LINE2 = (int)12L;
    /**
     * {@snippet lang=c :
     * enum _PyCodeLocationInfoKind.PY_CODE_LOCATION_INFO_ONE_LINE2 = 12
     * }
     */
    public static int PY_CODE_LOCATION_INFO_ONE_LINE2() {
        return PY_CODE_LOCATION_INFO_ONE_LINE2;
    }
    private static final int PY_CODE_LOCATION_INFO_NO_COLUMNS = (int)13L;
    /**
     * {@snippet lang=c :
     * enum _PyCodeLocationInfoKind.PY_CODE_LOCATION_INFO_NO_COLUMNS = 13
     * }
     */
    public static int PY_CODE_LOCATION_INFO_NO_COLUMNS() {
        return PY_CODE_LOCATION_INFO_NO_COLUMNS;
    }
    private static final int PY_CODE_LOCATION_INFO_LONG = (int)14L;
    /**
     * {@snippet lang=c :
     * enum _PyCodeLocationInfoKind.PY_CODE_LOCATION_INFO_LONG = 14
     * }
     */
    public static int PY_CODE_LOCATION_INFO_LONG() {
        return PY_CODE_LOCATION_INFO_LONG;
    }
    private static final int PY_CODE_LOCATION_INFO_NONE = (int)15L;
    /**
     * {@snippet lang=c :
     * enum _PyCodeLocationInfoKind.PY_CODE_LOCATION_INFO_NONE = 15
     * }
     */
    public static int PY_CODE_LOCATION_INFO_NONE() {
        return PY_CODE_LOCATION_INFO_NONE;
    }

    private static class PyFrame_GetLineNumber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFrame_GetLineNumber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyFrame_GetLineNumber(PyFrameObject *)
     * }
     */
    public static FunctionDescriptor PyFrame_GetLineNumber$descriptor() {
        return PyFrame_GetLineNumber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyFrame_GetLineNumber(PyFrameObject *)
     * }
     */
    public static MethodHandle PyFrame_GetLineNumber$handle() {
        return PyFrame_GetLineNumber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyFrame_GetLineNumber(PyFrameObject *)
     * }
     */
    public static MemorySegment PyFrame_GetLineNumber$address() {
        return PyFrame_GetLineNumber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyFrame_GetLineNumber(PyFrameObject *)
     * }
     */
    public static int PyFrame_GetLineNumber(MemorySegment x0) {
        var mh$ = PyFrame_GetLineNumber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFrame_GetLineNumber", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFrame_GetCode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFrame_GetCode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyCodeObject *PyFrame_GetCode(PyFrameObject *frame)
     * }
     */
    public static FunctionDescriptor PyFrame_GetCode$descriptor() {
        return PyFrame_GetCode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyCodeObject *PyFrame_GetCode(PyFrameObject *frame)
     * }
     */
    public static MethodHandle PyFrame_GetCode$handle() {
        return PyFrame_GetCode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyCodeObject *PyFrame_GetCode(PyFrameObject *frame)
     * }
     */
    public static MemorySegment PyFrame_GetCode$address() {
        return PyFrame_GetCode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyCodeObject *PyFrame_GetCode(PyFrameObject *frame)
     * }
     */
    public static MemorySegment PyFrame_GetCode(MemorySegment frame) {
        var mh$ = PyFrame_GetCode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFrame_GetCode", frame);
            }
            return (MemorySegment)mh$.invokeExact(frame);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFrame_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyFrame_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyFrame_Type
     * }
     */
    public static GroupLayout PyFrame_Type$layout() {
        return PyFrame_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyFrame_Type
     * }
     */
    public static MemorySegment PyFrame_Type() {
        return PyFrame_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyFrame_Type
     * }
     */
    public static void PyFrame_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyFrame_Type$constants.SEGMENT, 0L, PyFrame_Type$constants.LAYOUT.byteSize());
    }

    private static class PyFrame_GetBack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFrame_GetBack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyFrameObject *PyFrame_GetBack(PyFrameObject *frame)
     * }
     */
    public static FunctionDescriptor PyFrame_GetBack$descriptor() {
        return PyFrame_GetBack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyFrameObject *PyFrame_GetBack(PyFrameObject *frame)
     * }
     */
    public static MethodHandle PyFrame_GetBack$handle() {
        return PyFrame_GetBack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyFrameObject *PyFrame_GetBack(PyFrameObject *frame)
     * }
     */
    public static MemorySegment PyFrame_GetBack$address() {
        return PyFrame_GetBack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyFrameObject *PyFrame_GetBack(PyFrameObject *frame)
     * }
     */
    public static MemorySegment PyFrame_GetBack(MemorySegment frame) {
        var mh$ = PyFrame_GetBack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFrame_GetBack", frame);
            }
            return (MemorySegment)mh$.invokeExact(frame);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFrame_GetLocals {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFrame_GetLocals");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFrame_GetLocals(PyFrameObject *frame)
     * }
     */
    public static FunctionDescriptor PyFrame_GetLocals$descriptor() {
        return PyFrame_GetLocals.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFrame_GetLocals(PyFrameObject *frame)
     * }
     */
    public static MethodHandle PyFrame_GetLocals$handle() {
        return PyFrame_GetLocals.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFrame_GetLocals(PyFrameObject *frame)
     * }
     */
    public static MemorySegment PyFrame_GetLocals$address() {
        return PyFrame_GetLocals.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFrame_GetLocals(PyFrameObject *frame)
     * }
     */
    public static MemorySegment PyFrame_GetLocals(MemorySegment frame) {
        var mh$ = PyFrame_GetLocals.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFrame_GetLocals", frame);
            }
            return (MemorySegment)mh$.invokeExact(frame);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFrame_GetGlobals {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFrame_GetGlobals");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFrame_GetGlobals(PyFrameObject *frame)
     * }
     */
    public static FunctionDescriptor PyFrame_GetGlobals$descriptor() {
        return PyFrame_GetGlobals.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFrame_GetGlobals(PyFrameObject *frame)
     * }
     */
    public static MethodHandle PyFrame_GetGlobals$handle() {
        return PyFrame_GetGlobals.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFrame_GetGlobals(PyFrameObject *frame)
     * }
     */
    public static MemorySegment PyFrame_GetGlobals$address() {
        return PyFrame_GetGlobals.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFrame_GetGlobals(PyFrameObject *frame)
     * }
     */
    public static MemorySegment PyFrame_GetGlobals(MemorySegment frame) {
        var mh$ = PyFrame_GetGlobals.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFrame_GetGlobals", frame);
            }
            return (MemorySegment)mh$.invokeExact(frame);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFrame_GetBuiltins {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFrame_GetBuiltins");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFrame_GetBuiltins(PyFrameObject *frame)
     * }
     */
    public static FunctionDescriptor PyFrame_GetBuiltins$descriptor() {
        return PyFrame_GetBuiltins.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFrame_GetBuiltins(PyFrameObject *frame)
     * }
     */
    public static MethodHandle PyFrame_GetBuiltins$handle() {
        return PyFrame_GetBuiltins.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFrame_GetBuiltins(PyFrameObject *frame)
     * }
     */
    public static MemorySegment PyFrame_GetBuiltins$address() {
        return PyFrame_GetBuiltins.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFrame_GetBuiltins(PyFrameObject *frame)
     * }
     */
    public static MemorySegment PyFrame_GetBuiltins(MemorySegment frame) {
        var mh$ = PyFrame_GetBuiltins.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFrame_GetBuiltins", frame);
            }
            return (MemorySegment)mh$.invokeExact(frame);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFrame_GetGenerator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFrame_GetGenerator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFrame_GetGenerator(PyFrameObject *frame)
     * }
     */
    public static FunctionDescriptor PyFrame_GetGenerator$descriptor() {
        return PyFrame_GetGenerator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFrame_GetGenerator(PyFrameObject *frame)
     * }
     */
    public static MethodHandle PyFrame_GetGenerator$handle() {
        return PyFrame_GetGenerator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFrame_GetGenerator(PyFrameObject *frame)
     * }
     */
    public static MemorySegment PyFrame_GetGenerator$address() {
        return PyFrame_GetGenerator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFrame_GetGenerator(PyFrameObject *frame)
     * }
     */
    public static MemorySegment PyFrame_GetGenerator(MemorySegment frame) {
        var mh$ = PyFrame_GetGenerator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFrame_GetGenerator", frame);
            }
            return (MemorySegment)mh$.invokeExact(frame);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFrame_GetLasti {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFrame_GetLasti");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyFrame_GetLasti(PyFrameObject *frame)
     * }
     */
    public static FunctionDescriptor PyFrame_GetLasti$descriptor() {
        return PyFrame_GetLasti.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyFrame_GetLasti(PyFrameObject *frame)
     * }
     */
    public static MethodHandle PyFrame_GetLasti$handle() {
        return PyFrame_GetLasti.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyFrame_GetLasti(PyFrameObject *frame)
     * }
     */
    public static MemorySegment PyFrame_GetLasti$address() {
        return PyFrame_GetLasti.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyFrame_GetLasti(PyFrameObject *frame)
     * }
     */
    public static int PyFrame_GetLasti(MemorySegment frame) {
        var mh$ = PyFrame_GetLasti.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFrame_GetLasti", frame);
            }
            return (int)mh$.invokeExact(frame);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyTraceBack_Here {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyTraceBack_Here");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyTraceBack_Here(PyFrameObject *)
     * }
     */
    public static FunctionDescriptor PyTraceBack_Here$descriptor() {
        return PyTraceBack_Here.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyTraceBack_Here(PyFrameObject *)
     * }
     */
    public static MethodHandle PyTraceBack_Here$handle() {
        return PyTraceBack_Here.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyTraceBack_Here(PyFrameObject *)
     * }
     */
    public static MemorySegment PyTraceBack_Here$address() {
        return PyTraceBack_Here.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyTraceBack_Here(PyFrameObject *)
     * }
     */
    public static int PyTraceBack_Here(MemorySegment x0) {
        var mh$ = PyTraceBack_Here.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyTraceBack_Here", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyTraceBack_Print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyTraceBack_Print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyTraceBack_Print(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyTraceBack_Print$descriptor() {
        return PyTraceBack_Print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyTraceBack_Print(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyTraceBack_Print$handle() {
        return PyTraceBack_Print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyTraceBack_Print(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyTraceBack_Print$address() {
        return PyTraceBack_Print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyTraceBack_Print(PyObject *, PyObject *)
     * }
     */
    public static int PyTraceBack_Print(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyTraceBack_Print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyTraceBack_Print", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyTraceBack_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyTraceBack_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyTraceBack_Type
     * }
     */
    public static GroupLayout PyTraceBack_Type$layout() {
        return PyTraceBack_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyTraceBack_Type
     * }
     */
    public static MemorySegment PyTraceBack_Type() {
        return PyTraceBack_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyTraceBack_Type
     * }
     */
    public static void PyTraceBack_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyTraceBack_Type$constants.SEGMENT, 0L, PyTraceBack_Type$constants.LAYOUT.byteSize());
    }

    private static class _Py_DisplaySourceLine {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_DisplaySourceLine");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _Py_DisplaySourceLine(PyObject *, PyObject *, int, int, int *, PyObject **)
     * }
     */
    public static FunctionDescriptor _Py_DisplaySourceLine$descriptor() {
        return _Py_DisplaySourceLine.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _Py_DisplaySourceLine(PyObject *, PyObject *, int, int, int *, PyObject **)
     * }
     */
    public static MethodHandle _Py_DisplaySourceLine$handle() {
        return _Py_DisplaySourceLine.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _Py_DisplaySourceLine(PyObject *, PyObject *, int, int, int *, PyObject **)
     * }
     */
    public static MemorySegment _Py_DisplaySourceLine$address() {
        return _Py_DisplaySourceLine.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _Py_DisplaySourceLine(PyObject *, PyObject *, int, int, int *, PyObject **)
     * }
     */
    public static int _Py_DisplaySourceLine(MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = _Py_DisplaySourceLine.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_DisplaySourceLine", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTraceback_Add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTraceback_Add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyTraceback_Add(const char *, const char *, int)
     * }
     */
    public static FunctionDescriptor _PyTraceback_Add$descriptor() {
        return _PyTraceback_Add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyTraceback_Add(const char *, const char *, int)
     * }
     */
    public static MethodHandle _PyTraceback_Add$handle() {
        return _PyTraceback_Add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyTraceback_Add(const char *, const char *, int)
     * }
     */
    public static MemorySegment _PyTraceback_Add$address() {
        return _PyTraceback_Add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyTraceback_Add(const char *, const char *, int)
     * }
     */
    public static void _PyTraceback_Add(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = _PyTraceback_Add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTraceback_Add", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_EllipsisObject$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_Py_EllipsisObject").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject _Py_EllipsisObject
     * }
     */
    public static GroupLayout _Py_EllipsisObject$layout() {
        return _Py_EllipsisObject$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject _Py_EllipsisObject
     * }
     */
    public static MemorySegment _Py_EllipsisObject() {
        return _Py_EllipsisObject$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject _Py_EllipsisObject
     * }
     */
    public static void _Py_EllipsisObject(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Py_EllipsisObject$constants.SEGMENT, 0L, _Py_EllipsisObject$constants.LAYOUT.byteSize());
    }

    private static class PySlice_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PySlice_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySlice_Type
     * }
     */
    public static GroupLayout PySlice_Type$layout() {
        return PySlice_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySlice_Type
     * }
     */
    public static MemorySegment PySlice_Type() {
        return PySlice_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySlice_Type
     * }
     */
    public static void PySlice_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PySlice_Type$constants.SEGMENT, 0L, PySlice_Type$constants.LAYOUT.byteSize());
    }

    private static class PyEllipsis_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyEllipsis_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyEllipsis_Type
     * }
     */
    public static GroupLayout PyEllipsis_Type$layout() {
        return PyEllipsis_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyEllipsis_Type
     * }
     */
    public static MemorySegment PyEllipsis_Type() {
        return PyEllipsis_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyEllipsis_Type
     * }
     */
    public static void PyEllipsis_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyEllipsis_Type$constants.SEGMENT, 0L, PyEllipsis_Type$constants.LAYOUT.byteSize());
    }

    private static class PySlice_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySlice_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PySlice_New(PyObject *start, PyObject *stop, PyObject *step)
     * }
     */
    public static FunctionDescriptor PySlice_New$descriptor() {
        return PySlice_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PySlice_New(PyObject *start, PyObject *stop, PyObject *step)
     * }
     */
    public static MethodHandle PySlice_New$handle() {
        return PySlice_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PySlice_New(PyObject *start, PyObject *stop, PyObject *step)
     * }
     */
    public static MemorySegment PySlice_New$address() {
        return PySlice_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PySlice_New(PyObject *start, PyObject *stop, PyObject *step)
     * }
     */
    public static MemorySegment PySlice_New(MemorySegment start, MemorySegment stop, MemorySegment step) {
        var mh$ = PySlice_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySlice_New", start, stop, step);
            }
            return (MemorySegment)mh$.invokeExact(start, stop, step);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PySlice_FromIndices {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PySlice_FromIndices");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PySlice_FromIndices(Py_ssize_t start, Py_ssize_t stop)
     * }
     */
    public static FunctionDescriptor _PySlice_FromIndices$descriptor() {
        return _PySlice_FromIndices.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PySlice_FromIndices(Py_ssize_t start, Py_ssize_t stop)
     * }
     */
    public static MethodHandle _PySlice_FromIndices$handle() {
        return _PySlice_FromIndices.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PySlice_FromIndices(Py_ssize_t start, Py_ssize_t stop)
     * }
     */
    public static MemorySegment _PySlice_FromIndices$address() {
        return _PySlice_FromIndices.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PySlice_FromIndices(Py_ssize_t start, Py_ssize_t stop)
     * }
     */
    public static MemorySegment _PySlice_FromIndices(long start, long stop) {
        var mh$ = _PySlice_FromIndices.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PySlice_FromIndices", start, stop);
            }
            return (MemorySegment)mh$.invokeExact(start, stop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PySlice_GetLongIndices {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PySlice_GetLongIndices");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PySlice_GetLongIndices(PySliceObject *self, PyObject *length, PyObject **start_ptr, PyObject **stop_ptr, PyObject **step_ptr)
     * }
     */
    public static FunctionDescriptor _PySlice_GetLongIndices$descriptor() {
        return _PySlice_GetLongIndices.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PySlice_GetLongIndices(PySliceObject *self, PyObject *length, PyObject **start_ptr, PyObject **stop_ptr, PyObject **step_ptr)
     * }
     */
    public static MethodHandle _PySlice_GetLongIndices$handle() {
        return _PySlice_GetLongIndices.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PySlice_GetLongIndices(PySliceObject *self, PyObject *length, PyObject **start_ptr, PyObject **stop_ptr, PyObject **step_ptr)
     * }
     */
    public static MemorySegment _PySlice_GetLongIndices$address() {
        return _PySlice_GetLongIndices.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PySlice_GetLongIndices(PySliceObject *self, PyObject *length, PyObject **start_ptr, PyObject **stop_ptr, PyObject **step_ptr)
     * }
     */
    public static int _PySlice_GetLongIndices(MemorySegment self, MemorySegment length, MemorySegment start_ptr, MemorySegment stop_ptr, MemorySegment step_ptr) {
        var mh$ = _PySlice_GetLongIndices.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PySlice_GetLongIndices", self, length, start_ptr, stop_ptr, step_ptr);
            }
            return (int)mh$.invokeExact(self, length, start_ptr, stop_ptr, step_ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySlice_GetIndices {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySlice_GetIndices");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySlice_GetIndices(PyObject *r, Py_ssize_t length, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step)
     * }
     */
    public static FunctionDescriptor PySlice_GetIndices$descriptor() {
        return PySlice_GetIndices.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySlice_GetIndices(PyObject *r, Py_ssize_t length, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step)
     * }
     */
    public static MethodHandle PySlice_GetIndices$handle() {
        return PySlice_GetIndices.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySlice_GetIndices(PyObject *r, Py_ssize_t length, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step)
     * }
     */
    public static MemorySegment PySlice_GetIndices$address() {
        return PySlice_GetIndices.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySlice_GetIndices(PyObject *r, Py_ssize_t length, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step)
     * }
     */
    public static int PySlice_GetIndices(MemorySegment r, long length, MemorySegment start, MemorySegment stop, MemorySegment step) {
        var mh$ = PySlice_GetIndices.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySlice_GetIndices", r, length, start, stop, step);
            }
            return (int)mh$.invokeExact(r, length, start, stop, step);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySlice_GetIndicesEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySlice_GetIndicesEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySlice_GetIndicesEx(PyObject *r, Py_ssize_t length, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step, Py_ssize_t *slicelength)
     * }
     */
    public static FunctionDescriptor PySlice_GetIndicesEx$descriptor() {
        return PySlice_GetIndicesEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySlice_GetIndicesEx(PyObject *r, Py_ssize_t length, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step, Py_ssize_t *slicelength)
     * }
     */
    public static MethodHandle PySlice_GetIndicesEx$handle() {
        return PySlice_GetIndicesEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySlice_GetIndicesEx(PyObject *r, Py_ssize_t length, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step, Py_ssize_t *slicelength)
     * }
     */
    public static MemorySegment PySlice_GetIndicesEx$address() {
        return PySlice_GetIndicesEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySlice_GetIndicesEx(PyObject *r, Py_ssize_t length, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step, Py_ssize_t *slicelength)
     * }
     */
    public static int PySlice_GetIndicesEx(MemorySegment r, long length, MemorySegment start, MemorySegment stop, MemorySegment step, MemorySegment slicelength) {
        var mh$ = PySlice_GetIndicesEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySlice_GetIndicesEx", r, length, start, stop, step, slicelength);
            }
            return (int)mh$.invokeExact(r, length, start, stop, step, slicelength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySlice_Unpack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySlice_Unpack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySlice_Unpack(PyObject *slice, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step)
     * }
     */
    public static FunctionDescriptor PySlice_Unpack$descriptor() {
        return PySlice_Unpack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySlice_Unpack(PyObject *slice, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step)
     * }
     */
    public static MethodHandle PySlice_Unpack$handle() {
        return PySlice_Unpack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySlice_Unpack(PyObject *slice, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step)
     * }
     */
    public static MemorySegment PySlice_Unpack$address() {
        return PySlice_Unpack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySlice_Unpack(PyObject *slice, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step)
     * }
     */
    public static int PySlice_Unpack(MemorySegment slice, MemorySegment start, MemorySegment stop, MemorySegment step) {
        var mh$ = PySlice_Unpack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySlice_Unpack", slice, start, stop, step);
            }
            return (int)mh$.invokeExact(slice, start, stop, step);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySlice_AdjustIndices {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySlice_AdjustIndices");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PySlice_AdjustIndices(Py_ssize_t length, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t step)
     * }
     */
    public static FunctionDescriptor PySlice_AdjustIndices$descriptor() {
        return PySlice_AdjustIndices.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PySlice_AdjustIndices(Py_ssize_t length, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t step)
     * }
     */
    public static MethodHandle PySlice_AdjustIndices$handle() {
        return PySlice_AdjustIndices.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PySlice_AdjustIndices(Py_ssize_t length, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t step)
     * }
     */
    public static MemorySegment PySlice_AdjustIndices$address() {
        return PySlice_AdjustIndices.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PySlice_AdjustIndices(Py_ssize_t length, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t step)
     * }
     */
    public static long PySlice_AdjustIndices(long length, MemorySegment start, MemorySegment stop, long step) {
        var mh$ = PySlice_AdjustIndices.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySlice_AdjustIndices", length, start, stop, step);
            }
            return (long)mh$.invokeExact(length, start, stop, step);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCell_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyCell_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCell_Type
     * }
     */
    public static GroupLayout PyCell_Type$layout() {
        return PyCell_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCell_Type
     * }
     */
    public static MemorySegment PyCell_Type() {
        return PyCell_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCell_Type
     * }
     */
    public static void PyCell_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyCell_Type$constants.SEGMENT, 0L, PyCell_Type$constants.LAYOUT.byteSize());
    }

    private static class PyCell_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCell_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCell_New(PyObject *)
     * }
     */
    public static FunctionDescriptor PyCell_New$descriptor() {
        return PyCell_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCell_New(PyObject *)
     * }
     */
    public static MethodHandle PyCell_New$handle() {
        return PyCell_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCell_New(PyObject *)
     * }
     */
    public static MemorySegment PyCell_New$address() {
        return PyCell_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCell_New(PyObject *)
     * }
     */
    public static MemorySegment PyCell_New(MemorySegment x0) {
        var mh$ = PyCell_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCell_New", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCell_Get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCell_Get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCell_Get(PyObject *)
     * }
     */
    public static FunctionDescriptor PyCell_Get$descriptor() {
        return PyCell_Get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCell_Get(PyObject *)
     * }
     */
    public static MethodHandle PyCell_Get$handle() {
        return PyCell_Get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCell_Get(PyObject *)
     * }
     */
    public static MemorySegment PyCell_Get$address() {
        return PyCell_Get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCell_Get(PyObject *)
     * }
     */
    public static MemorySegment PyCell_Get(MemorySegment x0) {
        var mh$ = PyCell_Get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCell_Get", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCell_Set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCell_Set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyCell_Set(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyCell_Set$descriptor() {
        return PyCell_Set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyCell_Set(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyCell_Set$handle() {
        return PyCell_Set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyCell_Set(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyCell_Set$address() {
        return PyCell_Set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyCell_Set(PyObject *, PyObject *)
     * }
     */
    public static int PyCell_Set(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyCell_Set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCell_Set", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySeqIter_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PySeqIter_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySeqIter_Type
     * }
     */
    public static GroupLayout PySeqIter_Type$layout() {
        return PySeqIter_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySeqIter_Type
     * }
     */
    public static MemorySegment PySeqIter_Type() {
        return PySeqIter_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySeqIter_Type
     * }
     */
    public static void PySeqIter_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PySeqIter_Type$constants.SEGMENT, 0L, PySeqIter_Type$constants.LAYOUT.byteSize());
    }

    private static class PyCallIter_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyCallIter_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCallIter_Type
     * }
     */
    public static GroupLayout PyCallIter_Type$layout() {
        return PyCallIter_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCallIter_Type
     * }
     */
    public static MemorySegment PyCallIter_Type() {
        return PyCallIter_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCallIter_Type
     * }
     */
    public static void PyCallIter_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyCallIter_Type$constants.SEGMENT, 0L, PyCallIter_Type$constants.LAYOUT.byteSize());
    }

    private static class PySeqIter_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySeqIter_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PySeqIter_New(PyObject *)
     * }
     */
    public static FunctionDescriptor PySeqIter_New$descriptor() {
        return PySeqIter_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PySeqIter_New(PyObject *)
     * }
     */
    public static MethodHandle PySeqIter_New$handle() {
        return PySeqIter_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PySeqIter_New(PyObject *)
     * }
     */
    public static MemorySegment PySeqIter_New$address() {
        return PySeqIter_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PySeqIter_New(PyObject *)
     * }
     */
    public static MemorySegment PySeqIter_New(MemorySegment x0) {
        var mh$ = PySeqIter_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySeqIter_New", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCallIter_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCallIter_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCallIter_New(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyCallIter_New$descriptor() {
        return PyCallIter_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCallIter_New(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyCallIter_New$handle() {
        return PyCallIter_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCallIter_New(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyCallIter_New$address() {
        return PyCallIter_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCallIter_New(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyCallIter_New(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyCallIter_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCallIter_New", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int _PyStatus_TYPE_OK = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._PyStatus_TYPE_OK = 0
     * }
     */
    public static int _PyStatus_TYPE_OK() {
        return _PyStatus_TYPE_OK;
    }
    private static final int _PyStatus_TYPE_ERROR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._PyStatus_TYPE_ERROR = 1
     * }
     */
    public static int _PyStatus_TYPE_ERROR() {
        return _PyStatus_TYPE_ERROR;
    }
    private static final int _PyStatus_TYPE_EXIT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._PyStatus_TYPE_EXIT = 2
     * }
     */
    public static int _PyStatus_TYPE_EXIT() {
        return _PyStatus_TYPE_EXIT;
    }

    private static class PyStatus_Ok {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PyStatus.layout()    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyStatus_Ok");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyStatus PyStatus_Ok()
     * }
     */
    public static FunctionDescriptor PyStatus_Ok$descriptor() {
        return PyStatus_Ok.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyStatus PyStatus_Ok()
     * }
     */
    public static MethodHandle PyStatus_Ok$handle() {
        return PyStatus_Ok.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyStatus PyStatus_Ok()
     * }
     */
    public static MemorySegment PyStatus_Ok$address() {
        return PyStatus_Ok.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyStatus PyStatus_Ok()
     * }
     */
    public static MemorySegment PyStatus_Ok(SegmentAllocator allocator) {
        var mh$ = PyStatus_Ok.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyStatus_Ok", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyStatus_Error {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PyStatus.layout(),
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyStatus_Error");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyStatus PyStatus_Error(const char *err_msg)
     * }
     */
    public static FunctionDescriptor PyStatus_Error$descriptor() {
        return PyStatus_Error.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyStatus PyStatus_Error(const char *err_msg)
     * }
     */
    public static MethodHandle PyStatus_Error$handle() {
        return PyStatus_Error.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyStatus PyStatus_Error(const char *err_msg)
     * }
     */
    public static MemorySegment PyStatus_Error$address() {
        return PyStatus_Error.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyStatus PyStatus_Error(const char *err_msg)
     * }
     */
    public static MemorySegment PyStatus_Error(SegmentAllocator allocator, MemorySegment err_msg) {
        var mh$ = PyStatus_Error.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyStatus_Error", allocator, err_msg);
            }
            return (MemorySegment)mh$.invokeExact(allocator, err_msg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyStatus_NoMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PyStatus.layout()    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyStatus_NoMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyStatus PyStatus_NoMemory()
     * }
     */
    public static FunctionDescriptor PyStatus_NoMemory$descriptor() {
        return PyStatus_NoMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyStatus PyStatus_NoMemory()
     * }
     */
    public static MethodHandle PyStatus_NoMemory$handle() {
        return PyStatus_NoMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyStatus PyStatus_NoMemory()
     * }
     */
    public static MemorySegment PyStatus_NoMemory$address() {
        return PyStatus_NoMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyStatus PyStatus_NoMemory()
     * }
     */
    public static MemorySegment PyStatus_NoMemory(SegmentAllocator allocator) {
        var mh$ = PyStatus_NoMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyStatus_NoMemory", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyStatus_Exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PyStatus.layout(),
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyStatus_Exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyStatus PyStatus_Exit(int exitcode)
     * }
     */
    public static FunctionDescriptor PyStatus_Exit$descriptor() {
        return PyStatus_Exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyStatus PyStatus_Exit(int exitcode)
     * }
     */
    public static MethodHandle PyStatus_Exit$handle() {
        return PyStatus_Exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyStatus PyStatus_Exit(int exitcode)
     * }
     */
    public static MemorySegment PyStatus_Exit$address() {
        return PyStatus_Exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyStatus PyStatus_Exit(int exitcode)
     * }
     */
    public static MemorySegment PyStatus_Exit(SegmentAllocator allocator, int exitcode) {
        var mh$ = PyStatus_Exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyStatus_Exit", allocator, exitcode);
            }
            return (MemorySegment)mh$.invokeExact(allocator, exitcode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyStatus_IsError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            PyStatus.layout()
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyStatus_IsError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyStatus_IsError(PyStatus err)
     * }
     */
    public static FunctionDescriptor PyStatus_IsError$descriptor() {
        return PyStatus_IsError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyStatus_IsError(PyStatus err)
     * }
     */
    public static MethodHandle PyStatus_IsError$handle() {
        return PyStatus_IsError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyStatus_IsError(PyStatus err)
     * }
     */
    public static MemorySegment PyStatus_IsError$address() {
        return PyStatus_IsError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyStatus_IsError(PyStatus err)
     * }
     */
    public static int PyStatus_IsError(MemorySegment err) {
        var mh$ = PyStatus_IsError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyStatus_IsError", err);
            }
            return (int)mh$.invokeExact(err);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyStatus_IsExit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            PyStatus.layout()
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyStatus_IsExit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyStatus_IsExit(PyStatus err)
     * }
     */
    public static FunctionDescriptor PyStatus_IsExit$descriptor() {
        return PyStatus_IsExit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyStatus_IsExit(PyStatus err)
     * }
     */
    public static MethodHandle PyStatus_IsExit$handle() {
        return PyStatus_IsExit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyStatus_IsExit(PyStatus err)
     * }
     */
    public static MemorySegment PyStatus_IsExit$address() {
        return PyStatus_IsExit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyStatus_IsExit(PyStatus err)
     * }
     */
    public static int PyStatus_IsExit(MemorySegment err) {
        var mh$ = PyStatus_IsExit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyStatus_IsExit", err);
            }
            return (int)mh$.invokeExact(err);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyStatus_Exception {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            PyStatus.layout()
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyStatus_Exception");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyStatus_Exception(PyStatus err)
     * }
     */
    public static FunctionDescriptor PyStatus_Exception$descriptor() {
        return PyStatus_Exception.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyStatus_Exception(PyStatus err)
     * }
     */
    public static MethodHandle PyStatus_Exception$handle() {
        return PyStatus_Exception.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyStatus_Exception(PyStatus err)
     * }
     */
    public static MemorySegment PyStatus_Exception$address() {
        return PyStatus_Exception.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyStatus_Exception(PyStatus err)
     * }
     */
    public static int PyStatus_Exception(MemorySegment err) {
        var mh$ = PyStatus_Exception.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyStatus_Exception", err);
            }
            return (int)mh$.invokeExact(err);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyWideStringList_Append {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PyStatus.layout(),
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyWideStringList_Append");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyStatus PyWideStringList_Append(PyWideStringList *list, const wchar_t *item)
     * }
     */
    public static FunctionDescriptor PyWideStringList_Append$descriptor() {
        return PyWideStringList_Append.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyStatus PyWideStringList_Append(PyWideStringList *list, const wchar_t *item)
     * }
     */
    public static MethodHandle PyWideStringList_Append$handle() {
        return PyWideStringList_Append.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyStatus PyWideStringList_Append(PyWideStringList *list, const wchar_t *item)
     * }
     */
    public static MemorySegment PyWideStringList_Append$address() {
        return PyWideStringList_Append.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyStatus PyWideStringList_Append(PyWideStringList *list, const wchar_t *item)
     * }
     */
    public static MemorySegment PyWideStringList_Append(SegmentAllocator allocator, MemorySegment list, MemorySegment item) {
        var mh$ = PyWideStringList_Append.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyWideStringList_Append", allocator, list, item);
            }
            return (MemorySegment)mh$.invokeExact(allocator, list, item);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyWideStringList_Insert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PyStatus.layout(),
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyWideStringList_Insert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyStatus PyWideStringList_Insert(PyWideStringList *list, Py_ssize_t index, const wchar_t *item)
     * }
     */
    public static FunctionDescriptor PyWideStringList_Insert$descriptor() {
        return PyWideStringList_Insert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyStatus PyWideStringList_Insert(PyWideStringList *list, Py_ssize_t index, const wchar_t *item)
     * }
     */
    public static MethodHandle PyWideStringList_Insert$handle() {
        return PyWideStringList_Insert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyStatus PyWideStringList_Insert(PyWideStringList *list, Py_ssize_t index, const wchar_t *item)
     * }
     */
    public static MemorySegment PyWideStringList_Insert$address() {
        return PyWideStringList_Insert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyStatus PyWideStringList_Insert(PyWideStringList *list, Py_ssize_t index, const wchar_t *item)
     * }
     */
    public static MemorySegment PyWideStringList_Insert(SegmentAllocator allocator, MemorySegment list, long index, MemorySegment item) {
        var mh$ = PyWideStringList_Insert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyWideStringList_Insert", allocator, list, index, item);
            }
            return (MemorySegment)mh$.invokeExact(allocator, list, index, item);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyPreConfig_InitPythonConfig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyPreConfig_InitPythonConfig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyPreConfig_InitPythonConfig(PyPreConfig *config)
     * }
     */
    public static FunctionDescriptor PyPreConfig_InitPythonConfig$descriptor() {
        return PyPreConfig_InitPythonConfig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyPreConfig_InitPythonConfig(PyPreConfig *config)
     * }
     */
    public static MethodHandle PyPreConfig_InitPythonConfig$handle() {
        return PyPreConfig_InitPythonConfig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyPreConfig_InitPythonConfig(PyPreConfig *config)
     * }
     */
    public static MemorySegment PyPreConfig_InitPythonConfig$address() {
        return PyPreConfig_InitPythonConfig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyPreConfig_InitPythonConfig(PyPreConfig *config)
     * }
     */
    public static void PyPreConfig_InitPythonConfig(MemorySegment config) {
        var mh$ = PyPreConfig_InitPythonConfig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyPreConfig_InitPythonConfig", config);
            }
            mh$.invokeExact(config);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyPreConfig_InitIsolatedConfig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyPreConfig_InitIsolatedConfig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyPreConfig_InitIsolatedConfig(PyPreConfig *config)
     * }
     */
    public static FunctionDescriptor PyPreConfig_InitIsolatedConfig$descriptor() {
        return PyPreConfig_InitIsolatedConfig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyPreConfig_InitIsolatedConfig(PyPreConfig *config)
     * }
     */
    public static MethodHandle PyPreConfig_InitIsolatedConfig$handle() {
        return PyPreConfig_InitIsolatedConfig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyPreConfig_InitIsolatedConfig(PyPreConfig *config)
     * }
     */
    public static MemorySegment PyPreConfig_InitIsolatedConfig$address() {
        return PyPreConfig_InitIsolatedConfig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyPreConfig_InitIsolatedConfig(PyPreConfig *config)
     * }
     */
    public static void PyPreConfig_InitIsolatedConfig(MemorySegment config) {
        var mh$ = PyPreConfig_InitIsolatedConfig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyPreConfig_InitIsolatedConfig", config);
            }
            mh$.invokeExact(config);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyConfig_InitPythonConfig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyConfig_InitPythonConfig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyConfig_InitPythonConfig(PyConfig *config)
     * }
     */
    public static FunctionDescriptor PyConfig_InitPythonConfig$descriptor() {
        return PyConfig_InitPythonConfig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyConfig_InitPythonConfig(PyConfig *config)
     * }
     */
    public static MethodHandle PyConfig_InitPythonConfig$handle() {
        return PyConfig_InitPythonConfig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyConfig_InitPythonConfig(PyConfig *config)
     * }
     */
    public static MemorySegment PyConfig_InitPythonConfig$address() {
        return PyConfig_InitPythonConfig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyConfig_InitPythonConfig(PyConfig *config)
     * }
     */
    public static void PyConfig_InitPythonConfig(MemorySegment config) {
        var mh$ = PyConfig_InitPythonConfig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyConfig_InitPythonConfig", config);
            }
            mh$.invokeExact(config);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyConfig_InitIsolatedConfig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyConfig_InitIsolatedConfig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyConfig_InitIsolatedConfig(PyConfig *config)
     * }
     */
    public static FunctionDescriptor PyConfig_InitIsolatedConfig$descriptor() {
        return PyConfig_InitIsolatedConfig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyConfig_InitIsolatedConfig(PyConfig *config)
     * }
     */
    public static MethodHandle PyConfig_InitIsolatedConfig$handle() {
        return PyConfig_InitIsolatedConfig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyConfig_InitIsolatedConfig(PyConfig *config)
     * }
     */
    public static MemorySegment PyConfig_InitIsolatedConfig$address() {
        return PyConfig_InitIsolatedConfig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyConfig_InitIsolatedConfig(PyConfig *config)
     * }
     */
    public static void PyConfig_InitIsolatedConfig(MemorySegment config) {
        var mh$ = PyConfig_InitIsolatedConfig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyConfig_InitIsolatedConfig", config);
            }
            mh$.invokeExact(config);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyConfig_Clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyConfig_Clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyConfig_Clear(PyConfig *)
     * }
     */
    public static FunctionDescriptor PyConfig_Clear$descriptor() {
        return PyConfig_Clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyConfig_Clear(PyConfig *)
     * }
     */
    public static MethodHandle PyConfig_Clear$handle() {
        return PyConfig_Clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyConfig_Clear(PyConfig *)
     * }
     */
    public static MemorySegment PyConfig_Clear$address() {
        return PyConfig_Clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyConfig_Clear(PyConfig *)
     * }
     */
    public static void PyConfig_Clear(MemorySegment x0) {
        var mh$ = PyConfig_Clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyConfig_Clear", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyConfig_SetString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PyStatus.layout(),
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyConfig_SetString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyStatus PyConfig_SetString(PyConfig *config, wchar_t **config_str, const wchar_t *str)
     * }
     */
    public static FunctionDescriptor PyConfig_SetString$descriptor() {
        return PyConfig_SetString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyStatus PyConfig_SetString(PyConfig *config, wchar_t **config_str, const wchar_t *str)
     * }
     */
    public static MethodHandle PyConfig_SetString$handle() {
        return PyConfig_SetString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyStatus PyConfig_SetString(PyConfig *config, wchar_t **config_str, const wchar_t *str)
     * }
     */
    public static MemorySegment PyConfig_SetString$address() {
        return PyConfig_SetString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyStatus PyConfig_SetString(PyConfig *config, wchar_t **config_str, const wchar_t *str)
     * }
     */
    public static MemorySegment PyConfig_SetString(SegmentAllocator allocator, MemorySegment config, MemorySegment config_str, MemorySegment str) {
        var mh$ = PyConfig_SetString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyConfig_SetString", allocator, config, config_str, str);
            }
            return (MemorySegment)mh$.invokeExact(allocator, config, config_str, str);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyConfig_SetBytesString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PyStatus.layout(),
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyConfig_SetBytesString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyStatus PyConfig_SetBytesString(PyConfig *config, wchar_t **config_str, const char *str)
     * }
     */
    public static FunctionDescriptor PyConfig_SetBytesString$descriptor() {
        return PyConfig_SetBytesString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyStatus PyConfig_SetBytesString(PyConfig *config, wchar_t **config_str, const char *str)
     * }
     */
    public static MethodHandle PyConfig_SetBytesString$handle() {
        return PyConfig_SetBytesString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyStatus PyConfig_SetBytesString(PyConfig *config, wchar_t **config_str, const char *str)
     * }
     */
    public static MemorySegment PyConfig_SetBytesString$address() {
        return PyConfig_SetBytesString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyStatus PyConfig_SetBytesString(PyConfig *config, wchar_t **config_str, const char *str)
     * }
     */
    public static MemorySegment PyConfig_SetBytesString(SegmentAllocator allocator, MemorySegment config, MemorySegment config_str, MemorySegment str) {
        var mh$ = PyConfig_SetBytesString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyConfig_SetBytesString", allocator, config, config_str, str);
            }
            return (MemorySegment)mh$.invokeExact(allocator, config, config_str, str);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyConfig_Read {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PyStatus.layout(),
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyConfig_Read");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyStatus PyConfig_Read(PyConfig *config)
     * }
     */
    public static FunctionDescriptor PyConfig_Read$descriptor() {
        return PyConfig_Read.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyStatus PyConfig_Read(PyConfig *config)
     * }
     */
    public static MethodHandle PyConfig_Read$handle() {
        return PyConfig_Read.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyStatus PyConfig_Read(PyConfig *config)
     * }
     */
    public static MemorySegment PyConfig_Read$address() {
        return PyConfig_Read.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyStatus PyConfig_Read(PyConfig *config)
     * }
     */
    public static MemorySegment PyConfig_Read(SegmentAllocator allocator, MemorySegment config) {
        var mh$ = PyConfig_Read.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyConfig_Read", allocator, config);
            }
            return (MemorySegment)mh$.invokeExact(allocator, config);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyConfig_SetBytesArgv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PyStatus.layout(),
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyConfig_SetBytesArgv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyStatus PyConfig_SetBytesArgv(PyConfig *config, Py_ssize_t argc, char *const *argv)
     * }
     */
    public static FunctionDescriptor PyConfig_SetBytesArgv$descriptor() {
        return PyConfig_SetBytesArgv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyStatus PyConfig_SetBytesArgv(PyConfig *config, Py_ssize_t argc, char *const *argv)
     * }
     */
    public static MethodHandle PyConfig_SetBytesArgv$handle() {
        return PyConfig_SetBytesArgv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyStatus PyConfig_SetBytesArgv(PyConfig *config, Py_ssize_t argc, char *const *argv)
     * }
     */
    public static MemorySegment PyConfig_SetBytesArgv$address() {
        return PyConfig_SetBytesArgv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyStatus PyConfig_SetBytesArgv(PyConfig *config, Py_ssize_t argc, char *const *argv)
     * }
     */
    public static MemorySegment PyConfig_SetBytesArgv(SegmentAllocator allocator, MemorySegment config, long argc, MemorySegment argv) {
        var mh$ = PyConfig_SetBytesArgv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyConfig_SetBytesArgv", allocator, config, argc, argv);
            }
            return (MemorySegment)mh$.invokeExact(allocator, config, argc, argv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyConfig_SetArgv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PyStatus.layout(),
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyConfig_SetArgv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyStatus PyConfig_SetArgv(PyConfig *config, Py_ssize_t argc, wchar_t *const *argv)
     * }
     */
    public static FunctionDescriptor PyConfig_SetArgv$descriptor() {
        return PyConfig_SetArgv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyStatus PyConfig_SetArgv(PyConfig *config, Py_ssize_t argc, wchar_t *const *argv)
     * }
     */
    public static MethodHandle PyConfig_SetArgv$handle() {
        return PyConfig_SetArgv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyStatus PyConfig_SetArgv(PyConfig *config, Py_ssize_t argc, wchar_t *const *argv)
     * }
     */
    public static MemorySegment PyConfig_SetArgv$address() {
        return PyConfig_SetArgv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyStatus PyConfig_SetArgv(PyConfig *config, Py_ssize_t argc, wchar_t *const *argv)
     * }
     */
    public static MemorySegment PyConfig_SetArgv(SegmentAllocator allocator, MemorySegment config, long argc, MemorySegment argv) {
        var mh$ = PyConfig_SetArgv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyConfig_SetArgv", allocator, config, argc, argv);
            }
            return (MemorySegment)mh$.invokeExact(allocator, config, argc, argv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyConfig_SetWideStringList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PyStatus.layout(),
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyConfig_SetWideStringList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyStatus PyConfig_SetWideStringList(PyConfig *config, PyWideStringList *list, Py_ssize_t length, wchar_t **items)
     * }
     */
    public static FunctionDescriptor PyConfig_SetWideStringList$descriptor() {
        return PyConfig_SetWideStringList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyStatus PyConfig_SetWideStringList(PyConfig *config, PyWideStringList *list, Py_ssize_t length, wchar_t **items)
     * }
     */
    public static MethodHandle PyConfig_SetWideStringList$handle() {
        return PyConfig_SetWideStringList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyStatus PyConfig_SetWideStringList(PyConfig *config, PyWideStringList *list, Py_ssize_t length, wchar_t **items)
     * }
     */
    public static MemorySegment PyConfig_SetWideStringList$address() {
        return PyConfig_SetWideStringList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyStatus PyConfig_SetWideStringList(PyConfig *config, PyWideStringList *list, Py_ssize_t length, wchar_t **items)
     * }
     */
    public static MemorySegment PyConfig_SetWideStringList(SegmentAllocator allocator, MemorySegment config, MemorySegment list, long length, MemorySegment items) {
        var mh$ = PyConfig_SetWideStringList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyConfig_SetWideStringList", allocator, config, list, length, items);
            }
            return (MemorySegment)mh$.invokeExact(allocator, config, list, length, items);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_GetArgcArgv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_GetArgcArgv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_GetArgcArgv(int *argc, wchar_t ***argv)
     * }
     */
    public static FunctionDescriptor Py_GetArgcArgv$descriptor() {
        return Py_GetArgcArgv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_GetArgcArgv(int *argc, wchar_t ***argv)
     * }
     */
    public static MethodHandle Py_GetArgcArgv$handle() {
        return Py_GetArgcArgv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_GetArgcArgv(int *argc, wchar_t ***argv)
     * }
     */
    public static MemorySegment Py_GetArgcArgv$address() {
        return Py_GetArgcArgv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_GetArgcArgv(int *argc, wchar_t ***argv)
     * }
     */
    public static void Py_GetArgcArgv(MemorySegment argc, MemorySegment argv) {
        var mh$ = Py_GetArgcArgv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_GetArgcArgv", argc, argv);
            }
            mh$.invokeExact(argc, argv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyInterpreterState_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyInterpreterState_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_New()
     * }
     */
    public static FunctionDescriptor PyInterpreterState_New$descriptor() {
        return PyInterpreterState_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_New()
     * }
     */
    public static MethodHandle PyInterpreterState_New$handle() {
        return PyInterpreterState_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_New()
     * }
     */
    public static MemorySegment PyInterpreterState_New$address() {
        return PyInterpreterState_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_New()
     * }
     */
    public static MemorySegment PyInterpreterState_New() {
        var mh$ = PyInterpreterState_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyInterpreterState_New");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyInterpreterState_Clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyInterpreterState_Clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyInterpreterState_Clear(PyInterpreterState *)
     * }
     */
    public static FunctionDescriptor PyInterpreterState_Clear$descriptor() {
        return PyInterpreterState_Clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyInterpreterState_Clear(PyInterpreterState *)
     * }
     */
    public static MethodHandle PyInterpreterState_Clear$handle() {
        return PyInterpreterState_Clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyInterpreterState_Clear(PyInterpreterState *)
     * }
     */
    public static MemorySegment PyInterpreterState_Clear$address() {
        return PyInterpreterState_Clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyInterpreterState_Clear(PyInterpreterState *)
     * }
     */
    public static void PyInterpreterState_Clear(MemorySegment x0) {
        var mh$ = PyInterpreterState_Clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyInterpreterState_Clear", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyInterpreterState_Delete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyInterpreterState_Delete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyInterpreterState_Delete(PyInterpreterState *)
     * }
     */
    public static FunctionDescriptor PyInterpreterState_Delete$descriptor() {
        return PyInterpreterState_Delete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyInterpreterState_Delete(PyInterpreterState *)
     * }
     */
    public static MethodHandle PyInterpreterState_Delete$handle() {
        return PyInterpreterState_Delete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyInterpreterState_Delete(PyInterpreterState *)
     * }
     */
    public static MemorySegment PyInterpreterState_Delete$address() {
        return PyInterpreterState_Delete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyInterpreterState_Delete(PyInterpreterState *)
     * }
     */
    public static void PyInterpreterState_Delete(MemorySegment x0) {
        var mh$ = PyInterpreterState_Delete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyInterpreterState_Delete", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyInterpreterState_Get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyInterpreterState_Get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_Get()
     * }
     */
    public static FunctionDescriptor PyInterpreterState_Get$descriptor() {
        return PyInterpreterState_Get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_Get()
     * }
     */
    public static MethodHandle PyInterpreterState_Get$handle() {
        return PyInterpreterState_Get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_Get()
     * }
     */
    public static MemorySegment PyInterpreterState_Get$address() {
        return PyInterpreterState_Get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_Get()
     * }
     */
    public static MemorySegment PyInterpreterState_Get() {
        var mh$ = PyInterpreterState_Get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyInterpreterState_Get");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyInterpreterState_GetDict {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyInterpreterState_GetDict");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyInterpreterState_GetDict(PyInterpreterState *)
     * }
     */
    public static FunctionDescriptor PyInterpreterState_GetDict$descriptor() {
        return PyInterpreterState_GetDict.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyInterpreterState_GetDict(PyInterpreterState *)
     * }
     */
    public static MethodHandle PyInterpreterState_GetDict$handle() {
        return PyInterpreterState_GetDict.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyInterpreterState_GetDict(PyInterpreterState *)
     * }
     */
    public static MemorySegment PyInterpreterState_GetDict$address() {
        return PyInterpreterState_GetDict.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyInterpreterState_GetDict(PyInterpreterState *)
     * }
     */
    public static MemorySegment PyInterpreterState_GetDict(MemorySegment x0) {
        var mh$ = PyInterpreterState_GetDict.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyInterpreterState_GetDict", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyInterpreterState_GetID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyInterpreterState_GetID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t PyInterpreterState_GetID(PyInterpreterState *)
     * }
     */
    public static FunctionDescriptor PyInterpreterState_GetID$descriptor() {
        return PyInterpreterState_GetID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t PyInterpreterState_GetID(PyInterpreterState *)
     * }
     */
    public static MethodHandle PyInterpreterState_GetID$handle() {
        return PyInterpreterState_GetID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t PyInterpreterState_GetID(PyInterpreterState *)
     * }
     */
    public static MemorySegment PyInterpreterState_GetID$address() {
        return PyInterpreterState_GetID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t PyInterpreterState_GetID(PyInterpreterState *)
     * }
     */
    public static long PyInterpreterState_GetID(MemorySegment x0) {
        var mh$ = PyInterpreterState_GetID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyInterpreterState_GetID", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyState_AddModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyState_AddModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyState_AddModule(PyObject *, PyModuleDef *)
     * }
     */
    public static FunctionDescriptor PyState_AddModule$descriptor() {
        return PyState_AddModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyState_AddModule(PyObject *, PyModuleDef *)
     * }
     */
    public static MethodHandle PyState_AddModule$handle() {
        return PyState_AddModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyState_AddModule(PyObject *, PyModuleDef *)
     * }
     */
    public static MemorySegment PyState_AddModule$address() {
        return PyState_AddModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyState_AddModule(PyObject *, PyModuleDef *)
     * }
     */
    public static int PyState_AddModule(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyState_AddModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyState_AddModule", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyState_RemoveModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyState_RemoveModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyState_RemoveModule(PyModuleDef *)
     * }
     */
    public static FunctionDescriptor PyState_RemoveModule$descriptor() {
        return PyState_RemoveModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyState_RemoveModule(PyModuleDef *)
     * }
     */
    public static MethodHandle PyState_RemoveModule$handle() {
        return PyState_RemoveModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyState_RemoveModule(PyModuleDef *)
     * }
     */
    public static MemorySegment PyState_RemoveModule$address() {
        return PyState_RemoveModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyState_RemoveModule(PyModuleDef *)
     * }
     */
    public static int PyState_RemoveModule(MemorySegment x0) {
        var mh$ = PyState_RemoveModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyState_RemoveModule", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyState_FindModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyState_FindModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyState_FindModule(PyModuleDef *)
     * }
     */
    public static FunctionDescriptor PyState_FindModule$descriptor() {
        return PyState_FindModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyState_FindModule(PyModuleDef *)
     * }
     */
    public static MethodHandle PyState_FindModule$handle() {
        return PyState_FindModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyState_FindModule(PyModuleDef *)
     * }
     */
    public static MemorySegment PyState_FindModule$address() {
        return PyState_FindModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyState_FindModule(PyModuleDef *)
     * }
     */
    public static MemorySegment PyState_FindModule(MemorySegment x0) {
        var mh$ = PyState_FindModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyState_FindModule", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThreadState_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThreadState_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_New(PyInterpreterState *)
     * }
     */
    public static FunctionDescriptor PyThreadState_New$descriptor() {
        return PyThreadState_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_New(PyInterpreterState *)
     * }
     */
    public static MethodHandle PyThreadState_New$handle() {
        return PyThreadState_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_New(PyInterpreterState *)
     * }
     */
    public static MemorySegment PyThreadState_New$address() {
        return PyThreadState_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_New(PyInterpreterState *)
     * }
     */
    public static MemorySegment PyThreadState_New(MemorySegment x0) {
        var mh$ = PyThreadState_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThreadState_New", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThreadState_Clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThreadState_Clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyThreadState_Clear(PyThreadState *)
     * }
     */
    public static FunctionDescriptor PyThreadState_Clear$descriptor() {
        return PyThreadState_Clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyThreadState_Clear(PyThreadState *)
     * }
     */
    public static MethodHandle PyThreadState_Clear$handle() {
        return PyThreadState_Clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyThreadState_Clear(PyThreadState *)
     * }
     */
    public static MemorySegment PyThreadState_Clear$address() {
        return PyThreadState_Clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyThreadState_Clear(PyThreadState *)
     * }
     */
    public static void PyThreadState_Clear(MemorySegment x0) {
        var mh$ = PyThreadState_Clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThreadState_Clear", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThreadState_Delete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThreadState_Delete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyThreadState_Delete(PyThreadState *)
     * }
     */
    public static FunctionDescriptor PyThreadState_Delete$descriptor() {
        return PyThreadState_Delete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyThreadState_Delete(PyThreadState *)
     * }
     */
    public static MethodHandle PyThreadState_Delete$handle() {
        return PyThreadState_Delete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyThreadState_Delete(PyThreadState *)
     * }
     */
    public static MemorySegment PyThreadState_Delete$address() {
        return PyThreadState_Delete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyThreadState_Delete(PyThreadState *)
     * }
     */
    public static void PyThreadState_Delete(MemorySegment x0) {
        var mh$ = PyThreadState_Delete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThreadState_Delete", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThreadState_Get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThreadState_Get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_Get()
     * }
     */
    public static FunctionDescriptor PyThreadState_Get$descriptor() {
        return PyThreadState_Get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_Get()
     * }
     */
    public static MethodHandle PyThreadState_Get$handle() {
        return PyThreadState_Get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_Get()
     * }
     */
    public static MemorySegment PyThreadState_Get$address() {
        return PyThreadState_Get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_Get()
     * }
     */
    public static MemorySegment PyThreadState_Get() {
        var mh$ = PyThreadState_Get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThreadState_Get");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThreadState_Swap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThreadState_Swap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_Swap(PyThreadState *)
     * }
     */
    public static FunctionDescriptor PyThreadState_Swap$descriptor() {
        return PyThreadState_Swap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_Swap(PyThreadState *)
     * }
     */
    public static MethodHandle PyThreadState_Swap$handle() {
        return PyThreadState_Swap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_Swap(PyThreadState *)
     * }
     */
    public static MemorySegment PyThreadState_Swap$address() {
        return PyThreadState_Swap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_Swap(PyThreadState *)
     * }
     */
    public static MemorySegment PyThreadState_Swap(MemorySegment x0) {
        var mh$ = PyThreadState_Swap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThreadState_Swap", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThreadState_GetDict {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThreadState_GetDict");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyThreadState_GetDict()
     * }
     */
    public static FunctionDescriptor PyThreadState_GetDict$descriptor() {
        return PyThreadState_GetDict.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyThreadState_GetDict()
     * }
     */
    public static MethodHandle PyThreadState_GetDict$handle() {
        return PyThreadState_GetDict.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyThreadState_GetDict()
     * }
     */
    public static MemorySegment PyThreadState_GetDict$address() {
        return PyThreadState_GetDict.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyThreadState_GetDict()
     * }
     */
    public static MemorySegment PyThreadState_GetDict() {
        var mh$ = PyThreadState_GetDict.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThreadState_GetDict");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThreadState_SetAsyncExc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThreadState_SetAsyncExc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyThreadState_SetAsyncExc(unsigned long, PyObject *)
     * }
     */
    public static FunctionDescriptor PyThreadState_SetAsyncExc$descriptor() {
        return PyThreadState_SetAsyncExc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyThreadState_SetAsyncExc(unsigned long, PyObject *)
     * }
     */
    public static MethodHandle PyThreadState_SetAsyncExc$handle() {
        return PyThreadState_SetAsyncExc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyThreadState_SetAsyncExc(unsigned long, PyObject *)
     * }
     */
    public static MemorySegment PyThreadState_SetAsyncExc$address() {
        return PyThreadState_SetAsyncExc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyThreadState_SetAsyncExc(unsigned long, PyObject *)
     * }
     */
    public static int PyThreadState_SetAsyncExc(long x0, MemorySegment x1) {
        var mh$ = PyThreadState_SetAsyncExc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThreadState_SetAsyncExc", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThreadState_GetInterpreter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThreadState_GetInterpreter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyInterpreterState *PyThreadState_GetInterpreter(PyThreadState *tstate)
     * }
     */
    public static FunctionDescriptor PyThreadState_GetInterpreter$descriptor() {
        return PyThreadState_GetInterpreter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyInterpreterState *PyThreadState_GetInterpreter(PyThreadState *tstate)
     * }
     */
    public static MethodHandle PyThreadState_GetInterpreter$handle() {
        return PyThreadState_GetInterpreter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyInterpreterState *PyThreadState_GetInterpreter(PyThreadState *tstate)
     * }
     */
    public static MemorySegment PyThreadState_GetInterpreter$address() {
        return PyThreadState_GetInterpreter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyInterpreterState *PyThreadState_GetInterpreter(PyThreadState *tstate)
     * }
     */
    public static MemorySegment PyThreadState_GetInterpreter(MemorySegment tstate) {
        var mh$ = PyThreadState_GetInterpreter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThreadState_GetInterpreter", tstate);
            }
            return (MemorySegment)mh$.invokeExact(tstate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThreadState_GetFrame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThreadState_GetFrame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyFrameObject *PyThreadState_GetFrame(PyThreadState *tstate)
     * }
     */
    public static FunctionDescriptor PyThreadState_GetFrame$descriptor() {
        return PyThreadState_GetFrame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyFrameObject *PyThreadState_GetFrame(PyThreadState *tstate)
     * }
     */
    public static MethodHandle PyThreadState_GetFrame$handle() {
        return PyThreadState_GetFrame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyFrameObject *PyThreadState_GetFrame(PyThreadState *tstate)
     * }
     */
    public static MemorySegment PyThreadState_GetFrame$address() {
        return PyThreadState_GetFrame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyFrameObject *PyThreadState_GetFrame(PyThreadState *tstate)
     * }
     */
    public static MemorySegment PyThreadState_GetFrame(MemorySegment tstate) {
        var mh$ = PyThreadState_GetFrame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThreadState_GetFrame", tstate);
            }
            return (MemorySegment)mh$.invokeExact(tstate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThreadState_GetID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThreadState_GetID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint64_t PyThreadState_GetID(PyThreadState *tstate)
     * }
     */
    public static FunctionDescriptor PyThreadState_GetID$descriptor() {
        return PyThreadState_GetID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint64_t PyThreadState_GetID(PyThreadState *tstate)
     * }
     */
    public static MethodHandle PyThreadState_GetID$handle() {
        return PyThreadState_GetID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint64_t PyThreadState_GetID(PyThreadState *tstate)
     * }
     */
    public static MemorySegment PyThreadState_GetID$address() {
        return PyThreadState_GetID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint64_t PyThreadState_GetID(PyThreadState *tstate)
     * }
     */
    public static long PyThreadState_GetID(MemorySegment tstate) {
        var mh$ = PyThreadState_GetID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThreadState_GetID", tstate);
            }
            return (long)mh$.invokeExact(tstate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int PyGILState_LOCKED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PyGILState_LOCKED = 0
     * }
     */
    public static int PyGILState_LOCKED() {
        return PyGILState_LOCKED;
    }
    private static final int PyGILState_UNLOCKED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PyGILState_UNLOCKED = 1
     * }
     */
    public static int PyGILState_UNLOCKED() {
        return PyGILState_UNLOCKED;
    }

    private static class PyGILState_Ensure {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyGILState_Ensure");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyGILState_STATE PyGILState_Ensure()
     * }
     */
    public static FunctionDescriptor PyGILState_Ensure$descriptor() {
        return PyGILState_Ensure.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyGILState_STATE PyGILState_Ensure()
     * }
     */
    public static MethodHandle PyGILState_Ensure$handle() {
        return PyGILState_Ensure.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyGILState_STATE PyGILState_Ensure()
     * }
     */
    public static MemorySegment PyGILState_Ensure$address() {
        return PyGILState_Ensure.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyGILState_STATE PyGILState_Ensure()
     * }
     */
    public static int PyGILState_Ensure() {
        var mh$ = PyGILState_Ensure.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyGILState_Ensure");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyGILState_Release {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyGILState_Release");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyGILState_Release(PyGILState_STATE)
     * }
     */
    public static FunctionDescriptor PyGILState_Release$descriptor() {
        return PyGILState_Release.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyGILState_Release(PyGILState_STATE)
     * }
     */
    public static MethodHandle PyGILState_Release$handle() {
        return PyGILState_Release.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyGILState_Release(PyGILState_STATE)
     * }
     */
    public static MemorySegment PyGILState_Release$address() {
        return PyGILState_Release.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyGILState_Release(PyGILState_STATE)
     * }
     */
    public static void PyGILState_Release(int x0) {
        var mh$ = PyGILState_Release.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyGILState_Release", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyGILState_GetThisThreadState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyGILState_GetThisThreadState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyThreadState *PyGILState_GetThisThreadState()
     * }
     */
    public static FunctionDescriptor PyGILState_GetThisThreadState$descriptor() {
        return PyGILState_GetThisThreadState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyThreadState *PyGILState_GetThisThreadState()
     * }
     */
    public static MethodHandle PyGILState_GetThisThreadState$handle() {
        return PyGILState_GetThisThreadState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyThreadState *PyGILState_GetThisThreadState()
     * }
     */
    public static MemorySegment PyGILState_GetThisThreadState$address() {
        return PyGILState_GetThisThreadState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyThreadState *PyGILState_GetThisThreadState()
     * }
     */
    public static MemorySegment PyGILState_GetThisThreadState() {
        var mh$ = PyGILState_GetThisThreadState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyGILState_GetThisThreadState");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyInterpreterState_RequiresIDRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyInterpreterState_RequiresIDRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyInterpreterState_RequiresIDRef(PyInterpreterState *)
     * }
     */
    public static FunctionDescriptor _PyInterpreterState_RequiresIDRef$descriptor() {
        return _PyInterpreterState_RequiresIDRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyInterpreterState_RequiresIDRef(PyInterpreterState *)
     * }
     */
    public static MethodHandle _PyInterpreterState_RequiresIDRef$handle() {
        return _PyInterpreterState_RequiresIDRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyInterpreterState_RequiresIDRef(PyInterpreterState *)
     * }
     */
    public static MemorySegment _PyInterpreterState_RequiresIDRef$address() {
        return _PyInterpreterState_RequiresIDRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyInterpreterState_RequiresIDRef(PyInterpreterState *)
     * }
     */
    public static int _PyInterpreterState_RequiresIDRef(MemorySegment x0) {
        var mh$ = _PyInterpreterState_RequiresIDRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyInterpreterState_RequiresIDRef", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyInterpreterState_RequireIDRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyInterpreterState_RequireIDRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyInterpreterState_RequireIDRef(PyInterpreterState *, int)
     * }
     */
    public static FunctionDescriptor _PyInterpreterState_RequireIDRef$descriptor() {
        return _PyInterpreterState_RequireIDRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyInterpreterState_RequireIDRef(PyInterpreterState *, int)
     * }
     */
    public static MethodHandle _PyInterpreterState_RequireIDRef$handle() {
        return _PyInterpreterState_RequireIDRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyInterpreterState_RequireIDRef(PyInterpreterState *, int)
     * }
     */
    public static MemorySegment _PyInterpreterState_RequireIDRef$address() {
        return _PyInterpreterState_RequireIDRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyInterpreterState_RequireIDRef(PyInterpreterState *, int)
     * }
     */
    public static void _PyInterpreterState_RequireIDRef(MemorySegment x0, int x1) {
        var mh$ = _PyInterpreterState_RequireIDRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyInterpreterState_RequireIDRef", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyInterpreterState_GetMainModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyInterpreterState_GetMainModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyInterpreterState_GetMainModule(PyInterpreterState *)
     * }
     */
    public static FunctionDescriptor _PyInterpreterState_GetMainModule$descriptor() {
        return _PyInterpreterState_GetMainModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyInterpreterState_GetMainModule(PyInterpreterState *)
     * }
     */
    public static MethodHandle _PyInterpreterState_GetMainModule$handle() {
        return _PyInterpreterState_GetMainModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyInterpreterState_GetMainModule(PyInterpreterState *)
     * }
     */
    public static MemorySegment _PyInterpreterState_GetMainModule$address() {
        return _PyInterpreterState_GetMainModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyInterpreterState_GetMainModule(PyInterpreterState *)
     * }
     */
    public static MemorySegment _PyInterpreterState_GetMainModule(MemorySegment x0) {
        var mh$ = _PyInterpreterState_GetMainModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyInterpreterState_GetMainModule", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyThreadState_Prealloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyThreadState_Prealloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyThreadState *_PyThreadState_Prealloc(PyInterpreterState *)
     * }
     */
    public static FunctionDescriptor _PyThreadState_Prealloc$descriptor() {
        return _PyThreadState_Prealloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyThreadState *_PyThreadState_Prealloc(PyInterpreterState *)
     * }
     */
    public static MethodHandle _PyThreadState_Prealloc$handle() {
        return _PyThreadState_Prealloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyThreadState *_PyThreadState_Prealloc(PyInterpreterState *)
     * }
     */
    public static MemorySegment _PyThreadState_Prealloc$address() {
        return _PyThreadState_Prealloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyThreadState *_PyThreadState_Prealloc(PyInterpreterState *)
     * }
     */
    public static MemorySegment _PyThreadState_Prealloc(MemorySegment x0) {
        var mh$ = _PyThreadState_Prealloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyThreadState_Prealloc", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyThreadState_UncheckedGet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyThreadState_UncheckedGet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyThreadState *_PyThreadState_UncheckedGet()
     * }
     */
    public static FunctionDescriptor _PyThreadState_UncheckedGet$descriptor() {
        return _PyThreadState_UncheckedGet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyThreadState *_PyThreadState_UncheckedGet()
     * }
     */
    public static MethodHandle _PyThreadState_UncheckedGet$handle() {
        return _PyThreadState_UncheckedGet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyThreadState *_PyThreadState_UncheckedGet()
     * }
     */
    public static MemorySegment _PyThreadState_UncheckedGet$address() {
        return _PyThreadState_UncheckedGet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyThreadState *_PyThreadState_UncheckedGet()
     * }
     */
    public static MemorySegment _PyThreadState_UncheckedGet() {
        var mh$ = _PyThreadState_UncheckedGet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyThreadState_UncheckedGet");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyThreadState_GetDict {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyThreadState_GetDict");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyThreadState_GetDict(PyThreadState *tstate)
     * }
     */
    public static FunctionDescriptor _PyThreadState_GetDict$descriptor() {
        return _PyThreadState_GetDict.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyThreadState_GetDict(PyThreadState *tstate)
     * }
     */
    public static MethodHandle _PyThreadState_GetDict$handle() {
        return _PyThreadState_GetDict.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyThreadState_GetDict(PyThreadState *tstate)
     * }
     */
    public static MemorySegment _PyThreadState_GetDict$address() {
        return _PyThreadState_GetDict.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyThreadState_GetDict(PyThreadState *tstate)
     * }
     */
    public static MemorySegment _PyThreadState_GetDict(MemorySegment tstate) {
        var mh$ = _PyThreadState_GetDict.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyThreadState_GetDict", tstate);
            }
            return (MemorySegment)mh$.invokeExact(tstate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThreadState_EnterTracing {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThreadState_EnterTracing");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyThreadState_EnterTracing(PyThreadState *tstate)
     * }
     */
    public static FunctionDescriptor PyThreadState_EnterTracing$descriptor() {
        return PyThreadState_EnterTracing.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyThreadState_EnterTracing(PyThreadState *tstate)
     * }
     */
    public static MethodHandle PyThreadState_EnterTracing$handle() {
        return PyThreadState_EnterTracing.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyThreadState_EnterTracing(PyThreadState *tstate)
     * }
     */
    public static MemorySegment PyThreadState_EnterTracing$address() {
        return PyThreadState_EnterTracing.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyThreadState_EnterTracing(PyThreadState *tstate)
     * }
     */
    public static void PyThreadState_EnterTracing(MemorySegment tstate) {
        var mh$ = PyThreadState_EnterTracing.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThreadState_EnterTracing", tstate);
            }
            mh$.invokeExact(tstate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThreadState_LeaveTracing {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThreadState_LeaveTracing");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyThreadState_LeaveTracing(PyThreadState *tstate)
     * }
     */
    public static FunctionDescriptor PyThreadState_LeaveTracing$descriptor() {
        return PyThreadState_LeaveTracing.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyThreadState_LeaveTracing(PyThreadState *tstate)
     * }
     */
    public static MethodHandle PyThreadState_LeaveTracing$handle() {
        return PyThreadState_LeaveTracing.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyThreadState_LeaveTracing(PyThreadState *tstate)
     * }
     */
    public static MemorySegment PyThreadState_LeaveTracing$address() {
        return PyThreadState_LeaveTracing.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyThreadState_LeaveTracing(PyThreadState *tstate)
     * }
     */
    public static void PyThreadState_LeaveTracing(MemorySegment tstate) {
        var mh$ = PyThreadState_LeaveTracing.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThreadState_LeaveTracing", tstate);
            }
            mh$.invokeExact(tstate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyGILState_Check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyGILState_Check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyGILState_Check()
     * }
     */
    public static FunctionDescriptor PyGILState_Check$descriptor() {
        return PyGILState_Check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyGILState_Check()
     * }
     */
    public static MethodHandle PyGILState_Check$handle() {
        return PyGILState_Check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyGILState_Check()
     * }
     */
    public static MemorySegment PyGILState_Check$address() {
        return PyGILState_Check.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyGILState_Check()
     * }
     */
    public static int PyGILState_Check() {
        var mh$ = PyGILState_Check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyGILState_Check");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyGILState_GetInterpreterStateUnsafe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyGILState_GetInterpreterStateUnsafe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyInterpreterState *_PyGILState_GetInterpreterStateUnsafe()
     * }
     */
    public static FunctionDescriptor _PyGILState_GetInterpreterStateUnsafe$descriptor() {
        return _PyGILState_GetInterpreterStateUnsafe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyInterpreterState *_PyGILState_GetInterpreterStateUnsafe()
     * }
     */
    public static MethodHandle _PyGILState_GetInterpreterStateUnsafe$handle() {
        return _PyGILState_GetInterpreterStateUnsafe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyInterpreterState *_PyGILState_GetInterpreterStateUnsafe()
     * }
     */
    public static MemorySegment _PyGILState_GetInterpreterStateUnsafe$address() {
        return _PyGILState_GetInterpreterStateUnsafe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyInterpreterState *_PyGILState_GetInterpreterStateUnsafe()
     * }
     */
    public static MemorySegment _PyGILState_GetInterpreterStateUnsafe() {
        var mh$ = _PyGILState_GetInterpreterStateUnsafe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyGILState_GetInterpreterStateUnsafe");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyThread_CurrentFrames {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyThread_CurrentFrames");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyThread_CurrentFrames()
     * }
     */
    public static FunctionDescriptor _PyThread_CurrentFrames$descriptor() {
        return _PyThread_CurrentFrames.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyThread_CurrentFrames()
     * }
     */
    public static MethodHandle _PyThread_CurrentFrames$handle() {
        return _PyThread_CurrentFrames.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyThread_CurrentFrames()
     * }
     */
    public static MemorySegment _PyThread_CurrentFrames$address() {
        return _PyThread_CurrentFrames.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyThread_CurrentFrames()
     * }
     */
    public static MemorySegment _PyThread_CurrentFrames() {
        var mh$ = _PyThread_CurrentFrames.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyThread_CurrentFrames");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyThread_CurrentExceptions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyThread_CurrentExceptions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyThread_CurrentExceptions()
     * }
     */
    public static FunctionDescriptor _PyThread_CurrentExceptions$descriptor() {
        return _PyThread_CurrentExceptions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyThread_CurrentExceptions()
     * }
     */
    public static MethodHandle _PyThread_CurrentExceptions$handle() {
        return _PyThread_CurrentExceptions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyThread_CurrentExceptions()
     * }
     */
    public static MemorySegment _PyThread_CurrentExceptions$address() {
        return _PyThread_CurrentExceptions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyThread_CurrentExceptions()
     * }
     */
    public static MemorySegment _PyThread_CurrentExceptions() {
        var mh$ = _PyThread_CurrentExceptions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyThread_CurrentExceptions");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyInterpreterState_Main {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyInterpreterState_Main");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_Main()
     * }
     */
    public static FunctionDescriptor PyInterpreterState_Main$descriptor() {
        return PyInterpreterState_Main.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_Main()
     * }
     */
    public static MethodHandle PyInterpreterState_Main$handle() {
        return PyInterpreterState_Main.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_Main()
     * }
     */
    public static MemorySegment PyInterpreterState_Main$address() {
        return PyInterpreterState_Main.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_Main()
     * }
     */
    public static MemorySegment PyInterpreterState_Main() {
        var mh$ = PyInterpreterState_Main.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyInterpreterState_Main");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyInterpreterState_Head {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyInterpreterState_Head");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_Head()
     * }
     */
    public static FunctionDescriptor PyInterpreterState_Head$descriptor() {
        return PyInterpreterState_Head.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_Head()
     * }
     */
    public static MethodHandle PyInterpreterState_Head$handle() {
        return PyInterpreterState_Head.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_Head()
     * }
     */
    public static MemorySegment PyInterpreterState_Head$address() {
        return PyInterpreterState_Head.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_Head()
     * }
     */
    public static MemorySegment PyInterpreterState_Head() {
        var mh$ = PyInterpreterState_Head.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyInterpreterState_Head");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyInterpreterState_Next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyInterpreterState_Next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_Next(PyInterpreterState *)
     * }
     */
    public static FunctionDescriptor PyInterpreterState_Next$descriptor() {
        return PyInterpreterState_Next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_Next(PyInterpreterState *)
     * }
     */
    public static MethodHandle PyInterpreterState_Next$handle() {
        return PyInterpreterState_Next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_Next(PyInterpreterState *)
     * }
     */
    public static MemorySegment PyInterpreterState_Next$address() {
        return PyInterpreterState_Next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyInterpreterState *PyInterpreterState_Next(PyInterpreterState *)
     * }
     */
    public static MemorySegment PyInterpreterState_Next(MemorySegment x0) {
        var mh$ = PyInterpreterState_Next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyInterpreterState_Next", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyInterpreterState_ThreadHead {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyInterpreterState_ThreadHead");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyThreadState *PyInterpreterState_ThreadHead(PyInterpreterState *)
     * }
     */
    public static FunctionDescriptor PyInterpreterState_ThreadHead$descriptor() {
        return PyInterpreterState_ThreadHead.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyThreadState *PyInterpreterState_ThreadHead(PyInterpreterState *)
     * }
     */
    public static MethodHandle PyInterpreterState_ThreadHead$handle() {
        return PyInterpreterState_ThreadHead.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyThreadState *PyInterpreterState_ThreadHead(PyInterpreterState *)
     * }
     */
    public static MemorySegment PyInterpreterState_ThreadHead$address() {
        return PyInterpreterState_ThreadHead.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyThreadState *PyInterpreterState_ThreadHead(PyInterpreterState *)
     * }
     */
    public static MemorySegment PyInterpreterState_ThreadHead(MemorySegment x0) {
        var mh$ = PyInterpreterState_ThreadHead.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyInterpreterState_ThreadHead", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThreadState_Next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThreadState_Next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_Next(PyThreadState *)
     * }
     */
    public static FunctionDescriptor PyThreadState_Next$descriptor() {
        return PyThreadState_Next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_Next(PyThreadState *)
     * }
     */
    public static MethodHandle PyThreadState_Next$handle() {
        return PyThreadState_Next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_Next(PyThreadState *)
     * }
     */
    public static MemorySegment PyThreadState_Next$address() {
        return PyThreadState_Next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyThreadState *PyThreadState_Next(PyThreadState *)
     * }
     */
    public static MemorySegment PyThreadState_Next(MemorySegment x0) {
        var mh$ = PyThreadState_Next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThreadState_Next", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThreadState_DeleteCurrent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThreadState_DeleteCurrent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyThreadState_DeleteCurrent()
     * }
     */
    public static FunctionDescriptor PyThreadState_DeleteCurrent$descriptor() {
        return PyThreadState_DeleteCurrent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyThreadState_DeleteCurrent()
     * }
     */
    public static MethodHandle PyThreadState_DeleteCurrent$handle() {
        return PyThreadState_DeleteCurrent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyThreadState_DeleteCurrent()
     * }
     */
    public static MemorySegment PyThreadState_DeleteCurrent$address() {
        return PyThreadState_DeleteCurrent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyThreadState_DeleteCurrent()
     * }
     */
    public static void PyThreadState_DeleteCurrent() {
        var mh$ = PyThreadState_DeleteCurrent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThreadState_DeleteCurrent");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyInterpreterState_GetEvalFrameFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyInterpreterState_GetEvalFrameFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _PyFrameEvalFunction _PyInterpreterState_GetEvalFrameFunc(PyInterpreterState *interp)
     * }
     */
    public static FunctionDescriptor _PyInterpreterState_GetEvalFrameFunc$descriptor() {
        return _PyInterpreterState_GetEvalFrameFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _PyFrameEvalFunction _PyInterpreterState_GetEvalFrameFunc(PyInterpreterState *interp)
     * }
     */
    public static MethodHandle _PyInterpreterState_GetEvalFrameFunc$handle() {
        return _PyInterpreterState_GetEvalFrameFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _PyFrameEvalFunction _PyInterpreterState_GetEvalFrameFunc(PyInterpreterState *interp)
     * }
     */
    public static MemorySegment _PyInterpreterState_GetEvalFrameFunc$address() {
        return _PyInterpreterState_GetEvalFrameFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _PyFrameEvalFunction _PyInterpreterState_GetEvalFrameFunc(PyInterpreterState *interp)
     * }
     */
    public static MemorySegment _PyInterpreterState_GetEvalFrameFunc(MemorySegment interp) {
        var mh$ = _PyInterpreterState_GetEvalFrameFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyInterpreterState_GetEvalFrameFunc", interp);
            }
            return (MemorySegment)mh$.invokeExact(interp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyInterpreterState_SetEvalFrameFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyInterpreterState_SetEvalFrameFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyInterpreterState_SetEvalFrameFunc(PyInterpreterState *interp, _PyFrameEvalFunction eval_frame)
     * }
     */
    public static FunctionDescriptor _PyInterpreterState_SetEvalFrameFunc$descriptor() {
        return _PyInterpreterState_SetEvalFrameFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyInterpreterState_SetEvalFrameFunc(PyInterpreterState *interp, _PyFrameEvalFunction eval_frame)
     * }
     */
    public static MethodHandle _PyInterpreterState_SetEvalFrameFunc$handle() {
        return _PyInterpreterState_SetEvalFrameFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyInterpreterState_SetEvalFrameFunc(PyInterpreterState *interp, _PyFrameEvalFunction eval_frame)
     * }
     */
    public static MemorySegment _PyInterpreterState_SetEvalFrameFunc$address() {
        return _PyInterpreterState_SetEvalFrameFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyInterpreterState_SetEvalFrameFunc(PyInterpreterState *interp, _PyFrameEvalFunction eval_frame)
     * }
     */
    public static void _PyInterpreterState_SetEvalFrameFunc(MemorySegment interp, MemorySegment eval_frame) {
        var mh$ = _PyInterpreterState_SetEvalFrameFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyInterpreterState_SetEvalFrameFunc", interp, eval_frame);
            }
            mh$.invokeExact(interp, eval_frame);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyInterpreterState_GetConfig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyInterpreterState_GetConfig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const PyConfig *_PyInterpreterState_GetConfig(PyInterpreterState *interp)
     * }
     */
    public static FunctionDescriptor _PyInterpreterState_GetConfig$descriptor() {
        return _PyInterpreterState_GetConfig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const PyConfig *_PyInterpreterState_GetConfig(PyInterpreterState *interp)
     * }
     */
    public static MethodHandle _PyInterpreterState_GetConfig$handle() {
        return _PyInterpreterState_GetConfig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const PyConfig *_PyInterpreterState_GetConfig(PyInterpreterState *interp)
     * }
     */
    public static MemorySegment _PyInterpreterState_GetConfig$address() {
        return _PyInterpreterState_GetConfig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const PyConfig *_PyInterpreterState_GetConfig(PyInterpreterState *interp)
     * }
     */
    public static MemorySegment _PyInterpreterState_GetConfig(MemorySegment interp) {
        var mh$ = _PyInterpreterState_GetConfig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyInterpreterState_GetConfig", interp);
            }
            return (MemorySegment)mh$.invokeExact(interp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyInterpreterState_GetConfigCopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyInterpreterState_GetConfigCopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyInterpreterState_GetConfigCopy(struct PyConfig *config)
     * }
     */
    public static FunctionDescriptor _PyInterpreterState_GetConfigCopy$descriptor() {
        return _PyInterpreterState_GetConfigCopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyInterpreterState_GetConfigCopy(struct PyConfig *config)
     * }
     */
    public static MethodHandle _PyInterpreterState_GetConfigCopy$handle() {
        return _PyInterpreterState_GetConfigCopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyInterpreterState_GetConfigCopy(struct PyConfig *config)
     * }
     */
    public static MemorySegment _PyInterpreterState_GetConfigCopy$address() {
        return _PyInterpreterState_GetConfigCopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyInterpreterState_GetConfigCopy(struct PyConfig *config)
     * }
     */
    public static int _PyInterpreterState_GetConfigCopy(MemorySegment config) {
        var mh$ = _PyInterpreterState_GetConfigCopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyInterpreterState_GetConfigCopy", config);
            }
            return (int)mh$.invokeExact(config);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyInterpreterState_SetConfig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyInterpreterState_SetConfig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyInterpreterState_SetConfig(const struct PyConfig *config)
     * }
     */
    public static FunctionDescriptor _PyInterpreterState_SetConfig$descriptor() {
        return _PyInterpreterState_SetConfig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyInterpreterState_SetConfig(const struct PyConfig *config)
     * }
     */
    public static MethodHandle _PyInterpreterState_SetConfig$handle() {
        return _PyInterpreterState_SetConfig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyInterpreterState_SetConfig(const struct PyConfig *config)
     * }
     */
    public static MemorySegment _PyInterpreterState_SetConfig$address() {
        return _PyInterpreterState_SetConfig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyInterpreterState_SetConfig(const struct PyConfig *config)
     * }
     */
    public static int _PyInterpreterState_SetConfig(MemorySegment config) {
        var mh$ = _PyInterpreterState_SetConfig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyInterpreterState_SetConfig", config);
            }
            return (int)mh$.invokeExact(config);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_GetConfig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_GetConfig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const PyConfig *_Py_GetConfig()
     * }
     */
    public static FunctionDescriptor _Py_GetConfig$descriptor() {
        return _Py_GetConfig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const PyConfig *_Py_GetConfig()
     * }
     */
    public static MethodHandle _Py_GetConfig$handle() {
        return _Py_GetConfig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const PyConfig *_Py_GetConfig()
     * }
     */
    public static MemorySegment _Py_GetConfig$address() {
        return _Py_GetConfig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const PyConfig *_Py_GetConfig()
     * }
     */
    public static MemorySegment _Py_GetConfig() {
        var mh$ = _Py_GetConfig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_GetConfig");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_GetCrossInterpreterData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_GetCrossInterpreterData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyObject_GetCrossInterpreterData(PyObject *, _PyCrossInterpreterData *)
     * }
     */
    public static FunctionDescriptor _PyObject_GetCrossInterpreterData$descriptor() {
        return _PyObject_GetCrossInterpreterData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyObject_GetCrossInterpreterData(PyObject *, _PyCrossInterpreterData *)
     * }
     */
    public static MethodHandle _PyObject_GetCrossInterpreterData$handle() {
        return _PyObject_GetCrossInterpreterData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyObject_GetCrossInterpreterData(PyObject *, _PyCrossInterpreterData *)
     * }
     */
    public static MemorySegment _PyObject_GetCrossInterpreterData$address() {
        return _PyObject_GetCrossInterpreterData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyObject_GetCrossInterpreterData(PyObject *, _PyCrossInterpreterData *)
     * }
     */
    public static int _PyObject_GetCrossInterpreterData(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyObject_GetCrossInterpreterData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_GetCrossInterpreterData", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyCrossInterpreterData_NewObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyCrossInterpreterData_NewObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyCrossInterpreterData_NewObject(_PyCrossInterpreterData *)
     * }
     */
    public static FunctionDescriptor _PyCrossInterpreterData_NewObject$descriptor() {
        return _PyCrossInterpreterData_NewObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyCrossInterpreterData_NewObject(_PyCrossInterpreterData *)
     * }
     */
    public static MethodHandle _PyCrossInterpreterData_NewObject$handle() {
        return _PyCrossInterpreterData_NewObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyCrossInterpreterData_NewObject(_PyCrossInterpreterData *)
     * }
     */
    public static MemorySegment _PyCrossInterpreterData_NewObject$address() {
        return _PyCrossInterpreterData_NewObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyCrossInterpreterData_NewObject(_PyCrossInterpreterData *)
     * }
     */
    public static MemorySegment _PyCrossInterpreterData_NewObject(MemorySegment x0) {
        var mh$ = _PyCrossInterpreterData_NewObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyCrossInterpreterData_NewObject", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyCrossInterpreterData_Release {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyCrossInterpreterData_Release");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyCrossInterpreterData_Release(_PyCrossInterpreterData *)
     * }
     */
    public static FunctionDescriptor _PyCrossInterpreterData_Release$descriptor() {
        return _PyCrossInterpreterData_Release.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyCrossInterpreterData_Release(_PyCrossInterpreterData *)
     * }
     */
    public static MethodHandle _PyCrossInterpreterData_Release$handle() {
        return _PyCrossInterpreterData_Release.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyCrossInterpreterData_Release(_PyCrossInterpreterData *)
     * }
     */
    public static MemorySegment _PyCrossInterpreterData_Release$address() {
        return _PyCrossInterpreterData_Release.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyCrossInterpreterData_Release(_PyCrossInterpreterData *)
     * }
     */
    public static void _PyCrossInterpreterData_Release(MemorySegment x0) {
        var mh$ = _PyCrossInterpreterData_Release.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyCrossInterpreterData_Release", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_CheckCrossInterpreterData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_CheckCrossInterpreterData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyObject_CheckCrossInterpreterData(PyObject *)
     * }
     */
    public static FunctionDescriptor _PyObject_CheckCrossInterpreterData$descriptor() {
        return _PyObject_CheckCrossInterpreterData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyObject_CheckCrossInterpreterData(PyObject *)
     * }
     */
    public static MethodHandle _PyObject_CheckCrossInterpreterData$handle() {
        return _PyObject_CheckCrossInterpreterData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyObject_CheckCrossInterpreterData(PyObject *)
     * }
     */
    public static MemorySegment _PyObject_CheckCrossInterpreterData$address() {
        return _PyObject_CheckCrossInterpreterData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyObject_CheckCrossInterpreterData(PyObject *)
     * }
     */
    public static int _PyObject_CheckCrossInterpreterData(MemorySegment x0) {
        var mh$ = _PyObject_CheckCrossInterpreterData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_CheckCrossInterpreterData", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyCrossInterpreterData_RegisterClass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyCrossInterpreterData_RegisterClass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyCrossInterpreterData_RegisterClass(PyTypeObject *, crossinterpdatafunc)
     * }
     */
    public static FunctionDescriptor _PyCrossInterpreterData_RegisterClass$descriptor() {
        return _PyCrossInterpreterData_RegisterClass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyCrossInterpreterData_RegisterClass(PyTypeObject *, crossinterpdatafunc)
     * }
     */
    public static MethodHandle _PyCrossInterpreterData_RegisterClass$handle() {
        return _PyCrossInterpreterData_RegisterClass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyCrossInterpreterData_RegisterClass(PyTypeObject *, crossinterpdatafunc)
     * }
     */
    public static MemorySegment _PyCrossInterpreterData_RegisterClass$address() {
        return _PyCrossInterpreterData_RegisterClass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyCrossInterpreterData_RegisterClass(PyTypeObject *, crossinterpdatafunc)
     * }
     */
    public static int _PyCrossInterpreterData_RegisterClass(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyCrossInterpreterData_RegisterClass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyCrossInterpreterData_RegisterClass", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyCrossInterpreterData_Lookup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyCrossInterpreterData_Lookup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * crossinterpdatafunc _PyCrossInterpreterData_Lookup(PyObject *)
     * }
     */
    public static FunctionDescriptor _PyCrossInterpreterData_Lookup$descriptor() {
        return _PyCrossInterpreterData_Lookup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * crossinterpdatafunc _PyCrossInterpreterData_Lookup(PyObject *)
     * }
     */
    public static MethodHandle _PyCrossInterpreterData_Lookup$handle() {
        return _PyCrossInterpreterData_Lookup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * crossinterpdatafunc _PyCrossInterpreterData_Lookup(PyObject *)
     * }
     */
    public static MemorySegment _PyCrossInterpreterData_Lookup$address() {
        return _PyCrossInterpreterData_Lookup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * crossinterpdatafunc _PyCrossInterpreterData_Lookup(PyObject *)
     * }
     */
    public static MemorySegment _PyCrossInterpreterData_Lookup(MemorySegment x0) {
        var mh$ = _PyCrossInterpreterData_Lookup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyCrossInterpreterData_Lookup", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyGen_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyGen_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyGen_Type
     * }
     */
    public static GroupLayout PyGen_Type$layout() {
        return PyGen_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyGen_Type
     * }
     */
    public static MemorySegment PyGen_Type() {
        return PyGen_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyGen_Type
     * }
     */
    public static void PyGen_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyGen_Type$constants.SEGMENT, 0L, PyGen_Type$constants.LAYOUT.byteSize());
    }

    private static class PyGen_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyGen_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyGen_New(PyFrameObject *)
     * }
     */
    public static FunctionDescriptor PyGen_New$descriptor() {
        return PyGen_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyGen_New(PyFrameObject *)
     * }
     */
    public static MethodHandle PyGen_New$handle() {
        return PyGen_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyGen_New(PyFrameObject *)
     * }
     */
    public static MemorySegment PyGen_New$address() {
        return PyGen_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyGen_New(PyFrameObject *)
     * }
     */
    public static MemorySegment PyGen_New(MemorySegment x0) {
        var mh$ = PyGen_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyGen_New", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyGen_NewWithQualName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyGen_NewWithQualName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyGen_NewWithQualName(PyFrameObject *, PyObject *name, PyObject *qualname)
     * }
     */
    public static FunctionDescriptor PyGen_NewWithQualName$descriptor() {
        return PyGen_NewWithQualName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyGen_NewWithQualName(PyFrameObject *, PyObject *name, PyObject *qualname)
     * }
     */
    public static MethodHandle PyGen_NewWithQualName$handle() {
        return PyGen_NewWithQualName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyGen_NewWithQualName(PyFrameObject *, PyObject *name, PyObject *qualname)
     * }
     */
    public static MemorySegment PyGen_NewWithQualName$address() {
        return PyGen_NewWithQualName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyGen_NewWithQualName(PyFrameObject *, PyObject *name, PyObject *qualname)
     * }
     */
    public static MemorySegment PyGen_NewWithQualName(MemorySegment x0, MemorySegment name, MemorySegment qualname) {
        var mh$ = PyGen_NewWithQualName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyGen_NewWithQualName", x0, name, qualname);
            }
            return (MemorySegment)mh$.invokeExact(x0, name, qualname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyGen_SetStopIterationValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyGen_SetStopIterationValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyGen_SetStopIterationValue(PyObject *)
     * }
     */
    public static FunctionDescriptor _PyGen_SetStopIterationValue$descriptor() {
        return _PyGen_SetStopIterationValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyGen_SetStopIterationValue(PyObject *)
     * }
     */
    public static MethodHandle _PyGen_SetStopIterationValue$handle() {
        return _PyGen_SetStopIterationValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyGen_SetStopIterationValue(PyObject *)
     * }
     */
    public static MemorySegment _PyGen_SetStopIterationValue$address() {
        return _PyGen_SetStopIterationValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyGen_SetStopIterationValue(PyObject *)
     * }
     */
    public static int _PyGen_SetStopIterationValue(MemorySegment x0) {
        var mh$ = _PyGen_SetStopIterationValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyGen_SetStopIterationValue", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyGen_FetchStopIterationValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyGen_FetchStopIterationValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyGen_FetchStopIterationValue(PyObject **)
     * }
     */
    public static FunctionDescriptor _PyGen_FetchStopIterationValue$descriptor() {
        return _PyGen_FetchStopIterationValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyGen_FetchStopIterationValue(PyObject **)
     * }
     */
    public static MethodHandle _PyGen_FetchStopIterationValue$handle() {
        return _PyGen_FetchStopIterationValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyGen_FetchStopIterationValue(PyObject **)
     * }
     */
    public static MemorySegment _PyGen_FetchStopIterationValue$address() {
        return _PyGen_FetchStopIterationValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyGen_FetchStopIterationValue(PyObject **)
     * }
     */
    public static int _PyGen_FetchStopIterationValue(MemorySegment x0) {
        var mh$ = _PyGen_FetchStopIterationValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyGen_FetchStopIterationValue", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyGen_Finalize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyGen_Finalize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyGen_Finalize(PyObject *self)
     * }
     */
    public static FunctionDescriptor _PyGen_Finalize$descriptor() {
        return _PyGen_Finalize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyGen_Finalize(PyObject *self)
     * }
     */
    public static MethodHandle _PyGen_Finalize$handle() {
        return _PyGen_Finalize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyGen_Finalize(PyObject *self)
     * }
     */
    public static MemorySegment _PyGen_Finalize$address() {
        return _PyGen_Finalize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyGen_Finalize(PyObject *self)
     * }
     */
    public static void _PyGen_Finalize(MemorySegment self) {
        var mh$ = _PyGen_Finalize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyGen_Finalize", self);
            }
            mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCoro_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyCoro_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCoro_Type
     * }
     */
    public static GroupLayout PyCoro_Type$layout() {
        return PyCoro_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCoro_Type
     * }
     */
    public static MemorySegment PyCoro_Type() {
        return PyCoro_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyCoro_Type
     * }
     */
    public static void PyCoro_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyCoro_Type$constants.SEGMENT, 0L, PyCoro_Type$constants.LAYOUT.byteSize());
    }

    private static class _PyCoroWrapper_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_PyCoroWrapper_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyCoroWrapper_Type
     * }
     */
    public static GroupLayout _PyCoroWrapper_Type$layout() {
        return _PyCoroWrapper_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyCoroWrapper_Type
     * }
     */
    public static MemorySegment _PyCoroWrapper_Type() {
        return _PyCoroWrapper_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyCoroWrapper_Type
     * }
     */
    public static void _PyCoroWrapper_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _PyCoroWrapper_Type$constants.SEGMENT, 0L, _PyCoroWrapper_Type$constants.LAYOUT.byteSize());
    }

    private static class PyCoro_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCoro_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCoro_New(PyFrameObject *, PyObject *name, PyObject *qualname)
     * }
     */
    public static FunctionDescriptor PyCoro_New$descriptor() {
        return PyCoro_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCoro_New(PyFrameObject *, PyObject *name, PyObject *qualname)
     * }
     */
    public static MethodHandle PyCoro_New$handle() {
        return PyCoro_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCoro_New(PyFrameObject *, PyObject *name, PyObject *qualname)
     * }
     */
    public static MemorySegment PyCoro_New$address() {
        return PyCoro_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCoro_New(PyFrameObject *, PyObject *name, PyObject *qualname)
     * }
     */
    public static MemorySegment PyCoro_New(MemorySegment x0, MemorySegment name, MemorySegment qualname) {
        var mh$ = PyCoro_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCoro_New", x0, name, qualname);
            }
            return (MemorySegment)mh$.invokeExact(x0, name, qualname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyAsyncGen_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyAsyncGen_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyAsyncGen_Type
     * }
     */
    public static GroupLayout PyAsyncGen_Type$layout() {
        return PyAsyncGen_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyAsyncGen_Type
     * }
     */
    public static MemorySegment PyAsyncGen_Type() {
        return PyAsyncGen_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyAsyncGen_Type
     * }
     */
    public static void PyAsyncGen_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyAsyncGen_Type$constants.SEGMENT, 0L, PyAsyncGen_Type$constants.LAYOUT.byteSize());
    }

    private static class _PyAsyncGenASend_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_PyAsyncGenASend_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyAsyncGenASend_Type
     * }
     */
    public static GroupLayout _PyAsyncGenASend_Type$layout() {
        return _PyAsyncGenASend_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyAsyncGenASend_Type
     * }
     */
    public static MemorySegment _PyAsyncGenASend_Type() {
        return _PyAsyncGenASend_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyAsyncGenASend_Type
     * }
     */
    public static void _PyAsyncGenASend_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _PyAsyncGenASend_Type$constants.SEGMENT, 0L, _PyAsyncGenASend_Type$constants.LAYOUT.byteSize());
    }

    private static class _PyAsyncGenWrappedValue_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_PyAsyncGenWrappedValue_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyAsyncGenWrappedValue_Type
     * }
     */
    public static GroupLayout _PyAsyncGenWrappedValue_Type$layout() {
        return _PyAsyncGenWrappedValue_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyAsyncGenWrappedValue_Type
     * }
     */
    public static MemorySegment _PyAsyncGenWrappedValue_Type() {
        return _PyAsyncGenWrappedValue_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyAsyncGenWrappedValue_Type
     * }
     */
    public static void _PyAsyncGenWrappedValue_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _PyAsyncGenWrappedValue_Type$constants.SEGMENT, 0L, _PyAsyncGenWrappedValue_Type$constants.LAYOUT.byteSize());
    }

    private static class _PyAsyncGenAThrow_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_PyAsyncGenAThrow_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyAsyncGenAThrow_Type
     * }
     */
    public static GroupLayout _PyAsyncGenAThrow_Type$layout() {
        return _PyAsyncGenAThrow_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyAsyncGenAThrow_Type
     * }
     */
    public static MemorySegment _PyAsyncGenAThrow_Type() {
        return _PyAsyncGenAThrow_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyAsyncGenAThrow_Type
     * }
     */
    public static void _PyAsyncGenAThrow_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _PyAsyncGenAThrow_Type$constants.SEGMENT, 0L, _PyAsyncGenAThrow_Type$constants.LAYOUT.byteSize());
    }

    private static class PyAsyncGen_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyAsyncGen_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyAsyncGen_New(PyFrameObject *, PyObject *name, PyObject *qualname)
     * }
     */
    public static FunctionDescriptor PyAsyncGen_New$descriptor() {
        return PyAsyncGen_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyAsyncGen_New(PyFrameObject *, PyObject *name, PyObject *qualname)
     * }
     */
    public static MethodHandle PyAsyncGen_New$handle() {
        return PyAsyncGen_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyAsyncGen_New(PyFrameObject *, PyObject *name, PyObject *qualname)
     * }
     */
    public static MemorySegment PyAsyncGen_New$address() {
        return PyAsyncGen_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyAsyncGen_New(PyFrameObject *, PyObject *name, PyObject *qualname)
     * }
     */
    public static MemorySegment PyAsyncGen_New(MemorySegment x0, MemorySegment name, MemorySegment qualname) {
        var mh$ = PyAsyncGen_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyAsyncGen_New", x0, name, qualname);
            }
            return (MemorySegment)mh$.invokeExact(x0, name, qualname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyClassMethodDescr_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyClassMethodDescr_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyClassMethodDescr_Type
     * }
     */
    public static GroupLayout PyClassMethodDescr_Type$layout() {
        return PyClassMethodDescr_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyClassMethodDescr_Type
     * }
     */
    public static MemorySegment PyClassMethodDescr_Type() {
        return PyClassMethodDescr_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyClassMethodDescr_Type
     * }
     */
    public static void PyClassMethodDescr_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyClassMethodDescr_Type$constants.SEGMENT, 0L, PyClassMethodDescr_Type$constants.LAYOUT.byteSize());
    }

    private static class PyGetSetDescr_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyGetSetDescr_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyGetSetDescr_Type
     * }
     */
    public static GroupLayout PyGetSetDescr_Type$layout() {
        return PyGetSetDescr_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyGetSetDescr_Type
     * }
     */
    public static MemorySegment PyGetSetDescr_Type() {
        return PyGetSetDescr_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyGetSetDescr_Type
     * }
     */
    public static void PyGetSetDescr_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyGetSetDescr_Type$constants.SEGMENT, 0L, PyGetSetDescr_Type$constants.LAYOUT.byteSize());
    }

    private static class PyMemberDescr_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyMemberDescr_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyMemberDescr_Type
     * }
     */
    public static GroupLayout PyMemberDescr_Type$layout() {
        return PyMemberDescr_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyMemberDescr_Type
     * }
     */
    public static MemorySegment PyMemberDescr_Type() {
        return PyMemberDescr_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyMemberDescr_Type
     * }
     */
    public static void PyMemberDescr_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyMemberDescr_Type$constants.SEGMENT, 0L, PyMemberDescr_Type$constants.LAYOUT.byteSize());
    }

    private static class PyMethodDescr_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyMethodDescr_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyMethodDescr_Type
     * }
     */
    public static GroupLayout PyMethodDescr_Type$layout() {
        return PyMethodDescr_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyMethodDescr_Type
     * }
     */
    public static MemorySegment PyMethodDescr_Type() {
        return PyMethodDescr_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyMethodDescr_Type
     * }
     */
    public static void PyMethodDescr_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyMethodDescr_Type$constants.SEGMENT, 0L, PyMethodDescr_Type$constants.LAYOUT.byteSize());
    }

    private static class PyWrapperDescr_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyWrapperDescr_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyWrapperDescr_Type
     * }
     */
    public static GroupLayout PyWrapperDescr_Type$layout() {
        return PyWrapperDescr_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyWrapperDescr_Type
     * }
     */
    public static MemorySegment PyWrapperDescr_Type() {
        return PyWrapperDescr_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyWrapperDescr_Type
     * }
     */
    public static void PyWrapperDescr_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyWrapperDescr_Type$constants.SEGMENT, 0L, PyWrapperDescr_Type$constants.LAYOUT.byteSize());
    }

    private static class PyDictProxy_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyDictProxy_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictProxy_Type
     * }
     */
    public static GroupLayout PyDictProxy_Type$layout() {
        return PyDictProxy_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictProxy_Type
     * }
     */
    public static MemorySegment PyDictProxy_Type() {
        return PyDictProxy_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyDictProxy_Type
     * }
     */
    public static void PyDictProxy_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyDictProxy_Type$constants.SEGMENT, 0L, PyDictProxy_Type$constants.LAYOUT.byteSize());
    }

    private static class PyProperty_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyProperty_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyProperty_Type
     * }
     */
    public static GroupLayout PyProperty_Type$layout() {
        return PyProperty_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyProperty_Type
     * }
     */
    public static MemorySegment PyProperty_Type() {
        return PyProperty_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyProperty_Type
     * }
     */
    public static void PyProperty_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyProperty_Type$constants.SEGMENT, 0L, PyProperty_Type$constants.LAYOUT.byteSize());
    }

    private static class PyDescr_NewMethod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDescr_NewMethod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyDescr_NewMethod(PyTypeObject *, PyMethodDef *)
     * }
     */
    public static FunctionDescriptor PyDescr_NewMethod$descriptor() {
        return PyDescr_NewMethod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyDescr_NewMethod(PyTypeObject *, PyMethodDef *)
     * }
     */
    public static MethodHandle PyDescr_NewMethod$handle() {
        return PyDescr_NewMethod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyDescr_NewMethod(PyTypeObject *, PyMethodDef *)
     * }
     */
    public static MemorySegment PyDescr_NewMethod$address() {
        return PyDescr_NewMethod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyDescr_NewMethod(PyTypeObject *, PyMethodDef *)
     * }
     */
    public static MemorySegment PyDescr_NewMethod(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyDescr_NewMethod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDescr_NewMethod", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDescr_NewClassMethod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDescr_NewClassMethod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyDescr_NewClassMethod(PyTypeObject *, PyMethodDef *)
     * }
     */
    public static FunctionDescriptor PyDescr_NewClassMethod$descriptor() {
        return PyDescr_NewClassMethod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyDescr_NewClassMethod(PyTypeObject *, PyMethodDef *)
     * }
     */
    public static MethodHandle PyDescr_NewClassMethod$handle() {
        return PyDescr_NewClassMethod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyDescr_NewClassMethod(PyTypeObject *, PyMethodDef *)
     * }
     */
    public static MemorySegment PyDescr_NewClassMethod$address() {
        return PyDescr_NewClassMethod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyDescr_NewClassMethod(PyTypeObject *, PyMethodDef *)
     * }
     */
    public static MemorySegment PyDescr_NewClassMethod(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyDescr_NewClassMethod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDescr_NewClassMethod", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDescr_NewMember {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDescr_NewMember");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyDescr_NewMember(PyTypeObject *, PyMemberDef *)
     * }
     */
    public static FunctionDescriptor PyDescr_NewMember$descriptor() {
        return PyDescr_NewMember.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyDescr_NewMember(PyTypeObject *, PyMemberDef *)
     * }
     */
    public static MethodHandle PyDescr_NewMember$handle() {
        return PyDescr_NewMember.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyDescr_NewMember(PyTypeObject *, PyMemberDef *)
     * }
     */
    public static MemorySegment PyDescr_NewMember$address() {
        return PyDescr_NewMember.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyDescr_NewMember(PyTypeObject *, PyMemberDef *)
     * }
     */
    public static MemorySegment PyDescr_NewMember(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyDescr_NewMember.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDescr_NewMember", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDescr_NewGetSet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDescr_NewGetSet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyDescr_NewGetSet(PyTypeObject *, PyGetSetDef *)
     * }
     */
    public static FunctionDescriptor PyDescr_NewGetSet$descriptor() {
        return PyDescr_NewGetSet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyDescr_NewGetSet(PyTypeObject *, PyGetSetDef *)
     * }
     */
    public static MethodHandle PyDescr_NewGetSet$handle() {
        return PyDescr_NewGetSet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyDescr_NewGetSet(PyTypeObject *, PyGetSetDef *)
     * }
     */
    public static MemorySegment PyDescr_NewGetSet$address() {
        return PyDescr_NewGetSet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyDescr_NewGetSet(PyTypeObject *, PyGetSetDef *)
     * }
     */
    public static MemorySegment PyDescr_NewGetSet(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyDescr_NewGetSet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDescr_NewGetSet", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDictProxy_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDictProxy_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyDictProxy_New(PyObject *)
     * }
     */
    public static FunctionDescriptor PyDictProxy_New$descriptor() {
        return PyDictProxy_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyDictProxy_New(PyObject *)
     * }
     */
    public static MethodHandle PyDictProxy_New$handle() {
        return PyDictProxy_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyDictProxy_New(PyObject *)
     * }
     */
    public static MemorySegment PyDictProxy_New$address() {
        return PyDictProxy_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyDictProxy_New(PyObject *)
     * }
     */
    public static MemorySegment PyDictProxy_New(MemorySegment x0) {
        var mh$ = PyDictProxy_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDictProxy_New", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyWrapper_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyWrapper_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyWrapper_New(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyWrapper_New$descriptor() {
        return PyWrapper_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyWrapper_New(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyWrapper_New$handle() {
        return PyWrapper_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyWrapper_New(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyWrapper_New$address() {
        return PyWrapper_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyWrapper_New(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyWrapper_New(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyWrapper_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyWrapper_New", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyMethodWrapper_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_PyMethodWrapper_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyMethodWrapper_Type
     * }
     */
    public static GroupLayout _PyMethodWrapper_Type$layout() {
        return _PyMethodWrapper_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyMethodWrapper_Type
     * }
     */
    public static MemorySegment _PyMethodWrapper_Type() {
        return _PyMethodWrapper_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyMethodWrapper_Type
     * }
     */
    public static void _PyMethodWrapper_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _PyMethodWrapper_Type$constants.SEGMENT, 0L, _PyMethodWrapper_Type$constants.LAYOUT.byteSize());
    }

    private static class PyDescr_NewWrapper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDescr_NewWrapper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyDescr_NewWrapper(PyTypeObject *, struct wrapperbase *, void *)
     * }
     */
    public static FunctionDescriptor PyDescr_NewWrapper$descriptor() {
        return PyDescr_NewWrapper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyDescr_NewWrapper(PyTypeObject *, struct wrapperbase *, void *)
     * }
     */
    public static MethodHandle PyDescr_NewWrapper$handle() {
        return PyDescr_NewWrapper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyDescr_NewWrapper(PyTypeObject *, struct wrapperbase *, void *)
     * }
     */
    public static MemorySegment PyDescr_NewWrapper$address() {
        return PyDescr_NewWrapper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyDescr_NewWrapper(PyTypeObject *, struct wrapperbase *, void *)
     * }
     */
    public static MemorySegment PyDescr_NewWrapper(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyDescr_NewWrapper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDescr_NewWrapper", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyDescr_IsData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyDescr_IsData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyDescr_IsData(PyObject *)
     * }
     */
    public static FunctionDescriptor PyDescr_IsData$descriptor() {
        return PyDescr_IsData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyDescr_IsData(PyObject *)
     * }
     */
    public static MethodHandle PyDescr_IsData$handle() {
        return PyDescr_IsData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyDescr_IsData(PyObject *)
     * }
     */
    public static MemorySegment PyDescr_IsData$address() {
        return PyDescr_IsData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyDescr_IsData(PyObject *)
     * }
     */
    public static int PyDescr_IsData(MemorySegment x0) {
        var mh$ = PyDescr_IsData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyDescr_IsData", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_GenericAlias {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_GenericAlias");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *Py_GenericAlias(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor Py_GenericAlias$descriptor() {
        return Py_GenericAlias.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *Py_GenericAlias(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle Py_GenericAlias$handle() {
        return Py_GenericAlias.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *Py_GenericAlias(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment Py_GenericAlias$address() {
        return Py_GenericAlias.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *Py_GenericAlias(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment Py_GenericAlias(MemorySegment x0, MemorySegment x1) {
        var mh$ = Py_GenericAlias.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_GenericAlias", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_GenericAliasType$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_GenericAliasType").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject Py_GenericAliasType
     * }
     */
    public static GroupLayout Py_GenericAliasType$layout() {
        return Py_GenericAliasType$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject Py_GenericAliasType
     * }
     */
    public static MemorySegment Py_GenericAliasType() {
        return Py_GenericAliasType$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject Py_GenericAliasType
     * }
     */
    public static void Py_GenericAliasType(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, Py_GenericAliasType$constants.SEGMENT, 0L, Py_GenericAliasType$constants.LAYOUT.byteSize());
    }

    private static class PyErr_WarnEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_WarnEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyErr_WarnEx(PyObject *category, const char *message, Py_ssize_t stack_level)
     * }
     */
    public static FunctionDescriptor PyErr_WarnEx$descriptor() {
        return PyErr_WarnEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyErr_WarnEx(PyObject *category, const char *message, Py_ssize_t stack_level)
     * }
     */
    public static MethodHandle PyErr_WarnEx$handle() {
        return PyErr_WarnEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyErr_WarnEx(PyObject *category, const char *message, Py_ssize_t stack_level)
     * }
     */
    public static MemorySegment PyErr_WarnEx$address() {
        return PyErr_WarnEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyErr_WarnEx(PyObject *category, const char *message, Py_ssize_t stack_level)
     * }
     */
    public static int PyErr_WarnEx(MemorySegment category, MemorySegment message, long stack_level) {
        var mh$ = PyErr_WarnEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_WarnEx", category, message, stack_level);
            }
            return (int)mh$.invokeExact(category, message, stack_level);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int PyErr_WarnFormat(PyObject *category, Py_ssize_t stack_level, const char *format, ...)
     * }
     */
    public static class PyErr_WarnFormat {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_LONG,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_WarnFormat");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyErr_WarnFormat(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int PyErr_WarnFormat(PyObject *category, Py_ssize_t stack_level, const char *format, ...)
         * }
         */
        public static PyErr_WarnFormat makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyErr_WarnFormat(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment category, long stack_level, MemorySegment format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyErr_WarnFormat", category, stack_level, format, x3);
                }
                return (int)spreader.invokeExact(category, stack_level, format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int PyErr_ResourceWarning(PyObject *source, Py_ssize_t stack_level, const char *format, ...)
     * }
     */
    public static class PyErr_ResourceWarning {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_LONG,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_ResourceWarning");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyErr_ResourceWarning(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int PyErr_ResourceWarning(PyObject *source, Py_ssize_t stack_level, const char *format, ...)
         * }
         */
        public static PyErr_ResourceWarning makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyErr_ResourceWarning(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment source, long stack_level, MemorySegment format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyErr_ResourceWarning", source, stack_level, format, x3);
                }
                return (int)spreader.invokeExact(source, stack_level, format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class PyErr_WarnExplicit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_WarnExplicit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyErr_WarnExplicit(PyObject *category, const char *message, const char *filename, int lineno, const char *module, PyObject *registry)
     * }
     */
    public static FunctionDescriptor PyErr_WarnExplicit$descriptor() {
        return PyErr_WarnExplicit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyErr_WarnExplicit(PyObject *category, const char *message, const char *filename, int lineno, const char *module, PyObject *registry)
     * }
     */
    public static MethodHandle PyErr_WarnExplicit$handle() {
        return PyErr_WarnExplicit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyErr_WarnExplicit(PyObject *category, const char *message, const char *filename, int lineno, const char *module, PyObject *registry)
     * }
     */
    public static MemorySegment PyErr_WarnExplicit$address() {
        return PyErr_WarnExplicit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyErr_WarnExplicit(PyObject *category, const char *message, const char *filename, int lineno, const char *module, PyObject *registry)
     * }
     */
    public static int PyErr_WarnExplicit(MemorySegment category, MemorySegment message, MemorySegment filename, int lineno, MemorySegment module, MemorySegment registry) {
        var mh$ = PyErr_WarnExplicit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_WarnExplicit", category, message, filename, lineno, module, registry);
            }
            return (int)mh$.invokeExact(category, message, filename, lineno, module, registry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_WarnExplicitObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_WarnExplicitObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyErr_WarnExplicitObject(PyObject *category, PyObject *message, PyObject *filename, int lineno, PyObject *module, PyObject *registry)
     * }
     */
    public static FunctionDescriptor PyErr_WarnExplicitObject$descriptor() {
        return PyErr_WarnExplicitObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyErr_WarnExplicitObject(PyObject *category, PyObject *message, PyObject *filename, int lineno, PyObject *module, PyObject *registry)
     * }
     */
    public static MethodHandle PyErr_WarnExplicitObject$handle() {
        return PyErr_WarnExplicitObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyErr_WarnExplicitObject(PyObject *category, PyObject *message, PyObject *filename, int lineno, PyObject *module, PyObject *registry)
     * }
     */
    public static MemorySegment PyErr_WarnExplicitObject$address() {
        return PyErr_WarnExplicitObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyErr_WarnExplicitObject(PyObject *category, PyObject *message, PyObject *filename, int lineno, PyObject *module, PyObject *registry)
     * }
     */
    public static int PyErr_WarnExplicitObject(MemorySegment category, MemorySegment message, MemorySegment filename, int lineno, MemorySegment module, MemorySegment registry) {
        var mh$ = PyErr_WarnExplicitObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_WarnExplicitObject", category, message, filename, lineno, module, registry);
            }
            return (int)mh$.invokeExact(category, message, filename, lineno, module, registry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int PyErr_WarnExplicitFormat(PyObject *category, const char *filename, int lineno, const char *module, PyObject *registry, const char *format, ...)
     * }
     */
    public static class PyErr_WarnExplicitFormat {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_WarnExplicitFormat");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyErr_WarnExplicitFormat(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int PyErr_WarnExplicitFormat(PyObject *category, const char *filename, int lineno, const char *module, PyObject *registry, const char *format, ...)
         * }
         */
        public static PyErr_WarnExplicitFormat makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyErr_WarnExplicitFormat(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment category, MemorySegment filename, int lineno, MemorySegment module, MemorySegment registry, MemorySegment format, Object... x6) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyErr_WarnExplicitFormat", category, filename, lineno, module, registry, format, x6);
                }
                return (int)spreader.invokeExact(category, filename, lineno, module, registry, format, x6);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class _PyWeakref_RefType$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_PyWeakref_RefType").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyWeakref_RefType
     * }
     */
    public static GroupLayout _PyWeakref_RefType$layout() {
        return _PyWeakref_RefType$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyWeakref_RefType
     * }
     */
    public static MemorySegment _PyWeakref_RefType() {
        return _PyWeakref_RefType$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyWeakref_RefType
     * }
     */
    public static void _PyWeakref_RefType(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _PyWeakref_RefType$constants.SEGMENT, 0L, _PyWeakref_RefType$constants.LAYOUT.byteSize());
    }

    private static class _PyWeakref_ProxyType$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_PyWeakref_ProxyType").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyWeakref_ProxyType
     * }
     */
    public static GroupLayout _PyWeakref_ProxyType$layout() {
        return _PyWeakref_ProxyType$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyWeakref_ProxyType
     * }
     */
    public static MemorySegment _PyWeakref_ProxyType() {
        return _PyWeakref_ProxyType$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyWeakref_ProxyType
     * }
     */
    public static void _PyWeakref_ProxyType(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _PyWeakref_ProxyType$constants.SEGMENT, 0L, _PyWeakref_ProxyType$constants.LAYOUT.byteSize());
    }

    private static class _PyWeakref_CallableProxyType$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_PyWeakref_CallableProxyType").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyWeakref_CallableProxyType
     * }
     */
    public static GroupLayout _PyWeakref_CallableProxyType$layout() {
        return _PyWeakref_CallableProxyType$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyWeakref_CallableProxyType
     * }
     */
    public static MemorySegment _PyWeakref_CallableProxyType() {
        return _PyWeakref_CallableProxyType$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyWeakref_CallableProxyType
     * }
     */
    public static void _PyWeakref_CallableProxyType(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _PyWeakref_CallableProxyType$constants.SEGMENT, 0L, _PyWeakref_CallableProxyType$constants.LAYOUT.byteSize());
    }

    private static class PyWeakref_NewRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyWeakref_NewRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyWeakref_NewRef(PyObject *ob, PyObject *callback)
     * }
     */
    public static FunctionDescriptor PyWeakref_NewRef$descriptor() {
        return PyWeakref_NewRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyWeakref_NewRef(PyObject *ob, PyObject *callback)
     * }
     */
    public static MethodHandle PyWeakref_NewRef$handle() {
        return PyWeakref_NewRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyWeakref_NewRef(PyObject *ob, PyObject *callback)
     * }
     */
    public static MemorySegment PyWeakref_NewRef$address() {
        return PyWeakref_NewRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyWeakref_NewRef(PyObject *ob, PyObject *callback)
     * }
     */
    public static MemorySegment PyWeakref_NewRef(MemorySegment ob, MemorySegment callback) {
        var mh$ = PyWeakref_NewRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyWeakref_NewRef", ob, callback);
            }
            return (MemorySegment)mh$.invokeExact(ob, callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyWeakref_NewProxy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyWeakref_NewProxy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyWeakref_NewProxy(PyObject *ob, PyObject *callback)
     * }
     */
    public static FunctionDescriptor PyWeakref_NewProxy$descriptor() {
        return PyWeakref_NewProxy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyWeakref_NewProxy(PyObject *ob, PyObject *callback)
     * }
     */
    public static MethodHandle PyWeakref_NewProxy$handle() {
        return PyWeakref_NewProxy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyWeakref_NewProxy(PyObject *ob, PyObject *callback)
     * }
     */
    public static MemorySegment PyWeakref_NewProxy$address() {
        return PyWeakref_NewProxy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyWeakref_NewProxy(PyObject *ob, PyObject *callback)
     * }
     */
    public static MemorySegment PyWeakref_NewProxy(MemorySegment ob, MemorySegment callback) {
        var mh$ = PyWeakref_NewProxy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyWeakref_NewProxy", ob, callback);
            }
            return (MemorySegment)mh$.invokeExact(ob, callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyWeakref_GetObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyWeakref_GetObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyWeakref_GetObject(PyObject *ref)
     * }
     */
    public static FunctionDescriptor PyWeakref_GetObject$descriptor() {
        return PyWeakref_GetObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyWeakref_GetObject(PyObject *ref)
     * }
     */
    public static MethodHandle PyWeakref_GetObject$handle() {
        return PyWeakref_GetObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyWeakref_GetObject(PyObject *ref)
     * }
     */
    public static MemorySegment PyWeakref_GetObject$address() {
        return PyWeakref_GetObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyWeakref_GetObject(PyObject *ref)
     * }
     */
    public static MemorySegment PyWeakref_GetObject(MemorySegment ref) {
        var mh$ = PyWeakref_GetObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyWeakref_GetObject", ref);
            }
            return (MemorySegment)mh$.invokeExact(ref);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyWeakref_GetWeakrefCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyWeakref_GetWeakrefCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t _PyWeakref_GetWeakrefCount(PyWeakReference *head)
     * }
     */
    public static FunctionDescriptor _PyWeakref_GetWeakrefCount$descriptor() {
        return _PyWeakref_GetWeakrefCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t _PyWeakref_GetWeakrefCount(PyWeakReference *head)
     * }
     */
    public static MethodHandle _PyWeakref_GetWeakrefCount$handle() {
        return _PyWeakref_GetWeakrefCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t _PyWeakref_GetWeakrefCount(PyWeakReference *head)
     * }
     */
    public static MemorySegment _PyWeakref_GetWeakrefCount$address() {
        return _PyWeakref_GetWeakrefCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t _PyWeakref_GetWeakrefCount(PyWeakReference *head)
     * }
     */
    public static long _PyWeakref_GetWeakrefCount(MemorySegment head) {
        var mh$ = _PyWeakref_GetWeakrefCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyWeakref_GetWeakrefCount", head);
            }
            return (long)mh$.invokeExact(head);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyWeakref_ClearRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyWeakref_ClearRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyWeakref_ClearRef(PyWeakReference *self)
     * }
     */
    public static FunctionDescriptor _PyWeakref_ClearRef$descriptor() {
        return _PyWeakref_ClearRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyWeakref_ClearRef(PyWeakReference *self)
     * }
     */
    public static MethodHandle _PyWeakref_ClearRef$handle() {
        return _PyWeakref_ClearRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyWeakref_ClearRef(PyWeakReference *self)
     * }
     */
    public static MemorySegment _PyWeakref_ClearRef$address() {
        return _PyWeakref_ClearRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyWeakref_ClearRef(PyWeakReference *self)
     * }
     */
    public static void _PyWeakref_ClearRef(MemorySegment self) {
        var mh$ = _PyWeakref_ClearRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyWeakref_ClearRef", self);
            }
            mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyStructSequence_UnnamedField$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyStructSequence_UnnamedField").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const char *const PyStructSequence_UnnamedField
     * }
     */
    public static AddressLayout PyStructSequence_UnnamedField$layout() {
        return PyStructSequence_UnnamedField$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const char *const PyStructSequence_UnnamedField
     * }
     */
    public static MemorySegment PyStructSequence_UnnamedField$segment() {
        return PyStructSequence_UnnamedField$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const char *const PyStructSequence_UnnamedField
     * }
     */
    public static MemorySegment PyStructSequence_UnnamedField() {
        return PyStructSequence_UnnamedField$constants.SEGMENT.get(PyStructSequence_UnnamedField$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const char *const PyStructSequence_UnnamedField
     * }
     */
    public static void PyStructSequence_UnnamedField(MemorySegment varValue) {
        PyStructSequence_UnnamedField$constants.SEGMENT.set(PyStructSequence_UnnamedField$constants.LAYOUT, 0L, varValue);
    }

    private static class PyStructSequence_InitType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyStructSequence_InitType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyStructSequence_InitType(PyTypeObject *type, PyStructSequence_Desc *desc)
     * }
     */
    public static FunctionDescriptor PyStructSequence_InitType$descriptor() {
        return PyStructSequence_InitType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyStructSequence_InitType(PyTypeObject *type, PyStructSequence_Desc *desc)
     * }
     */
    public static MethodHandle PyStructSequence_InitType$handle() {
        return PyStructSequence_InitType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyStructSequence_InitType(PyTypeObject *type, PyStructSequence_Desc *desc)
     * }
     */
    public static MemorySegment PyStructSequence_InitType$address() {
        return PyStructSequence_InitType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyStructSequence_InitType(PyTypeObject *type, PyStructSequence_Desc *desc)
     * }
     */
    public static void PyStructSequence_InitType(MemorySegment type, MemorySegment desc) {
        var mh$ = PyStructSequence_InitType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyStructSequence_InitType", type, desc);
            }
            mh$.invokeExact(type, desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyStructSequence_InitType2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyStructSequence_InitType2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyStructSequence_InitType2(PyTypeObject *type, PyStructSequence_Desc *desc)
     * }
     */
    public static FunctionDescriptor PyStructSequence_InitType2$descriptor() {
        return PyStructSequence_InitType2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyStructSequence_InitType2(PyTypeObject *type, PyStructSequence_Desc *desc)
     * }
     */
    public static MethodHandle PyStructSequence_InitType2$handle() {
        return PyStructSequence_InitType2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyStructSequence_InitType2(PyTypeObject *type, PyStructSequence_Desc *desc)
     * }
     */
    public static MemorySegment PyStructSequence_InitType2$address() {
        return PyStructSequence_InitType2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyStructSequence_InitType2(PyTypeObject *type, PyStructSequence_Desc *desc)
     * }
     */
    public static int PyStructSequence_InitType2(MemorySegment type, MemorySegment desc) {
        var mh$ = PyStructSequence_InitType2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyStructSequence_InitType2", type, desc);
            }
            return (int)mh$.invokeExact(type, desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyStructSequence_NewType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyStructSequence_NewType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyTypeObject *PyStructSequence_NewType(PyStructSequence_Desc *desc)
     * }
     */
    public static FunctionDescriptor PyStructSequence_NewType$descriptor() {
        return PyStructSequence_NewType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyTypeObject *PyStructSequence_NewType(PyStructSequence_Desc *desc)
     * }
     */
    public static MethodHandle PyStructSequence_NewType$handle() {
        return PyStructSequence_NewType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyTypeObject *PyStructSequence_NewType(PyStructSequence_Desc *desc)
     * }
     */
    public static MemorySegment PyStructSequence_NewType$address() {
        return PyStructSequence_NewType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyTypeObject *PyStructSequence_NewType(PyStructSequence_Desc *desc)
     * }
     */
    public static MemorySegment PyStructSequence_NewType(MemorySegment desc) {
        var mh$ = PyStructSequence_NewType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyStructSequence_NewType", desc);
            }
            return (MemorySegment)mh$.invokeExact(desc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyStructSequence_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyStructSequence_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyStructSequence_New(PyTypeObject *type)
     * }
     */
    public static FunctionDescriptor PyStructSequence_New$descriptor() {
        return PyStructSequence_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyStructSequence_New(PyTypeObject *type)
     * }
     */
    public static MethodHandle PyStructSequence_New$handle() {
        return PyStructSequence_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyStructSequence_New(PyTypeObject *type)
     * }
     */
    public static MemorySegment PyStructSequence_New$address() {
        return PyStructSequence_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyStructSequence_New(PyTypeObject *type)
     * }
     */
    public static MemorySegment PyStructSequence_New(MemorySegment type) {
        var mh$ = PyStructSequence_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyStructSequence_New", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyStructSequence_SetItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyStructSequence_SetItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyStructSequence_SetItem(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static FunctionDescriptor PyStructSequence_SetItem$descriptor() {
        return PyStructSequence_SetItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyStructSequence_SetItem(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static MethodHandle PyStructSequence_SetItem$handle() {
        return PyStructSequence_SetItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyStructSequence_SetItem(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static MemorySegment PyStructSequence_SetItem$address() {
        return PyStructSequence_SetItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyStructSequence_SetItem(PyObject *, Py_ssize_t, PyObject *)
     * }
     */
    public static void PyStructSequence_SetItem(MemorySegment x0, long x1, MemorySegment x2) {
        var mh$ = PyStructSequence_SetItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyStructSequence_SetItem", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyStructSequence_GetItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyStructSequence_GetItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyStructSequence_GetItem(PyObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyStructSequence_GetItem$descriptor() {
        return PyStructSequence_GetItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyStructSequence_GetItem(PyObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyStructSequence_GetItem$handle() {
        return PyStructSequence_GetItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyStructSequence_GetItem(PyObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyStructSequence_GetItem$address() {
        return PyStructSequence_GetItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyStructSequence_GetItem(PyObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyStructSequence_GetItem(MemorySegment x0, long x1) {
        var mh$ = PyStructSequence_GetItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyStructSequence_GetItem", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyPickleBuffer_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyPickleBuffer_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyPickleBuffer_Type
     * }
     */
    public static GroupLayout PyPickleBuffer_Type$layout() {
        return PyPickleBuffer_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyPickleBuffer_Type
     * }
     */
    public static MemorySegment PyPickleBuffer_Type() {
        return PyPickleBuffer_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyPickleBuffer_Type
     * }
     */
    public static void PyPickleBuffer_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyPickleBuffer_Type$constants.SEGMENT, 0L, PyPickleBuffer_Type$constants.LAYOUT.byteSize());
    }

    private static class PyPickleBuffer_FromObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyPickleBuffer_FromObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyPickleBuffer_FromObject(PyObject *)
     * }
     */
    public static FunctionDescriptor PyPickleBuffer_FromObject$descriptor() {
        return PyPickleBuffer_FromObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyPickleBuffer_FromObject(PyObject *)
     * }
     */
    public static MethodHandle PyPickleBuffer_FromObject$handle() {
        return PyPickleBuffer_FromObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyPickleBuffer_FromObject(PyObject *)
     * }
     */
    public static MemorySegment PyPickleBuffer_FromObject$address() {
        return PyPickleBuffer_FromObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyPickleBuffer_FromObject(PyObject *)
     * }
     */
    public static MemorySegment PyPickleBuffer_FromObject(MemorySegment x0) {
        var mh$ = PyPickleBuffer_FromObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyPickleBuffer_FromObject", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyPickleBuffer_GetBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyPickleBuffer_GetBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const Py_buffer *PyPickleBuffer_GetBuffer(PyObject *)
     * }
     */
    public static FunctionDescriptor PyPickleBuffer_GetBuffer$descriptor() {
        return PyPickleBuffer_GetBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const Py_buffer *PyPickleBuffer_GetBuffer(PyObject *)
     * }
     */
    public static MethodHandle PyPickleBuffer_GetBuffer$handle() {
        return PyPickleBuffer_GetBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const Py_buffer *PyPickleBuffer_GetBuffer(PyObject *)
     * }
     */
    public static MemorySegment PyPickleBuffer_GetBuffer$address() {
        return PyPickleBuffer_GetBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const Py_buffer *PyPickleBuffer_GetBuffer(PyObject *)
     * }
     */
    public static MemorySegment PyPickleBuffer_GetBuffer(MemorySegment x0) {
        var mh$ = PyPickleBuffer_GetBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyPickleBuffer_GetBuffer", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyPickleBuffer_Release {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyPickleBuffer_Release");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyPickleBuffer_Release(PyObject *)
     * }
     */
    public static FunctionDescriptor PyPickleBuffer_Release$descriptor() {
        return PyPickleBuffer_Release.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyPickleBuffer_Release(PyObject *)
     * }
     */
    public static MethodHandle PyPickleBuffer_Release$handle() {
        return PyPickleBuffer_Release.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyPickleBuffer_Release(PyObject *)
     * }
     */
    public static MemorySegment PyPickleBuffer_Release$address() {
        return PyPickleBuffer_Release.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyPickleBuffer_Release(PyObject *)
     * }
     */
    public static int PyPickleBuffer_Release(MemorySegment x0) {
        var mh$ = PyPickleBuffer_Release.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyPickleBuffer_Release", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int64_t _PyTime_t
     * }
     */
    public static final OfLong _PyTime_t = Python_h.C_LONG_LONG;
    private static final int _PyTime_ROUND_FLOOR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._PyTime_ROUND_FLOOR = 0
     * }
     */
    public static int _PyTime_ROUND_FLOOR() {
        return _PyTime_ROUND_FLOOR;
    }
    private static final int _PyTime_ROUND_CEILING = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._PyTime_ROUND_CEILING = 1
     * }
     */
    public static int _PyTime_ROUND_CEILING() {
        return _PyTime_ROUND_CEILING;
    }
    private static final int _PyTime_ROUND_HALF_EVEN = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._PyTime_ROUND_HALF_EVEN = 2
     * }
     */
    public static int _PyTime_ROUND_HALF_EVEN() {
        return _PyTime_ROUND_HALF_EVEN;
    }
    private static final int _PyTime_ROUND_UP = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._PyTime_ROUND_UP = 3
     * }
     */
    public static int _PyTime_ROUND_UP() {
        return _PyTime_ROUND_UP;
    }
    private static final int _PyTime_ROUND_TIMEOUT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._PyTime_ROUND_TIMEOUT = 3
     * }
     */
    public static int _PyTime_ROUND_TIMEOUT() {
        return _PyTime_ROUND_TIMEOUT;
    }

    private static class _PyLong_FromTime_t {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyLong_FromTime_t");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyLong_FromTime_t(time_t sec)
     * }
     */
    public static FunctionDescriptor _PyLong_FromTime_t$descriptor() {
        return _PyLong_FromTime_t.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyLong_FromTime_t(time_t sec)
     * }
     */
    public static MethodHandle _PyLong_FromTime_t$handle() {
        return _PyLong_FromTime_t.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyLong_FromTime_t(time_t sec)
     * }
     */
    public static MemorySegment _PyLong_FromTime_t$address() {
        return _PyLong_FromTime_t.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyLong_FromTime_t(time_t sec)
     * }
     */
    public static MemorySegment _PyLong_FromTime_t(long sec) {
        var mh$ = _PyLong_FromTime_t.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyLong_FromTime_t", sec);
            }
            return (MemorySegment)mh$.invokeExact(sec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyLong_AsTime_t {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyLong_AsTime_t");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * time_t _PyLong_AsTime_t(PyObject *obj)
     * }
     */
    public static FunctionDescriptor _PyLong_AsTime_t$descriptor() {
        return _PyLong_AsTime_t.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * time_t _PyLong_AsTime_t(PyObject *obj)
     * }
     */
    public static MethodHandle _PyLong_AsTime_t$handle() {
        return _PyLong_AsTime_t.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * time_t _PyLong_AsTime_t(PyObject *obj)
     * }
     */
    public static MemorySegment _PyLong_AsTime_t$address() {
        return _PyLong_AsTime_t.ADDR;
    }

    /**
     * {@snippet lang=c :
     * time_t _PyLong_AsTime_t(PyObject *obj)
     * }
     */
    public static long _PyLong_AsTime_t(MemorySegment obj) {
        var mh$ = _PyLong_AsTime_t.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyLong_AsTime_t", obj);
            }
            return (long)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTime_ObjectToTime_t {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTime_ObjectToTime_t");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyTime_ObjectToTime_t(PyObject *obj, time_t *sec, _PyTime_round_t)
     * }
     */
    public static FunctionDescriptor _PyTime_ObjectToTime_t$descriptor() {
        return _PyTime_ObjectToTime_t.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyTime_ObjectToTime_t(PyObject *obj, time_t *sec, _PyTime_round_t)
     * }
     */
    public static MethodHandle _PyTime_ObjectToTime_t$handle() {
        return _PyTime_ObjectToTime_t.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyTime_ObjectToTime_t(PyObject *obj, time_t *sec, _PyTime_round_t)
     * }
     */
    public static MemorySegment _PyTime_ObjectToTime_t$address() {
        return _PyTime_ObjectToTime_t.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyTime_ObjectToTime_t(PyObject *obj, time_t *sec, _PyTime_round_t)
     * }
     */
    public static int _PyTime_ObjectToTime_t(MemorySegment obj, MemorySegment sec, int x2) {
        var mh$ = _PyTime_ObjectToTime_t.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTime_ObjectToTime_t", obj, sec, x2);
            }
            return (int)mh$.invokeExact(obj, sec, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTime_ObjectToTimeval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTime_ObjectToTimeval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyTime_ObjectToTimeval(PyObject *obj, time_t *sec, long *usec, _PyTime_round_t)
     * }
     */
    public static FunctionDescriptor _PyTime_ObjectToTimeval$descriptor() {
        return _PyTime_ObjectToTimeval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyTime_ObjectToTimeval(PyObject *obj, time_t *sec, long *usec, _PyTime_round_t)
     * }
     */
    public static MethodHandle _PyTime_ObjectToTimeval$handle() {
        return _PyTime_ObjectToTimeval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyTime_ObjectToTimeval(PyObject *obj, time_t *sec, long *usec, _PyTime_round_t)
     * }
     */
    public static MemorySegment _PyTime_ObjectToTimeval$address() {
        return _PyTime_ObjectToTimeval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyTime_ObjectToTimeval(PyObject *obj, time_t *sec, long *usec, _PyTime_round_t)
     * }
     */
    public static int _PyTime_ObjectToTimeval(MemorySegment obj, MemorySegment sec, MemorySegment usec, int x3) {
        var mh$ = _PyTime_ObjectToTimeval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTime_ObjectToTimeval", obj, sec, usec, x3);
            }
            return (int)mh$.invokeExact(obj, sec, usec, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTime_ObjectToTimespec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTime_ObjectToTimespec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyTime_ObjectToTimespec(PyObject *obj, time_t *sec, long *nsec, _PyTime_round_t)
     * }
     */
    public static FunctionDescriptor _PyTime_ObjectToTimespec$descriptor() {
        return _PyTime_ObjectToTimespec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyTime_ObjectToTimespec(PyObject *obj, time_t *sec, long *nsec, _PyTime_round_t)
     * }
     */
    public static MethodHandle _PyTime_ObjectToTimespec$handle() {
        return _PyTime_ObjectToTimespec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyTime_ObjectToTimespec(PyObject *obj, time_t *sec, long *nsec, _PyTime_round_t)
     * }
     */
    public static MemorySegment _PyTime_ObjectToTimespec$address() {
        return _PyTime_ObjectToTimespec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyTime_ObjectToTimespec(PyObject *obj, time_t *sec, long *nsec, _PyTime_round_t)
     * }
     */
    public static int _PyTime_ObjectToTimespec(MemorySegment obj, MemorySegment sec, MemorySegment nsec, int x3) {
        var mh$ = _PyTime_ObjectToTimespec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTime_ObjectToTimespec", obj, sec, nsec, x3);
            }
            return (int)mh$.invokeExact(obj, sec, nsec, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTime_FromSeconds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTime_FromSeconds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _PyTime_t _PyTime_FromSeconds(int seconds)
     * }
     */
    public static FunctionDescriptor _PyTime_FromSeconds$descriptor() {
        return _PyTime_FromSeconds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _PyTime_t _PyTime_FromSeconds(int seconds)
     * }
     */
    public static MethodHandle _PyTime_FromSeconds$handle() {
        return _PyTime_FromSeconds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _PyTime_t _PyTime_FromSeconds(int seconds)
     * }
     */
    public static MemorySegment _PyTime_FromSeconds$address() {
        return _PyTime_FromSeconds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _PyTime_t _PyTime_FromSeconds(int seconds)
     * }
     */
    public static long _PyTime_FromSeconds(int seconds) {
        var mh$ = _PyTime_FromSeconds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTime_FromSeconds", seconds);
            }
            return (long)mh$.invokeExact(seconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTime_FromNanoseconds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTime_FromNanoseconds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _PyTime_t _PyTime_FromNanoseconds(_PyTime_t ns)
     * }
     */
    public static FunctionDescriptor _PyTime_FromNanoseconds$descriptor() {
        return _PyTime_FromNanoseconds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _PyTime_t _PyTime_FromNanoseconds(_PyTime_t ns)
     * }
     */
    public static MethodHandle _PyTime_FromNanoseconds$handle() {
        return _PyTime_FromNanoseconds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _PyTime_t _PyTime_FromNanoseconds(_PyTime_t ns)
     * }
     */
    public static MemorySegment _PyTime_FromNanoseconds$address() {
        return _PyTime_FromNanoseconds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _PyTime_t _PyTime_FromNanoseconds(_PyTime_t ns)
     * }
     */
    public static long _PyTime_FromNanoseconds(long ns) {
        var mh$ = _PyTime_FromNanoseconds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTime_FromNanoseconds", ns);
            }
            return (long)mh$.invokeExact(ns);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTime_FromNanosecondsObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTime_FromNanosecondsObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyTime_FromNanosecondsObject(_PyTime_t *t, PyObject *obj)
     * }
     */
    public static FunctionDescriptor _PyTime_FromNanosecondsObject$descriptor() {
        return _PyTime_FromNanosecondsObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyTime_FromNanosecondsObject(_PyTime_t *t, PyObject *obj)
     * }
     */
    public static MethodHandle _PyTime_FromNanosecondsObject$handle() {
        return _PyTime_FromNanosecondsObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyTime_FromNanosecondsObject(_PyTime_t *t, PyObject *obj)
     * }
     */
    public static MemorySegment _PyTime_FromNanosecondsObject$address() {
        return _PyTime_FromNanosecondsObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyTime_FromNanosecondsObject(_PyTime_t *t, PyObject *obj)
     * }
     */
    public static int _PyTime_FromNanosecondsObject(MemorySegment t, MemorySegment obj) {
        var mh$ = _PyTime_FromNanosecondsObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTime_FromNanosecondsObject", t, obj);
            }
            return (int)mh$.invokeExact(t, obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTime_FromSecondsObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTime_FromSecondsObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyTime_FromSecondsObject(_PyTime_t *t, PyObject *obj, _PyTime_round_t round)
     * }
     */
    public static FunctionDescriptor _PyTime_FromSecondsObject$descriptor() {
        return _PyTime_FromSecondsObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyTime_FromSecondsObject(_PyTime_t *t, PyObject *obj, _PyTime_round_t round)
     * }
     */
    public static MethodHandle _PyTime_FromSecondsObject$handle() {
        return _PyTime_FromSecondsObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyTime_FromSecondsObject(_PyTime_t *t, PyObject *obj, _PyTime_round_t round)
     * }
     */
    public static MemorySegment _PyTime_FromSecondsObject$address() {
        return _PyTime_FromSecondsObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyTime_FromSecondsObject(_PyTime_t *t, PyObject *obj, _PyTime_round_t round)
     * }
     */
    public static int _PyTime_FromSecondsObject(MemorySegment t, MemorySegment obj, int round) {
        var mh$ = _PyTime_FromSecondsObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTime_FromSecondsObject", t, obj, round);
            }
            return (int)mh$.invokeExact(t, obj, round);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTime_FromMillisecondsObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTime_FromMillisecondsObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyTime_FromMillisecondsObject(_PyTime_t *t, PyObject *obj, _PyTime_round_t round)
     * }
     */
    public static FunctionDescriptor _PyTime_FromMillisecondsObject$descriptor() {
        return _PyTime_FromMillisecondsObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyTime_FromMillisecondsObject(_PyTime_t *t, PyObject *obj, _PyTime_round_t round)
     * }
     */
    public static MethodHandle _PyTime_FromMillisecondsObject$handle() {
        return _PyTime_FromMillisecondsObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyTime_FromMillisecondsObject(_PyTime_t *t, PyObject *obj, _PyTime_round_t round)
     * }
     */
    public static MemorySegment _PyTime_FromMillisecondsObject$address() {
        return _PyTime_FromMillisecondsObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyTime_FromMillisecondsObject(_PyTime_t *t, PyObject *obj, _PyTime_round_t round)
     * }
     */
    public static int _PyTime_FromMillisecondsObject(MemorySegment t, MemorySegment obj, int round) {
        var mh$ = _PyTime_FromMillisecondsObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTime_FromMillisecondsObject", t, obj, round);
            }
            return (int)mh$.invokeExact(t, obj, round);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTime_AsSecondsDouble {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTime_AsSecondsDouble");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _PyTime_AsSecondsDouble(_PyTime_t t)
     * }
     */
    public static FunctionDescriptor _PyTime_AsSecondsDouble$descriptor() {
        return _PyTime_AsSecondsDouble.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _PyTime_AsSecondsDouble(_PyTime_t t)
     * }
     */
    public static MethodHandle _PyTime_AsSecondsDouble$handle() {
        return _PyTime_AsSecondsDouble.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _PyTime_AsSecondsDouble(_PyTime_t t)
     * }
     */
    public static MemorySegment _PyTime_AsSecondsDouble$address() {
        return _PyTime_AsSecondsDouble.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _PyTime_AsSecondsDouble(_PyTime_t t)
     * }
     */
    public static double _PyTime_AsSecondsDouble(long t) {
        var mh$ = _PyTime_AsSecondsDouble.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTime_AsSecondsDouble", t);
            }
            return (double)mh$.invokeExact(t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTime_AsMilliseconds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTime_AsMilliseconds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _PyTime_t _PyTime_AsMilliseconds(_PyTime_t t, _PyTime_round_t round)
     * }
     */
    public static FunctionDescriptor _PyTime_AsMilliseconds$descriptor() {
        return _PyTime_AsMilliseconds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _PyTime_t _PyTime_AsMilliseconds(_PyTime_t t, _PyTime_round_t round)
     * }
     */
    public static MethodHandle _PyTime_AsMilliseconds$handle() {
        return _PyTime_AsMilliseconds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _PyTime_t _PyTime_AsMilliseconds(_PyTime_t t, _PyTime_round_t round)
     * }
     */
    public static MemorySegment _PyTime_AsMilliseconds$address() {
        return _PyTime_AsMilliseconds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _PyTime_t _PyTime_AsMilliseconds(_PyTime_t t, _PyTime_round_t round)
     * }
     */
    public static long _PyTime_AsMilliseconds(long t, int round) {
        var mh$ = _PyTime_AsMilliseconds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTime_AsMilliseconds", t, round);
            }
            return (long)mh$.invokeExact(t, round);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTime_AsMicroseconds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTime_AsMicroseconds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _PyTime_t _PyTime_AsMicroseconds(_PyTime_t t, _PyTime_round_t round)
     * }
     */
    public static FunctionDescriptor _PyTime_AsMicroseconds$descriptor() {
        return _PyTime_AsMicroseconds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _PyTime_t _PyTime_AsMicroseconds(_PyTime_t t, _PyTime_round_t round)
     * }
     */
    public static MethodHandle _PyTime_AsMicroseconds$handle() {
        return _PyTime_AsMicroseconds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _PyTime_t _PyTime_AsMicroseconds(_PyTime_t t, _PyTime_round_t round)
     * }
     */
    public static MemorySegment _PyTime_AsMicroseconds$address() {
        return _PyTime_AsMicroseconds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _PyTime_t _PyTime_AsMicroseconds(_PyTime_t t, _PyTime_round_t round)
     * }
     */
    public static long _PyTime_AsMicroseconds(long t, int round) {
        var mh$ = _PyTime_AsMicroseconds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTime_AsMicroseconds", t, round);
            }
            return (long)mh$.invokeExact(t, round);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTime_AsNanoseconds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTime_AsNanoseconds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _PyTime_t _PyTime_AsNanoseconds(_PyTime_t t)
     * }
     */
    public static FunctionDescriptor _PyTime_AsNanoseconds$descriptor() {
        return _PyTime_AsNanoseconds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _PyTime_t _PyTime_AsNanoseconds(_PyTime_t t)
     * }
     */
    public static MethodHandle _PyTime_AsNanoseconds$handle() {
        return _PyTime_AsNanoseconds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _PyTime_t _PyTime_AsNanoseconds(_PyTime_t t)
     * }
     */
    public static MemorySegment _PyTime_AsNanoseconds$address() {
        return _PyTime_AsNanoseconds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _PyTime_t _PyTime_AsNanoseconds(_PyTime_t t)
     * }
     */
    public static long _PyTime_AsNanoseconds(long t) {
        var mh$ = _PyTime_AsNanoseconds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTime_AsNanoseconds", t);
            }
            return (long)mh$.invokeExact(t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTime_AsNanosecondsObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTime_AsNanosecondsObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyTime_AsNanosecondsObject(_PyTime_t t)
     * }
     */
    public static FunctionDescriptor _PyTime_AsNanosecondsObject$descriptor() {
        return _PyTime_AsNanosecondsObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyTime_AsNanosecondsObject(_PyTime_t t)
     * }
     */
    public static MethodHandle _PyTime_AsNanosecondsObject$handle() {
        return _PyTime_AsNanosecondsObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyTime_AsNanosecondsObject(_PyTime_t t)
     * }
     */
    public static MemorySegment _PyTime_AsNanosecondsObject$address() {
        return _PyTime_AsNanosecondsObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyTime_AsNanosecondsObject(_PyTime_t t)
     * }
     */
    public static MemorySegment _PyTime_AsNanosecondsObject(long t) {
        var mh$ = _PyTime_AsNanosecondsObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTime_AsNanosecondsObject", t);
            }
            return (MemorySegment)mh$.invokeExact(t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTime_FromTimeval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTime_FromTimeval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyTime_FromTimeval(_PyTime_t *tp, struct timeval *tv)
     * }
     */
    public static FunctionDescriptor _PyTime_FromTimeval$descriptor() {
        return _PyTime_FromTimeval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyTime_FromTimeval(_PyTime_t *tp, struct timeval *tv)
     * }
     */
    public static MethodHandle _PyTime_FromTimeval$handle() {
        return _PyTime_FromTimeval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyTime_FromTimeval(_PyTime_t *tp, struct timeval *tv)
     * }
     */
    public static MemorySegment _PyTime_FromTimeval$address() {
        return _PyTime_FromTimeval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyTime_FromTimeval(_PyTime_t *tp, struct timeval *tv)
     * }
     */
    public static int _PyTime_FromTimeval(MemorySegment tp, MemorySegment tv) {
        var mh$ = _PyTime_FromTimeval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTime_FromTimeval", tp, tv);
            }
            return (int)mh$.invokeExact(tp, tv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTime_AsTimeval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTime_AsTimeval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyTime_AsTimeval(_PyTime_t t, struct timeval *tv, _PyTime_round_t round)
     * }
     */
    public static FunctionDescriptor _PyTime_AsTimeval$descriptor() {
        return _PyTime_AsTimeval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyTime_AsTimeval(_PyTime_t t, struct timeval *tv, _PyTime_round_t round)
     * }
     */
    public static MethodHandle _PyTime_AsTimeval$handle() {
        return _PyTime_AsTimeval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyTime_AsTimeval(_PyTime_t t, struct timeval *tv, _PyTime_round_t round)
     * }
     */
    public static MemorySegment _PyTime_AsTimeval$address() {
        return _PyTime_AsTimeval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyTime_AsTimeval(_PyTime_t t, struct timeval *tv, _PyTime_round_t round)
     * }
     */
    public static int _PyTime_AsTimeval(long t, MemorySegment tv, int round) {
        var mh$ = _PyTime_AsTimeval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTime_AsTimeval", t, tv, round);
            }
            return (int)mh$.invokeExact(t, tv, round);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTime_AsTimeval_clamp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTime_AsTimeval_clamp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyTime_AsTimeval_clamp(_PyTime_t t, struct timeval *tv, _PyTime_round_t round)
     * }
     */
    public static FunctionDescriptor _PyTime_AsTimeval_clamp$descriptor() {
        return _PyTime_AsTimeval_clamp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyTime_AsTimeval_clamp(_PyTime_t t, struct timeval *tv, _PyTime_round_t round)
     * }
     */
    public static MethodHandle _PyTime_AsTimeval_clamp$handle() {
        return _PyTime_AsTimeval_clamp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyTime_AsTimeval_clamp(_PyTime_t t, struct timeval *tv, _PyTime_round_t round)
     * }
     */
    public static MemorySegment _PyTime_AsTimeval_clamp$address() {
        return _PyTime_AsTimeval_clamp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyTime_AsTimeval_clamp(_PyTime_t t, struct timeval *tv, _PyTime_round_t round)
     * }
     */
    public static void _PyTime_AsTimeval_clamp(long t, MemorySegment tv, int round) {
        var mh$ = _PyTime_AsTimeval_clamp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTime_AsTimeval_clamp", t, tv, round);
            }
            mh$.invokeExact(t, tv, round);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTime_AsTimevalTime_t {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTime_AsTimevalTime_t");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyTime_AsTimevalTime_t(_PyTime_t t, time_t *secs, int *us, _PyTime_round_t round)
     * }
     */
    public static FunctionDescriptor _PyTime_AsTimevalTime_t$descriptor() {
        return _PyTime_AsTimevalTime_t.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyTime_AsTimevalTime_t(_PyTime_t t, time_t *secs, int *us, _PyTime_round_t round)
     * }
     */
    public static MethodHandle _PyTime_AsTimevalTime_t$handle() {
        return _PyTime_AsTimevalTime_t.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyTime_AsTimevalTime_t(_PyTime_t t, time_t *secs, int *us, _PyTime_round_t round)
     * }
     */
    public static MemorySegment _PyTime_AsTimevalTime_t$address() {
        return _PyTime_AsTimevalTime_t.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyTime_AsTimevalTime_t(_PyTime_t t, time_t *secs, int *us, _PyTime_round_t round)
     * }
     */
    public static int _PyTime_AsTimevalTime_t(long t, MemorySegment secs, MemorySegment us, int round) {
        var mh$ = _PyTime_AsTimevalTime_t.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTime_AsTimevalTime_t", t, secs, us, round);
            }
            return (int)mh$.invokeExact(t, secs, us, round);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTime_FromTimespec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTime_FromTimespec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyTime_FromTimespec(_PyTime_t *tp, struct timespec *ts)
     * }
     */
    public static FunctionDescriptor _PyTime_FromTimespec$descriptor() {
        return _PyTime_FromTimespec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyTime_FromTimespec(_PyTime_t *tp, struct timespec *ts)
     * }
     */
    public static MethodHandle _PyTime_FromTimespec$handle() {
        return _PyTime_FromTimespec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyTime_FromTimespec(_PyTime_t *tp, struct timespec *ts)
     * }
     */
    public static MemorySegment _PyTime_FromTimespec$address() {
        return _PyTime_FromTimespec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyTime_FromTimespec(_PyTime_t *tp, struct timespec *ts)
     * }
     */
    public static int _PyTime_FromTimespec(MemorySegment tp, MemorySegment ts) {
        var mh$ = _PyTime_FromTimespec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTime_FromTimespec", tp, ts);
            }
            return (int)mh$.invokeExact(tp, ts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTime_AsTimespec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTime_AsTimespec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyTime_AsTimespec(_PyTime_t t, struct timespec *ts)
     * }
     */
    public static FunctionDescriptor _PyTime_AsTimespec$descriptor() {
        return _PyTime_AsTimespec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyTime_AsTimespec(_PyTime_t t, struct timespec *ts)
     * }
     */
    public static MethodHandle _PyTime_AsTimespec$handle() {
        return _PyTime_AsTimespec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyTime_AsTimespec(_PyTime_t t, struct timespec *ts)
     * }
     */
    public static MemorySegment _PyTime_AsTimespec$address() {
        return _PyTime_AsTimespec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyTime_AsTimespec(_PyTime_t t, struct timespec *ts)
     * }
     */
    public static int _PyTime_AsTimespec(long t, MemorySegment ts) {
        var mh$ = _PyTime_AsTimespec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTime_AsTimespec", t, ts);
            }
            return (int)mh$.invokeExact(t, ts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTime_AsTimespec_clamp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTime_AsTimespec_clamp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyTime_AsTimespec_clamp(_PyTime_t t, struct timespec *ts)
     * }
     */
    public static FunctionDescriptor _PyTime_AsTimespec_clamp$descriptor() {
        return _PyTime_AsTimespec_clamp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyTime_AsTimespec_clamp(_PyTime_t t, struct timespec *ts)
     * }
     */
    public static MethodHandle _PyTime_AsTimespec_clamp$handle() {
        return _PyTime_AsTimespec_clamp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyTime_AsTimespec_clamp(_PyTime_t t, struct timespec *ts)
     * }
     */
    public static MemorySegment _PyTime_AsTimespec_clamp$address() {
        return _PyTime_AsTimespec_clamp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyTime_AsTimespec_clamp(_PyTime_t t, struct timespec *ts)
     * }
     */
    public static void _PyTime_AsTimespec_clamp(long t, MemorySegment ts) {
        var mh$ = _PyTime_AsTimespec_clamp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTime_AsTimespec_clamp", t, ts);
            }
            mh$.invokeExact(t, ts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTime_Add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTime_Add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _PyTime_t _PyTime_Add(_PyTime_t t1, _PyTime_t t2)
     * }
     */
    public static FunctionDescriptor _PyTime_Add$descriptor() {
        return _PyTime_Add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _PyTime_t _PyTime_Add(_PyTime_t t1, _PyTime_t t2)
     * }
     */
    public static MethodHandle _PyTime_Add$handle() {
        return _PyTime_Add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _PyTime_t _PyTime_Add(_PyTime_t t1, _PyTime_t t2)
     * }
     */
    public static MemorySegment _PyTime_Add$address() {
        return _PyTime_Add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _PyTime_t _PyTime_Add(_PyTime_t t1, _PyTime_t t2)
     * }
     */
    public static long _PyTime_Add(long t1, long t2) {
        var mh$ = _PyTime_Add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTime_Add", t1, t2);
            }
            return (long)mh$.invokeExact(t1, t2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTime_MulDiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTime_MulDiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _PyTime_t _PyTime_MulDiv(_PyTime_t ticks, _PyTime_t mul, _PyTime_t div)
     * }
     */
    public static FunctionDescriptor _PyTime_MulDiv$descriptor() {
        return _PyTime_MulDiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _PyTime_t _PyTime_MulDiv(_PyTime_t ticks, _PyTime_t mul, _PyTime_t div)
     * }
     */
    public static MethodHandle _PyTime_MulDiv$handle() {
        return _PyTime_MulDiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _PyTime_t _PyTime_MulDiv(_PyTime_t ticks, _PyTime_t mul, _PyTime_t div)
     * }
     */
    public static MemorySegment _PyTime_MulDiv$address() {
        return _PyTime_MulDiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _PyTime_t _PyTime_MulDiv(_PyTime_t ticks, _PyTime_t mul, _PyTime_t div)
     * }
     */
    public static long _PyTime_MulDiv(long ticks, long mul, long div) {
        var mh$ = _PyTime_MulDiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTime_MulDiv", ticks, mul, div);
            }
            return (long)mh$.invokeExact(ticks, mul, div);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTime_GetSystemClock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTime_GetSystemClock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _PyTime_t _PyTime_GetSystemClock()
     * }
     */
    public static FunctionDescriptor _PyTime_GetSystemClock$descriptor() {
        return _PyTime_GetSystemClock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _PyTime_t _PyTime_GetSystemClock()
     * }
     */
    public static MethodHandle _PyTime_GetSystemClock$handle() {
        return _PyTime_GetSystemClock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _PyTime_t _PyTime_GetSystemClock()
     * }
     */
    public static MemorySegment _PyTime_GetSystemClock$address() {
        return _PyTime_GetSystemClock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _PyTime_t _PyTime_GetSystemClock()
     * }
     */
    public static long _PyTime_GetSystemClock() {
        var mh$ = _PyTime_GetSystemClock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTime_GetSystemClock");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTime_GetSystemClockWithInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTime_GetSystemClockWithInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyTime_GetSystemClockWithInfo(_PyTime_t *t, _Py_clock_info_t *info)
     * }
     */
    public static FunctionDescriptor _PyTime_GetSystemClockWithInfo$descriptor() {
        return _PyTime_GetSystemClockWithInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyTime_GetSystemClockWithInfo(_PyTime_t *t, _Py_clock_info_t *info)
     * }
     */
    public static MethodHandle _PyTime_GetSystemClockWithInfo$handle() {
        return _PyTime_GetSystemClockWithInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyTime_GetSystemClockWithInfo(_PyTime_t *t, _Py_clock_info_t *info)
     * }
     */
    public static MemorySegment _PyTime_GetSystemClockWithInfo$address() {
        return _PyTime_GetSystemClockWithInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyTime_GetSystemClockWithInfo(_PyTime_t *t, _Py_clock_info_t *info)
     * }
     */
    public static int _PyTime_GetSystemClockWithInfo(MemorySegment t, MemorySegment info) {
        var mh$ = _PyTime_GetSystemClockWithInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTime_GetSystemClockWithInfo", t, info);
            }
            return (int)mh$.invokeExact(t, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTime_GetMonotonicClock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTime_GetMonotonicClock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _PyTime_t _PyTime_GetMonotonicClock()
     * }
     */
    public static FunctionDescriptor _PyTime_GetMonotonicClock$descriptor() {
        return _PyTime_GetMonotonicClock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _PyTime_t _PyTime_GetMonotonicClock()
     * }
     */
    public static MethodHandle _PyTime_GetMonotonicClock$handle() {
        return _PyTime_GetMonotonicClock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _PyTime_t _PyTime_GetMonotonicClock()
     * }
     */
    public static MemorySegment _PyTime_GetMonotonicClock$address() {
        return _PyTime_GetMonotonicClock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _PyTime_t _PyTime_GetMonotonicClock()
     * }
     */
    public static long _PyTime_GetMonotonicClock() {
        var mh$ = _PyTime_GetMonotonicClock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTime_GetMonotonicClock");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTime_GetMonotonicClockWithInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTime_GetMonotonicClockWithInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyTime_GetMonotonicClockWithInfo(_PyTime_t *t, _Py_clock_info_t *info)
     * }
     */
    public static FunctionDescriptor _PyTime_GetMonotonicClockWithInfo$descriptor() {
        return _PyTime_GetMonotonicClockWithInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyTime_GetMonotonicClockWithInfo(_PyTime_t *t, _Py_clock_info_t *info)
     * }
     */
    public static MethodHandle _PyTime_GetMonotonicClockWithInfo$handle() {
        return _PyTime_GetMonotonicClockWithInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyTime_GetMonotonicClockWithInfo(_PyTime_t *t, _Py_clock_info_t *info)
     * }
     */
    public static MemorySegment _PyTime_GetMonotonicClockWithInfo$address() {
        return _PyTime_GetMonotonicClockWithInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyTime_GetMonotonicClockWithInfo(_PyTime_t *t, _Py_clock_info_t *info)
     * }
     */
    public static int _PyTime_GetMonotonicClockWithInfo(MemorySegment t, MemorySegment info) {
        var mh$ = _PyTime_GetMonotonicClockWithInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTime_GetMonotonicClockWithInfo", t, info);
            }
            return (int)mh$.invokeExact(t, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTime_localtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTime_localtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyTime_localtime(time_t t, struct tm *tm)
     * }
     */
    public static FunctionDescriptor _PyTime_localtime$descriptor() {
        return _PyTime_localtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyTime_localtime(time_t t, struct tm *tm)
     * }
     */
    public static MethodHandle _PyTime_localtime$handle() {
        return _PyTime_localtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyTime_localtime(time_t t, struct tm *tm)
     * }
     */
    public static MemorySegment _PyTime_localtime$address() {
        return _PyTime_localtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyTime_localtime(time_t t, struct tm *tm)
     * }
     */
    public static int _PyTime_localtime(long t, MemorySegment tm) {
        var mh$ = _PyTime_localtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTime_localtime", t, tm);
            }
            return (int)mh$.invokeExact(t, tm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTime_gmtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTime_gmtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyTime_gmtime(time_t t, struct tm *tm)
     * }
     */
    public static FunctionDescriptor _PyTime_gmtime$descriptor() {
        return _PyTime_gmtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyTime_gmtime(time_t t, struct tm *tm)
     * }
     */
    public static MethodHandle _PyTime_gmtime$handle() {
        return _PyTime_gmtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyTime_gmtime(time_t t, struct tm *tm)
     * }
     */
    public static MemorySegment _PyTime_gmtime$address() {
        return _PyTime_gmtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyTime_gmtime(time_t t, struct tm *tm)
     * }
     */
    public static int _PyTime_gmtime(long t, MemorySegment tm) {
        var mh$ = _PyTime_gmtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTime_gmtime", t, tm);
            }
            return (int)mh$.invokeExact(t, tm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTime_GetPerfCounter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTime_GetPerfCounter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _PyTime_t _PyTime_GetPerfCounter()
     * }
     */
    public static FunctionDescriptor _PyTime_GetPerfCounter$descriptor() {
        return _PyTime_GetPerfCounter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _PyTime_t _PyTime_GetPerfCounter()
     * }
     */
    public static MethodHandle _PyTime_GetPerfCounter$handle() {
        return _PyTime_GetPerfCounter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _PyTime_t _PyTime_GetPerfCounter()
     * }
     */
    public static MemorySegment _PyTime_GetPerfCounter$address() {
        return _PyTime_GetPerfCounter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _PyTime_t _PyTime_GetPerfCounter()
     * }
     */
    public static long _PyTime_GetPerfCounter() {
        var mh$ = _PyTime_GetPerfCounter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTime_GetPerfCounter");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTime_GetPerfCounterWithInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTime_GetPerfCounterWithInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyTime_GetPerfCounterWithInfo(_PyTime_t *t, _Py_clock_info_t *info)
     * }
     */
    public static FunctionDescriptor _PyTime_GetPerfCounterWithInfo$descriptor() {
        return _PyTime_GetPerfCounterWithInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyTime_GetPerfCounterWithInfo(_PyTime_t *t, _Py_clock_info_t *info)
     * }
     */
    public static MethodHandle _PyTime_GetPerfCounterWithInfo$handle() {
        return _PyTime_GetPerfCounterWithInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyTime_GetPerfCounterWithInfo(_PyTime_t *t, _Py_clock_info_t *info)
     * }
     */
    public static MemorySegment _PyTime_GetPerfCounterWithInfo$address() {
        return _PyTime_GetPerfCounterWithInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyTime_GetPerfCounterWithInfo(_PyTime_t *t, _Py_clock_info_t *info)
     * }
     */
    public static int _PyTime_GetPerfCounterWithInfo(MemorySegment t, MemorySegment info) {
        var mh$ = _PyTime_GetPerfCounterWithInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTime_GetPerfCounterWithInfo", t, info);
            }
            return (int)mh$.invokeExact(t, info);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyDeadline_Init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyDeadline_Init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _PyTime_t _PyDeadline_Init(_PyTime_t timeout)
     * }
     */
    public static FunctionDescriptor _PyDeadline_Init$descriptor() {
        return _PyDeadline_Init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _PyTime_t _PyDeadline_Init(_PyTime_t timeout)
     * }
     */
    public static MethodHandle _PyDeadline_Init$handle() {
        return _PyDeadline_Init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _PyTime_t _PyDeadline_Init(_PyTime_t timeout)
     * }
     */
    public static MemorySegment _PyDeadline_Init$address() {
        return _PyDeadline_Init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _PyTime_t _PyDeadline_Init(_PyTime_t timeout)
     * }
     */
    public static long _PyDeadline_Init(long timeout) {
        var mh$ = _PyDeadline_Init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyDeadline_Init", timeout);
            }
            return (long)mh$.invokeExact(timeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyDeadline_Get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyDeadline_Get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _PyTime_t _PyDeadline_Get(_PyTime_t deadline)
     * }
     */
    public static FunctionDescriptor _PyDeadline_Get$descriptor() {
        return _PyDeadline_Get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _PyTime_t _PyDeadline_Get(_PyTime_t deadline)
     * }
     */
    public static MethodHandle _PyDeadline_Get$handle() {
        return _PyDeadline_Get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _PyTime_t _PyDeadline_Get(_PyTime_t deadline)
     * }
     */
    public static MemorySegment _PyDeadline_Get$address() {
        return _PyDeadline_Get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _PyTime_t _PyDeadline_Get(_PyTime_t deadline)
     * }
     */
    public static long _PyDeadline_Get(long deadline) {
        var mh$ = _PyDeadline_Get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyDeadline_Get", deadline);
            }
            return (long)mh$.invokeExact(deadline);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_Register {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_Register");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyCodec_Register(PyObject *search_function)
     * }
     */
    public static FunctionDescriptor PyCodec_Register$descriptor() {
        return PyCodec_Register.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyCodec_Register(PyObject *search_function)
     * }
     */
    public static MethodHandle PyCodec_Register$handle() {
        return PyCodec_Register.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyCodec_Register(PyObject *search_function)
     * }
     */
    public static MemorySegment PyCodec_Register$address() {
        return PyCodec_Register.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyCodec_Register(PyObject *search_function)
     * }
     */
    public static int PyCodec_Register(MemorySegment search_function) {
        var mh$ = PyCodec_Register.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_Register", search_function);
            }
            return (int)mh$.invokeExact(search_function);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_Unregister {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_Unregister");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyCodec_Unregister(PyObject *search_function)
     * }
     */
    public static FunctionDescriptor PyCodec_Unregister$descriptor() {
        return PyCodec_Unregister.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyCodec_Unregister(PyObject *search_function)
     * }
     */
    public static MethodHandle PyCodec_Unregister$handle() {
        return PyCodec_Unregister.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyCodec_Unregister(PyObject *search_function)
     * }
     */
    public static MemorySegment PyCodec_Unregister$address() {
        return PyCodec_Unregister.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyCodec_Unregister(PyObject *search_function)
     * }
     */
    public static int PyCodec_Unregister(MemorySegment search_function) {
        var mh$ = PyCodec_Unregister.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_Unregister", search_function);
            }
            return (int)mh$.invokeExact(search_function);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyCodec_Lookup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyCodec_Lookup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyCodec_Lookup(const char *encoding)
     * }
     */
    public static FunctionDescriptor _PyCodec_Lookup$descriptor() {
        return _PyCodec_Lookup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyCodec_Lookup(const char *encoding)
     * }
     */
    public static MethodHandle _PyCodec_Lookup$handle() {
        return _PyCodec_Lookup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyCodec_Lookup(const char *encoding)
     * }
     */
    public static MemorySegment _PyCodec_Lookup$address() {
        return _PyCodec_Lookup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyCodec_Lookup(const char *encoding)
     * }
     */
    public static MemorySegment _PyCodec_Lookup(MemorySegment encoding) {
        var mh$ = _PyCodec_Lookup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyCodec_Lookup", encoding);
            }
            return (MemorySegment)mh$.invokeExact(encoding);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyCodec_Forget {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyCodec_Forget");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyCodec_Forget(const char *encoding)
     * }
     */
    public static FunctionDescriptor _PyCodec_Forget$descriptor() {
        return _PyCodec_Forget.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyCodec_Forget(const char *encoding)
     * }
     */
    public static MethodHandle _PyCodec_Forget$handle() {
        return _PyCodec_Forget.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyCodec_Forget(const char *encoding)
     * }
     */
    public static MemorySegment _PyCodec_Forget$address() {
        return _PyCodec_Forget.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyCodec_Forget(const char *encoding)
     * }
     */
    public static int _PyCodec_Forget(MemorySegment encoding) {
        var mh$ = _PyCodec_Forget.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyCodec_Forget", encoding);
            }
            return (int)mh$.invokeExact(encoding);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_KnownEncoding {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_KnownEncoding");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyCodec_KnownEncoding(const char *encoding)
     * }
     */
    public static FunctionDescriptor PyCodec_KnownEncoding$descriptor() {
        return PyCodec_KnownEncoding.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyCodec_KnownEncoding(const char *encoding)
     * }
     */
    public static MethodHandle PyCodec_KnownEncoding$handle() {
        return PyCodec_KnownEncoding.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyCodec_KnownEncoding(const char *encoding)
     * }
     */
    public static MemorySegment PyCodec_KnownEncoding$address() {
        return PyCodec_KnownEncoding.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyCodec_KnownEncoding(const char *encoding)
     * }
     */
    public static int PyCodec_KnownEncoding(MemorySegment encoding) {
        var mh$ = PyCodec_KnownEncoding.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_KnownEncoding", encoding);
            }
            return (int)mh$.invokeExact(encoding);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_Encode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_Encode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCodec_Encode(PyObject *object, const char *encoding, const char *errors)
     * }
     */
    public static FunctionDescriptor PyCodec_Encode$descriptor() {
        return PyCodec_Encode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCodec_Encode(PyObject *object, const char *encoding, const char *errors)
     * }
     */
    public static MethodHandle PyCodec_Encode$handle() {
        return PyCodec_Encode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCodec_Encode(PyObject *object, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyCodec_Encode$address() {
        return PyCodec_Encode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCodec_Encode(PyObject *object, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyCodec_Encode(MemorySegment object, MemorySegment encoding, MemorySegment errors) {
        var mh$ = PyCodec_Encode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_Encode", object, encoding, errors);
            }
            return (MemorySegment)mh$.invokeExact(object, encoding, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_Decode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_Decode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCodec_Decode(PyObject *object, const char *encoding, const char *errors)
     * }
     */
    public static FunctionDescriptor PyCodec_Decode$descriptor() {
        return PyCodec_Decode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCodec_Decode(PyObject *object, const char *encoding, const char *errors)
     * }
     */
    public static MethodHandle PyCodec_Decode$handle() {
        return PyCodec_Decode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCodec_Decode(PyObject *object, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyCodec_Decode$address() {
        return PyCodec_Decode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCodec_Decode(PyObject *object, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyCodec_Decode(MemorySegment object, MemorySegment encoding, MemorySegment errors) {
        var mh$ = PyCodec_Decode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_Decode", object, encoding, errors);
            }
            return (MemorySegment)mh$.invokeExact(object, encoding, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyCodec_LookupTextEncoding {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyCodec_LookupTextEncoding");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyCodec_LookupTextEncoding(const char *encoding, const char *alternate_command)
     * }
     */
    public static FunctionDescriptor _PyCodec_LookupTextEncoding$descriptor() {
        return _PyCodec_LookupTextEncoding.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyCodec_LookupTextEncoding(const char *encoding, const char *alternate_command)
     * }
     */
    public static MethodHandle _PyCodec_LookupTextEncoding$handle() {
        return _PyCodec_LookupTextEncoding.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyCodec_LookupTextEncoding(const char *encoding, const char *alternate_command)
     * }
     */
    public static MemorySegment _PyCodec_LookupTextEncoding$address() {
        return _PyCodec_LookupTextEncoding.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyCodec_LookupTextEncoding(const char *encoding, const char *alternate_command)
     * }
     */
    public static MemorySegment _PyCodec_LookupTextEncoding(MemorySegment encoding, MemorySegment alternate_command) {
        var mh$ = _PyCodec_LookupTextEncoding.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyCodec_LookupTextEncoding", encoding, alternate_command);
            }
            return (MemorySegment)mh$.invokeExact(encoding, alternate_command);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyCodec_EncodeText {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyCodec_EncodeText");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyCodec_EncodeText(PyObject *object, const char *encoding, const char *errors)
     * }
     */
    public static FunctionDescriptor _PyCodec_EncodeText$descriptor() {
        return _PyCodec_EncodeText.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyCodec_EncodeText(PyObject *object, const char *encoding, const char *errors)
     * }
     */
    public static MethodHandle _PyCodec_EncodeText$handle() {
        return _PyCodec_EncodeText.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyCodec_EncodeText(PyObject *object, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment _PyCodec_EncodeText$address() {
        return _PyCodec_EncodeText.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyCodec_EncodeText(PyObject *object, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment _PyCodec_EncodeText(MemorySegment object, MemorySegment encoding, MemorySegment errors) {
        var mh$ = _PyCodec_EncodeText.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyCodec_EncodeText", object, encoding, errors);
            }
            return (MemorySegment)mh$.invokeExact(object, encoding, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyCodec_DecodeText {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyCodec_DecodeText");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyCodec_DecodeText(PyObject *object, const char *encoding, const char *errors)
     * }
     */
    public static FunctionDescriptor _PyCodec_DecodeText$descriptor() {
        return _PyCodec_DecodeText.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyCodec_DecodeText(PyObject *object, const char *encoding, const char *errors)
     * }
     */
    public static MethodHandle _PyCodec_DecodeText$handle() {
        return _PyCodec_DecodeText.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyCodec_DecodeText(PyObject *object, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment _PyCodec_DecodeText$address() {
        return _PyCodec_DecodeText.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyCodec_DecodeText(PyObject *object, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment _PyCodec_DecodeText(MemorySegment object, MemorySegment encoding, MemorySegment errors) {
        var mh$ = _PyCodec_DecodeText.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyCodec_DecodeText", object, encoding, errors);
            }
            return (MemorySegment)mh$.invokeExact(object, encoding, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyCodecInfo_GetIncrementalDecoder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyCodecInfo_GetIncrementalDecoder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyCodecInfo_GetIncrementalDecoder(PyObject *codec_info, const char *errors)
     * }
     */
    public static FunctionDescriptor _PyCodecInfo_GetIncrementalDecoder$descriptor() {
        return _PyCodecInfo_GetIncrementalDecoder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyCodecInfo_GetIncrementalDecoder(PyObject *codec_info, const char *errors)
     * }
     */
    public static MethodHandle _PyCodecInfo_GetIncrementalDecoder$handle() {
        return _PyCodecInfo_GetIncrementalDecoder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyCodecInfo_GetIncrementalDecoder(PyObject *codec_info, const char *errors)
     * }
     */
    public static MemorySegment _PyCodecInfo_GetIncrementalDecoder$address() {
        return _PyCodecInfo_GetIncrementalDecoder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyCodecInfo_GetIncrementalDecoder(PyObject *codec_info, const char *errors)
     * }
     */
    public static MemorySegment _PyCodecInfo_GetIncrementalDecoder(MemorySegment codec_info, MemorySegment errors) {
        var mh$ = _PyCodecInfo_GetIncrementalDecoder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyCodecInfo_GetIncrementalDecoder", codec_info, errors);
            }
            return (MemorySegment)mh$.invokeExact(codec_info, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyCodecInfo_GetIncrementalEncoder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyCodecInfo_GetIncrementalEncoder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyCodecInfo_GetIncrementalEncoder(PyObject *codec_info, const char *errors)
     * }
     */
    public static FunctionDescriptor _PyCodecInfo_GetIncrementalEncoder$descriptor() {
        return _PyCodecInfo_GetIncrementalEncoder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyCodecInfo_GetIncrementalEncoder(PyObject *codec_info, const char *errors)
     * }
     */
    public static MethodHandle _PyCodecInfo_GetIncrementalEncoder$handle() {
        return _PyCodecInfo_GetIncrementalEncoder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyCodecInfo_GetIncrementalEncoder(PyObject *codec_info, const char *errors)
     * }
     */
    public static MemorySegment _PyCodecInfo_GetIncrementalEncoder$address() {
        return _PyCodecInfo_GetIncrementalEncoder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyCodecInfo_GetIncrementalEncoder(PyObject *codec_info, const char *errors)
     * }
     */
    public static MemorySegment _PyCodecInfo_GetIncrementalEncoder(MemorySegment codec_info, MemorySegment errors) {
        var mh$ = _PyCodecInfo_GetIncrementalEncoder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyCodecInfo_GetIncrementalEncoder", codec_info, errors);
            }
            return (MemorySegment)mh$.invokeExact(codec_info, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_Encoder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_Encoder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCodec_Encoder(const char *encoding)
     * }
     */
    public static FunctionDescriptor PyCodec_Encoder$descriptor() {
        return PyCodec_Encoder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCodec_Encoder(const char *encoding)
     * }
     */
    public static MethodHandle PyCodec_Encoder$handle() {
        return PyCodec_Encoder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCodec_Encoder(const char *encoding)
     * }
     */
    public static MemorySegment PyCodec_Encoder$address() {
        return PyCodec_Encoder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCodec_Encoder(const char *encoding)
     * }
     */
    public static MemorySegment PyCodec_Encoder(MemorySegment encoding) {
        var mh$ = PyCodec_Encoder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_Encoder", encoding);
            }
            return (MemorySegment)mh$.invokeExact(encoding);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_Decoder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_Decoder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCodec_Decoder(const char *encoding)
     * }
     */
    public static FunctionDescriptor PyCodec_Decoder$descriptor() {
        return PyCodec_Decoder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCodec_Decoder(const char *encoding)
     * }
     */
    public static MethodHandle PyCodec_Decoder$handle() {
        return PyCodec_Decoder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCodec_Decoder(const char *encoding)
     * }
     */
    public static MemorySegment PyCodec_Decoder$address() {
        return PyCodec_Decoder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCodec_Decoder(const char *encoding)
     * }
     */
    public static MemorySegment PyCodec_Decoder(MemorySegment encoding) {
        var mh$ = PyCodec_Decoder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_Decoder", encoding);
            }
            return (MemorySegment)mh$.invokeExact(encoding);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_IncrementalEncoder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_IncrementalEncoder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCodec_IncrementalEncoder(const char *encoding, const char *errors)
     * }
     */
    public static FunctionDescriptor PyCodec_IncrementalEncoder$descriptor() {
        return PyCodec_IncrementalEncoder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCodec_IncrementalEncoder(const char *encoding, const char *errors)
     * }
     */
    public static MethodHandle PyCodec_IncrementalEncoder$handle() {
        return PyCodec_IncrementalEncoder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCodec_IncrementalEncoder(const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyCodec_IncrementalEncoder$address() {
        return PyCodec_IncrementalEncoder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCodec_IncrementalEncoder(const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyCodec_IncrementalEncoder(MemorySegment encoding, MemorySegment errors) {
        var mh$ = PyCodec_IncrementalEncoder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_IncrementalEncoder", encoding, errors);
            }
            return (MemorySegment)mh$.invokeExact(encoding, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_IncrementalDecoder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_IncrementalDecoder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCodec_IncrementalDecoder(const char *encoding, const char *errors)
     * }
     */
    public static FunctionDescriptor PyCodec_IncrementalDecoder$descriptor() {
        return PyCodec_IncrementalDecoder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCodec_IncrementalDecoder(const char *encoding, const char *errors)
     * }
     */
    public static MethodHandle PyCodec_IncrementalDecoder$handle() {
        return PyCodec_IncrementalDecoder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCodec_IncrementalDecoder(const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyCodec_IncrementalDecoder$address() {
        return PyCodec_IncrementalDecoder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCodec_IncrementalDecoder(const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyCodec_IncrementalDecoder(MemorySegment encoding, MemorySegment errors) {
        var mh$ = PyCodec_IncrementalDecoder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_IncrementalDecoder", encoding, errors);
            }
            return (MemorySegment)mh$.invokeExact(encoding, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_StreamReader {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_StreamReader");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCodec_StreamReader(const char *encoding, PyObject *stream, const char *errors)
     * }
     */
    public static FunctionDescriptor PyCodec_StreamReader$descriptor() {
        return PyCodec_StreamReader.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCodec_StreamReader(const char *encoding, PyObject *stream, const char *errors)
     * }
     */
    public static MethodHandle PyCodec_StreamReader$handle() {
        return PyCodec_StreamReader.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCodec_StreamReader(const char *encoding, PyObject *stream, const char *errors)
     * }
     */
    public static MemorySegment PyCodec_StreamReader$address() {
        return PyCodec_StreamReader.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCodec_StreamReader(const char *encoding, PyObject *stream, const char *errors)
     * }
     */
    public static MemorySegment PyCodec_StreamReader(MemorySegment encoding, MemorySegment stream, MemorySegment errors) {
        var mh$ = PyCodec_StreamReader.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_StreamReader", encoding, stream, errors);
            }
            return (MemorySegment)mh$.invokeExact(encoding, stream, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_StreamWriter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_StreamWriter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCodec_StreamWriter(const char *encoding, PyObject *stream, const char *errors)
     * }
     */
    public static FunctionDescriptor PyCodec_StreamWriter$descriptor() {
        return PyCodec_StreamWriter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCodec_StreamWriter(const char *encoding, PyObject *stream, const char *errors)
     * }
     */
    public static MethodHandle PyCodec_StreamWriter$handle() {
        return PyCodec_StreamWriter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCodec_StreamWriter(const char *encoding, PyObject *stream, const char *errors)
     * }
     */
    public static MemorySegment PyCodec_StreamWriter$address() {
        return PyCodec_StreamWriter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCodec_StreamWriter(const char *encoding, PyObject *stream, const char *errors)
     * }
     */
    public static MemorySegment PyCodec_StreamWriter(MemorySegment encoding, MemorySegment stream, MemorySegment errors) {
        var mh$ = PyCodec_StreamWriter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_StreamWriter", encoding, stream, errors);
            }
            return (MemorySegment)mh$.invokeExact(encoding, stream, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_RegisterError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_RegisterError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyCodec_RegisterError(const char *name, PyObject *error)
     * }
     */
    public static FunctionDescriptor PyCodec_RegisterError$descriptor() {
        return PyCodec_RegisterError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyCodec_RegisterError(const char *name, PyObject *error)
     * }
     */
    public static MethodHandle PyCodec_RegisterError$handle() {
        return PyCodec_RegisterError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyCodec_RegisterError(const char *name, PyObject *error)
     * }
     */
    public static MemorySegment PyCodec_RegisterError$address() {
        return PyCodec_RegisterError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyCodec_RegisterError(const char *name, PyObject *error)
     * }
     */
    public static int PyCodec_RegisterError(MemorySegment name, MemorySegment error) {
        var mh$ = PyCodec_RegisterError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_RegisterError", name, error);
            }
            return (int)mh$.invokeExact(name, error);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_LookupError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_LookupError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCodec_LookupError(const char *name)
     * }
     */
    public static FunctionDescriptor PyCodec_LookupError$descriptor() {
        return PyCodec_LookupError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCodec_LookupError(const char *name)
     * }
     */
    public static MethodHandle PyCodec_LookupError$handle() {
        return PyCodec_LookupError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCodec_LookupError(const char *name)
     * }
     */
    public static MemorySegment PyCodec_LookupError$address() {
        return PyCodec_LookupError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCodec_LookupError(const char *name)
     * }
     */
    public static MemorySegment PyCodec_LookupError(MemorySegment name) {
        var mh$ = PyCodec_LookupError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_LookupError", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_StrictErrors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_StrictErrors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCodec_StrictErrors(PyObject *exc)
     * }
     */
    public static FunctionDescriptor PyCodec_StrictErrors$descriptor() {
        return PyCodec_StrictErrors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCodec_StrictErrors(PyObject *exc)
     * }
     */
    public static MethodHandle PyCodec_StrictErrors$handle() {
        return PyCodec_StrictErrors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCodec_StrictErrors(PyObject *exc)
     * }
     */
    public static MemorySegment PyCodec_StrictErrors$address() {
        return PyCodec_StrictErrors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCodec_StrictErrors(PyObject *exc)
     * }
     */
    public static MemorySegment PyCodec_StrictErrors(MemorySegment exc) {
        var mh$ = PyCodec_StrictErrors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_StrictErrors", exc);
            }
            return (MemorySegment)mh$.invokeExact(exc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_IgnoreErrors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_IgnoreErrors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCodec_IgnoreErrors(PyObject *exc)
     * }
     */
    public static FunctionDescriptor PyCodec_IgnoreErrors$descriptor() {
        return PyCodec_IgnoreErrors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCodec_IgnoreErrors(PyObject *exc)
     * }
     */
    public static MethodHandle PyCodec_IgnoreErrors$handle() {
        return PyCodec_IgnoreErrors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCodec_IgnoreErrors(PyObject *exc)
     * }
     */
    public static MemorySegment PyCodec_IgnoreErrors$address() {
        return PyCodec_IgnoreErrors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCodec_IgnoreErrors(PyObject *exc)
     * }
     */
    public static MemorySegment PyCodec_IgnoreErrors(MemorySegment exc) {
        var mh$ = PyCodec_IgnoreErrors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_IgnoreErrors", exc);
            }
            return (MemorySegment)mh$.invokeExact(exc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_ReplaceErrors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_ReplaceErrors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCodec_ReplaceErrors(PyObject *exc)
     * }
     */
    public static FunctionDescriptor PyCodec_ReplaceErrors$descriptor() {
        return PyCodec_ReplaceErrors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCodec_ReplaceErrors(PyObject *exc)
     * }
     */
    public static MethodHandle PyCodec_ReplaceErrors$handle() {
        return PyCodec_ReplaceErrors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCodec_ReplaceErrors(PyObject *exc)
     * }
     */
    public static MemorySegment PyCodec_ReplaceErrors$address() {
        return PyCodec_ReplaceErrors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCodec_ReplaceErrors(PyObject *exc)
     * }
     */
    public static MemorySegment PyCodec_ReplaceErrors(MemorySegment exc) {
        var mh$ = PyCodec_ReplaceErrors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_ReplaceErrors", exc);
            }
            return (MemorySegment)mh$.invokeExact(exc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_XMLCharRefReplaceErrors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_XMLCharRefReplaceErrors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCodec_XMLCharRefReplaceErrors(PyObject *exc)
     * }
     */
    public static FunctionDescriptor PyCodec_XMLCharRefReplaceErrors$descriptor() {
        return PyCodec_XMLCharRefReplaceErrors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCodec_XMLCharRefReplaceErrors(PyObject *exc)
     * }
     */
    public static MethodHandle PyCodec_XMLCharRefReplaceErrors$handle() {
        return PyCodec_XMLCharRefReplaceErrors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCodec_XMLCharRefReplaceErrors(PyObject *exc)
     * }
     */
    public static MemorySegment PyCodec_XMLCharRefReplaceErrors$address() {
        return PyCodec_XMLCharRefReplaceErrors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCodec_XMLCharRefReplaceErrors(PyObject *exc)
     * }
     */
    public static MemorySegment PyCodec_XMLCharRefReplaceErrors(MemorySegment exc) {
        var mh$ = PyCodec_XMLCharRefReplaceErrors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_XMLCharRefReplaceErrors", exc);
            }
            return (MemorySegment)mh$.invokeExact(exc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_BackslashReplaceErrors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_BackslashReplaceErrors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCodec_BackslashReplaceErrors(PyObject *exc)
     * }
     */
    public static FunctionDescriptor PyCodec_BackslashReplaceErrors$descriptor() {
        return PyCodec_BackslashReplaceErrors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCodec_BackslashReplaceErrors(PyObject *exc)
     * }
     */
    public static MethodHandle PyCodec_BackslashReplaceErrors$handle() {
        return PyCodec_BackslashReplaceErrors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCodec_BackslashReplaceErrors(PyObject *exc)
     * }
     */
    public static MemorySegment PyCodec_BackslashReplaceErrors$address() {
        return PyCodec_BackslashReplaceErrors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCodec_BackslashReplaceErrors(PyObject *exc)
     * }
     */
    public static MemorySegment PyCodec_BackslashReplaceErrors(MemorySegment exc) {
        var mh$ = PyCodec_BackslashReplaceErrors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_BackslashReplaceErrors", exc);
            }
            return (MemorySegment)mh$.invokeExact(exc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCodec_NameReplaceErrors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCodec_NameReplaceErrors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyCodec_NameReplaceErrors(PyObject *exc)
     * }
     */
    public static FunctionDescriptor PyCodec_NameReplaceErrors$descriptor() {
        return PyCodec_NameReplaceErrors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyCodec_NameReplaceErrors(PyObject *exc)
     * }
     */
    public static MethodHandle PyCodec_NameReplaceErrors$handle() {
        return PyCodec_NameReplaceErrors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyCodec_NameReplaceErrors(PyObject *exc)
     * }
     */
    public static MemorySegment PyCodec_NameReplaceErrors$address() {
        return PyCodec_NameReplaceErrors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyCodec_NameReplaceErrors(PyObject *exc)
     * }
     */
    public static MemorySegment PyCodec_NameReplaceErrors(MemorySegment exc) {
        var mh$ = PyCodec_NameReplaceErrors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCodec_NameReplaceErrors", exc);
            }
            return (MemorySegment)mh$.invokeExact(exc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_hexdigits$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_hexdigits").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const char *Py_hexdigits
     * }
     */
    public static AddressLayout Py_hexdigits$layout() {
        return Py_hexdigits$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const char *Py_hexdigits
     * }
     */
    public static MemorySegment Py_hexdigits$segment() {
        return Py_hexdigits$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const char *Py_hexdigits
     * }
     */
    public static MemorySegment Py_hexdigits() {
        return Py_hexdigits$constants.SEGMENT.get(Py_hexdigits$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const char *Py_hexdigits
     * }
     */
    public static void Py_hexdigits(MemorySegment varValue) {
        Py_hexdigits$constants.SEGMENT.set(Py_hexdigits$constants.LAYOUT, 0L, varValue);
    }

    private static class PyErr_SetNone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetNone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_SetNone(PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_SetNone$descriptor() {
        return PyErr_SetNone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_SetNone(PyObject *)
     * }
     */
    public static MethodHandle PyErr_SetNone$handle() {
        return PyErr_SetNone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_SetNone(PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetNone$address() {
        return PyErr_SetNone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_SetNone(PyObject *)
     * }
     */
    public static void PyErr_SetNone(MemorySegment x0) {
        var mh$ = PyErr_SetNone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetNone", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SetObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_SetObject(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_SetObject$descriptor() {
        return PyErr_SetObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_SetObject(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyErr_SetObject$handle() {
        return PyErr_SetObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_SetObject(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetObject$address() {
        return PyErr_SetObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_SetObject(PyObject *, PyObject *)
     * }
     */
    public static void PyErr_SetObject(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyErr_SetObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetObject", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SetString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_SetString(PyObject *exception, const char *string)
     * }
     */
    public static FunctionDescriptor PyErr_SetString$descriptor() {
        return PyErr_SetString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_SetString(PyObject *exception, const char *string)
     * }
     */
    public static MethodHandle PyErr_SetString$handle() {
        return PyErr_SetString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_SetString(PyObject *exception, const char *string)
     * }
     */
    public static MemorySegment PyErr_SetString$address() {
        return PyErr_SetString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_SetString(PyObject *exception, const char *string)
     * }
     */
    public static void PyErr_SetString(MemorySegment exception, MemorySegment string) {
        var mh$ = PyErr_SetString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetString", exception, string);
            }
            mh$.invokeExact(exception, string);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_Occurred {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_Occurred");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_Occurred()
     * }
     */
    public static FunctionDescriptor PyErr_Occurred$descriptor() {
        return PyErr_Occurred.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_Occurred()
     * }
     */
    public static MethodHandle PyErr_Occurred$handle() {
        return PyErr_Occurred.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_Occurred()
     * }
     */
    public static MemorySegment PyErr_Occurred$address() {
        return PyErr_Occurred.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_Occurred()
     * }
     */
    public static MemorySegment PyErr_Occurred() {
        var mh$ = PyErr_Occurred.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_Occurred");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_Clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_Clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_Clear()
     * }
     */
    public static FunctionDescriptor PyErr_Clear$descriptor() {
        return PyErr_Clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_Clear()
     * }
     */
    public static MethodHandle PyErr_Clear$handle() {
        return PyErr_Clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_Clear()
     * }
     */
    public static MemorySegment PyErr_Clear$address() {
        return PyErr_Clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_Clear()
     * }
     */
    public static void PyErr_Clear() {
        var mh$ = PyErr_Clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_Clear");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_Fetch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_Fetch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_Fetch(PyObject **, PyObject **, PyObject **)
     * }
     */
    public static FunctionDescriptor PyErr_Fetch$descriptor() {
        return PyErr_Fetch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_Fetch(PyObject **, PyObject **, PyObject **)
     * }
     */
    public static MethodHandle PyErr_Fetch$handle() {
        return PyErr_Fetch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_Fetch(PyObject **, PyObject **, PyObject **)
     * }
     */
    public static MemorySegment PyErr_Fetch$address() {
        return PyErr_Fetch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_Fetch(PyObject **, PyObject **, PyObject **)
     * }
     */
    public static void PyErr_Fetch(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyErr_Fetch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_Fetch", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_Restore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_Restore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_Restore(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_Restore$descriptor() {
        return PyErr_Restore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_Restore(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyErr_Restore$handle() {
        return PyErr_Restore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_Restore(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyErr_Restore$address() {
        return PyErr_Restore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_Restore(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static void PyErr_Restore(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyErr_Restore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_Restore", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_GetHandledException {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_GetHandledException");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_GetHandledException()
     * }
     */
    public static FunctionDescriptor PyErr_GetHandledException$descriptor() {
        return PyErr_GetHandledException.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_GetHandledException()
     * }
     */
    public static MethodHandle PyErr_GetHandledException$handle() {
        return PyErr_GetHandledException.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_GetHandledException()
     * }
     */
    public static MemorySegment PyErr_GetHandledException$address() {
        return PyErr_GetHandledException.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_GetHandledException()
     * }
     */
    public static MemorySegment PyErr_GetHandledException() {
        var mh$ = PyErr_GetHandledException.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_GetHandledException");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SetHandledException {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetHandledException");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_SetHandledException(PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_SetHandledException$descriptor() {
        return PyErr_SetHandledException.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_SetHandledException(PyObject *)
     * }
     */
    public static MethodHandle PyErr_SetHandledException$handle() {
        return PyErr_SetHandledException.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_SetHandledException(PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetHandledException$address() {
        return PyErr_SetHandledException.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_SetHandledException(PyObject *)
     * }
     */
    public static void PyErr_SetHandledException(MemorySegment x0) {
        var mh$ = PyErr_SetHandledException.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetHandledException", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_GetExcInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_GetExcInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_GetExcInfo(PyObject **, PyObject **, PyObject **)
     * }
     */
    public static FunctionDescriptor PyErr_GetExcInfo$descriptor() {
        return PyErr_GetExcInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_GetExcInfo(PyObject **, PyObject **, PyObject **)
     * }
     */
    public static MethodHandle PyErr_GetExcInfo$handle() {
        return PyErr_GetExcInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_GetExcInfo(PyObject **, PyObject **, PyObject **)
     * }
     */
    public static MemorySegment PyErr_GetExcInfo$address() {
        return PyErr_GetExcInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_GetExcInfo(PyObject **, PyObject **, PyObject **)
     * }
     */
    public static void PyErr_GetExcInfo(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyErr_GetExcInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_GetExcInfo", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SetExcInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetExcInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_SetExcInfo(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_SetExcInfo$descriptor() {
        return PyErr_SetExcInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_SetExcInfo(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyErr_SetExcInfo$handle() {
        return PyErr_SetExcInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_SetExcInfo(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetExcInfo$address() {
        return PyErr_SetExcInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_SetExcInfo(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static void PyErr_SetExcInfo(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyErr_SetExcInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetExcInfo", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_FatalError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_FatalError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_FatalError(const char *message)
     * }
     */
    public static FunctionDescriptor Py_FatalError$descriptor() {
        return Py_FatalError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_FatalError(const char *message)
     * }
     */
    public static MethodHandle Py_FatalError$handle() {
        return Py_FatalError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_FatalError(const char *message)
     * }
     */
    public static MemorySegment Py_FatalError$address() {
        return Py_FatalError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_FatalError(const char *message)
     * }
     */
    public static void Py_FatalError(MemorySegment message) {
        var mh$ = Py_FatalError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_FatalError", message);
            }
            mh$.invokeExact(message);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_GivenExceptionMatches {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_GivenExceptionMatches");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyErr_GivenExceptionMatches(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_GivenExceptionMatches$descriptor() {
        return PyErr_GivenExceptionMatches.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyErr_GivenExceptionMatches(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyErr_GivenExceptionMatches$handle() {
        return PyErr_GivenExceptionMatches.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyErr_GivenExceptionMatches(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyErr_GivenExceptionMatches$address() {
        return PyErr_GivenExceptionMatches.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyErr_GivenExceptionMatches(PyObject *, PyObject *)
     * }
     */
    public static int PyErr_GivenExceptionMatches(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyErr_GivenExceptionMatches.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_GivenExceptionMatches", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_ExceptionMatches {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_ExceptionMatches");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyErr_ExceptionMatches(PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_ExceptionMatches$descriptor() {
        return PyErr_ExceptionMatches.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyErr_ExceptionMatches(PyObject *)
     * }
     */
    public static MethodHandle PyErr_ExceptionMatches$handle() {
        return PyErr_ExceptionMatches.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyErr_ExceptionMatches(PyObject *)
     * }
     */
    public static MemorySegment PyErr_ExceptionMatches$address() {
        return PyErr_ExceptionMatches.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyErr_ExceptionMatches(PyObject *)
     * }
     */
    public static int PyErr_ExceptionMatches(MemorySegment x0) {
        var mh$ = PyErr_ExceptionMatches.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_ExceptionMatches", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_NormalizeException {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_NormalizeException");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_NormalizeException(PyObject **, PyObject **, PyObject **)
     * }
     */
    public static FunctionDescriptor PyErr_NormalizeException$descriptor() {
        return PyErr_NormalizeException.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_NormalizeException(PyObject **, PyObject **, PyObject **)
     * }
     */
    public static MethodHandle PyErr_NormalizeException$handle() {
        return PyErr_NormalizeException.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_NormalizeException(PyObject **, PyObject **, PyObject **)
     * }
     */
    public static MemorySegment PyErr_NormalizeException$address() {
        return PyErr_NormalizeException.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_NormalizeException(PyObject **, PyObject **, PyObject **)
     * }
     */
    public static void PyErr_NormalizeException(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyErr_NormalizeException.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_NormalizeException", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyException_SetTraceback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyException_SetTraceback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyException_SetTraceback(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyException_SetTraceback$descriptor() {
        return PyException_SetTraceback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyException_SetTraceback(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyException_SetTraceback$handle() {
        return PyException_SetTraceback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyException_SetTraceback(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyException_SetTraceback$address() {
        return PyException_SetTraceback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyException_SetTraceback(PyObject *, PyObject *)
     * }
     */
    public static int PyException_SetTraceback(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyException_SetTraceback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyException_SetTraceback", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyException_GetTraceback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyException_GetTraceback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyException_GetTraceback(PyObject *)
     * }
     */
    public static FunctionDescriptor PyException_GetTraceback$descriptor() {
        return PyException_GetTraceback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyException_GetTraceback(PyObject *)
     * }
     */
    public static MethodHandle PyException_GetTraceback$handle() {
        return PyException_GetTraceback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyException_GetTraceback(PyObject *)
     * }
     */
    public static MemorySegment PyException_GetTraceback$address() {
        return PyException_GetTraceback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyException_GetTraceback(PyObject *)
     * }
     */
    public static MemorySegment PyException_GetTraceback(MemorySegment x0) {
        var mh$ = PyException_GetTraceback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyException_GetTraceback", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyException_GetCause {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyException_GetCause");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyException_GetCause(PyObject *)
     * }
     */
    public static FunctionDescriptor PyException_GetCause$descriptor() {
        return PyException_GetCause.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyException_GetCause(PyObject *)
     * }
     */
    public static MethodHandle PyException_GetCause$handle() {
        return PyException_GetCause.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyException_GetCause(PyObject *)
     * }
     */
    public static MemorySegment PyException_GetCause$address() {
        return PyException_GetCause.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyException_GetCause(PyObject *)
     * }
     */
    public static MemorySegment PyException_GetCause(MemorySegment x0) {
        var mh$ = PyException_GetCause.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyException_GetCause", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyException_SetCause {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyException_SetCause");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyException_SetCause(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyException_SetCause$descriptor() {
        return PyException_SetCause.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyException_SetCause(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyException_SetCause$handle() {
        return PyException_SetCause.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyException_SetCause(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyException_SetCause$address() {
        return PyException_SetCause.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyException_SetCause(PyObject *, PyObject *)
     * }
     */
    public static void PyException_SetCause(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyException_SetCause.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyException_SetCause", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyException_GetContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyException_GetContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyException_GetContext(PyObject *)
     * }
     */
    public static FunctionDescriptor PyException_GetContext$descriptor() {
        return PyException_GetContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyException_GetContext(PyObject *)
     * }
     */
    public static MethodHandle PyException_GetContext$handle() {
        return PyException_GetContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyException_GetContext(PyObject *)
     * }
     */
    public static MemorySegment PyException_GetContext$address() {
        return PyException_GetContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyException_GetContext(PyObject *)
     * }
     */
    public static MemorySegment PyException_GetContext(MemorySegment x0) {
        var mh$ = PyException_GetContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyException_GetContext", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyException_SetContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyException_SetContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyException_SetContext(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyException_SetContext$descriptor() {
        return PyException_SetContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyException_SetContext(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyException_SetContext$handle() {
        return PyException_SetContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyException_SetContext(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyException_SetContext$address() {
        return PyException_SetContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyException_SetContext(PyObject *, PyObject *)
     * }
     */
    public static void PyException_SetContext(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyException_SetContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyException_SetContext", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyExceptionClass_Name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyExceptionClass_Name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *PyExceptionClass_Name(PyObject *)
     * }
     */
    public static FunctionDescriptor PyExceptionClass_Name$descriptor() {
        return PyExceptionClass_Name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *PyExceptionClass_Name(PyObject *)
     * }
     */
    public static MethodHandle PyExceptionClass_Name$handle() {
        return PyExceptionClass_Name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *PyExceptionClass_Name(PyObject *)
     * }
     */
    public static MemorySegment PyExceptionClass_Name$address() {
        return PyExceptionClass_Name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *PyExceptionClass_Name(PyObject *)
     * }
     */
    public static MemorySegment PyExceptionClass_Name(MemorySegment x0) {
        var mh$ = PyExceptionClass_Name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyExceptionClass_Name", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyExc_BaseException$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_BaseException").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BaseException
     * }
     */
    public static AddressLayout PyExc_BaseException$layout() {
        return PyExc_BaseException$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BaseException
     * }
     */
    public static MemorySegment PyExc_BaseException$segment() {
        return PyExc_BaseException$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BaseException
     * }
     */
    public static MemorySegment PyExc_BaseException() {
        return PyExc_BaseException$constants.SEGMENT.get(PyExc_BaseException$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BaseException
     * }
     */
    public static void PyExc_BaseException(MemorySegment varValue) {
        PyExc_BaseException$constants.SEGMENT.set(PyExc_BaseException$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_Exception$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_Exception").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_Exception
     * }
     */
    public static AddressLayout PyExc_Exception$layout() {
        return PyExc_Exception$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_Exception
     * }
     */
    public static MemorySegment PyExc_Exception$segment() {
        return PyExc_Exception$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_Exception
     * }
     */
    public static MemorySegment PyExc_Exception() {
        return PyExc_Exception$constants.SEGMENT.get(PyExc_Exception$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_Exception
     * }
     */
    public static void PyExc_Exception(MemorySegment varValue) {
        PyExc_Exception$constants.SEGMENT.set(PyExc_Exception$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_BaseExceptionGroup$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_BaseExceptionGroup").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BaseExceptionGroup
     * }
     */
    public static AddressLayout PyExc_BaseExceptionGroup$layout() {
        return PyExc_BaseExceptionGroup$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BaseExceptionGroup
     * }
     */
    public static MemorySegment PyExc_BaseExceptionGroup$segment() {
        return PyExc_BaseExceptionGroup$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BaseExceptionGroup
     * }
     */
    public static MemorySegment PyExc_BaseExceptionGroup() {
        return PyExc_BaseExceptionGroup$constants.SEGMENT.get(PyExc_BaseExceptionGroup$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BaseExceptionGroup
     * }
     */
    public static void PyExc_BaseExceptionGroup(MemorySegment varValue) {
        PyExc_BaseExceptionGroup$constants.SEGMENT.set(PyExc_BaseExceptionGroup$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_StopAsyncIteration$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_StopAsyncIteration").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_StopAsyncIteration
     * }
     */
    public static AddressLayout PyExc_StopAsyncIteration$layout() {
        return PyExc_StopAsyncIteration$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_StopAsyncIteration
     * }
     */
    public static MemorySegment PyExc_StopAsyncIteration$segment() {
        return PyExc_StopAsyncIteration$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_StopAsyncIteration
     * }
     */
    public static MemorySegment PyExc_StopAsyncIteration() {
        return PyExc_StopAsyncIteration$constants.SEGMENT.get(PyExc_StopAsyncIteration$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_StopAsyncIteration
     * }
     */
    public static void PyExc_StopAsyncIteration(MemorySegment varValue) {
        PyExc_StopAsyncIteration$constants.SEGMENT.set(PyExc_StopAsyncIteration$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_StopIteration$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_StopIteration").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_StopIteration
     * }
     */
    public static AddressLayout PyExc_StopIteration$layout() {
        return PyExc_StopIteration$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_StopIteration
     * }
     */
    public static MemorySegment PyExc_StopIteration$segment() {
        return PyExc_StopIteration$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_StopIteration
     * }
     */
    public static MemorySegment PyExc_StopIteration() {
        return PyExc_StopIteration$constants.SEGMENT.get(PyExc_StopIteration$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_StopIteration
     * }
     */
    public static void PyExc_StopIteration(MemorySegment varValue) {
        PyExc_StopIteration$constants.SEGMENT.set(PyExc_StopIteration$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_GeneratorExit$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_GeneratorExit").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_GeneratorExit
     * }
     */
    public static AddressLayout PyExc_GeneratorExit$layout() {
        return PyExc_GeneratorExit$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_GeneratorExit
     * }
     */
    public static MemorySegment PyExc_GeneratorExit$segment() {
        return PyExc_GeneratorExit$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_GeneratorExit
     * }
     */
    public static MemorySegment PyExc_GeneratorExit() {
        return PyExc_GeneratorExit$constants.SEGMENT.get(PyExc_GeneratorExit$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_GeneratorExit
     * }
     */
    public static void PyExc_GeneratorExit(MemorySegment varValue) {
        PyExc_GeneratorExit$constants.SEGMENT.set(PyExc_GeneratorExit$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_ArithmeticError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_ArithmeticError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ArithmeticError
     * }
     */
    public static AddressLayout PyExc_ArithmeticError$layout() {
        return PyExc_ArithmeticError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ArithmeticError
     * }
     */
    public static MemorySegment PyExc_ArithmeticError$segment() {
        return PyExc_ArithmeticError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ArithmeticError
     * }
     */
    public static MemorySegment PyExc_ArithmeticError() {
        return PyExc_ArithmeticError$constants.SEGMENT.get(PyExc_ArithmeticError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ArithmeticError
     * }
     */
    public static void PyExc_ArithmeticError(MemorySegment varValue) {
        PyExc_ArithmeticError$constants.SEGMENT.set(PyExc_ArithmeticError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_LookupError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_LookupError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_LookupError
     * }
     */
    public static AddressLayout PyExc_LookupError$layout() {
        return PyExc_LookupError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_LookupError
     * }
     */
    public static MemorySegment PyExc_LookupError$segment() {
        return PyExc_LookupError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_LookupError
     * }
     */
    public static MemorySegment PyExc_LookupError() {
        return PyExc_LookupError$constants.SEGMENT.get(PyExc_LookupError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_LookupError
     * }
     */
    public static void PyExc_LookupError(MemorySegment varValue) {
        PyExc_LookupError$constants.SEGMENT.set(PyExc_LookupError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_AssertionError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_AssertionError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_AssertionError
     * }
     */
    public static AddressLayout PyExc_AssertionError$layout() {
        return PyExc_AssertionError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_AssertionError
     * }
     */
    public static MemorySegment PyExc_AssertionError$segment() {
        return PyExc_AssertionError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_AssertionError
     * }
     */
    public static MemorySegment PyExc_AssertionError() {
        return PyExc_AssertionError$constants.SEGMENT.get(PyExc_AssertionError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_AssertionError
     * }
     */
    public static void PyExc_AssertionError(MemorySegment varValue) {
        PyExc_AssertionError$constants.SEGMENT.set(PyExc_AssertionError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_AttributeError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_AttributeError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_AttributeError
     * }
     */
    public static AddressLayout PyExc_AttributeError$layout() {
        return PyExc_AttributeError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_AttributeError
     * }
     */
    public static MemorySegment PyExc_AttributeError$segment() {
        return PyExc_AttributeError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_AttributeError
     * }
     */
    public static MemorySegment PyExc_AttributeError() {
        return PyExc_AttributeError$constants.SEGMENT.get(PyExc_AttributeError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_AttributeError
     * }
     */
    public static void PyExc_AttributeError(MemorySegment varValue) {
        PyExc_AttributeError$constants.SEGMENT.set(PyExc_AttributeError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_BufferError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_BufferError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BufferError
     * }
     */
    public static AddressLayout PyExc_BufferError$layout() {
        return PyExc_BufferError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BufferError
     * }
     */
    public static MemorySegment PyExc_BufferError$segment() {
        return PyExc_BufferError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BufferError
     * }
     */
    public static MemorySegment PyExc_BufferError() {
        return PyExc_BufferError$constants.SEGMENT.get(PyExc_BufferError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BufferError
     * }
     */
    public static void PyExc_BufferError(MemorySegment varValue) {
        PyExc_BufferError$constants.SEGMENT.set(PyExc_BufferError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_EOFError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_EOFError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_EOFError
     * }
     */
    public static AddressLayout PyExc_EOFError$layout() {
        return PyExc_EOFError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_EOFError
     * }
     */
    public static MemorySegment PyExc_EOFError$segment() {
        return PyExc_EOFError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_EOFError
     * }
     */
    public static MemorySegment PyExc_EOFError() {
        return PyExc_EOFError$constants.SEGMENT.get(PyExc_EOFError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_EOFError
     * }
     */
    public static void PyExc_EOFError(MemorySegment varValue) {
        PyExc_EOFError$constants.SEGMENT.set(PyExc_EOFError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_FloatingPointError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_FloatingPointError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FloatingPointError
     * }
     */
    public static AddressLayout PyExc_FloatingPointError$layout() {
        return PyExc_FloatingPointError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FloatingPointError
     * }
     */
    public static MemorySegment PyExc_FloatingPointError$segment() {
        return PyExc_FloatingPointError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FloatingPointError
     * }
     */
    public static MemorySegment PyExc_FloatingPointError() {
        return PyExc_FloatingPointError$constants.SEGMENT.get(PyExc_FloatingPointError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FloatingPointError
     * }
     */
    public static void PyExc_FloatingPointError(MemorySegment varValue) {
        PyExc_FloatingPointError$constants.SEGMENT.set(PyExc_FloatingPointError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_OSError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_OSError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_OSError
     * }
     */
    public static AddressLayout PyExc_OSError$layout() {
        return PyExc_OSError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_OSError
     * }
     */
    public static MemorySegment PyExc_OSError$segment() {
        return PyExc_OSError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_OSError
     * }
     */
    public static MemorySegment PyExc_OSError() {
        return PyExc_OSError$constants.SEGMENT.get(PyExc_OSError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_OSError
     * }
     */
    public static void PyExc_OSError(MemorySegment varValue) {
        PyExc_OSError$constants.SEGMENT.set(PyExc_OSError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_ImportError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_ImportError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ImportError
     * }
     */
    public static AddressLayout PyExc_ImportError$layout() {
        return PyExc_ImportError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ImportError
     * }
     */
    public static MemorySegment PyExc_ImportError$segment() {
        return PyExc_ImportError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ImportError
     * }
     */
    public static MemorySegment PyExc_ImportError() {
        return PyExc_ImportError$constants.SEGMENT.get(PyExc_ImportError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ImportError
     * }
     */
    public static void PyExc_ImportError(MemorySegment varValue) {
        PyExc_ImportError$constants.SEGMENT.set(PyExc_ImportError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_ModuleNotFoundError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_ModuleNotFoundError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ModuleNotFoundError
     * }
     */
    public static AddressLayout PyExc_ModuleNotFoundError$layout() {
        return PyExc_ModuleNotFoundError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ModuleNotFoundError
     * }
     */
    public static MemorySegment PyExc_ModuleNotFoundError$segment() {
        return PyExc_ModuleNotFoundError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ModuleNotFoundError
     * }
     */
    public static MemorySegment PyExc_ModuleNotFoundError() {
        return PyExc_ModuleNotFoundError$constants.SEGMENT.get(PyExc_ModuleNotFoundError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ModuleNotFoundError
     * }
     */
    public static void PyExc_ModuleNotFoundError(MemorySegment varValue) {
        PyExc_ModuleNotFoundError$constants.SEGMENT.set(PyExc_ModuleNotFoundError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_IndexError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_IndexError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IndexError
     * }
     */
    public static AddressLayout PyExc_IndexError$layout() {
        return PyExc_IndexError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IndexError
     * }
     */
    public static MemorySegment PyExc_IndexError$segment() {
        return PyExc_IndexError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IndexError
     * }
     */
    public static MemorySegment PyExc_IndexError() {
        return PyExc_IndexError$constants.SEGMENT.get(PyExc_IndexError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IndexError
     * }
     */
    public static void PyExc_IndexError(MemorySegment varValue) {
        PyExc_IndexError$constants.SEGMENT.set(PyExc_IndexError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_KeyError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_KeyError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_KeyError
     * }
     */
    public static AddressLayout PyExc_KeyError$layout() {
        return PyExc_KeyError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_KeyError
     * }
     */
    public static MemorySegment PyExc_KeyError$segment() {
        return PyExc_KeyError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_KeyError
     * }
     */
    public static MemorySegment PyExc_KeyError() {
        return PyExc_KeyError$constants.SEGMENT.get(PyExc_KeyError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_KeyError
     * }
     */
    public static void PyExc_KeyError(MemorySegment varValue) {
        PyExc_KeyError$constants.SEGMENT.set(PyExc_KeyError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_KeyboardInterrupt$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_KeyboardInterrupt").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_KeyboardInterrupt
     * }
     */
    public static AddressLayout PyExc_KeyboardInterrupt$layout() {
        return PyExc_KeyboardInterrupt$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_KeyboardInterrupt
     * }
     */
    public static MemorySegment PyExc_KeyboardInterrupt$segment() {
        return PyExc_KeyboardInterrupt$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_KeyboardInterrupt
     * }
     */
    public static MemorySegment PyExc_KeyboardInterrupt() {
        return PyExc_KeyboardInterrupt$constants.SEGMENT.get(PyExc_KeyboardInterrupt$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_KeyboardInterrupt
     * }
     */
    public static void PyExc_KeyboardInterrupt(MemorySegment varValue) {
        PyExc_KeyboardInterrupt$constants.SEGMENT.set(PyExc_KeyboardInterrupt$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_MemoryError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_MemoryError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_MemoryError
     * }
     */
    public static AddressLayout PyExc_MemoryError$layout() {
        return PyExc_MemoryError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_MemoryError
     * }
     */
    public static MemorySegment PyExc_MemoryError$segment() {
        return PyExc_MemoryError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_MemoryError
     * }
     */
    public static MemorySegment PyExc_MemoryError() {
        return PyExc_MemoryError$constants.SEGMENT.get(PyExc_MemoryError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_MemoryError
     * }
     */
    public static void PyExc_MemoryError(MemorySegment varValue) {
        PyExc_MemoryError$constants.SEGMENT.set(PyExc_MemoryError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_NameError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_NameError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_NameError
     * }
     */
    public static AddressLayout PyExc_NameError$layout() {
        return PyExc_NameError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_NameError
     * }
     */
    public static MemorySegment PyExc_NameError$segment() {
        return PyExc_NameError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_NameError
     * }
     */
    public static MemorySegment PyExc_NameError() {
        return PyExc_NameError$constants.SEGMENT.get(PyExc_NameError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_NameError
     * }
     */
    public static void PyExc_NameError(MemorySegment varValue) {
        PyExc_NameError$constants.SEGMENT.set(PyExc_NameError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_OverflowError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_OverflowError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_OverflowError
     * }
     */
    public static AddressLayout PyExc_OverflowError$layout() {
        return PyExc_OverflowError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_OverflowError
     * }
     */
    public static MemorySegment PyExc_OverflowError$segment() {
        return PyExc_OverflowError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_OverflowError
     * }
     */
    public static MemorySegment PyExc_OverflowError() {
        return PyExc_OverflowError$constants.SEGMENT.get(PyExc_OverflowError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_OverflowError
     * }
     */
    public static void PyExc_OverflowError(MemorySegment varValue) {
        PyExc_OverflowError$constants.SEGMENT.set(PyExc_OverflowError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_RuntimeError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_RuntimeError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_RuntimeError
     * }
     */
    public static AddressLayout PyExc_RuntimeError$layout() {
        return PyExc_RuntimeError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_RuntimeError
     * }
     */
    public static MemorySegment PyExc_RuntimeError$segment() {
        return PyExc_RuntimeError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_RuntimeError
     * }
     */
    public static MemorySegment PyExc_RuntimeError() {
        return PyExc_RuntimeError$constants.SEGMENT.get(PyExc_RuntimeError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_RuntimeError
     * }
     */
    public static void PyExc_RuntimeError(MemorySegment varValue) {
        PyExc_RuntimeError$constants.SEGMENT.set(PyExc_RuntimeError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_RecursionError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_RecursionError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_RecursionError
     * }
     */
    public static AddressLayout PyExc_RecursionError$layout() {
        return PyExc_RecursionError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_RecursionError
     * }
     */
    public static MemorySegment PyExc_RecursionError$segment() {
        return PyExc_RecursionError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_RecursionError
     * }
     */
    public static MemorySegment PyExc_RecursionError() {
        return PyExc_RecursionError$constants.SEGMENT.get(PyExc_RecursionError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_RecursionError
     * }
     */
    public static void PyExc_RecursionError(MemorySegment varValue) {
        PyExc_RecursionError$constants.SEGMENT.set(PyExc_RecursionError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_NotImplementedError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_NotImplementedError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_NotImplementedError
     * }
     */
    public static AddressLayout PyExc_NotImplementedError$layout() {
        return PyExc_NotImplementedError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_NotImplementedError
     * }
     */
    public static MemorySegment PyExc_NotImplementedError$segment() {
        return PyExc_NotImplementedError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_NotImplementedError
     * }
     */
    public static MemorySegment PyExc_NotImplementedError() {
        return PyExc_NotImplementedError$constants.SEGMENT.get(PyExc_NotImplementedError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_NotImplementedError
     * }
     */
    public static void PyExc_NotImplementedError(MemorySegment varValue) {
        PyExc_NotImplementedError$constants.SEGMENT.set(PyExc_NotImplementedError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_SyntaxError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_SyntaxError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SyntaxError
     * }
     */
    public static AddressLayout PyExc_SyntaxError$layout() {
        return PyExc_SyntaxError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SyntaxError
     * }
     */
    public static MemorySegment PyExc_SyntaxError$segment() {
        return PyExc_SyntaxError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SyntaxError
     * }
     */
    public static MemorySegment PyExc_SyntaxError() {
        return PyExc_SyntaxError$constants.SEGMENT.get(PyExc_SyntaxError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SyntaxError
     * }
     */
    public static void PyExc_SyntaxError(MemorySegment varValue) {
        PyExc_SyntaxError$constants.SEGMENT.set(PyExc_SyntaxError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_IndentationError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_IndentationError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IndentationError
     * }
     */
    public static AddressLayout PyExc_IndentationError$layout() {
        return PyExc_IndentationError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IndentationError
     * }
     */
    public static MemorySegment PyExc_IndentationError$segment() {
        return PyExc_IndentationError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IndentationError
     * }
     */
    public static MemorySegment PyExc_IndentationError() {
        return PyExc_IndentationError$constants.SEGMENT.get(PyExc_IndentationError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IndentationError
     * }
     */
    public static void PyExc_IndentationError(MemorySegment varValue) {
        PyExc_IndentationError$constants.SEGMENT.set(PyExc_IndentationError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_TabError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_TabError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_TabError
     * }
     */
    public static AddressLayout PyExc_TabError$layout() {
        return PyExc_TabError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_TabError
     * }
     */
    public static MemorySegment PyExc_TabError$segment() {
        return PyExc_TabError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_TabError
     * }
     */
    public static MemorySegment PyExc_TabError() {
        return PyExc_TabError$constants.SEGMENT.get(PyExc_TabError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_TabError
     * }
     */
    public static void PyExc_TabError(MemorySegment varValue) {
        PyExc_TabError$constants.SEGMENT.set(PyExc_TabError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_ReferenceError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_ReferenceError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ReferenceError
     * }
     */
    public static AddressLayout PyExc_ReferenceError$layout() {
        return PyExc_ReferenceError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ReferenceError
     * }
     */
    public static MemorySegment PyExc_ReferenceError$segment() {
        return PyExc_ReferenceError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ReferenceError
     * }
     */
    public static MemorySegment PyExc_ReferenceError() {
        return PyExc_ReferenceError$constants.SEGMENT.get(PyExc_ReferenceError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ReferenceError
     * }
     */
    public static void PyExc_ReferenceError(MemorySegment varValue) {
        PyExc_ReferenceError$constants.SEGMENT.set(PyExc_ReferenceError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_SystemError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_SystemError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SystemError
     * }
     */
    public static AddressLayout PyExc_SystemError$layout() {
        return PyExc_SystemError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SystemError
     * }
     */
    public static MemorySegment PyExc_SystemError$segment() {
        return PyExc_SystemError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SystemError
     * }
     */
    public static MemorySegment PyExc_SystemError() {
        return PyExc_SystemError$constants.SEGMENT.get(PyExc_SystemError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SystemError
     * }
     */
    public static void PyExc_SystemError(MemorySegment varValue) {
        PyExc_SystemError$constants.SEGMENT.set(PyExc_SystemError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_SystemExit$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_SystemExit").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SystemExit
     * }
     */
    public static AddressLayout PyExc_SystemExit$layout() {
        return PyExc_SystemExit$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SystemExit
     * }
     */
    public static MemorySegment PyExc_SystemExit$segment() {
        return PyExc_SystemExit$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SystemExit
     * }
     */
    public static MemorySegment PyExc_SystemExit() {
        return PyExc_SystemExit$constants.SEGMENT.get(PyExc_SystemExit$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SystemExit
     * }
     */
    public static void PyExc_SystemExit(MemorySegment varValue) {
        PyExc_SystemExit$constants.SEGMENT.set(PyExc_SystemExit$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_TypeError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_TypeError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_TypeError
     * }
     */
    public static AddressLayout PyExc_TypeError$layout() {
        return PyExc_TypeError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_TypeError
     * }
     */
    public static MemorySegment PyExc_TypeError$segment() {
        return PyExc_TypeError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_TypeError
     * }
     */
    public static MemorySegment PyExc_TypeError() {
        return PyExc_TypeError$constants.SEGMENT.get(PyExc_TypeError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_TypeError
     * }
     */
    public static void PyExc_TypeError(MemorySegment varValue) {
        PyExc_TypeError$constants.SEGMENT.set(PyExc_TypeError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_UnboundLocalError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_UnboundLocalError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnboundLocalError
     * }
     */
    public static AddressLayout PyExc_UnboundLocalError$layout() {
        return PyExc_UnboundLocalError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnboundLocalError
     * }
     */
    public static MemorySegment PyExc_UnboundLocalError$segment() {
        return PyExc_UnboundLocalError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnboundLocalError
     * }
     */
    public static MemorySegment PyExc_UnboundLocalError() {
        return PyExc_UnboundLocalError$constants.SEGMENT.get(PyExc_UnboundLocalError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnboundLocalError
     * }
     */
    public static void PyExc_UnboundLocalError(MemorySegment varValue) {
        PyExc_UnboundLocalError$constants.SEGMENT.set(PyExc_UnboundLocalError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_UnicodeError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_UnicodeError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeError
     * }
     */
    public static AddressLayout PyExc_UnicodeError$layout() {
        return PyExc_UnicodeError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeError
     * }
     */
    public static MemorySegment PyExc_UnicodeError$segment() {
        return PyExc_UnicodeError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeError
     * }
     */
    public static MemorySegment PyExc_UnicodeError() {
        return PyExc_UnicodeError$constants.SEGMENT.get(PyExc_UnicodeError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeError
     * }
     */
    public static void PyExc_UnicodeError(MemorySegment varValue) {
        PyExc_UnicodeError$constants.SEGMENT.set(PyExc_UnicodeError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_UnicodeEncodeError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_UnicodeEncodeError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeEncodeError
     * }
     */
    public static AddressLayout PyExc_UnicodeEncodeError$layout() {
        return PyExc_UnicodeEncodeError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeEncodeError
     * }
     */
    public static MemorySegment PyExc_UnicodeEncodeError$segment() {
        return PyExc_UnicodeEncodeError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeEncodeError
     * }
     */
    public static MemorySegment PyExc_UnicodeEncodeError() {
        return PyExc_UnicodeEncodeError$constants.SEGMENT.get(PyExc_UnicodeEncodeError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeEncodeError
     * }
     */
    public static void PyExc_UnicodeEncodeError(MemorySegment varValue) {
        PyExc_UnicodeEncodeError$constants.SEGMENT.set(PyExc_UnicodeEncodeError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_UnicodeDecodeError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_UnicodeDecodeError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeDecodeError
     * }
     */
    public static AddressLayout PyExc_UnicodeDecodeError$layout() {
        return PyExc_UnicodeDecodeError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeDecodeError
     * }
     */
    public static MemorySegment PyExc_UnicodeDecodeError$segment() {
        return PyExc_UnicodeDecodeError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeDecodeError
     * }
     */
    public static MemorySegment PyExc_UnicodeDecodeError() {
        return PyExc_UnicodeDecodeError$constants.SEGMENT.get(PyExc_UnicodeDecodeError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeDecodeError
     * }
     */
    public static void PyExc_UnicodeDecodeError(MemorySegment varValue) {
        PyExc_UnicodeDecodeError$constants.SEGMENT.set(PyExc_UnicodeDecodeError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_UnicodeTranslateError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_UnicodeTranslateError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeTranslateError
     * }
     */
    public static AddressLayout PyExc_UnicodeTranslateError$layout() {
        return PyExc_UnicodeTranslateError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeTranslateError
     * }
     */
    public static MemorySegment PyExc_UnicodeTranslateError$segment() {
        return PyExc_UnicodeTranslateError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeTranslateError
     * }
     */
    public static MemorySegment PyExc_UnicodeTranslateError() {
        return PyExc_UnicodeTranslateError$constants.SEGMENT.get(PyExc_UnicodeTranslateError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeTranslateError
     * }
     */
    public static void PyExc_UnicodeTranslateError(MemorySegment varValue) {
        PyExc_UnicodeTranslateError$constants.SEGMENT.set(PyExc_UnicodeTranslateError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_ValueError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_ValueError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ValueError
     * }
     */
    public static AddressLayout PyExc_ValueError$layout() {
        return PyExc_ValueError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ValueError
     * }
     */
    public static MemorySegment PyExc_ValueError$segment() {
        return PyExc_ValueError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ValueError
     * }
     */
    public static MemorySegment PyExc_ValueError() {
        return PyExc_ValueError$constants.SEGMENT.get(PyExc_ValueError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ValueError
     * }
     */
    public static void PyExc_ValueError(MemorySegment varValue) {
        PyExc_ValueError$constants.SEGMENT.set(PyExc_ValueError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_ZeroDivisionError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_ZeroDivisionError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ZeroDivisionError
     * }
     */
    public static AddressLayout PyExc_ZeroDivisionError$layout() {
        return PyExc_ZeroDivisionError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ZeroDivisionError
     * }
     */
    public static MemorySegment PyExc_ZeroDivisionError$segment() {
        return PyExc_ZeroDivisionError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ZeroDivisionError
     * }
     */
    public static MemorySegment PyExc_ZeroDivisionError() {
        return PyExc_ZeroDivisionError$constants.SEGMENT.get(PyExc_ZeroDivisionError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ZeroDivisionError
     * }
     */
    public static void PyExc_ZeroDivisionError(MemorySegment varValue) {
        PyExc_ZeroDivisionError$constants.SEGMENT.set(PyExc_ZeroDivisionError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_BlockingIOError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_BlockingIOError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BlockingIOError
     * }
     */
    public static AddressLayout PyExc_BlockingIOError$layout() {
        return PyExc_BlockingIOError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BlockingIOError
     * }
     */
    public static MemorySegment PyExc_BlockingIOError$segment() {
        return PyExc_BlockingIOError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BlockingIOError
     * }
     */
    public static MemorySegment PyExc_BlockingIOError() {
        return PyExc_BlockingIOError$constants.SEGMENT.get(PyExc_BlockingIOError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BlockingIOError
     * }
     */
    public static void PyExc_BlockingIOError(MemorySegment varValue) {
        PyExc_BlockingIOError$constants.SEGMENT.set(PyExc_BlockingIOError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_BrokenPipeError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_BrokenPipeError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BrokenPipeError
     * }
     */
    public static AddressLayout PyExc_BrokenPipeError$layout() {
        return PyExc_BrokenPipeError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BrokenPipeError
     * }
     */
    public static MemorySegment PyExc_BrokenPipeError$segment() {
        return PyExc_BrokenPipeError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BrokenPipeError
     * }
     */
    public static MemorySegment PyExc_BrokenPipeError() {
        return PyExc_BrokenPipeError$constants.SEGMENT.get(PyExc_BrokenPipeError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BrokenPipeError
     * }
     */
    public static void PyExc_BrokenPipeError(MemorySegment varValue) {
        PyExc_BrokenPipeError$constants.SEGMENT.set(PyExc_BrokenPipeError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_ChildProcessError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_ChildProcessError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ChildProcessError
     * }
     */
    public static AddressLayout PyExc_ChildProcessError$layout() {
        return PyExc_ChildProcessError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ChildProcessError
     * }
     */
    public static MemorySegment PyExc_ChildProcessError$segment() {
        return PyExc_ChildProcessError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ChildProcessError
     * }
     */
    public static MemorySegment PyExc_ChildProcessError() {
        return PyExc_ChildProcessError$constants.SEGMENT.get(PyExc_ChildProcessError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ChildProcessError
     * }
     */
    public static void PyExc_ChildProcessError(MemorySegment varValue) {
        PyExc_ChildProcessError$constants.SEGMENT.set(PyExc_ChildProcessError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_ConnectionError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_ConnectionError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionError
     * }
     */
    public static AddressLayout PyExc_ConnectionError$layout() {
        return PyExc_ConnectionError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionError
     * }
     */
    public static MemorySegment PyExc_ConnectionError$segment() {
        return PyExc_ConnectionError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionError
     * }
     */
    public static MemorySegment PyExc_ConnectionError() {
        return PyExc_ConnectionError$constants.SEGMENT.get(PyExc_ConnectionError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionError
     * }
     */
    public static void PyExc_ConnectionError(MemorySegment varValue) {
        PyExc_ConnectionError$constants.SEGMENT.set(PyExc_ConnectionError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_ConnectionAbortedError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_ConnectionAbortedError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionAbortedError
     * }
     */
    public static AddressLayout PyExc_ConnectionAbortedError$layout() {
        return PyExc_ConnectionAbortedError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionAbortedError
     * }
     */
    public static MemorySegment PyExc_ConnectionAbortedError$segment() {
        return PyExc_ConnectionAbortedError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionAbortedError
     * }
     */
    public static MemorySegment PyExc_ConnectionAbortedError() {
        return PyExc_ConnectionAbortedError$constants.SEGMENT.get(PyExc_ConnectionAbortedError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionAbortedError
     * }
     */
    public static void PyExc_ConnectionAbortedError(MemorySegment varValue) {
        PyExc_ConnectionAbortedError$constants.SEGMENT.set(PyExc_ConnectionAbortedError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_ConnectionRefusedError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_ConnectionRefusedError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionRefusedError
     * }
     */
    public static AddressLayout PyExc_ConnectionRefusedError$layout() {
        return PyExc_ConnectionRefusedError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionRefusedError
     * }
     */
    public static MemorySegment PyExc_ConnectionRefusedError$segment() {
        return PyExc_ConnectionRefusedError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionRefusedError
     * }
     */
    public static MemorySegment PyExc_ConnectionRefusedError() {
        return PyExc_ConnectionRefusedError$constants.SEGMENT.get(PyExc_ConnectionRefusedError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionRefusedError
     * }
     */
    public static void PyExc_ConnectionRefusedError(MemorySegment varValue) {
        PyExc_ConnectionRefusedError$constants.SEGMENT.set(PyExc_ConnectionRefusedError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_ConnectionResetError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_ConnectionResetError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionResetError
     * }
     */
    public static AddressLayout PyExc_ConnectionResetError$layout() {
        return PyExc_ConnectionResetError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionResetError
     * }
     */
    public static MemorySegment PyExc_ConnectionResetError$segment() {
        return PyExc_ConnectionResetError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionResetError
     * }
     */
    public static MemorySegment PyExc_ConnectionResetError() {
        return PyExc_ConnectionResetError$constants.SEGMENT.get(PyExc_ConnectionResetError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ConnectionResetError
     * }
     */
    public static void PyExc_ConnectionResetError(MemorySegment varValue) {
        PyExc_ConnectionResetError$constants.SEGMENT.set(PyExc_ConnectionResetError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_FileExistsError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_FileExistsError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FileExistsError
     * }
     */
    public static AddressLayout PyExc_FileExistsError$layout() {
        return PyExc_FileExistsError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FileExistsError
     * }
     */
    public static MemorySegment PyExc_FileExistsError$segment() {
        return PyExc_FileExistsError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FileExistsError
     * }
     */
    public static MemorySegment PyExc_FileExistsError() {
        return PyExc_FileExistsError$constants.SEGMENT.get(PyExc_FileExistsError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FileExistsError
     * }
     */
    public static void PyExc_FileExistsError(MemorySegment varValue) {
        PyExc_FileExistsError$constants.SEGMENT.set(PyExc_FileExistsError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_FileNotFoundError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_FileNotFoundError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FileNotFoundError
     * }
     */
    public static AddressLayout PyExc_FileNotFoundError$layout() {
        return PyExc_FileNotFoundError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FileNotFoundError
     * }
     */
    public static MemorySegment PyExc_FileNotFoundError$segment() {
        return PyExc_FileNotFoundError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FileNotFoundError
     * }
     */
    public static MemorySegment PyExc_FileNotFoundError() {
        return PyExc_FileNotFoundError$constants.SEGMENT.get(PyExc_FileNotFoundError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FileNotFoundError
     * }
     */
    public static void PyExc_FileNotFoundError(MemorySegment varValue) {
        PyExc_FileNotFoundError$constants.SEGMENT.set(PyExc_FileNotFoundError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_InterruptedError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_InterruptedError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_InterruptedError
     * }
     */
    public static AddressLayout PyExc_InterruptedError$layout() {
        return PyExc_InterruptedError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_InterruptedError
     * }
     */
    public static MemorySegment PyExc_InterruptedError$segment() {
        return PyExc_InterruptedError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_InterruptedError
     * }
     */
    public static MemorySegment PyExc_InterruptedError() {
        return PyExc_InterruptedError$constants.SEGMENT.get(PyExc_InterruptedError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_InterruptedError
     * }
     */
    public static void PyExc_InterruptedError(MemorySegment varValue) {
        PyExc_InterruptedError$constants.SEGMENT.set(PyExc_InterruptedError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_IsADirectoryError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_IsADirectoryError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IsADirectoryError
     * }
     */
    public static AddressLayout PyExc_IsADirectoryError$layout() {
        return PyExc_IsADirectoryError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IsADirectoryError
     * }
     */
    public static MemorySegment PyExc_IsADirectoryError$segment() {
        return PyExc_IsADirectoryError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IsADirectoryError
     * }
     */
    public static MemorySegment PyExc_IsADirectoryError() {
        return PyExc_IsADirectoryError$constants.SEGMENT.get(PyExc_IsADirectoryError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IsADirectoryError
     * }
     */
    public static void PyExc_IsADirectoryError(MemorySegment varValue) {
        PyExc_IsADirectoryError$constants.SEGMENT.set(PyExc_IsADirectoryError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_NotADirectoryError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_NotADirectoryError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_NotADirectoryError
     * }
     */
    public static AddressLayout PyExc_NotADirectoryError$layout() {
        return PyExc_NotADirectoryError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_NotADirectoryError
     * }
     */
    public static MemorySegment PyExc_NotADirectoryError$segment() {
        return PyExc_NotADirectoryError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_NotADirectoryError
     * }
     */
    public static MemorySegment PyExc_NotADirectoryError() {
        return PyExc_NotADirectoryError$constants.SEGMENT.get(PyExc_NotADirectoryError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_NotADirectoryError
     * }
     */
    public static void PyExc_NotADirectoryError(MemorySegment varValue) {
        PyExc_NotADirectoryError$constants.SEGMENT.set(PyExc_NotADirectoryError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_PermissionError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_PermissionError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_PermissionError
     * }
     */
    public static AddressLayout PyExc_PermissionError$layout() {
        return PyExc_PermissionError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_PermissionError
     * }
     */
    public static MemorySegment PyExc_PermissionError$segment() {
        return PyExc_PermissionError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_PermissionError
     * }
     */
    public static MemorySegment PyExc_PermissionError() {
        return PyExc_PermissionError$constants.SEGMENT.get(PyExc_PermissionError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_PermissionError
     * }
     */
    public static void PyExc_PermissionError(MemorySegment varValue) {
        PyExc_PermissionError$constants.SEGMENT.set(PyExc_PermissionError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_ProcessLookupError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_ProcessLookupError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ProcessLookupError
     * }
     */
    public static AddressLayout PyExc_ProcessLookupError$layout() {
        return PyExc_ProcessLookupError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ProcessLookupError
     * }
     */
    public static MemorySegment PyExc_ProcessLookupError$segment() {
        return PyExc_ProcessLookupError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ProcessLookupError
     * }
     */
    public static MemorySegment PyExc_ProcessLookupError() {
        return PyExc_ProcessLookupError$constants.SEGMENT.get(PyExc_ProcessLookupError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ProcessLookupError
     * }
     */
    public static void PyExc_ProcessLookupError(MemorySegment varValue) {
        PyExc_ProcessLookupError$constants.SEGMENT.set(PyExc_ProcessLookupError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_TimeoutError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_TimeoutError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_TimeoutError
     * }
     */
    public static AddressLayout PyExc_TimeoutError$layout() {
        return PyExc_TimeoutError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_TimeoutError
     * }
     */
    public static MemorySegment PyExc_TimeoutError$segment() {
        return PyExc_TimeoutError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_TimeoutError
     * }
     */
    public static MemorySegment PyExc_TimeoutError() {
        return PyExc_TimeoutError$constants.SEGMENT.get(PyExc_TimeoutError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_TimeoutError
     * }
     */
    public static void PyExc_TimeoutError(MemorySegment varValue) {
        PyExc_TimeoutError$constants.SEGMENT.set(PyExc_TimeoutError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_EnvironmentError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_EnvironmentError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_EnvironmentError
     * }
     */
    public static AddressLayout PyExc_EnvironmentError$layout() {
        return PyExc_EnvironmentError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_EnvironmentError
     * }
     */
    public static MemorySegment PyExc_EnvironmentError$segment() {
        return PyExc_EnvironmentError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_EnvironmentError
     * }
     */
    public static MemorySegment PyExc_EnvironmentError() {
        return PyExc_EnvironmentError$constants.SEGMENT.get(PyExc_EnvironmentError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_EnvironmentError
     * }
     */
    public static void PyExc_EnvironmentError(MemorySegment varValue) {
        PyExc_EnvironmentError$constants.SEGMENT.set(PyExc_EnvironmentError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_IOError$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_IOError").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IOError
     * }
     */
    public static AddressLayout PyExc_IOError$layout() {
        return PyExc_IOError$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IOError
     * }
     */
    public static MemorySegment PyExc_IOError$segment() {
        return PyExc_IOError$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IOError
     * }
     */
    public static MemorySegment PyExc_IOError() {
        return PyExc_IOError$constants.SEGMENT.get(PyExc_IOError$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_IOError
     * }
     */
    public static void PyExc_IOError(MemorySegment varValue) {
        PyExc_IOError$constants.SEGMENT.set(PyExc_IOError$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_Warning$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_Warning").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_Warning
     * }
     */
    public static AddressLayout PyExc_Warning$layout() {
        return PyExc_Warning$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_Warning
     * }
     */
    public static MemorySegment PyExc_Warning$segment() {
        return PyExc_Warning$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_Warning
     * }
     */
    public static MemorySegment PyExc_Warning() {
        return PyExc_Warning$constants.SEGMENT.get(PyExc_Warning$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_Warning
     * }
     */
    public static void PyExc_Warning(MemorySegment varValue) {
        PyExc_Warning$constants.SEGMENT.set(PyExc_Warning$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_UserWarning$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_UserWarning").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UserWarning
     * }
     */
    public static AddressLayout PyExc_UserWarning$layout() {
        return PyExc_UserWarning$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UserWarning
     * }
     */
    public static MemorySegment PyExc_UserWarning$segment() {
        return PyExc_UserWarning$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UserWarning
     * }
     */
    public static MemorySegment PyExc_UserWarning() {
        return PyExc_UserWarning$constants.SEGMENT.get(PyExc_UserWarning$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UserWarning
     * }
     */
    public static void PyExc_UserWarning(MemorySegment varValue) {
        PyExc_UserWarning$constants.SEGMENT.set(PyExc_UserWarning$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_DeprecationWarning$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_DeprecationWarning").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_DeprecationWarning
     * }
     */
    public static AddressLayout PyExc_DeprecationWarning$layout() {
        return PyExc_DeprecationWarning$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_DeprecationWarning
     * }
     */
    public static MemorySegment PyExc_DeprecationWarning$segment() {
        return PyExc_DeprecationWarning$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_DeprecationWarning
     * }
     */
    public static MemorySegment PyExc_DeprecationWarning() {
        return PyExc_DeprecationWarning$constants.SEGMENT.get(PyExc_DeprecationWarning$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_DeprecationWarning
     * }
     */
    public static void PyExc_DeprecationWarning(MemorySegment varValue) {
        PyExc_DeprecationWarning$constants.SEGMENT.set(PyExc_DeprecationWarning$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_PendingDeprecationWarning$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_PendingDeprecationWarning").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_PendingDeprecationWarning
     * }
     */
    public static AddressLayout PyExc_PendingDeprecationWarning$layout() {
        return PyExc_PendingDeprecationWarning$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_PendingDeprecationWarning
     * }
     */
    public static MemorySegment PyExc_PendingDeprecationWarning$segment() {
        return PyExc_PendingDeprecationWarning$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_PendingDeprecationWarning
     * }
     */
    public static MemorySegment PyExc_PendingDeprecationWarning() {
        return PyExc_PendingDeprecationWarning$constants.SEGMENT.get(PyExc_PendingDeprecationWarning$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_PendingDeprecationWarning
     * }
     */
    public static void PyExc_PendingDeprecationWarning(MemorySegment varValue) {
        PyExc_PendingDeprecationWarning$constants.SEGMENT.set(PyExc_PendingDeprecationWarning$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_SyntaxWarning$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_SyntaxWarning").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SyntaxWarning
     * }
     */
    public static AddressLayout PyExc_SyntaxWarning$layout() {
        return PyExc_SyntaxWarning$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SyntaxWarning
     * }
     */
    public static MemorySegment PyExc_SyntaxWarning$segment() {
        return PyExc_SyntaxWarning$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SyntaxWarning
     * }
     */
    public static MemorySegment PyExc_SyntaxWarning() {
        return PyExc_SyntaxWarning$constants.SEGMENT.get(PyExc_SyntaxWarning$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_SyntaxWarning
     * }
     */
    public static void PyExc_SyntaxWarning(MemorySegment varValue) {
        PyExc_SyntaxWarning$constants.SEGMENT.set(PyExc_SyntaxWarning$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_RuntimeWarning$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_RuntimeWarning").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_RuntimeWarning
     * }
     */
    public static AddressLayout PyExc_RuntimeWarning$layout() {
        return PyExc_RuntimeWarning$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_RuntimeWarning
     * }
     */
    public static MemorySegment PyExc_RuntimeWarning$segment() {
        return PyExc_RuntimeWarning$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_RuntimeWarning
     * }
     */
    public static MemorySegment PyExc_RuntimeWarning() {
        return PyExc_RuntimeWarning$constants.SEGMENT.get(PyExc_RuntimeWarning$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_RuntimeWarning
     * }
     */
    public static void PyExc_RuntimeWarning(MemorySegment varValue) {
        PyExc_RuntimeWarning$constants.SEGMENT.set(PyExc_RuntimeWarning$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_FutureWarning$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_FutureWarning").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FutureWarning
     * }
     */
    public static AddressLayout PyExc_FutureWarning$layout() {
        return PyExc_FutureWarning$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FutureWarning
     * }
     */
    public static MemorySegment PyExc_FutureWarning$segment() {
        return PyExc_FutureWarning$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FutureWarning
     * }
     */
    public static MemorySegment PyExc_FutureWarning() {
        return PyExc_FutureWarning$constants.SEGMENT.get(PyExc_FutureWarning$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_FutureWarning
     * }
     */
    public static void PyExc_FutureWarning(MemorySegment varValue) {
        PyExc_FutureWarning$constants.SEGMENT.set(PyExc_FutureWarning$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_ImportWarning$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_ImportWarning").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ImportWarning
     * }
     */
    public static AddressLayout PyExc_ImportWarning$layout() {
        return PyExc_ImportWarning$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ImportWarning
     * }
     */
    public static MemorySegment PyExc_ImportWarning$segment() {
        return PyExc_ImportWarning$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ImportWarning
     * }
     */
    public static MemorySegment PyExc_ImportWarning() {
        return PyExc_ImportWarning$constants.SEGMENT.get(PyExc_ImportWarning$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ImportWarning
     * }
     */
    public static void PyExc_ImportWarning(MemorySegment varValue) {
        PyExc_ImportWarning$constants.SEGMENT.set(PyExc_ImportWarning$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_UnicodeWarning$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_UnicodeWarning").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeWarning
     * }
     */
    public static AddressLayout PyExc_UnicodeWarning$layout() {
        return PyExc_UnicodeWarning$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeWarning
     * }
     */
    public static MemorySegment PyExc_UnicodeWarning$segment() {
        return PyExc_UnicodeWarning$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeWarning
     * }
     */
    public static MemorySegment PyExc_UnicodeWarning() {
        return PyExc_UnicodeWarning$constants.SEGMENT.get(PyExc_UnicodeWarning$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_UnicodeWarning
     * }
     */
    public static void PyExc_UnicodeWarning(MemorySegment varValue) {
        PyExc_UnicodeWarning$constants.SEGMENT.set(PyExc_UnicodeWarning$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_BytesWarning$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_BytesWarning").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BytesWarning
     * }
     */
    public static AddressLayout PyExc_BytesWarning$layout() {
        return PyExc_BytesWarning$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BytesWarning
     * }
     */
    public static MemorySegment PyExc_BytesWarning$segment() {
        return PyExc_BytesWarning$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BytesWarning
     * }
     */
    public static MemorySegment PyExc_BytesWarning() {
        return PyExc_BytesWarning$constants.SEGMENT.get(PyExc_BytesWarning$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_BytesWarning
     * }
     */
    public static void PyExc_BytesWarning(MemorySegment varValue) {
        PyExc_BytesWarning$constants.SEGMENT.set(PyExc_BytesWarning$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_EncodingWarning$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_EncodingWarning").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_EncodingWarning
     * }
     */
    public static AddressLayout PyExc_EncodingWarning$layout() {
        return PyExc_EncodingWarning$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_EncodingWarning
     * }
     */
    public static MemorySegment PyExc_EncodingWarning$segment() {
        return PyExc_EncodingWarning$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_EncodingWarning
     * }
     */
    public static MemorySegment PyExc_EncodingWarning() {
        return PyExc_EncodingWarning$constants.SEGMENT.get(PyExc_EncodingWarning$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_EncodingWarning
     * }
     */
    public static void PyExc_EncodingWarning(MemorySegment varValue) {
        PyExc_EncodingWarning$constants.SEGMENT.set(PyExc_EncodingWarning$constants.LAYOUT, 0L, varValue);
    }

    private static class PyExc_ResourceWarning$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyExc_ResourceWarning").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ResourceWarning
     * }
     */
    public static AddressLayout PyExc_ResourceWarning$layout() {
        return PyExc_ResourceWarning$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ResourceWarning
     * }
     */
    public static MemorySegment PyExc_ResourceWarning$segment() {
        return PyExc_ResourceWarning$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ResourceWarning
     * }
     */
    public static MemorySegment PyExc_ResourceWarning() {
        return PyExc_ResourceWarning$constants.SEGMENT.get(PyExc_ResourceWarning$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject *PyExc_ResourceWarning
     * }
     */
    public static void PyExc_ResourceWarning(MemorySegment varValue) {
        PyExc_ResourceWarning$constants.SEGMENT.set(PyExc_ResourceWarning$constants.LAYOUT, 0L, varValue);
    }

    private static class PyErr_BadArgument {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_BadArgument");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyErr_BadArgument()
     * }
     */
    public static FunctionDescriptor PyErr_BadArgument$descriptor() {
        return PyErr_BadArgument.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyErr_BadArgument()
     * }
     */
    public static MethodHandle PyErr_BadArgument$handle() {
        return PyErr_BadArgument.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyErr_BadArgument()
     * }
     */
    public static MemorySegment PyErr_BadArgument$address() {
        return PyErr_BadArgument.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyErr_BadArgument()
     * }
     */
    public static int PyErr_BadArgument() {
        var mh$ = PyErr_BadArgument.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_BadArgument");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_NoMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_NoMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_NoMemory()
     * }
     */
    public static FunctionDescriptor PyErr_NoMemory$descriptor() {
        return PyErr_NoMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_NoMemory()
     * }
     */
    public static MethodHandle PyErr_NoMemory$handle() {
        return PyErr_NoMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_NoMemory()
     * }
     */
    public static MemorySegment PyErr_NoMemory$address() {
        return PyErr_NoMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_NoMemory()
     * }
     */
    public static MemorySegment PyErr_NoMemory() {
        var mh$ = PyErr_NoMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_NoMemory");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SetFromErrno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetFromErrno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrno(PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_SetFromErrno$descriptor() {
        return PyErr_SetFromErrno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrno(PyObject *)
     * }
     */
    public static MethodHandle PyErr_SetFromErrno$handle() {
        return PyErr_SetFromErrno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrno(PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetFromErrno$address() {
        return PyErr_SetFromErrno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrno(PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetFromErrno(MemorySegment x0) {
        var mh$ = PyErr_SetFromErrno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetFromErrno", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SetFromErrnoWithFilenameObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetFromErrnoWithFilenameObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrnoWithFilenameObject(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_SetFromErrnoWithFilenameObject$descriptor() {
        return PyErr_SetFromErrnoWithFilenameObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrnoWithFilenameObject(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyErr_SetFromErrnoWithFilenameObject$handle() {
        return PyErr_SetFromErrnoWithFilenameObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrnoWithFilenameObject(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetFromErrnoWithFilenameObject$address() {
        return PyErr_SetFromErrnoWithFilenameObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrnoWithFilenameObject(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetFromErrnoWithFilenameObject(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyErr_SetFromErrnoWithFilenameObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetFromErrnoWithFilenameObject", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SetFromErrnoWithFilenameObjects {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetFromErrnoWithFilenameObjects");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrnoWithFilenameObjects(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_SetFromErrnoWithFilenameObjects$descriptor() {
        return PyErr_SetFromErrnoWithFilenameObjects.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrnoWithFilenameObjects(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyErr_SetFromErrnoWithFilenameObjects$handle() {
        return PyErr_SetFromErrnoWithFilenameObjects.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrnoWithFilenameObjects(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetFromErrnoWithFilenameObjects$address() {
        return PyErr_SetFromErrnoWithFilenameObjects.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrnoWithFilenameObjects(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetFromErrnoWithFilenameObjects(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyErr_SetFromErrnoWithFilenameObjects.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetFromErrnoWithFilenameObjects", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SetFromErrnoWithFilename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetFromErrnoWithFilename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrnoWithFilename(PyObject *exc, const char *filename)
     * }
     */
    public static FunctionDescriptor PyErr_SetFromErrnoWithFilename$descriptor() {
        return PyErr_SetFromErrnoWithFilename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrnoWithFilename(PyObject *exc, const char *filename)
     * }
     */
    public static MethodHandle PyErr_SetFromErrnoWithFilename$handle() {
        return PyErr_SetFromErrnoWithFilename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrnoWithFilename(PyObject *exc, const char *filename)
     * }
     */
    public static MemorySegment PyErr_SetFromErrnoWithFilename$address() {
        return PyErr_SetFromErrnoWithFilename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_SetFromErrnoWithFilename(PyObject *exc, const char *filename)
     * }
     */
    public static MemorySegment PyErr_SetFromErrnoWithFilename(MemorySegment exc, MemorySegment filename) {
        var mh$ = PyErr_SetFromErrnoWithFilename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetFromErrnoWithFilename", exc, filename);
            }
            return (MemorySegment)mh$.invokeExact(exc, filename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *PyErr_Format(PyObject *exception, const char *format, ...)
     * }
     */
    public static class PyErr_Format {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_Format");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyErr_Format(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *PyErr_Format(PyObject *exception, const char *format, ...)
         * }
         */
        public static PyErr_Format makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyErr_Format(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment exception, MemorySegment format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyErr_Format", exception, format, x2);
                }
                return (MemorySegment)spreader.invokeExact(exception, format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class PyErr_FormatV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_FormatV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_FormatV(PyObject *exception, const char *format, va_list vargs)
     * }
     */
    public static FunctionDescriptor PyErr_FormatV$descriptor() {
        return PyErr_FormatV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_FormatV(PyObject *exception, const char *format, va_list vargs)
     * }
     */
    public static MethodHandle PyErr_FormatV$handle() {
        return PyErr_FormatV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_FormatV(PyObject *exception, const char *format, va_list vargs)
     * }
     */
    public static MemorySegment PyErr_FormatV$address() {
        return PyErr_FormatV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_FormatV(PyObject *exception, const char *format, va_list vargs)
     * }
     */
    public static MemorySegment PyErr_FormatV(MemorySegment exception, MemorySegment format, MemorySegment vargs) {
        var mh$ = PyErr_FormatV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_FormatV", exception, format, vargs);
            }
            return (MemorySegment)mh$.invokeExact(exception, format, vargs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SetImportErrorSubclass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetImportErrorSubclass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetImportErrorSubclass(PyObject *, PyObject *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_SetImportErrorSubclass$descriptor() {
        return PyErr_SetImportErrorSubclass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetImportErrorSubclass(PyObject *, PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyErr_SetImportErrorSubclass$handle() {
        return PyErr_SetImportErrorSubclass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetImportErrorSubclass(PyObject *, PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetImportErrorSubclass$address() {
        return PyErr_SetImportErrorSubclass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_SetImportErrorSubclass(PyObject *, PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetImportErrorSubclass(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = PyErr_SetImportErrorSubclass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetImportErrorSubclass", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SetImportError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetImportError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetImportError(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_SetImportError$descriptor() {
        return PyErr_SetImportError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetImportError(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyErr_SetImportError$handle() {
        return PyErr_SetImportError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_SetImportError(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetImportError$address() {
        return PyErr_SetImportError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_SetImportError(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyErr_SetImportError(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyErr_SetImportError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetImportError", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_BadInternalCall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_BadInternalCall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_BadInternalCall()
     * }
     */
    public static FunctionDescriptor PyErr_BadInternalCall$descriptor() {
        return PyErr_BadInternalCall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_BadInternalCall()
     * }
     */
    public static MethodHandle PyErr_BadInternalCall$handle() {
        return PyErr_BadInternalCall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_BadInternalCall()
     * }
     */
    public static MemorySegment PyErr_BadInternalCall$address() {
        return PyErr_BadInternalCall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_BadInternalCall()
     * }
     */
    public static void PyErr_BadInternalCall() {
        var mh$ = PyErr_BadInternalCall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_BadInternalCall");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyErr_BadInternalCall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyErr_BadInternalCall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyErr_BadInternalCall(const char *filename, int lineno)
     * }
     */
    public static FunctionDescriptor _PyErr_BadInternalCall$descriptor() {
        return _PyErr_BadInternalCall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyErr_BadInternalCall(const char *filename, int lineno)
     * }
     */
    public static MethodHandle _PyErr_BadInternalCall$handle() {
        return _PyErr_BadInternalCall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyErr_BadInternalCall(const char *filename, int lineno)
     * }
     */
    public static MemorySegment _PyErr_BadInternalCall$address() {
        return _PyErr_BadInternalCall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyErr_BadInternalCall(const char *filename, int lineno)
     * }
     */
    public static void _PyErr_BadInternalCall(MemorySegment filename, int lineno) {
        var mh$ = _PyErr_BadInternalCall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyErr_BadInternalCall", filename, lineno);
            }
            mh$.invokeExact(filename, lineno);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_NewException {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_NewException");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_NewException(const char *name, PyObject *base, PyObject *dict)
     * }
     */
    public static FunctionDescriptor PyErr_NewException$descriptor() {
        return PyErr_NewException.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_NewException(const char *name, PyObject *base, PyObject *dict)
     * }
     */
    public static MethodHandle PyErr_NewException$handle() {
        return PyErr_NewException.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_NewException(const char *name, PyObject *base, PyObject *dict)
     * }
     */
    public static MemorySegment PyErr_NewException$address() {
        return PyErr_NewException.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_NewException(const char *name, PyObject *base, PyObject *dict)
     * }
     */
    public static MemorySegment PyErr_NewException(MemorySegment name, MemorySegment base, MemorySegment dict) {
        var mh$ = PyErr_NewException.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_NewException", name, base, dict);
            }
            return (MemorySegment)mh$.invokeExact(name, base, dict);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_NewExceptionWithDoc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_NewExceptionWithDoc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_NewExceptionWithDoc(const char *name, const char *doc, PyObject *base, PyObject *dict)
     * }
     */
    public static FunctionDescriptor PyErr_NewExceptionWithDoc$descriptor() {
        return PyErr_NewExceptionWithDoc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_NewExceptionWithDoc(const char *name, const char *doc, PyObject *base, PyObject *dict)
     * }
     */
    public static MethodHandle PyErr_NewExceptionWithDoc$handle() {
        return PyErr_NewExceptionWithDoc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_NewExceptionWithDoc(const char *name, const char *doc, PyObject *base, PyObject *dict)
     * }
     */
    public static MemorySegment PyErr_NewExceptionWithDoc$address() {
        return PyErr_NewExceptionWithDoc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_NewExceptionWithDoc(const char *name, const char *doc, PyObject *base, PyObject *dict)
     * }
     */
    public static MemorySegment PyErr_NewExceptionWithDoc(MemorySegment name, MemorySegment doc, MemorySegment base, MemorySegment dict) {
        var mh$ = PyErr_NewExceptionWithDoc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_NewExceptionWithDoc", name, doc, base, dict);
            }
            return (MemorySegment)mh$.invokeExact(name, doc, base, dict);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_WriteUnraisable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_WriteUnraisable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_WriteUnraisable(PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_WriteUnraisable$descriptor() {
        return PyErr_WriteUnraisable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_WriteUnraisable(PyObject *)
     * }
     */
    public static MethodHandle PyErr_WriteUnraisable$handle() {
        return PyErr_WriteUnraisable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_WriteUnraisable(PyObject *)
     * }
     */
    public static MemorySegment PyErr_WriteUnraisable$address() {
        return PyErr_WriteUnraisable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_WriteUnraisable(PyObject *)
     * }
     */
    public static void PyErr_WriteUnraisable(MemorySegment x0) {
        var mh$ = PyErr_WriteUnraisable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_WriteUnraisable", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_CheckSignals {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_CheckSignals");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyErr_CheckSignals()
     * }
     */
    public static FunctionDescriptor PyErr_CheckSignals$descriptor() {
        return PyErr_CheckSignals.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyErr_CheckSignals()
     * }
     */
    public static MethodHandle PyErr_CheckSignals$handle() {
        return PyErr_CheckSignals.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyErr_CheckSignals()
     * }
     */
    public static MemorySegment PyErr_CheckSignals$address() {
        return PyErr_CheckSignals.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyErr_CheckSignals()
     * }
     */
    public static int PyErr_CheckSignals() {
        var mh$ = PyErr_CheckSignals.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_CheckSignals");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SetInterrupt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetInterrupt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_SetInterrupt()
     * }
     */
    public static FunctionDescriptor PyErr_SetInterrupt$descriptor() {
        return PyErr_SetInterrupt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_SetInterrupt()
     * }
     */
    public static MethodHandle PyErr_SetInterrupt$handle() {
        return PyErr_SetInterrupt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_SetInterrupt()
     * }
     */
    public static MemorySegment PyErr_SetInterrupt$address() {
        return PyErr_SetInterrupt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_SetInterrupt()
     * }
     */
    public static void PyErr_SetInterrupt() {
        var mh$ = PyErr_SetInterrupt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetInterrupt");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SetInterruptEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SetInterruptEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyErr_SetInterruptEx(int signum)
     * }
     */
    public static FunctionDescriptor PyErr_SetInterruptEx$descriptor() {
        return PyErr_SetInterruptEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyErr_SetInterruptEx(int signum)
     * }
     */
    public static MethodHandle PyErr_SetInterruptEx$handle() {
        return PyErr_SetInterruptEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyErr_SetInterruptEx(int signum)
     * }
     */
    public static MemorySegment PyErr_SetInterruptEx$address() {
        return PyErr_SetInterruptEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyErr_SetInterruptEx(int signum)
     * }
     */
    public static int PyErr_SetInterruptEx(int signum) {
        var mh$ = PyErr_SetInterruptEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SetInterruptEx", signum);
            }
            return (int)mh$.invokeExact(signum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SyntaxLocation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SyntaxLocation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_SyntaxLocation(const char *filename, int lineno)
     * }
     */
    public static FunctionDescriptor PyErr_SyntaxLocation$descriptor() {
        return PyErr_SyntaxLocation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_SyntaxLocation(const char *filename, int lineno)
     * }
     */
    public static MethodHandle PyErr_SyntaxLocation$handle() {
        return PyErr_SyntaxLocation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_SyntaxLocation(const char *filename, int lineno)
     * }
     */
    public static MemorySegment PyErr_SyntaxLocation$address() {
        return PyErr_SyntaxLocation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_SyntaxLocation(const char *filename, int lineno)
     * }
     */
    public static void PyErr_SyntaxLocation(MemorySegment filename, int lineno) {
        var mh$ = PyErr_SyntaxLocation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SyntaxLocation", filename, lineno);
            }
            mh$.invokeExact(filename, lineno);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SyntaxLocationEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SyntaxLocationEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_SyntaxLocationEx(const char *filename, int lineno, int col_offset)
     * }
     */
    public static FunctionDescriptor PyErr_SyntaxLocationEx$descriptor() {
        return PyErr_SyntaxLocationEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_SyntaxLocationEx(const char *filename, int lineno, int col_offset)
     * }
     */
    public static MethodHandle PyErr_SyntaxLocationEx$handle() {
        return PyErr_SyntaxLocationEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_SyntaxLocationEx(const char *filename, int lineno, int col_offset)
     * }
     */
    public static MemorySegment PyErr_SyntaxLocationEx$address() {
        return PyErr_SyntaxLocationEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_SyntaxLocationEx(const char *filename, int lineno, int col_offset)
     * }
     */
    public static void PyErr_SyntaxLocationEx(MemorySegment filename, int lineno, int col_offset) {
        var mh$ = PyErr_SyntaxLocationEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SyntaxLocationEx", filename, lineno, col_offset);
            }
            mh$.invokeExact(filename, lineno, col_offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_ProgramText {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_ProgramText");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_ProgramText(const char *filename, int lineno)
     * }
     */
    public static FunctionDescriptor PyErr_ProgramText$descriptor() {
        return PyErr_ProgramText.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_ProgramText(const char *filename, int lineno)
     * }
     */
    public static MethodHandle PyErr_ProgramText$handle() {
        return PyErr_ProgramText.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_ProgramText(const char *filename, int lineno)
     * }
     */
    public static MemorySegment PyErr_ProgramText$address() {
        return PyErr_ProgramText.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_ProgramText(const char *filename, int lineno)
     * }
     */
    public static MemorySegment PyErr_ProgramText(MemorySegment filename, int lineno) {
        var mh$ = PyErr_ProgramText.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_ProgramText", filename, lineno);
            }
            return (MemorySegment)mh$.invokeExact(filename, lineno);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeDecodeError_Create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeDecodeError_Create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_Create(const char *encoding, const char *object, Py_ssize_t length, Py_ssize_t start, Py_ssize_t end, const char *reason)
     * }
     */
    public static FunctionDescriptor PyUnicodeDecodeError_Create$descriptor() {
        return PyUnicodeDecodeError_Create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_Create(const char *encoding, const char *object, Py_ssize_t length, Py_ssize_t start, Py_ssize_t end, const char *reason)
     * }
     */
    public static MethodHandle PyUnicodeDecodeError_Create$handle() {
        return PyUnicodeDecodeError_Create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_Create(const char *encoding, const char *object, Py_ssize_t length, Py_ssize_t start, Py_ssize_t end, const char *reason)
     * }
     */
    public static MemorySegment PyUnicodeDecodeError_Create$address() {
        return PyUnicodeDecodeError_Create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_Create(const char *encoding, const char *object, Py_ssize_t length, Py_ssize_t start, Py_ssize_t end, const char *reason)
     * }
     */
    public static MemorySegment PyUnicodeDecodeError_Create(MemorySegment encoding, MemorySegment object, long length, long start, long end, MemorySegment reason) {
        var mh$ = PyUnicodeDecodeError_Create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeDecodeError_Create", encoding, object, length, start, end, reason);
            }
            return (MemorySegment)mh$.invokeExact(encoding, object, length, start, end, reason);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeEncodeError_GetEncoding {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeEncodeError_GetEncoding");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeEncodeError_GetEncoding(PyObject *)
     * }
     */
    public static FunctionDescriptor PyUnicodeEncodeError_GetEncoding$descriptor() {
        return PyUnicodeEncodeError_GetEncoding.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeEncodeError_GetEncoding(PyObject *)
     * }
     */
    public static MethodHandle PyUnicodeEncodeError_GetEncoding$handle() {
        return PyUnicodeEncodeError_GetEncoding.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeEncodeError_GetEncoding(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeEncodeError_GetEncoding$address() {
        return PyUnicodeEncodeError_GetEncoding.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicodeEncodeError_GetEncoding(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeEncodeError_GetEncoding(MemorySegment x0) {
        var mh$ = PyUnicodeEncodeError_GetEncoding.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeEncodeError_GetEncoding", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeDecodeError_GetEncoding {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeDecodeError_GetEncoding");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_GetEncoding(PyObject *)
     * }
     */
    public static FunctionDescriptor PyUnicodeDecodeError_GetEncoding$descriptor() {
        return PyUnicodeDecodeError_GetEncoding.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_GetEncoding(PyObject *)
     * }
     */
    public static MethodHandle PyUnicodeDecodeError_GetEncoding$handle() {
        return PyUnicodeDecodeError_GetEncoding.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_GetEncoding(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeDecodeError_GetEncoding$address() {
        return PyUnicodeDecodeError_GetEncoding.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_GetEncoding(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeDecodeError_GetEncoding(MemorySegment x0) {
        var mh$ = PyUnicodeDecodeError_GetEncoding.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeDecodeError_GetEncoding", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeEncodeError_GetObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeEncodeError_GetObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeEncodeError_GetObject(PyObject *)
     * }
     */
    public static FunctionDescriptor PyUnicodeEncodeError_GetObject$descriptor() {
        return PyUnicodeEncodeError_GetObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeEncodeError_GetObject(PyObject *)
     * }
     */
    public static MethodHandle PyUnicodeEncodeError_GetObject$handle() {
        return PyUnicodeEncodeError_GetObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeEncodeError_GetObject(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeEncodeError_GetObject$address() {
        return PyUnicodeEncodeError_GetObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicodeEncodeError_GetObject(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeEncodeError_GetObject(MemorySegment x0) {
        var mh$ = PyUnicodeEncodeError_GetObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeEncodeError_GetObject", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeDecodeError_GetObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeDecodeError_GetObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_GetObject(PyObject *)
     * }
     */
    public static FunctionDescriptor PyUnicodeDecodeError_GetObject$descriptor() {
        return PyUnicodeDecodeError_GetObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_GetObject(PyObject *)
     * }
     */
    public static MethodHandle PyUnicodeDecodeError_GetObject$handle() {
        return PyUnicodeDecodeError_GetObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_GetObject(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeDecodeError_GetObject$address() {
        return PyUnicodeDecodeError_GetObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_GetObject(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeDecodeError_GetObject(MemorySegment x0) {
        var mh$ = PyUnicodeDecodeError_GetObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeDecodeError_GetObject", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeTranslateError_GetObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeTranslateError_GetObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeTranslateError_GetObject(PyObject *)
     * }
     */
    public static FunctionDescriptor PyUnicodeTranslateError_GetObject$descriptor() {
        return PyUnicodeTranslateError_GetObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeTranslateError_GetObject(PyObject *)
     * }
     */
    public static MethodHandle PyUnicodeTranslateError_GetObject$handle() {
        return PyUnicodeTranslateError_GetObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeTranslateError_GetObject(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeTranslateError_GetObject$address() {
        return PyUnicodeTranslateError_GetObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicodeTranslateError_GetObject(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeTranslateError_GetObject(MemorySegment x0) {
        var mh$ = PyUnicodeTranslateError_GetObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeTranslateError_GetObject", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeEncodeError_GetStart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeEncodeError_GetStart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_GetStart(PyObject *, Py_ssize_t *)
     * }
     */
    public static FunctionDescriptor PyUnicodeEncodeError_GetStart$descriptor() {
        return PyUnicodeEncodeError_GetStart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_GetStart(PyObject *, Py_ssize_t *)
     * }
     */
    public static MethodHandle PyUnicodeEncodeError_GetStart$handle() {
        return PyUnicodeEncodeError_GetStart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_GetStart(PyObject *, Py_ssize_t *)
     * }
     */
    public static MemorySegment PyUnicodeEncodeError_GetStart$address() {
        return PyUnicodeEncodeError_GetStart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_GetStart(PyObject *, Py_ssize_t *)
     * }
     */
    public static int PyUnicodeEncodeError_GetStart(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyUnicodeEncodeError_GetStart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeEncodeError_GetStart", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeDecodeError_GetStart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeDecodeError_GetStart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_GetStart(PyObject *, Py_ssize_t *)
     * }
     */
    public static FunctionDescriptor PyUnicodeDecodeError_GetStart$descriptor() {
        return PyUnicodeDecodeError_GetStart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_GetStart(PyObject *, Py_ssize_t *)
     * }
     */
    public static MethodHandle PyUnicodeDecodeError_GetStart$handle() {
        return PyUnicodeDecodeError_GetStart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_GetStart(PyObject *, Py_ssize_t *)
     * }
     */
    public static MemorySegment PyUnicodeDecodeError_GetStart$address() {
        return PyUnicodeDecodeError_GetStart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_GetStart(PyObject *, Py_ssize_t *)
     * }
     */
    public static int PyUnicodeDecodeError_GetStart(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyUnicodeDecodeError_GetStart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeDecodeError_GetStart", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeTranslateError_GetStart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeTranslateError_GetStart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_GetStart(PyObject *, Py_ssize_t *)
     * }
     */
    public static FunctionDescriptor PyUnicodeTranslateError_GetStart$descriptor() {
        return PyUnicodeTranslateError_GetStart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_GetStart(PyObject *, Py_ssize_t *)
     * }
     */
    public static MethodHandle PyUnicodeTranslateError_GetStart$handle() {
        return PyUnicodeTranslateError_GetStart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_GetStart(PyObject *, Py_ssize_t *)
     * }
     */
    public static MemorySegment PyUnicodeTranslateError_GetStart$address() {
        return PyUnicodeTranslateError_GetStart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_GetStart(PyObject *, Py_ssize_t *)
     * }
     */
    public static int PyUnicodeTranslateError_GetStart(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyUnicodeTranslateError_GetStart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeTranslateError_GetStart", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeEncodeError_SetStart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeEncodeError_SetStart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_SetStart(PyObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyUnicodeEncodeError_SetStart$descriptor() {
        return PyUnicodeEncodeError_SetStart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_SetStart(PyObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyUnicodeEncodeError_SetStart$handle() {
        return PyUnicodeEncodeError_SetStart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_SetStart(PyObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyUnicodeEncodeError_SetStart$address() {
        return PyUnicodeEncodeError_SetStart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_SetStart(PyObject *, Py_ssize_t)
     * }
     */
    public static int PyUnicodeEncodeError_SetStart(MemorySegment x0, long x1) {
        var mh$ = PyUnicodeEncodeError_SetStart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeEncodeError_SetStart", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeDecodeError_SetStart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeDecodeError_SetStart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_SetStart(PyObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyUnicodeDecodeError_SetStart$descriptor() {
        return PyUnicodeDecodeError_SetStart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_SetStart(PyObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyUnicodeDecodeError_SetStart$handle() {
        return PyUnicodeDecodeError_SetStart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_SetStart(PyObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyUnicodeDecodeError_SetStart$address() {
        return PyUnicodeDecodeError_SetStart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_SetStart(PyObject *, Py_ssize_t)
     * }
     */
    public static int PyUnicodeDecodeError_SetStart(MemorySegment x0, long x1) {
        var mh$ = PyUnicodeDecodeError_SetStart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeDecodeError_SetStart", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeTranslateError_SetStart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeTranslateError_SetStart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_SetStart(PyObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyUnicodeTranslateError_SetStart$descriptor() {
        return PyUnicodeTranslateError_SetStart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_SetStart(PyObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyUnicodeTranslateError_SetStart$handle() {
        return PyUnicodeTranslateError_SetStart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_SetStart(PyObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyUnicodeTranslateError_SetStart$address() {
        return PyUnicodeTranslateError_SetStart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_SetStart(PyObject *, Py_ssize_t)
     * }
     */
    public static int PyUnicodeTranslateError_SetStart(MemorySegment x0, long x1) {
        var mh$ = PyUnicodeTranslateError_SetStart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeTranslateError_SetStart", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeEncodeError_GetEnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeEncodeError_GetEnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_GetEnd(PyObject *, Py_ssize_t *)
     * }
     */
    public static FunctionDescriptor PyUnicodeEncodeError_GetEnd$descriptor() {
        return PyUnicodeEncodeError_GetEnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_GetEnd(PyObject *, Py_ssize_t *)
     * }
     */
    public static MethodHandle PyUnicodeEncodeError_GetEnd$handle() {
        return PyUnicodeEncodeError_GetEnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_GetEnd(PyObject *, Py_ssize_t *)
     * }
     */
    public static MemorySegment PyUnicodeEncodeError_GetEnd$address() {
        return PyUnicodeEncodeError_GetEnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_GetEnd(PyObject *, Py_ssize_t *)
     * }
     */
    public static int PyUnicodeEncodeError_GetEnd(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyUnicodeEncodeError_GetEnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeEncodeError_GetEnd", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeDecodeError_GetEnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeDecodeError_GetEnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_GetEnd(PyObject *, Py_ssize_t *)
     * }
     */
    public static FunctionDescriptor PyUnicodeDecodeError_GetEnd$descriptor() {
        return PyUnicodeDecodeError_GetEnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_GetEnd(PyObject *, Py_ssize_t *)
     * }
     */
    public static MethodHandle PyUnicodeDecodeError_GetEnd$handle() {
        return PyUnicodeDecodeError_GetEnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_GetEnd(PyObject *, Py_ssize_t *)
     * }
     */
    public static MemorySegment PyUnicodeDecodeError_GetEnd$address() {
        return PyUnicodeDecodeError_GetEnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_GetEnd(PyObject *, Py_ssize_t *)
     * }
     */
    public static int PyUnicodeDecodeError_GetEnd(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyUnicodeDecodeError_GetEnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeDecodeError_GetEnd", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeTranslateError_GetEnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeTranslateError_GetEnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_GetEnd(PyObject *, Py_ssize_t *)
     * }
     */
    public static FunctionDescriptor PyUnicodeTranslateError_GetEnd$descriptor() {
        return PyUnicodeTranslateError_GetEnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_GetEnd(PyObject *, Py_ssize_t *)
     * }
     */
    public static MethodHandle PyUnicodeTranslateError_GetEnd$handle() {
        return PyUnicodeTranslateError_GetEnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_GetEnd(PyObject *, Py_ssize_t *)
     * }
     */
    public static MemorySegment PyUnicodeTranslateError_GetEnd$address() {
        return PyUnicodeTranslateError_GetEnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_GetEnd(PyObject *, Py_ssize_t *)
     * }
     */
    public static int PyUnicodeTranslateError_GetEnd(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyUnicodeTranslateError_GetEnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeTranslateError_GetEnd", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeEncodeError_SetEnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeEncodeError_SetEnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_SetEnd(PyObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyUnicodeEncodeError_SetEnd$descriptor() {
        return PyUnicodeEncodeError_SetEnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_SetEnd(PyObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyUnicodeEncodeError_SetEnd$handle() {
        return PyUnicodeEncodeError_SetEnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_SetEnd(PyObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyUnicodeEncodeError_SetEnd$address() {
        return PyUnicodeEncodeError_SetEnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_SetEnd(PyObject *, Py_ssize_t)
     * }
     */
    public static int PyUnicodeEncodeError_SetEnd(MemorySegment x0, long x1) {
        var mh$ = PyUnicodeEncodeError_SetEnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeEncodeError_SetEnd", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeDecodeError_SetEnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeDecodeError_SetEnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_SetEnd(PyObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyUnicodeDecodeError_SetEnd$descriptor() {
        return PyUnicodeDecodeError_SetEnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_SetEnd(PyObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyUnicodeDecodeError_SetEnd$handle() {
        return PyUnicodeDecodeError_SetEnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_SetEnd(PyObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyUnicodeDecodeError_SetEnd$address() {
        return PyUnicodeDecodeError_SetEnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_SetEnd(PyObject *, Py_ssize_t)
     * }
     */
    public static int PyUnicodeDecodeError_SetEnd(MemorySegment x0, long x1) {
        var mh$ = PyUnicodeDecodeError_SetEnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeDecodeError_SetEnd", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeTranslateError_SetEnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeTranslateError_SetEnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_SetEnd(PyObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyUnicodeTranslateError_SetEnd$descriptor() {
        return PyUnicodeTranslateError_SetEnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_SetEnd(PyObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyUnicodeTranslateError_SetEnd$handle() {
        return PyUnicodeTranslateError_SetEnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_SetEnd(PyObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyUnicodeTranslateError_SetEnd$address() {
        return PyUnicodeTranslateError_SetEnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_SetEnd(PyObject *, Py_ssize_t)
     * }
     */
    public static int PyUnicodeTranslateError_SetEnd(MemorySegment x0, long x1) {
        var mh$ = PyUnicodeTranslateError_SetEnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeTranslateError_SetEnd", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeEncodeError_GetReason {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeEncodeError_GetReason");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeEncodeError_GetReason(PyObject *)
     * }
     */
    public static FunctionDescriptor PyUnicodeEncodeError_GetReason$descriptor() {
        return PyUnicodeEncodeError_GetReason.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeEncodeError_GetReason(PyObject *)
     * }
     */
    public static MethodHandle PyUnicodeEncodeError_GetReason$handle() {
        return PyUnicodeEncodeError_GetReason.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeEncodeError_GetReason(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeEncodeError_GetReason$address() {
        return PyUnicodeEncodeError_GetReason.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicodeEncodeError_GetReason(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeEncodeError_GetReason(MemorySegment x0) {
        var mh$ = PyUnicodeEncodeError_GetReason.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeEncodeError_GetReason", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeDecodeError_GetReason {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeDecodeError_GetReason");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_GetReason(PyObject *)
     * }
     */
    public static FunctionDescriptor PyUnicodeDecodeError_GetReason$descriptor() {
        return PyUnicodeDecodeError_GetReason.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_GetReason(PyObject *)
     * }
     */
    public static MethodHandle PyUnicodeDecodeError_GetReason$handle() {
        return PyUnicodeDecodeError_GetReason.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_GetReason(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeDecodeError_GetReason$address() {
        return PyUnicodeDecodeError_GetReason.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicodeDecodeError_GetReason(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeDecodeError_GetReason(MemorySegment x0) {
        var mh$ = PyUnicodeDecodeError_GetReason.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeDecodeError_GetReason", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeTranslateError_GetReason {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeTranslateError_GetReason");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeTranslateError_GetReason(PyObject *)
     * }
     */
    public static FunctionDescriptor PyUnicodeTranslateError_GetReason$descriptor() {
        return PyUnicodeTranslateError_GetReason.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeTranslateError_GetReason(PyObject *)
     * }
     */
    public static MethodHandle PyUnicodeTranslateError_GetReason$handle() {
        return PyUnicodeTranslateError_GetReason.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicodeTranslateError_GetReason(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeTranslateError_GetReason$address() {
        return PyUnicodeTranslateError_GetReason.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicodeTranslateError_GetReason(PyObject *)
     * }
     */
    public static MemorySegment PyUnicodeTranslateError_GetReason(MemorySegment x0) {
        var mh$ = PyUnicodeTranslateError_GetReason.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeTranslateError_GetReason", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeEncodeError_SetReason {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeEncodeError_SetReason");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_SetReason(PyObject *exc, const char *reason)
     * }
     */
    public static FunctionDescriptor PyUnicodeEncodeError_SetReason$descriptor() {
        return PyUnicodeEncodeError_SetReason.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_SetReason(PyObject *exc, const char *reason)
     * }
     */
    public static MethodHandle PyUnicodeEncodeError_SetReason$handle() {
        return PyUnicodeEncodeError_SetReason.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_SetReason(PyObject *exc, const char *reason)
     * }
     */
    public static MemorySegment PyUnicodeEncodeError_SetReason$address() {
        return PyUnicodeEncodeError_SetReason.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicodeEncodeError_SetReason(PyObject *exc, const char *reason)
     * }
     */
    public static int PyUnicodeEncodeError_SetReason(MemorySegment exc, MemorySegment reason) {
        var mh$ = PyUnicodeEncodeError_SetReason.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeEncodeError_SetReason", exc, reason);
            }
            return (int)mh$.invokeExact(exc, reason);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeDecodeError_SetReason {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeDecodeError_SetReason");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_SetReason(PyObject *exc, const char *reason)
     * }
     */
    public static FunctionDescriptor PyUnicodeDecodeError_SetReason$descriptor() {
        return PyUnicodeDecodeError_SetReason.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_SetReason(PyObject *exc, const char *reason)
     * }
     */
    public static MethodHandle PyUnicodeDecodeError_SetReason$handle() {
        return PyUnicodeDecodeError_SetReason.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_SetReason(PyObject *exc, const char *reason)
     * }
     */
    public static MemorySegment PyUnicodeDecodeError_SetReason$address() {
        return PyUnicodeDecodeError_SetReason.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicodeDecodeError_SetReason(PyObject *exc, const char *reason)
     * }
     */
    public static int PyUnicodeDecodeError_SetReason(MemorySegment exc, MemorySegment reason) {
        var mh$ = PyUnicodeDecodeError_SetReason.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeDecodeError_SetReason", exc, reason);
            }
            return (int)mh$.invokeExact(exc, reason);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicodeTranslateError_SetReason {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicodeTranslateError_SetReason");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_SetReason(PyObject *exc, const char *reason)
     * }
     */
    public static FunctionDescriptor PyUnicodeTranslateError_SetReason$descriptor() {
        return PyUnicodeTranslateError_SetReason.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_SetReason(PyObject *exc, const char *reason)
     * }
     */
    public static MethodHandle PyUnicodeTranslateError_SetReason$handle() {
        return PyUnicodeTranslateError_SetReason.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_SetReason(PyObject *exc, const char *reason)
     * }
     */
    public static MemorySegment PyUnicodeTranslateError_SetReason$address() {
        return PyUnicodeTranslateError_SetReason.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicodeTranslateError_SetReason(PyObject *exc, const char *reason)
     * }
     */
    public static int PyUnicodeTranslateError_SetReason(MemorySegment exc, MemorySegment reason) {
        var mh$ = PyUnicodeTranslateError_SetReason.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicodeTranslateError_SetReason", exc, reason);
            }
            return (int)mh$.invokeExact(exc, reason);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int PyOS_snprintf(char *str, size_t size, const char *format, ...)
     * }
     */
    public static class PyOS_snprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_LONG,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyOS_snprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyOS_snprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int PyOS_snprintf(char *str, size_t size, const char *format, ...)
         * }
         */
        public static PyOS_snprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyOS_snprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment str, long size, MemorySegment format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyOS_snprintf", str, size, format, x3);
                }
                return (int)spreader.invokeExact(str, size, format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class PyOS_vsnprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyOS_vsnprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyOS_vsnprintf(char *str, size_t size, const char *format, va_list va)
     * }
     */
    public static FunctionDescriptor PyOS_vsnprintf$descriptor() {
        return PyOS_vsnprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyOS_vsnprintf(char *str, size_t size, const char *format, va_list va)
     * }
     */
    public static MethodHandle PyOS_vsnprintf$handle() {
        return PyOS_vsnprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyOS_vsnprintf(char *str, size_t size, const char *format, va_list va)
     * }
     */
    public static MemorySegment PyOS_vsnprintf$address() {
        return PyOS_vsnprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyOS_vsnprintf(char *str, size_t size, const char *format, va_list va)
     * }
     */
    public static int PyOS_vsnprintf(MemorySegment str, long size, MemorySegment format, MemorySegment va) {
        var mh$ = PyOS_vsnprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyOS_vsnprintf", str, size, format, va);
            }
            return (int)mh$.invokeExact(str, size, format, va);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyErr_SetKeyError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyErr_SetKeyError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyErr_SetKeyError(PyObject *)
     * }
     */
    public static FunctionDescriptor _PyErr_SetKeyError$descriptor() {
        return _PyErr_SetKeyError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyErr_SetKeyError(PyObject *)
     * }
     */
    public static MethodHandle _PyErr_SetKeyError$handle() {
        return _PyErr_SetKeyError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyErr_SetKeyError(PyObject *)
     * }
     */
    public static MemorySegment _PyErr_SetKeyError$address() {
        return _PyErr_SetKeyError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyErr_SetKeyError(PyObject *)
     * }
     */
    public static void _PyErr_SetKeyError(MemorySegment x0) {
        var mh$ = _PyErr_SetKeyError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyErr_SetKeyError", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyErr_GetTopmostException {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyErr_GetTopmostException");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _PyErr_StackItem *_PyErr_GetTopmostException(PyThreadState *tstate)
     * }
     */
    public static FunctionDescriptor _PyErr_GetTopmostException$descriptor() {
        return _PyErr_GetTopmostException.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _PyErr_StackItem *_PyErr_GetTopmostException(PyThreadState *tstate)
     * }
     */
    public static MethodHandle _PyErr_GetTopmostException$handle() {
        return _PyErr_GetTopmostException.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _PyErr_StackItem *_PyErr_GetTopmostException(PyThreadState *tstate)
     * }
     */
    public static MemorySegment _PyErr_GetTopmostException$address() {
        return _PyErr_GetTopmostException.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _PyErr_StackItem *_PyErr_GetTopmostException(PyThreadState *tstate)
     * }
     */
    public static MemorySegment _PyErr_GetTopmostException(MemorySegment tstate) {
        var mh$ = _PyErr_GetTopmostException.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyErr_GetTopmostException", tstate);
            }
            return (MemorySegment)mh$.invokeExact(tstate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyErr_GetHandledException {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyErr_GetHandledException");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyErr_GetHandledException(PyThreadState *)
     * }
     */
    public static FunctionDescriptor _PyErr_GetHandledException$descriptor() {
        return _PyErr_GetHandledException.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyErr_GetHandledException(PyThreadState *)
     * }
     */
    public static MethodHandle _PyErr_GetHandledException$handle() {
        return _PyErr_GetHandledException.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyErr_GetHandledException(PyThreadState *)
     * }
     */
    public static MemorySegment _PyErr_GetHandledException$address() {
        return _PyErr_GetHandledException.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyErr_GetHandledException(PyThreadState *)
     * }
     */
    public static MemorySegment _PyErr_GetHandledException(MemorySegment x0) {
        var mh$ = _PyErr_GetHandledException.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyErr_GetHandledException", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyErr_SetHandledException {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyErr_SetHandledException");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyErr_SetHandledException(PyThreadState *, PyObject *)
     * }
     */
    public static FunctionDescriptor _PyErr_SetHandledException$descriptor() {
        return _PyErr_SetHandledException.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyErr_SetHandledException(PyThreadState *, PyObject *)
     * }
     */
    public static MethodHandle _PyErr_SetHandledException$handle() {
        return _PyErr_SetHandledException.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyErr_SetHandledException(PyThreadState *, PyObject *)
     * }
     */
    public static MemorySegment _PyErr_SetHandledException$address() {
        return _PyErr_SetHandledException.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyErr_SetHandledException(PyThreadState *, PyObject *)
     * }
     */
    public static void _PyErr_SetHandledException(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyErr_SetHandledException.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyErr_SetHandledException", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyErr_GetExcInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyErr_GetExcInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyErr_GetExcInfo(PyThreadState *, PyObject **, PyObject **, PyObject **)
     * }
     */
    public static FunctionDescriptor _PyErr_GetExcInfo$descriptor() {
        return _PyErr_GetExcInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyErr_GetExcInfo(PyThreadState *, PyObject **, PyObject **, PyObject **)
     * }
     */
    public static MethodHandle _PyErr_GetExcInfo$handle() {
        return _PyErr_GetExcInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyErr_GetExcInfo(PyThreadState *, PyObject **, PyObject **, PyObject **)
     * }
     */
    public static MemorySegment _PyErr_GetExcInfo$address() {
        return _PyErr_GetExcInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyErr_GetExcInfo(PyThreadState *, PyObject **, PyObject **, PyObject **)
     * }
     */
    public static void _PyErr_GetExcInfo(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = _PyErr_GetExcInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyErr_GetExcInfo", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyErr_ChainExceptions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyErr_ChainExceptions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyErr_ChainExceptions(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor _PyErr_ChainExceptions$descriptor() {
        return _PyErr_ChainExceptions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyErr_ChainExceptions(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle _PyErr_ChainExceptions$handle() {
        return _PyErr_ChainExceptions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyErr_ChainExceptions(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment _PyErr_ChainExceptions$address() {
        return _PyErr_ChainExceptions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyErr_ChainExceptions(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static void _PyErr_ChainExceptions(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = _PyErr_ChainExceptions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyErr_ChainExceptions", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *_PyErr_FormatFromCause(PyObject *exception, const char *format, ...)
     * }
     */
    public static class _PyErr_FormatFromCause {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("_PyErr_FormatFromCause");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private _PyErr_FormatFromCause(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *_PyErr_FormatFromCause(PyObject *exception, const char *format, ...)
         * }
         */
        public static _PyErr_FormatFromCause makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new _PyErr_FormatFromCause(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment exception, MemorySegment format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("_PyErr_FormatFromCause", exception, format, x2);
                }
                return (MemorySegment)spreader.invokeExact(exception, format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *_PyErr_TrySetFromCause(const char *prefix_format, ...)
     * }
     */
    public static class _PyErr_TrySetFromCause {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("_PyErr_TrySetFromCause");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private _PyErr_TrySetFromCause(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *_PyErr_TrySetFromCause(const char *prefix_format, ...)
         * }
         */
        public static _PyErr_TrySetFromCause makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new _PyErr_TrySetFromCause(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment prefix_format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("_PyErr_TrySetFromCause", prefix_format, x1);
                }
                return (MemorySegment)spreader.invokeExact(prefix_format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class PySignal_SetWakeupFd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySignal_SetWakeupFd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySignal_SetWakeupFd(int fd)
     * }
     */
    public static FunctionDescriptor PySignal_SetWakeupFd$descriptor() {
        return PySignal_SetWakeupFd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySignal_SetWakeupFd(int fd)
     * }
     */
    public static MethodHandle PySignal_SetWakeupFd$handle() {
        return PySignal_SetWakeupFd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySignal_SetWakeupFd(int fd)
     * }
     */
    public static MemorySegment PySignal_SetWakeupFd$address() {
        return PySignal_SetWakeupFd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySignal_SetWakeupFd(int fd)
     * }
     */
    public static int PySignal_SetWakeupFd(int fd) {
        var mh$ = PySignal_SetWakeupFd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySignal_SetWakeupFd", fd);
            }
            return (int)mh$.invokeExact(fd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyErr_CheckSignals {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyErr_CheckSignals");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyErr_CheckSignals()
     * }
     */
    public static FunctionDescriptor _PyErr_CheckSignals$descriptor() {
        return _PyErr_CheckSignals.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyErr_CheckSignals()
     * }
     */
    public static MethodHandle _PyErr_CheckSignals$handle() {
        return _PyErr_CheckSignals.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyErr_CheckSignals()
     * }
     */
    public static MemorySegment _PyErr_CheckSignals$address() {
        return _PyErr_CheckSignals.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyErr_CheckSignals()
     * }
     */
    public static int _PyErr_CheckSignals() {
        var mh$ = _PyErr_CheckSignals.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyErr_CheckSignals");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_SyntaxLocationObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_SyntaxLocationObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_SyntaxLocationObject(PyObject *filename, int lineno, int col_offset)
     * }
     */
    public static FunctionDescriptor PyErr_SyntaxLocationObject$descriptor() {
        return PyErr_SyntaxLocationObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_SyntaxLocationObject(PyObject *filename, int lineno, int col_offset)
     * }
     */
    public static MethodHandle PyErr_SyntaxLocationObject$handle() {
        return PyErr_SyntaxLocationObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_SyntaxLocationObject(PyObject *filename, int lineno, int col_offset)
     * }
     */
    public static MemorySegment PyErr_SyntaxLocationObject$address() {
        return PyErr_SyntaxLocationObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_SyntaxLocationObject(PyObject *filename, int lineno, int col_offset)
     * }
     */
    public static void PyErr_SyntaxLocationObject(MemorySegment filename, int lineno, int col_offset) {
        var mh$ = PyErr_SyntaxLocationObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_SyntaxLocationObject", filename, lineno, col_offset);
            }
            mh$.invokeExact(filename, lineno, col_offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_RangedSyntaxLocationObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_RangedSyntaxLocationObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_RangedSyntaxLocationObject(PyObject *filename, int lineno, int col_offset, int end_lineno, int end_col_offset)
     * }
     */
    public static FunctionDescriptor PyErr_RangedSyntaxLocationObject$descriptor() {
        return PyErr_RangedSyntaxLocationObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_RangedSyntaxLocationObject(PyObject *filename, int lineno, int col_offset, int end_lineno, int end_col_offset)
     * }
     */
    public static MethodHandle PyErr_RangedSyntaxLocationObject$handle() {
        return PyErr_RangedSyntaxLocationObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_RangedSyntaxLocationObject(PyObject *filename, int lineno, int col_offset, int end_lineno, int end_col_offset)
     * }
     */
    public static MemorySegment PyErr_RangedSyntaxLocationObject$address() {
        return PyErr_RangedSyntaxLocationObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_RangedSyntaxLocationObject(PyObject *filename, int lineno, int col_offset, int end_lineno, int end_col_offset)
     * }
     */
    public static void PyErr_RangedSyntaxLocationObject(MemorySegment filename, int lineno, int col_offset, int end_lineno, int end_col_offset) {
        var mh$ = PyErr_RangedSyntaxLocationObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_RangedSyntaxLocationObject", filename, lineno, col_offset, end_lineno, end_col_offset);
            }
            mh$.invokeExact(filename, lineno, col_offset, end_lineno, end_col_offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_ProgramTextObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_ProgramTextObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyErr_ProgramTextObject(PyObject *filename, int lineno)
     * }
     */
    public static FunctionDescriptor PyErr_ProgramTextObject$descriptor() {
        return PyErr_ProgramTextObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyErr_ProgramTextObject(PyObject *filename, int lineno)
     * }
     */
    public static MethodHandle PyErr_ProgramTextObject$handle() {
        return PyErr_ProgramTextObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyErr_ProgramTextObject(PyObject *filename, int lineno)
     * }
     */
    public static MemorySegment PyErr_ProgramTextObject$address() {
        return PyErr_ProgramTextObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyErr_ProgramTextObject(PyObject *filename, int lineno)
     * }
     */
    public static MemorySegment PyErr_ProgramTextObject(MemorySegment filename, int lineno) {
        var mh$ = PyErr_ProgramTextObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_ProgramTextObject", filename, lineno);
            }
            return (MemorySegment)mh$.invokeExact(filename, lineno);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyErr_ProgramDecodedTextObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyErr_ProgramDecodedTextObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyErr_ProgramDecodedTextObject(PyObject *filename, int lineno, const char *encoding)
     * }
     */
    public static FunctionDescriptor _PyErr_ProgramDecodedTextObject$descriptor() {
        return _PyErr_ProgramDecodedTextObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyErr_ProgramDecodedTextObject(PyObject *filename, int lineno, const char *encoding)
     * }
     */
    public static MethodHandle _PyErr_ProgramDecodedTextObject$handle() {
        return _PyErr_ProgramDecodedTextObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyErr_ProgramDecodedTextObject(PyObject *filename, int lineno, const char *encoding)
     * }
     */
    public static MemorySegment _PyErr_ProgramDecodedTextObject$address() {
        return _PyErr_ProgramDecodedTextObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyErr_ProgramDecodedTextObject(PyObject *filename, int lineno, const char *encoding)
     * }
     */
    public static MemorySegment _PyErr_ProgramDecodedTextObject(MemorySegment filename, int lineno, MemorySegment encoding) {
        var mh$ = _PyErr_ProgramDecodedTextObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyErr_ProgramDecodedTextObject", filename, lineno, encoding);
            }
            return (MemorySegment)mh$.invokeExact(filename, lineno, encoding);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicodeTranslateError_Create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicodeTranslateError_Create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyUnicodeTranslateError_Create(PyObject *object, Py_ssize_t start, Py_ssize_t end, const char *reason)
     * }
     */
    public static FunctionDescriptor _PyUnicodeTranslateError_Create$descriptor() {
        return _PyUnicodeTranslateError_Create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyUnicodeTranslateError_Create(PyObject *object, Py_ssize_t start, Py_ssize_t end, const char *reason)
     * }
     */
    public static MethodHandle _PyUnicodeTranslateError_Create$handle() {
        return _PyUnicodeTranslateError_Create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyUnicodeTranslateError_Create(PyObject *object, Py_ssize_t start, Py_ssize_t end, const char *reason)
     * }
     */
    public static MemorySegment _PyUnicodeTranslateError_Create$address() {
        return _PyUnicodeTranslateError_Create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyUnicodeTranslateError_Create(PyObject *object, Py_ssize_t start, Py_ssize_t end, const char *reason)
     * }
     */
    public static MemorySegment _PyUnicodeTranslateError_Create(MemorySegment object, long start, long end, MemorySegment reason) {
        var mh$ = _PyUnicodeTranslateError_Create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicodeTranslateError_Create", object, start, end, reason);
            }
            return (MemorySegment)mh$.invokeExact(object, start, end, reason);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyErr_WriteUnraisableMsg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyErr_WriteUnraisableMsg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyErr_WriteUnraisableMsg(const char *err_msg, PyObject *obj)
     * }
     */
    public static FunctionDescriptor _PyErr_WriteUnraisableMsg$descriptor() {
        return _PyErr_WriteUnraisableMsg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyErr_WriteUnraisableMsg(const char *err_msg, PyObject *obj)
     * }
     */
    public static MethodHandle _PyErr_WriteUnraisableMsg$handle() {
        return _PyErr_WriteUnraisableMsg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyErr_WriteUnraisableMsg(const char *err_msg, PyObject *obj)
     * }
     */
    public static MemorySegment _PyErr_WriteUnraisableMsg$address() {
        return _PyErr_WriteUnraisableMsg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyErr_WriteUnraisableMsg(const char *err_msg, PyObject *obj)
     * }
     */
    public static void _PyErr_WriteUnraisableMsg(MemorySegment err_msg, MemorySegment obj) {
        var mh$ = _PyErr_WriteUnraisableMsg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyErr_WriteUnraisableMsg", err_msg, obj);
            }
            mh$.invokeExact(err_msg, obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_FatalErrorFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_FatalErrorFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _Py_FatalErrorFunc(const char *func, const char *message)
     * }
     */
    public static FunctionDescriptor _Py_FatalErrorFunc$descriptor() {
        return _Py_FatalErrorFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _Py_FatalErrorFunc(const char *func, const char *message)
     * }
     */
    public static MethodHandle _Py_FatalErrorFunc$handle() {
        return _Py_FatalErrorFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _Py_FatalErrorFunc(const char *func, const char *message)
     * }
     */
    public static MemorySegment _Py_FatalErrorFunc$address() {
        return _Py_FatalErrorFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _Py_FatalErrorFunc(const char *func, const char *message)
     * }
     */
    public static void _Py_FatalErrorFunc(MemorySegment func, MemorySegment message) {
        var mh$ = _Py_FatalErrorFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_FatalErrorFunc", func, message);
            }
            mh$.invokeExact(func, message);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void _Py_FatalErrorFormat(const char *func, const char *format, ...)
     * }
     */
    public static class _Py_FatalErrorFormat {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("_Py_FatalErrorFormat");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private _Py_FatalErrorFormat(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void _Py_FatalErrorFormat(const char *func, const char *format, ...)
         * }
         */
        public static _Py_FatalErrorFormat makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new _Py_FatalErrorFormat(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment func, MemorySegment format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("_Py_FatalErrorFormat", func, format, x2);
                }
                spreader.invokeExact(func, format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }
    /**
     * {@snippet lang=c :
     * typedef void *PyThread_type_lock
     * }
     */
    public static final AddressLayout PyThread_type_lock = Python_h.C_POINTER;
    private static final int PY_LOCK_FAILURE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum PyLockStatus.PY_LOCK_FAILURE = 0
     * }
     */
    public static int PY_LOCK_FAILURE() {
        return PY_LOCK_FAILURE;
    }
    private static final int PY_LOCK_ACQUIRED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum PyLockStatus.PY_LOCK_ACQUIRED = 1
     * }
     */
    public static int PY_LOCK_ACQUIRED() {
        return PY_LOCK_ACQUIRED;
    }
    private static final int PY_LOCK_INTR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum PyLockStatus.PY_LOCK_INTR = 2
     * }
     */
    public static int PY_LOCK_INTR() {
        return PY_LOCK_INTR;
    }

    private static class PyThread_init_thread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_init_thread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyThread_init_thread()
     * }
     */
    public static FunctionDescriptor PyThread_init_thread$descriptor() {
        return PyThread_init_thread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyThread_init_thread()
     * }
     */
    public static MethodHandle PyThread_init_thread$handle() {
        return PyThread_init_thread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyThread_init_thread()
     * }
     */
    public static MemorySegment PyThread_init_thread$address() {
        return PyThread_init_thread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyThread_init_thread()
     * }
     */
    public static void PyThread_init_thread() {
        var mh$ = PyThread_init_thread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_init_thread");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_start_new_thread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_start_new_thread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long PyThread_start_new_thread(void (*)(void *), void *)
     * }
     */
    public static FunctionDescriptor PyThread_start_new_thread$descriptor() {
        return PyThread_start_new_thread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long PyThread_start_new_thread(void (*)(void *), void *)
     * }
     */
    public static MethodHandle PyThread_start_new_thread$handle() {
        return PyThread_start_new_thread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long PyThread_start_new_thread(void (*)(void *), void *)
     * }
     */
    public static MemorySegment PyThread_start_new_thread$address() {
        return PyThread_start_new_thread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long PyThread_start_new_thread(void (*)(void *), void *)
     * }
     */
    public static long PyThread_start_new_thread(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyThread_start_new_thread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_start_new_thread", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_exit_thread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_exit_thread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyThread_exit_thread()
     * }
     */
    public static FunctionDescriptor PyThread_exit_thread$descriptor() {
        return PyThread_exit_thread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyThread_exit_thread()
     * }
     */
    public static MethodHandle PyThread_exit_thread$handle() {
        return PyThread_exit_thread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyThread_exit_thread()
     * }
     */
    public static MemorySegment PyThread_exit_thread$address() {
        return PyThread_exit_thread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyThread_exit_thread()
     * }
     */
    public static void PyThread_exit_thread() {
        var mh$ = PyThread_exit_thread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_exit_thread");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_get_thread_ident {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_get_thread_ident");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long PyThread_get_thread_ident()
     * }
     */
    public static FunctionDescriptor PyThread_get_thread_ident$descriptor() {
        return PyThread_get_thread_ident.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long PyThread_get_thread_ident()
     * }
     */
    public static MethodHandle PyThread_get_thread_ident$handle() {
        return PyThread_get_thread_ident.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long PyThread_get_thread_ident()
     * }
     */
    public static MemorySegment PyThread_get_thread_ident$address() {
        return PyThread_get_thread_ident.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long PyThread_get_thread_ident()
     * }
     */
    public static long PyThread_get_thread_ident() {
        var mh$ = PyThread_get_thread_ident.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_get_thread_ident");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_get_thread_native_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_get_thread_native_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long PyThread_get_thread_native_id()
     * }
     */
    public static FunctionDescriptor PyThread_get_thread_native_id$descriptor() {
        return PyThread_get_thread_native_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long PyThread_get_thread_native_id()
     * }
     */
    public static MethodHandle PyThread_get_thread_native_id$handle() {
        return PyThread_get_thread_native_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long PyThread_get_thread_native_id()
     * }
     */
    public static MemorySegment PyThread_get_thread_native_id$address() {
        return PyThread_get_thread_native_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long PyThread_get_thread_native_id()
     * }
     */
    public static long PyThread_get_thread_native_id() {
        var mh$ = PyThread_get_thread_native_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_get_thread_native_id");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_allocate_lock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_allocate_lock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyThread_type_lock PyThread_allocate_lock()
     * }
     */
    public static FunctionDescriptor PyThread_allocate_lock$descriptor() {
        return PyThread_allocate_lock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyThread_type_lock PyThread_allocate_lock()
     * }
     */
    public static MethodHandle PyThread_allocate_lock$handle() {
        return PyThread_allocate_lock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyThread_type_lock PyThread_allocate_lock()
     * }
     */
    public static MemorySegment PyThread_allocate_lock$address() {
        return PyThread_allocate_lock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyThread_type_lock PyThread_allocate_lock()
     * }
     */
    public static MemorySegment PyThread_allocate_lock() {
        var mh$ = PyThread_allocate_lock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_allocate_lock");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_free_lock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_free_lock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyThread_free_lock(PyThread_type_lock)
     * }
     */
    public static FunctionDescriptor PyThread_free_lock$descriptor() {
        return PyThread_free_lock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyThread_free_lock(PyThread_type_lock)
     * }
     */
    public static MethodHandle PyThread_free_lock$handle() {
        return PyThread_free_lock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyThread_free_lock(PyThread_type_lock)
     * }
     */
    public static MemorySegment PyThread_free_lock$address() {
        return PyThread_free_lock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyThread_free_lock(PyThread_type_lock)
     * }
     */
    public static void PyThread_free_lock(MemorySegment x0) {
        var mh$ = PyThread_free_lock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_free_lock", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_acquire_lock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_acquire_lock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyThread_acquire_lock(PyThread_type_lock, int)
     * }
     */
    public static FunctionDescriptor PyThread_acquire_lock$descriptor() {
        return PyThread_acquire_lock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyThread_acquire_lock(PyThread_type_lock, int)
     * }
     */
    public static MethodHandle PyThread_acquire_lock$handle() {
        return PyThread_acquire_lock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyThread_acquire_lock(PyThread_type_lock, int)
     * }
     */
    public static MemorySegment PyThread_acquire_lock$address() {
        return PyThread_acquire_lock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyThread_acquire_lock(PyThread_type_lock, int)
     * }
     */
    public static int PyThread_acquire_lock(MemorySegment x0, int x1) {
        var mh$ = PyThread_acquire_lock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_acquire_lock", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_acquire_lock_timed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_acquire_lock_timed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyLockStatus PyThread_acquire_lock_timed(PyThread_type_lock, long long microseconds, int intr_flag)
     * }
     */
    public static FunctionDescriptor PyThread_acquire_lock_timed$descriptor() {
        return PyThread_acquire_lock_timed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyLockStatus PyThread_acquire_lock_timed(PyThread_type_lock, long long microseconds, int intr_flag)
     * }
     */
    public static MethodHandle PyThread_acquire_lock_timed$handle() {
        return PyThread_acquire_lock_timed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyLockStatus PyThread_acquire_lock_timed(PyThread_type_lock, long long microseconds, int intr_flag)
     * }
     */
    public static MemorySegment PyThread_acquire_lock_timed$address() {
        return PyThread_acquire_lock_timed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyLockStatus PyThread_acquire_lock_timed(PyThread_type_lock, long long microseconds, int intr_flag)
     * }
     */
    public static int PyThread_acquire_lock_timed(MemorySegment x0, long microseconds, int intr_flag) {
        var mh$ = PyThread_acquire_lock_timed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_acquire_lock_timed", x0, microseconds, intr_flag);
            }
            return (int)mh$.invokeExact(x0, microseconds, intr_flag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_release_lock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_release_lock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyThread_release_lock(PyThread_type_lock)
     * }
     */
    public static FunctionDescriptor PyThread_release_lock$descriptor() {
        return PyThread_release_lock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyThread_release_lock(PyThread_type_lock)
     * }
     */
    public static MethodHandle PyThread_release_lock$handle() {
        return PyThread_release_lock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyThread_release_lock(PyThread_type_lock)
     * }
     */
    public static MemorySegment PyThread_release_lock$address() {
        return PyThread_release_lock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyThread_release_lock(PyThread_type_lock)
     * }
     */
    public static void PyThread_release_lock(MemorySegment x0) {
        var mh$ = PyThread_release_lock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_release_lock", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_get_stacksize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_get_stacksize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t PyThread_get_stacksize()
     * }
     */
    public static FunctionDescriptor PyThread_get_stacksize$descriptor() {
        return PyThread_get_stacksize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t PyThread_get_stacksize()
     * }
     */
    public static MethodHandle PyThread_get_stacksize$handle() {
        return PyThread_get_stacksize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t PyThread_get_stacksize()
     * }
     */
    public static MemorySegment PyThread_get_stacksize$address() {
        return PyThread_get_stacksize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t PyThread_get_stacksize()
     * }
     */
    public static long PyThread_get_stacksize() {
        var mh$ = PyThread_get_stacksize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_get_stacksize");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_set_stacksize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_set_stacksize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyThread_set_stacksize(size_t)
     * }
     */
    public static FunctionDescriptor PyThread_set_stacksize$descriptor() {
        return PyThread_set_stacksize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyThread_set_stacksize(size_t)
     * }
     */
    public static MethodHandle PyThread_set_stacksize$handle() {
        return PyThread_set_stacksize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyThread_set_stacksize(size_t)
     * }
     */
    public static MemorySegment PyThread_set_stacksize$address() {
        return PyThread_set_stacksize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyThread_set_stacksize(size_t)
     * }
     */
    public static int PyThread_set_stacksize(long x0) {
        var mh$ = PyThread_set_stacksize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_set_stacksize", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_GetInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_GetInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyThread_GetInfo()
     * }
     */
    public static FunctionDescriptor PyThread_GetInfo$descriptor() {
        return PyThread_GetInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyThread_GetInfo()
     * }
     */
    public static MethodHandle PyThread_GetInfo$handle() {
        return PyThread_GetInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyThread_GetInfo()
     * }
     */
    public static MemorySegment PyThread_GetInfo$address() {
        return PyThread_GetInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyThread_GetInfo()
     * }
     */
    public static MemorySegment PyThread_GetInfo() {
        var mh$ = PyThread_GetInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_GetInfo");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_create_key {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_create_key");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyThread_create_key()
     * }
     */
    public static FunctionDescriptor PyThread_create_key$descriptor() {
        return PyThread_create_key.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyThread_create_key()
     * }
     */
    public static MethodHandle PyThread_create_key$handle() {
        return PyThread_create_key.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyThread_create_key()
     * }
     */
    public static MemorySegment PyThread_create_key$address() {
        return PyThread_create_key.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyThread_create_key()
     * }
     */
    public static int PyThread_create_key() {
        var mh$ = PyThread_create_key.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_create_key");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_delete_key {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_delete_key");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyThread_delete_key(int key)
     * }
     */
    public static FunctionDescriptor PyThread_delete_key$descriptor() {
        return PyThread_delete_key.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyThread_delete_key(int key)
     * }
     */
    public static MethodHandle PyThread_delete_key$handle() {
        return PyThread_delete_key.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyThread_delete_key(int key)
     * }
     */
    public static MemorySegment PyThread_delete_key$address() {
        return PyThread_delete_key.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyThread_delete_key(int key)
     * }
     */
    public static void PyThread_delete_key(int key) {
        var mh$ = PyThread_delete_key.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_delete_key", key);
            }
            mh$.invokeExact(key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_set_key_value {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_set_key_value");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyThread_set_key_value(int key, void *value)
     * }
     */
    public static FunctionDescriptor PyThread_set_key_value$descriptor() {
        return PyThread_set_key_value.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyThread_set_key_value(int key, void *value)
     * }
     */
    public static MethodHandle PyThread_set_key_value$handle() {
        return PyThread_set_key_value.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyThread_set_key_value(int key, void *value)
     * }
     */
    public static MemorySegment PyThread_set_key_value$address() {
        return PyThread_set_key_value.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyThread_set_key_value(int key, void *value)
     * }
     */
    public static int PyThread_set_key_value(int key, MemorySegment value) {
        var mh$ = PyThread_set_key_value.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_set_key_value", key, value);
            }
            return (int)mh$.invokeExact(key, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_get_key_value {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_get_key_value");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyThread_get_key_value(int key)
     * }
     */
    public static FunctionDescriptor PyThread_get_key_value$descriptor() {
        return PyThread_get_key_value.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyThread_get_key_value(int key)
     * }
     */
    public static MethodHandle PyThread_get_key_value$handle() {
        return PyThread_get_key_value.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyThread_get_key_value(int key)
     * }
     */
    public static MemorySegment PyThread_get_key_value$address() {
        return PyThread_get_key_value.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyThread_get_key_value(int key)
     * }
     */
    public static MemorySegment PyThread_get_key_value(int key) {
        var mh$ = PyThread_get_key_value.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_get_key_value", key);
            }
            return (MemorySegment)mh$.invokeExact(key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_delete_key_value {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_delete_key_value");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyThread_delete_key_value(int key)
     * }
     */
    public static FunctionDescriptor PyThread_delete_key_value$descriptor() {
        return PyThread_delete_key_value.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyThread_delete_key_value(int key)
     * }
     */
    public static MethodHandle PyThread_delete_key_value$handle() {
        return PyThread_delete_key_value.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyThread_delete_key_value(int key)
     * }
     */
    public static MemorySegment PyThread_delete_key_value$address() {
        return PyThread_delete_key_value.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyThread_delete_key_value(int key)
     * }
     */
    public static void PyThread_delete_key_value(int key) {
        var mh$ = PyThread_delete_key_value.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_delete_key_value", key);
            }
            mh$.invokeExact(key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_ReInitTLS {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_ReInitTLS");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyThread_ReInitTLS()
     * }
     */
    public static FunctionDescriptor PyThread_ReInitTLS$descriptor() {
        return PyThread_ReInitTLS.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyThread_ReInitTLS()
     * }
     */
    public static MethodHandle PyThread_ReInitTLS$handle() {
        return PyThread_ReInitTLS.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyThread_ReInitTLS()
     * }
     */
    public static MemorySegment PyThread_ReInitTLS$address() {
        return PyThread_ReInitTLS.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyThread_ReInitTLS()
     * }
     */
    public static void PyThread_ReInitTLS() {
        var mh$ = PyThread_ReInitTLS.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_ReInitTLS");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_tss_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_tss_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_tss_t *PyThread_tss_alloc()
     * }
     */
    public static FunctionDescriptor PyThread_tss_alloc$descriptor() {
        return PyThread_tss_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_tss_t *PyThread_tss_alloc()
     * }
     */
    public static MethodHandle PyThread_tss_alloc$handle() {
        return PyThread_tss_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_tss_t *PyThread_tss_alloc()
     * }
     */
    public static MemorySegment PyThread_tss_alloc$address() {
        return PyThread_tss_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_tss_t *PyThread_tss_alloc()
     * }
     */
    public static MemorySegment PyThread_tss_alloc() {
        var mh$ = PyThread_tss_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_tss_alloc");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_tss_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_tss_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyThread_tss_free(Py_tss_t *key)
     * }
     */
    public static FunctionDescriptor PyThread_tss_free$descriptor() {
        return PyThread_tss_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyThread_tss_free(Py_tss_t *key)
     * }
     */
    public static MethodHandle PyThread_tss_free$handle() {
        return PyThread_tss_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyThread_tss_free(Py_tss_t *key)
     * }
     */
    public static MemorySegment PyThread_tss_free$address() {
        return PyThread_tss_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyThread_tss_free(Py_tss_t *key)
     * }
     */
    public static void PyThread_tss_free(MemorySegment key) {
        var mh$ = PyThread_tss_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_tss_free", key);
            }
            mh$.invokeExact(key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_tss_is_created {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_tss_is_created");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyThread_tss_is_created(Py_tss_t *key)
     * }
     */
    public static FunctionDescriptor PyThread_tss_is_created$descriptor() {
        return PyThread_tss_is_created.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyThread_tss_is_created(Py_tss_t *key)
     * }
     */
    public static MethodHandle PyThread_tss_is_created$handle() {
        return PyThread_tss_is_created.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyThread_tss_is_created(Py_tss_t *key)
     * }
     */
    public static MemorySegment PyThread_tss_is_created$address() {
        return PyThread_tss_is_created.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyThread_tss_is_created(Py_tss_t *key)
     * }
     */
    public static int PyThread_tss_is_created(MemorySegment key) {
        var mh$ = PyThread_tss_is_created.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_tss_is_created", key);
            }
            return (int)mh$.invokeExact(key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_tss_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_tss_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyThread_tss_create(Py_tss_t *key)
     * }
     */
    public static FunctionDescriptor PyThread_tss_create$descriptor() {
        return PyThread_tss_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyThread_tss_create(Py_tss_t *key)
     * }
     */
    public static MethodHandle PyThread_tss_create$handle() {
        return PyThread_tss_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyThread_tss_create(Py_tss_t *key)
     * }
     */
    public static MemorySegment PyThread_tss_create$address() {
        return PyThread_tss_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyThread_tss_create(Py_tss_t *key)
     * }
     */
    public static int PyThread_tss_create(MemorySegment key) {
        var mh$ = PyThread_tss_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_tss_create", key);
            }
            return (int)mh$.invokeExact(key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_tss_delete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_tss_delete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyThread_tss_delete(Py_tss_t *key)
     * }
     */
    public static FunctionDescriptor PyThread_tss_delete$descriptor() {
        return PyThread_tss_delete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyThread_tss_delete(Py_tss_t *key)
     * }
     */
    public static MethodHandle PyThread_tss_delete$handle() {
        return PyThread_tss_delete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyThread_tss_delete(Py_tss_t *key)
     * }
     */
    public static MemorySegment PyThread_tss_delete$address() {
        return PyThread_tss_delete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyThread_tss_delete(Py_tss_t *key)
     * }
     */
    public static void PyThread_tss_delete(MemorySegment key) {
        var mh$ = PyThread_tss_delete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_tss_delete", key);
            }
            mh$.invokeExact(key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_tss_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_tss_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyThread_tss_set(Py_tss_t *key, void *value)
     * }
     */
    public static FunctionDescriptor PyThread_tss_set$descriptor() {
        return PyThread_tss_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyThread_tss_set(Py_tss_t *key, void *value)
     * }
     */
    public static MethodHandle PyThread_tss_set$handle() {
        return PyThread_tss_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyThread_tss_set(Py_tss_t *key, void *value)
     * }
     */
    public static MemorySegment PyThread_tss_set$address() {
        return PyThread_tss_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyThread_tss_set(Py_tss_t *key, void *value)
     * }
     */
    public static int PyThread_tss_set(MemorySegment key, MemorySegment value) {
        var mh$ = PyThread_tss_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_tss_set", key, value);
            }
            return (int)mh$.invokeExact(key, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyThread_tss_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyThread_tss_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyThread_tss_get(Py_tss_t *key)
     * }
     */
    public static FunctionDescriptor PyThread_tss_get$descriptor() {
        return PyThread_tss_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyThread_tss_get(Py_tss_t *key)
     * }
     */
    public static MethodHandle PyThread_tss_get$handle() {
        return PyThread_tss_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyThread_tss_get(Py_tss_t *key)
     * }
     */
    public static MemorySegment PyThread_tss_get$address() {
        return PyThread_tss_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyThread_tss_get(Py_tss_t *key)
     * }
     */
    public static MemorySegment PyThread_tss_get(MemorySegment key) {
        var mh$ = PyThread_tss_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyThread_tss_get", key);
            }
            return (MemorySegment)mh$.invokeExact(key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyThread_at_fork_reinit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyThread_at_fork_reinit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyThread_at_fork_reinit(PyThread_type_lock *lock)
     * }
     */
    public static FunctionDescriptor _PyThread_at_fork_reinit$descriptor() {
        return _PyThread_at_fork_reinit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyThread_at_fork_reinit(PyThread_type_lock *lock)
     * }
     */
    public static MethodHandle _PyThread_at_fork_reinit$handle() {
        return _PyThread_at_fork_reinit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyThread_at_fork_reinit(PyThread_type_lock *lock)
     * }
     */
    public static MemorySegment _PyThread_at_fork_reinit$address() {
        return _PyThread_at_fork_reinit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyThread_at_fork_reinit(PyThread_type_lock *lock)
     * }
     */
    public static int _PyThread_at_fork_reinit(MemorySegment lock) {
        var mh$ = _PyThread_at_fork_reinit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyThread_at_fork_reinit", lock);
            }
            return (int)mh$.invokeExact(lock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_yield {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sched_yield");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_yield()
     * }
     */
    public static FunctionDescriptor sched_yield$descriptor() {
        return sched_yield.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_yield()
     * }
     */
    public static MethodHandle sched_yield$handle() {
        return sched_yield.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_yield()
     * }
     */
    public static MemorySegment sched_yield$address() {
        return sched_yield.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_yield()
     * }
     */
    public static int sched_yield() {
        var mh$ = sched_yield.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_yield");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_get_priority_min {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sched_get_priority_min");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_get_priority_min(int)
     * }
     */
    public static FunctionDescriptor sched_get_priority_min$descriptor() {
        return sched_get_priority_min.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_get_priority_min(int)
     * }
     */
    public static MethodHandle sched_get_priority_min$handle() {
        return sched_get_priority_min.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_get_priority_min(int)
     * }
     */
    public static MemorySegment sched_get_priority_min$address() {
        return sched_get_priority_min.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_get_priority_min(int)
     * }
     */
    public static int sched_get_priority_min(int x0) {
        var mh$ = sched_get_priority_min.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_get_priority_min", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sched_get_priority_max {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sched_get_priority_max");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sched_get_priority_max(int)
     * }
     */
    public static FunctionDescriptor sched_get_priority_max$descriptor() {
        return sched_get_priority_max.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sched_get_priority_max(int)
     * }
     */
    public static MethodHandle sched_get_priority_max$handle() {
        return sched_get_priority_max.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sched_get_priority_max(int)
     * }
     */
    public static MemorySegment sched_get_priority_max$address() {
        return sched_get_priority_max.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sched_get_priority_max(int)
     * }
     */
    public static int sched_get_priority_max(int x0) {
        var mh$ = sched_get_priority_max.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sched_get_priority_max", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_pthread_key_t pthread_key_t
     * }
     */
    public static final OfLong pthread_key_t = Python_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_pthread_t pthread_t
     * }
     */
    public static final AddressLayout pthread_t = Python_h.C_POINTER;
    private static final int QOS_CLASS_USER_INTERACTIVE = (int)33L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.QOS_CLASS_USER_INTERACTIVE = 33
     * }
     */
    public static int QOS_CLASS_USER_INTERACTIVE() {
        return QOS_CLASS_USER_INTERACTIVE;
    }
    private static final int QOS_CLASS_USER_INITIATED = (int)25L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.QOS_CLASS_USER_INITIATED = 25
     * }
     */
    public static int QOS_CLASS_USER_INITIATED() {
        return QOS_CLASS_USER_INITIATED;
    }
    private static final int QOS_CLASS_DEFAULT = (int)21L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.QOS_CLASS_DEFAULT = 21
     * }
     */
    public static int QOS_CLASS_DEFAULT() {
        return QOS_CLASS_DEFAULT;
    }
    private static final int QOS_CLASS_UTILITY = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.QOS_CLASS_UTILITY = 17
     * }
     */
    public static int QOS_CLASS_UTILITY() {
        return QOS_CLASS_UTILITY;
    }
    private static final int QOS_CLASS_BACKGROUND = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.QOS_CLASS_BACKGROUND = 9
     * }
     */
    public static int QOS_CLASS_BACKGROUND() {
        return QOS_CLASS_BACKGROUND;
    }
    private static final int QOS_CLASS_UNSPECIFIED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.QOS_CLASS_UNSPECIFIED = 0
     * }
     */
    public static int QOS_CLASS_UNSPECIFIED() {
        return QOS_CLASS_UNSPECIFIED;
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned int qos_class_t
     * }
     */
    public static final OfInt qos_class_t = Python_h.C_INT;

    private static class qos_class_self {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("qos_class_self");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * qos_class_t qos_class_self()
     * }
     */
    public static FunctionDescriptor qos_class_self$descriptor() {
        return qos_class_self.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * qos_class_t qos_class_self()
     * }
     */
    public static MethodHandle qos_class_self$handle() {
        return qos_class_self.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * qos_class_t qos_class_self()
     * }
     */
    public static MemorySegment qos_class_self$address() {
        return qos_class_self.ADDR;
    }

    /**
     * {@snippet lang=c :
     * qos_class_t qos_class_self()
     * }
     */
    public static int qos_class_self() {
        var mh$ = qos_class_self.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qos_class_self");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qos_class_main {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("qos_class_main");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * qos_class_t qos_class_main()
     * }
     */
    public static FunctionDescriptor qos_class_main$descriptor() {
        return qos_class_main.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * qos_class_t qos_class_main()
     * }
     */
    public static MethodHandle qos_class_main$handle() {
        return qos_class_main.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * qos_class_t qos_class_main()
     * }
     */
    public static MemorySegment qos_class_main$address() {
        return qos_class_main.ADDR;
    }

    /**
     * {@snippet lang=c :
     * qos_class_t qos_class_main()
     * }
     */
    public static int qos_class_main() {
        var mh$ = qos_class_main.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qos_class_main");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_set_qos_class_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_attr_set_qos_class_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_attr_set_qos_class_np(pthread_attr_t * _Nonnull __attr, qos_class_t __qos_class, int __relative_priority)
     * }
     */
    public static FunctionDescriptor pthread_attr_set_qos_class_np$descriptor() {
        return pthread_attr_set_qos_class_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_attr_set_qos_class_np(pthread_attr_t * _Nonnull __attr, qos_class_t __qos_class, int __relative_priority)
     * }
     */
    public static MethodHandle pthread_attr_set_qos_class_np$handle() {
        return pthread_attr_set_qos_class_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_attr_set_qos_class_np(pthread_attr_t * _Nonnull __attr, qos_class_t __qos_class, int __relative_priority)
     * }
     */
    public static MemorySegment pthread_attr_set_qos_class_np$address() {
        return pthread_attr_set_qos_class_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_attr_set_qos_class_np(pthread_attr_t * _Nonnull __attr, qos_class_t __qos_class, int __relative_priority)
     * }
     */
    public static int pthread_attr_set_qos_class_np(MemorySegment __attr, int __qos_class, int __relative_priority) {
        var mh$ = pthread_attr_set_qos_class_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_set_qos_class_np", __attr, __qos_class, __relative_priority);
            }
            return (int)mh$.invokeExact(__attr, __qos_class, __relative_priority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_get_qos_class_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_attr_get_qos_class_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_attr_get_qos_class_np(pthread_attr_t *restrict  _Nonnull __attr, qos_class_t *restrict  _Nullable __qos_class, int *restrict  _Nullable __relative_priority)
     * }
     */
    public static FunctionDescriptor pthread_attr_get_qos_class_np$descriptor() {
        return pthread_attr_get_qos_class_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_attr_get_qos_class_np(pthread_attr_t *restrict  _Nonnull __attr, qos_class_t *restrict  _Nullable __qos_class, int *restrict  _Nullable __relative_priority)
     * }
     */
    public static MethodHandle pthread_attr_get_qos_class_np$handle() {
        return pthread_attr_get_qos_class_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_attr_get_qos_class_np(pthread_attr_t *restrict  _Nonnull __attr, qos_class_t *restrict  _Nullable __qos_class, int *restrict  _Nullable __relative_priority)
     * }
     */
    public static MemorySegment pthread_attr_get_qos_class_np$address() {
        return pthread_attr_get_qos_class_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_attr_get_qos_class_np(pthread_attr_t *restrict  _Nonnull __attr, qos_class_t *restrict  _Nullable __qos_class, int *restrict  _Nullable __relative_priority)
     * }
     */
    public static int pthread_attr_get_qos_class_np(MemorySegment __attr, MemorySegment __qos_class, MemorySegment __relative_priority) {
        var mh$ = pthread_attr_get_qos_class_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_get_qos_class_np", __attr, __qos_class, __relative_priority);
            }
            return (int)mh$.invokeExact(__attr, __qos_class, __relative_priority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_set_qos_class_self_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_set_qos_class_self_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_set_qos_class_self_np(qos_class_t __qos_class, int __relative_priority)
     * }
     */
    public static FunctionDescriptor pthread_set_qos_class_self_np$descriptor() {
        return pthread_set_qos_class_self_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_set_qos_class_self_np(qos_class_t __qos_class, int __relative_priority)
     * }
     */
    public static MethodHandle pthread_set_qos_class_self_np$handle() {
        return pthread_set_qos_class_self_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_set_qos_class_self_np(qos_class_t __qos_class, int __relative_priority)
     * }
     */
    public static MemorySegment pthread_set_qos_class_self_np$address() {
        return pthread_set_qos_class_self_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_set_qos_class_self_np(qos_class_t __qos_class, int __relative_priority)
     * }
     */
    public static int pthread_set_qos_class_self_np(int __qos_class, int __relative_priority) {
        var mh$ = pthread_set_qos_class_self_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_set_qos_class_self_np", __qos_class, __relative_priority);
            }
            return (int)mh$.invokeExact(__qos_class, __relative_priority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_get_qos_class_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_get_qos_class_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_get_qos_class_np(pthread_t  _Nonnull __pthread, qos_class_t *restrict  _Nullable __qos_class, int *restrict  _Nullable __relative_priority)
     * }
     */
    public static FunctionDescriptor pthread_get_qos_class_np$descriptor() {
        return pthread_get_qos_class_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_get_qos_class_np(pthread_t  _Nonnull __pthread, qos_class_t *restrict  _Nullable __qos_class, int *restrict  _Nullable __relative_priority)
     * }
     */
    public static MethodHandle pthread_get_qos_class_np$handle() {
        return pthread_get_qos_class_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_get_qos_class_np(pthread_t  _Nonnull __pthread, qos_class_t *restrict  _Nullable __qos_class, int *restrict  _Nullable __relative_priority)
     * }
     */
    public static MemorySegment pthread_get_qos_class_np$address() {
        return pthread_get_qos_class_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_get_qos_class_np(pthread_t  _Nonnull __pthread, qos_class_t *restrict  _Nullable __qos_class, int *restrict  _Nullable __relative_priority)
     * }
     */
    public static int pthread_get_qos_class_np(MemorySegment __pthread, MemorySegment __qos_class, MemorySegment __relative_priority) {
        var mh$ = pthread_get_qos_class_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_get_qos_class_np", __pthread, __qos_class, __relative_priority);
            }
            return (int)mh$.invokeExact(__pthread, __qos_class, __relative_priority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct pthread_override_s *pthread_override_t
     * }
     */
    public static final AddressLayout pthread_override_t = Python_h.C_POINTER;

    private static class pthread_override_qos_class_start_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_override_qos_class_start_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pthread_override_t  _Nonnull pthread_override_qos_class_start_np(pthread_t  _Nonnull __pthread, qos_class_t __qos_class, int __relative_priority)
     * }
     */
    public static FunctionDescriptor pthread_override_qos_class_start_np$descriptor() {
        return pthread_override_qos_class_start_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pthread_override_t  _Nonnull pthread_override_qos_class_start_np(pthread_t  _Nonnull __pthread, qos_class_t __qos_class, int __relative_priority)
     * }
     */
    public static MethodHandle pthread_override_qos_class_start_np$handle() {
        return pthread_override_qos_class_start_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pthread_override_t  _Nonnull pthread_override_qos_class_start_np(pthread_t  _Nonnull __pthread, qos_class_t __qos_class, int __relative_priority)
     * }
     */
    public static MemorySegment pthread_override_qos_class_start_np$address() {
        return pthread_override_qos_class_start_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pthread_override_t  _Nonnull pthread_override_qos_class_start_np(pthread_t  _Nonnull __pthread, qos_class_t __qos_class, int __relative_priority)
     * }
     */
    public static MemorySegment pthread_override_qos_class_start_np(MemorySegment __pthread, int __qos_class, int __relative_priority) {
        var mh$ = pthread_override_qos_class_start_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_override_qos_class_start_np", __pthread, __qos_class, __relative_priority);
            }
            return (MemorySegment)mh$.invokeExact(__pthread, __qos_class, __relative_priority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_override_qos_class_end_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_override_qos_class_end_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_override_qos_class_end_np(pthread_override_t  _Nonnull __override)
     * }
     */
    public static FunctionDescriptor pthread_override_qos_class_end_np$descriptor() {
        return pthread_override_qos_class_end_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_override_qos_class_end_np(pthread_override_t  _Nonnull __override)
     * }
     */
    public static MethodHandle pthread_override_qos_class_end_np$handle() {
        return pthread_override_qos_class_end_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_override_qos_class_end_np(pthread_override_t  _Nonnull __override)
     * }
     */
    public static MemorySegment pthread_override_qos_class_end_np$address() {
        return pthread_override_qos_class_end_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_override_qos_class_end_np(pthread_override_t  _Nonnull __override)
     * }
     */
    public static int pthread_override_qos_class_end_np(MemorySegment __override) {
        var mh$ = pthread_override_qos_class_end_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_override_qos_class_end_np", __override);
            }
            return (int)mh$.invokeExact(__override);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_mach_port_t mach_port_t
     * }
     */
    public static final OfInt mach_port_t = Python_h.C_INT;

    private static class pthread_atfork {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_atfork");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_atfork(void (* _Nullable)(void), void (* _Nullable)(void), void (* _Nullable)(void))
     * }
     */
    public static FunctionDescriptor pthread_atfork$descriptor() {
        return pthread_atfork.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_atfork(void (* _Nullable)(void), void (* _Nullable)(void), void (* _Nullable)(void))
     * }
     */
    public static MethodHandle pthread_atfork$handle() {
        return pthread_atfork.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_atfork(void (* _Nullable)(void), void (* _Nullable)(void), void (* _Nullable)(void))
     * }
     */
    public static MemorySegment pthread_atfork$address() {
        return pthread_atfork.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_atfork(void (* _Nullable)(void), void (* _Nullable)(void), void (* _Nullable)(void))
     * }
     */
    public static int pthread_atfork(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = pthread_atfork.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_atfork", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_attr_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_attr_destroy(pthread_attr_t * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_attr_destroy$descriptor() {
        return pthread_attr_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_attr_destroy(pthread_attr_t * _Nonnull)
     * }
     */
    public static MethodHandle pthread_attr_destroy$handle() {
        return pthread_attr_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_attr_destroy(pthread_attr_t * _Nonnull)
     * }
     */
    public static MemorySegment pthread_attr_destroy$address() {
        return pthread_attr_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_attr_destroy(pthread_attr_t * _Nonnull)
     * }
     */
    public static int pthread_attr_destroy(MemorySegment x0) {
        var mh$ = pthread_attr_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_destroy", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_getdetachstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_attr_getdetachstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_attr_getdetachstate(const pthread_attr_t * _Nonnull, int * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_attr_getdetachstate$descriptor() {
        return pthread_attr_getdetachstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_attr_getdetachstate(const pthread_attr_t * _Nonnull, int * _Nonnull)
     * }
     */
    public static MethodHandle pthread_attr_getdetachstate$handle() {
        return pthread_attr_getdetachstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_attr_getdetachstate(const pthread_attr_t * _Nonnull, int * _Nonnull)
     * }
     */
    public static MemorySegment pthread_attr_getdetachstate$address() {
        return pthread_attr_getdetachstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_attr_getdetachstate(const pthread_attr_t * _Nonnull, int * _Nonnull)
     * }
     */
    public static int pthread_attr_getdetachstate(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_attr_getdetachstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_getdetachstate", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_getguardsize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_attr_getguardsize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_attr_getguardsize(const pthread_attr_t *restrict _Nonnull, size_t *restrict _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_attr_getguardsize$descriptor() {
        return pthread_attr_getguardsize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_attr_getguardsize(const pthread_attr_t *restrict _Nonnull, size_t *restrict _Nonnull)
     * }
     */
    public static MethodHandle pthread_attr_getguardsize$handle() {
        return pthread_attr_getguardsize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_attr_getguardsize(const pthread_attr_t *restrict _Nonnull, size_t *restrict _Nonnull)
     * }
     */
    public static MemorySegment pthread_attr_getguardsize$address() {
        return pthread_attr_getguardsize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_attr_getguardsize(const pthread_attr_t *restrict _Nonnull, size_t *restrict _Nonnull)
     * }
     */
    public static int pthread_attr_getguardsize(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_attr_getguardsize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_getguardsize", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_getinheritsched {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_attr_getinheritsched");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_attr_getinheritsched(const pthread_attr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_attr_getinheritsched$descriptor() {
        return pthread_attr_getinheritsched.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_attr_getinheritsched(const pthread_attr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static MethodHandle pthread_attr_getinheritsched$handle() {
        return pthread_attr_getinheritsched.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_attr_getinheritsched(const pthread_attr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static MemorySegment pthread_attr_getinheritsched$address() {
        return pthread_attr_getinheritsched.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_attr_getinheritsched(const pthread_attr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static int pthread_attr_getinheritsched(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_attr_getinheritsched.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_getinheritsched", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_getschedparam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_attr_getschedparam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_attr_getschedparam(const pthread_attr_t *restrict _Nonnull, struct sched_param *restrict _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_attr_getschedparam$descriptor() {
        return pthread_attr_getschedparam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_attr_getschedparam(const pthread_attr_t *restrict _Nonnull, struct sched_param *restrict _Nonnull)
     * }
     */
    public static MethodHandle pthread_attr_getschedparam$handle() {
        return pthread_attr_getschedparam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_attr_getschedparam(const pthread_attr_t *restrict _Nonnull, struct sched_param *restrict _Nonnull)
     * }
     */
    public static MemorySegment pthread_attr_getschedparam$address() {
        return pthread_attr_getschedparam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_attr_getschedparam(const pthread_attr_t *restrict _Nonnull, struct sched_param *restrict _Nonnull)
     * }
     */
    public static int pthread_attr_getschedparam(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_attr_getschedparam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_getschedparam", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_getschedpolicy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_attr_getschedpolicy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_attr_getschedpolicy(const pthread_attr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_attr_getschedpolicy$descriptor() {
        return pthread_attr_getschedpolicy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_attr_getschedpolicy(const pthread_attr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static MethodHandle pthread_attr_getschedpolicy$handle() {
        return pthread_attr_getschedpolicy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_attr_getschedpolicy(const pthread_attr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static MemorySegment pthread_attr_getschedpolicy$address() {
        return pthread_attr_getschedpolicy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_attr_getschedpolicy(const pthread_attr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static int pthread_attr_getschedpolicy(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_attr_getschedpolicy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_getschedpolicy", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_getscope {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_attr_getscope");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_attr_getscope(const pthread_attr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_attr_getscope$descriptor() {
        return pthread_attr_getscope.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_attr_getscope(const pthread_attr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static MethodHandle pthread_attr_getscope$handle() {
        return pthread_attr_getscope.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_attr_getscope(const pthread_attr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static MemorySegment pthread_attr_getscope$address() {
        return pthread_attr_getscope.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_attr_getscope(const pthread_attr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static int pthread_attr_getscope(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_attr_getscope.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_getscope", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_getstack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_attr_getstack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_attr_getstack(const pthread_attr_t *restrict _Nonnull, void * _Nullable *restrict _Nonnull, size_t *restrict _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_attr_getstack$descriptor() {
        return pthread_attr_getstack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_attr_getstack(const pthread_attr_t *restrict _Nonnull, void * _Nullable *restrict _Nonnull, size_t *restrict _Nonnull)
     * }
     */
    public static MethodHandle pthread_attr_getstack$handle() {
        return pthread_attr_getstack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_attr_getstack(const pthread_attr_t *restrict _Nonnull, void * _Nullable *restrict _Nonnull, size_t *restrict _Nonnull)
     * }
     */
    public static MemorySegment pthread_attr_getstack$address() {
        return pthread_attr_getstack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_attr_getstack(const pthread_attr_t *restrict _Nonnull, void * _Nullable *restrict _Nonnull, size_t *restrict _Nonnull)
     * }
     */
    public static int pthread_attr_getstack(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = pthread_attr_getstack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_getstack", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_getstackaddr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_attr_getstackaddr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_attr_getstackaddr(const pthread_attr_t *restrict _Nonnull, void * _Nullable *restrict _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_attr_getstackaddr$descriptor() {
        return pthread_attr_getstackaddr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_attr_getstackaddr(const pthread_attr_t *restrict _Nonnull, void * _Nullable *restrict _Nonnull)
     * }
     */
    public static MethodHandle pthread_attr_getstackaddr$handle() {
        return pthread_attr_getstackaddr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_attr_getstackaddr(const pthread_attr_t *restrict _Nonnull, void * _Nullable *restrict _Nonnull)
     * }
     */
    public static MemorySegment pthread_attr_getstackaddr$address() {
        return pthread_attr_getstackaddr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_attr_getstackaddr(const pthread_attr_t *restrict _Nonnull, void * _Nullable *restrict _Nonnull)
     * }
     */
    public static int pthread_attr_getstackaddr(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_attr_getstackaddr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_getstackaddr", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_getstacksize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_attr_getstacksize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_attr_getstacksize(const pthread_attr_t *restrict _Nonnull, size_t *restrict _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_attr_getstacksize$descriptor() {
        return pthread_attr_getstacksize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_attr_getstacksize(const pthread_attr_t *restrict _Nonnull, size_t *restrict _Nonnull)
     * }
     */
    public static MethodHandle pthread_attr_getstacksize$handle() {
        return pthread_attr_getstacksize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_attr_getstacksize(const pthread_attr_t *restrict _Nonnull, size_t *restrict _Nonnull)
     * }
     */
    public static MemorySegment pthread_attr_getstacksize$address() {
        return pthread_attr_getstacksize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_attr_getstacksize(const pthread_attr_t *restrict _Nonnull, size_t *restrict _Nonnull)
     * }
     */
    public static int pthread_attr_getstacksize(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_attr_getstacksize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_getstacksize", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_attr_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_attr_init(pthread_attr_t * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_attr_init$descriptor() {
        return pthread_attr_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_attr_init(pthread_attr_t * _Nonnull)
     * }
     */
    public static MethodHandle pthread_attr_init$handle() {
        return pthread_attr_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_attr_init(pthread_attr_t * _Nonnull)
     * }
     */
    public static MemorySegment pthread_attr_init$address() {
        return pthread_attr_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_attr_init(pthread_attr_t * _Nonnull)
     * }
     */
    public static int pthread_attr_init(MemorySegment x0) {
        var mh$ = pthread_attr_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_init", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_setdetachstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_attr_setdetachstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_attr_setdetachstate(pthread_attr_t * _Nonnull, int)
     * }
     */
    public static FunctionDescriptor pthread_attr_setdetachstate$descriptor() {
        return pthread_attr_setdetachstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_attr_setdetachstate(pthread_attr_t * _Nonnull, int)
     * }
     */
    public static MethodHandle pthread_attr_setdetachstate$handle() {
        return pthread_attr_setdetachstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_attr_setdetachstate(pthread_attr_t * _Nonnull, int)
     * }
     */
    public static MemorySegment pthread_attr_setdetachstate$address() {
        return pthread_attr_setdetachstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_attr_setdetachstate(pthread_attr_t * _Nonnull, int)
     * }
     */
    public static int pthread_attr_setdetachstate(MemorySegment x0, int x1) {
        var mh$ = pthread_attr_setdetachstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_setdetachstate", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_setguardsize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_attr_setguardsize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_attr_setguardsize(pthread_attr_t * _Nonnull, size_t)
     * }
     */
    public static FunctionDescriptor pthread_attr_setguardsize$descriptor() {
        return pthread_attr_setguardsize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_attr_setguardsize(pthread_attr_t * _Nonnull, size_t)
     * }
     */
    public static MethodHandle pthread_attr_setguardsize$handle() {
        return pthread_attr_setguardsize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_attr_setguardsize(pthread_attr_t * _Nonnull, size_t)
     * }
     */
    public static MemorySegment pthread_attr_setguardsize$address() {
        return pthread_attr_setguardsize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_attr_setguardsize(pthread_attr_t * _Nonnull, size_t)
     * }
     */
    public static int pthread_attr_setguardsize(MemorySegment x0, long x1) {
        var mh$ = pthread_attr_setguardsize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_setguardsize", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_setinheritsched {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_attr_setinheritsched");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_attr_setinheritsched(pthread_attr_t * _Nonnull, int)
     * }
     */
    public static FunctionDescriptor pthread_attr_setinheritsched$descriptor() {
        return pthread_attr_setinheritsched.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_attr_setinheritsched(pthread_attr_t * _Nonnull, int)
     * }
     */
    public static MethodHandle pthread_attr_setinheritsched$handle() {
        return pthread_attr_setinheritsched.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_attr_setinheritsched(pthread_attr_t * _Nonnull, int)
     * }
     */
    public static MemorySegment pthread_attr_setinheritsched$address() {
        return pthread_attr_setinheritsched.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_attr_setinheritsched(pthread_attr_t * _Nonnull, int)
     * }
     */
    public static int pthread_attr_setinheritsched(MemorySegment x0, int x1) {
        var mh$ = pthread_attr_setinheritsched.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_setinheritsched", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_setschedparam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_attr_setschedparam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_attr_setschedparam(pthread_attr_t *restrict _Nonnull, const struct sched_param *restrict _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_attr_setschedparam$descriptor() {
        return pthread_attr_setschedparam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_attr_setschedparam(pthread_attr_t *restrict _Nonnull, const struct sched_param *restrict _Nonnull)
     * }
     */
    public static MethodHandle pthread_attr_setschedparam$handle() {
        return pthread_attr_setschedparam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_attr_setschedparam(pthread_attr_t *restrict _Nonnull, const struct sched_param *restrict _Nonnull)
     * }
     */
    public static MemorySegment pthread_attr_setschedparam$address() {
        return pthread_attr_setschedparam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_attr_setschedparam(pthread_attr_t *restrict _Nonnull, const struct sched_param *restrict _Nonnull)
     * }
     */
    public static int pthread_attr_setschedparam(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_attr_setschedparam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_setschedparam", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_setschedpolicy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_attr_setschedpolicy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_attr_setschedpolicy(pthread_attr_t * _Nonnull, int)
     * }
     */
    public static FunctionDescriptor pthread_attr_setschedpolicy$descriptor() {
        return pthread_attr_setschedpolicy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_attr_setschedpolicy(pthread_attr_t * _Nonnull, int)
     * }
     */
    public static MethodHandle pthread_attr_setschedpolicy$handle() {
        return pthread_attr_setschedpolicy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_attr_setschedpolicy(pthread_attr_t * _Nonnull, int)
     * }
     */
    public static MemorySegment pthread_attr_setschedpolicy$address() {
        return pthread_attr_setschedpolicy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_attr_setschedpolicy(pthread_attr_t * _Nonnull, int)
     * }
     */
    public static int pthread_attr_setschedpolicy(MemorySegment x0, int x1) {
        var mh$ = pthread_attr_setschedpolicy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_setschedpolicy", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_setscope {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_attr_setscope");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_attr_setscope(pthread_attr_t * _Nonnull, int)
     * }
     */
    public static FunctionDescriptor pthread_attr_setscope$descriptor() {
        return pthread_attr_setscope.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_attr_setscope(pthread_attr_t * _Nonnull, int)
     * }
     */
    public static MethodHandle pthread_attr_setscope$handle() {
        return pthread_attr_setscope.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_attr_setscope(pthread_attr_t * _Nonnull, int)
     * }
     */
    public static MemorySegment pthread_attr_setscope$address() {
        return pthread_attr_setscope.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_attr_setscope(pthread_attr_t * _Nonnull, int)
     * }
     */
    public static int pthread_attr_setscope(MemorySegment x0, int x1) {
        var mh$ = pthread_attr_setscope.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_setscope", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_setstack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_attr_setstack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_attr_setstack(pthread_attr_t * _Nonnull, void * _Nonnull, size_t)
     * }
     */
    public static FunctionDescriptor pthread_attr_setstack$descriptor() {
        return pthread_attr_setstack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_attr_setstack(pthread_attr_t * _Nonnull, void * _Nonnull, size_t)
     * }
     */
    public static MethodHandle pthread_attr_setstack$handle() {
        return pthread_attr_setstack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_attr_setstack(pthread_attr_t * _Nonnull, void * _Nonnull, size_t)
     * }
     */
    public static MemorySegment pthread_attr_setstack$address() {
        return pthread_attr_setstack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_attr_setstack(pthread_attr_t * _Nonnull, void * _Nonnull, size_t)
     * }
     */
    public static int pthread_attr_setstack(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = pthread_attr_setstack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_setstack", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_setstackaddr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_attr_setstackaddr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_attr_setstackaddr(pthread_attr_t * _Nonnull, void * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_attr_setstackaddr$descriptor() {
        return pthread_attr_setstackaddr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_attr_setstackaddr(pthread_attr_t * _Nonnull, void * _Nonnull)
     * }
     */
    public static MethodHandle pthread_attr_setstackaddr$handle() {
        return pthread_attr_setstackaddr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_attr_setstackaddr(pthread_attr_t * _Nonnull, void * _Nonnull)
     * }
     */
    public static MemorySegment pthread_attr_setstackaddr$address() {
        return pthread_attr_setstackaddr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_attr_setstackaddr(pthread_attr_t * _Nonnull, void * _Nonnull)
     * }
     */
    public static int pthread_attr_setstackaddr(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_attr_setstackaddr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_setstackaddr", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_attr_setstacksize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_attr_setstacksize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_attr_setstacksize(pthread_attr_t * _Nonnull, size_t)
     * }
     */
    public static FunctionDescriptor pthread_attr_setstacksize$descriptor() {
        return pthread_attr_setstacksize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_attr_setstacksize(pthread_attr_t * _Nonnull, size_t)
     * }
     */
    public static MethodHandle pthread_attr_setstacksize$handle() {
        return pthread_attr_setstacksize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_attr_setstacksize(pthread_attr_t * _Nonnull, size_t)
     * }
     */
    public static MemorySegment pthread_attr_setstacksize$address() {
        return pthread_attr_setstacksize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_attr_setstacksize(pthread_attr_t * _Nonnull, size_t)
     * }
     */
    public static int pthread_attr_setstacksize(MemorySegment x0, long x1) {
        var mh$ = pthread_attr_setstacksize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_attr_setstacksize", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_cancel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_cancel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_cancel(pthread_t _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_cancel$descriptor() {
        return pthread_cancel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_cancel(pthread_t _Nonnull)
     * }
     */
    public static MethodHandle pthread_cancel$handle() {
        return pthread_cancel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_cancel(pthread_t _Nonnull)
     * }
     */
    public static MemorySegment pthread_cancel$address() {
        return pthread_cancel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_cancel(pthread_t _Nonnull)
     * }
     */
    public static int pthread_cancel(MemorySegment x0) {
        var mh$ = pthread_cancel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_cancel", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_cond_broadcast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_cond_broadcast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_cond_broadcast(pthread_cond_t * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_cond_broadcast$descriptor() {
        return pthread_cond_broadcast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_cond_broadcast(pthread_cond_t * _Nonnull)
     * }
     */
    public static MethodHandle pthread_cond_broadcast$handle() {
        return pthread_cond_broadcast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_cond_broadcast(pthread_cond_t * _Nonnull)
     * }
     */
    public static MemorySegment pthread_cond_broadcast$address() {
        return pthread_cond_broadcast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_cond_broadcast(pthread_cond_t * _Nonnull)
     * }
     */
    public static int pthread_cond_broadcast(MemorySegment x0) {
        var mh$ = pthread_cond_broadcast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_cond_broadcast", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_cond_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_cond_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_cond_destroy(pthread_cond_t * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_cond_destroy$descriptor() {
        return pthread_cond_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_cond_destroy(pthread_cond_t * _Nonnull)
     * }
     */
    public static MethodHandle pthread_cond_destroy$handle() {
        return pthread_cond_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_cond_destroy(pthread_cond_t * _Nonnull)
     * }
     */
    public static MemorySegment pthread_cond_destroy$address() {
        return pthread_cond_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_cond_destroy(pthread_cond_t * _Nonnull)
     * }
     */
    public static int pthread_cond_destroy(MemorySegment x0) {
        var mh$ = pthread_cond_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_cond_destroy", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_cond_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_cond_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_cond_init(pthread_cond_t *restrict _Nonnull, const pthread_condattr_t *restrict _Nullable)
     * }
     */
    public static FunctionDescriptor pthread_cond_init$descriptor() {
        return pthread_cond_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_cond_init(pthread_cond_t *restrict _Nonnull, const pthread_condattr_t *restrict _Nullable)
     * }
     */
    public static MethodHandle pthread_cond_init$handle() {
        return pthread_cond_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_cond_init(pthread_cond_t *restrict _Nonnull, const pthread_condattr_t *restrict _Nullable)
     * }
     */
    public static MemorySegment pthread_cond_init$address() {
        return pthread_cond_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_cond_init(pthread_cond_t *restrict _Nonnull, const pthread_condattr_t *restrict _Nullable)
     * }
     */
    public static int pthread_cond_init(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_cond_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_cond_init", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_cond_signal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_cond_signal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_cond_signal(pthread_cond_t * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_cond_signal$descriptor() {
        return pthread_cond_signal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_cond_signal(pthread_cond_t * _Nonnull)
     * }
     */
    public static MethodHandle pthread_cond_signal$handle() {
        return pthread_cond_signal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_cond_signal(pthread_cond_t * _Nonnull)
     * }
     */
    public static MemorySegment pthread_cond_signal$address() {
        return pthread_cond_signal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_cond_signal(pthread_cond_t * _Nonnull)
     * }
     */
    public static int pthread_cond_signal(MemorySegment x0) {
        var mh$ = pthread_cond_signal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_cond_signal", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_cond_timedwait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_cond_timedwait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_cond_timedwait(pthread_cond_t *restrict _Nonnull, pthread_mutex_t *restrict _Nonnull, const struct timespec *restrict _Nullable)
     * }
     */
    public static FunctionDescriptor pthread_cond_timedwait$descriptor() {
        return pthread_cond_timedwait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_cond_timedwait(pthread_cond_t *restrict _Nonnull, pthread_mutex_t *restrict _Nonnull, const struct timespec *restrict _Nullable)
     * }
     */
    public static MethodHandle pthread_cond_timedwait$handle() {
        return pthread_cond_timedwait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_cond_timedwait(pthread_cond_t *restrict _Nonnull, pthread_mutex_t *restrict _Nonnull, const struct timespec *restrict _Nullable)
     * }
     */
    public static MemorySegment pthread_cond_timedwait$address() {
        return pthread_cond_timedwait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_cond_timedwait(pthread_cond_t *restrict _Nonnull, pthread_mutex_t *restrict _Nonnull, const struct timespec *restrict _Nullable)
     * }
     */
    public static int pthread_cond_timedwait(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = pthread_cond_timedwait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_cond_timedwait", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_cond_wait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_cond_wait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_cond_wait(pthread_cond_t *restrict _Nonnull, pthread_mutex_t *restrict _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_cond_wait$descriptor() {
        return pthread_cond_wait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_cond_wait(pthread_cond_t *restrict _Nonnull, pthread_mutex_t *restrict _Nonnull)
     * }
     */
    public static MethodHandle pthread_cond_wait$handle() {
        return pthread_cond_wait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_cond_wait(pthread_cond_t *restrict _Nonnull, pthread_mutex_t *restrict _Nonnull)
     * }
     */
    public static MemorySegment pthread_cond_wait$address() {
        return pthread_cond_wait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_cond_wait(pthread_cond_t *restrict _Nonnull, pthread_mutex_t *restrict _Nonnull)
     * }
     */
    public static int pthread_cond_wait(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_cond_wait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_cond_wait", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_condattr_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_condattr_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_condattr_destroy(pthread_condattr_t * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_condattr_destroy$descriptor() {
        return pthread_condattr_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_condattr_destroy(pthread_condattr_t * _Nonnull)
     * }
     */
    public static MethodHandle pthread_condattr_destroy$handle() {
        return pthread_condattr_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_condattr_destroy(pthread_condattr_t * _Nonnull)
     * }
     */
    public static MemorySegment pthread_condattr_destroy$address() {
        return pthread_condattr_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_condattr_destroy(pthread_condattr_t * _Nonnull)
     * }
     */
    public static int pthread_condattr_destroy(MemorySegment x0) {
        var mh$ = pthread_condattr_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_condattr_destroy", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_condattr_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_condattr_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_condattr_init(pthread_condattr_t * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_condattr_init$descriptor() {
        return pthread_condattr_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_condattr_init(pthread_condattr_t * _Nonnull)
     * }
     */
    public static MethodHandle pthread_condattr_init$handle() {
        return pthread_condattr_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_condattr_init(pthread_condattr_t * _Nonnull)
     * }
     */
    public static MemorySegment pthread_condattr_init$address() {
        return pthread_condattr_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_condattr_init(pthread_condattr_t * _Nonnull)
     * }
     */
    public static int pthread_condattr_init(MemorySegment x0) {
        var mh$ = pthread_condattr_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_condattr_init", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_condattr_getpshared {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_condattr_getpshared");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_condattr_getpshared(const pthread_condattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_condattr_getpshared$descriptor() {
        return pthread_condattr_getpshared.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_condattr_getpshared(const pthread_condattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static MethodHandle pthread_condattr_getpshared$handle() {
        return pthread_condattr_getpshared.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_condattr_getpshared(const pthread_condattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static MemorySegment pthread_condattr_getpshared$address() {
        return pthread_condattr_getpshared.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_condattr_getpshared(const pthread_condattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static int pthread_condattr_getpshared(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_condattr_getpshared.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_condattr_getpshared", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_condattr_setpshared {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_condattr_setpshared");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_condattr_setpshared(pthread_condattr_t * _Nonnull, int)
     * }
     */
    public static FunctionDescriptor pthread_condattr_setpshared$descriptor() {
        return pthread_condattr_setpshared.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_condattr_setpshared(pthread_condattr_t * _Nonnull, int)
     * }
     */
    public static MethodHandle pthread_condattr_setpshared$handle() {
        return pthread_condattr_setpshared.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_condattr_setpshared(pthread_condattr_t * _Nonnull, int)
     * }
     */
    public static MemorySegment pthread_condattr_setpshared$address() {
        return pthread_condattr_setpshared.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_condattr_setpshared(pthread_condattr_t * _Nonnull, int)
     * }
     */
    public static int pthread_condattr_setpshared(MemorySegment x0, int x1) {
        var mh$ = pthread_condattr_setpshared.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_condattr_setpshared", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_create(pthread_t  _Nullable *restrict _Nonnull, const pthread_attr_t *restrict _Nullable, void * _Nullable (* _Nonnull)(void * _Nullable), void *restrict _Nullable)
     * }
     */
    public static FunctionDescriptor pthread_create$descriptor() {
        return pthread_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_create(pthread_t  _Nullable *restrict _Nonnull, const pthread_attr_t *restrict _Nullable, void * _Nullable (* _Nonnull)(void * _Nullable), void *restrict _Nullable)
     * }
     */
    public static MethodHandle pthread_create$handle() {
        return pthread_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_create(pthread_t  _Nullable *restrict _Nonnull, const pthread_attr_t *restrict _Nullable, void * _Nullable (* _Nonnull)(void * _Nullable), void *restrict _Nullable)
     * }
     */
    public static MemorySegment pthread_create$address() {
        return pthread_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_create(pthread_t  _Nullable *restrict _Nonnull, const pthread_attr_t *restrict _Nullable, void * _Nullable (* _Nonnull)(void * _Nullable), void *restrict _Nullable)
     * }
     */
    public static int pthread_create(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = pthread_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_create", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_detach {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_detach");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_detach(pthread_t _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_detach$descriptor() {
        return pthread_detach.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_detach(pthread_t _Nonnull)
     * }
     */
    public static MethodHandle pthread_detach$handle() {
        return pthread_detach.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_detach(pthread_t _Nonnull)
     * }
     */
    public static MemorySegment pthread_detach$address() {
        return pthread_detach.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_detach(pthread_t _Nonnull)
     * }
     */
    public static int pthread_detach(MemorySegment x0) {
        var mh$ = pthread_detach.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_detach", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_equal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_equal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_equal(pthread_t _Nullable, pthread_t _Nullable)
     * }
     */
    public static FunctionDescriptor pthread_equal$descriptor() {
        return pthread_equal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_equal(pthread_t _Nullable, pthread_t _Nullable)
     * }
     */
    public static MethodHandle pthread_equal$handle() {
        return pthread_equal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_equal(pthread_t _Nullable, pthread_t _Nullable)
     * }
     */
    public static MemorySegment pthread_equal$address() {
        return pthread_equal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_equal(pthread_t _Nullable, pthread_t _Nullable)
     * }
     */
    public static int pthread_equal(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_equal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_equal", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pthread_exit(void * _Nullable)
     * }
     */
    public static FunctionDescriptor pthread_exit$descriptor() {
        return pthread_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pthread_exit(void * _Nullable)
     * }
     */
    public static MethodHandle pthread_exit$handle() {
        return pthread_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pthread_exit(void * _Nullable)
     * }
     */
    public static MemorySegment pthread_exit$address() {
        return pthread_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pthread_exit(void * _Nullable)
     * }
     */
    public static void pthread_exit(MemorySegment x0) {
        var mh$ = pthread_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_exit", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_getconcurrency {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_getconcurrency");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_getconcurrency()
     * }
     */
    public static FunctionDescriptor pthread_getconcurrency$descriptor() {
        return pthread_getconcurrency.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_getconcurrency()
     * }
     */
    public static MethodHandle pthread_getconcurrency$handle() {
        return pthread_getconcurrency.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_getconcurrency()
     * }
     */
    public static MemorySegment pthread_getconcurrency$address() {
        return pthread_getconcurrency.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_getconcurrency()
     * }
     */
    public static int pthread_getconcurrency() {
        var mh$ = pthread_getconcurrency.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_getconcurrency");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_getschedparam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_getschedparam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_getschedparam(pthread_t _Nonnull, int *restrict _Nullable, struct sched_param *restrict _Nullable)
     * }
     */
    public static FunctionDescriptor pthread_getschedparam$descriptor() {
        return pthread_getschedparam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_getschedparam(pthread_t _Nonnull, int *restrict _Nullable, struct sched_param *restrict _Nullable)
     * }
     */
    public static MethodHandle pthread_getschedparam$handle() {
        return pthread_getschedparam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_getschedparam(pthread_t _Nonnull, int *restrict _Nullable, struct sched_param *restrict _Nullable)
     * }
     */
    public static MemorySegment pthread_getschedparam$address() {
        return pthread_getschedparam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_getschedparam(pthread_t _Nonnull, int *restrict _Nullable, struct sched_param *restrict _Nullable)
     * }
     */
    public static int pthread_getschedparam(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = pthread_getschedparam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_getschedparam", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_getspecific {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_getspecific");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void * _Nullable pthread_getspecific(pthread_key_t)
     * }
     */
    public static FunctionDescriptor pthread_getspecific$descriptor() {
        return pthread_getspecific.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void * _Nullable pthread_getspecific(pthread_key_t)
     * }
     */
    public static MethodHandle pthread_getspecific$handle() {
        return pthread_getspecific.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void * _Nullable pthread_getspecific(pthread_key_t)
     * }
     */
    public static MemorySegment pthread_getspecific$address() {
        return pthread_getspecific.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void * _Nullable pthread_getspecific(pthread_key_t)
     * }
     */
    public static MemorySegment pthread_getspecific(long x0) {
        var mh$ = pthread_getspecific.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_getspecific", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_join {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_join");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_join(pthread_t _Nonnull, void * _Nullable * _Nullable)
     * }
     */
    public static FunctionDescriptor pthread_join$descriptor() {
        return pthread_join.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_join(pthread_t _Nonnull, void * _Nullable * _Nullable)
     * }
     */
    public static MethodHandle pthread_join$handle() {
        return pthread_join.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_join(pthread_t _Nonnull, void * _Nullable * _Nullable)
     * }
     */
    public static MemorySegment pthread_join$address() {
        return pthread_join.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_join(pthread_t _Nonnull, void * _Nullable * _Nullable)
     * }
     */
    public static int pthread_join(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_join.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_join", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_key_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_key_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_key_create(pthread_key_t * _Nonnull, void (* _Nullable)(void * _Nonnull))
     * }
     */
    public static FunctionDescriptor pthread_key_create$descriptor() {
        return pthread_key_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_key_create(pthread_key_t * _Nonnull, void (* _Nullable)(void * _Nonnull))
     * }
     */
    public static MethodHandle pthread_key_create$handle() {
        return pthread_key_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_key_create(pthread_key_t * _Nonnull, void (* _Nullable)(void * _Nonnull))
     * }
     */
    public static MemorySegment pthread_key_create$address() {
        return pthread_key_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_key_create(pthread_key_t * _Nonnull, void (* _Nullable)(void * _Nonnull))
     * }
     */
    public static int pthread_key_create(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_key_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_key_create", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_key_delete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_key_delete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_key_delete(pthread_key_t)
     * }
     */
    public static FunctionDescriptor pthread_key_delete$descriptor() {
        return pthread_key_delete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_key_delete(pthread_key_t)
     * }
     */
    public static MethodHandle pthread_key_delete$handle() {
        return pthread_key_delete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_key_delete(pthread_key_t)
     * }
     */
    public static MemorySegment pthread_key_delete$address() {
        return pthread_key_delete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_key_delete(pthread_key_t)
     * }
     */
    public static int pthread_key_delete(long x0) {
        var mh$ = pthread_key_delete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_key_delete", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutex_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_mutex_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_mutex_destroy(pthread_mutex_t * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_mutex_destroy$descriptor() {
        return pthread_mutex_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_mutex_destroy(pthread_mutex_t * _Nonnull)
     * }
     */
    public static MethodHandle pthread_mutex_destroy$handle() {
        return pthread_mutex_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_mutex_destroy(pthread_mutex_t * _Nonnull)
     * }
     */
    public static MemorySegment pthread_mutex_destroy$address() {
        return pthread_mutex_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_mutex_destroy(pthread_mutex_t * _Nonnull)
     * }
     */
    public static int pthread_mutex_destroy(MemorySegment x0) {
        var mh$ = pthread_mutex_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutex_destroy", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutex_getprioceiling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_mutex_getprioceiling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_mutex_getprioceiling(const pthread_mutex_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_mutex_getprioceiling$descriptor() {
        return pthread_mutex_getprioceiling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_mutex_getprioceiling(const pthread_mutex_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static MethodHandle pthread_mutex_getprioceiling$handle() {
        return pthread_mutex_getprioceiling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_mutex_getprioceiling(const pthread_mutex_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static MemorySegment pthread_mutex_getprioceiling$address() {
        return pthread_mutex_getprioceiling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_mutex_getprioceiling(const pthread_mutex_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static int pthread_mutex_getprioceiling(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_mutex_getprioceiling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutex_getprioceiling", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutex_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_mutex_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_mutex_init(pthread_mutex_t *restrict _Nonnull, const pthread_mutexattr_t *restrict _Nullable)
     * }
     */
    public static FunctionDescriptor pthread_mutex_init$descriptor() {
        return pthread_mutex_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_mutex_init(pthread_mutex_t *restrict _Nonnull, const pthread_mutexattr_t *restrict _Nullable)
     * }
     */
    public static MethodHandle pthread_mutex_init$handle() {
        return pthread_mutex_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_mutex_init(pthread_mutex_t *restrict _Nonnull, const pthread_mutexattr_t *restrict _Nullable)
     * }
     */
    public static MemorySegment pthread_mutex_init$address() {
        return pthread_mutex_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_mutex_init(pthread_mutex_t *restrict _Nonnull, const pthread_mutexattr_t *restrict _Nullable)
     * }
     */
    public static int pthread_mutex_init(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_mutex_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutex_init", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutex_lock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_mutex_lock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_mutex_lock(pthread_mutex_t * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_mutex_lock$descriptor() {
        return pthread_mutex_lock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_mutex_lock(pthread_mutex_t * _Nonnull)
     * }
     */
    public static MethodHandle pthread_mutex_lock$handle() {
        return pthread_mutex_lock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_mutex_lock(pthread_mutex_t * _Nonnull)
     * }
     */
    public static MemorySegment pthread_mutex_lock$address() {
        return pthread_mutex_lock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_mutex_lock(pthread_mutex_t * _Nonnull)
     * }
     */
    public static int pthread_mutex_lock(MemorySegment x0) {
        var mh$ = pthread_mutex_lock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutex_lock", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutex_setprioceiling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_mutex_setprioceiling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_mutex_setprioceiling(pthread_mutex_t *restrict _Nonnull, int, int *restrict _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_mutex_setprioceiling$descriptor() {
        return pthread_mutex_setprioceiling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_mutex_setprioceiling(pthread_mutex_t *restrict _Nonnull, int, int *restrict _Nonnull)
     * }
     */
    public static MethodHandle pthread_mutex_setprioceiling$handle() {
        return pthread_mutex_setprioceiling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_mutex_setprioceiling(pthread_mutex_t *restrict _Nonnull, int, int *restrict _Nonnull)
     * }
     */
    public static MemorySegment pthread_mutex_setprioceiling$address() {
        return pthread_mutex_setprioceiling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_mutex_setprioceiling(pthread_mutex_t *restrict _Nonnull, int, int *restrict _Nonnull)
     * }
     */
    public static int pthread_mutex_setprioceiling(MemorySegment x0, int x1, MemorySegment x2) {
        var mh$ = pthread_mutex_setprioceiling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutex_setprioceiling", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutex_trylock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_mutex_trylock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_mutex_trylock(pthread_mutex_t * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_mutex_trylock$descriptor() {
        return pthread_mutex_trylock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_mutex_trylock(pthread_mutex_t * _Nonnull)
     * }
     */
    public static MethodHandle pthread_mutex_trylock$handle() {
        return pthread_mutex_trylock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_mutex_trylock(pthread_mutex_t * _Nonnull)
     * }
     */
    public static MemorySegment pthread_mutex_trylock$address() {
        return pthread_mutex_trylock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_mutex_trylock(pthread_mutex_t * _Nonnull)
     * }
     */
    public static int pthread_mutex_trylock(MemorySegment x0) {
        var mh$ = pthread_mutex_trylock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutex_trylock", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutex_unlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_mutex_unlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_mutex_unlock(pthread_mutex_t * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_mutex_unlock$descriptor() {
        return pthread_mutex_unlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_mutex_unlock(pthread_mutex_t * _Nonnull)
     * }
     */
    public static MethodHandle pthread_mutex_unlock$handle() {
        return pthread_mutex_unlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_mutex_unlock(pthread_mutex_t * _Nonnull)
     * }
     */
    public static MemorySegment pthread_mutex_unlock$address() {
        return pthread_mutex_unlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_mutex_unlock(pthread_mutex_t * _Nonnull)
     * }
     */
    public static int pthread_mutex_unlock(MemorySegment x0) {
        var mh$ = pthread_mutex_unlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutex_unlock", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_mutexattr_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_mutexattr_destroy(pthread_mutexattr_t * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_destroy$descriptor() {
        return pthread_mutexattr_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_mutexattr_destroy(pthread_mutexattr_t * _Nonnull)
     * }
     */
    public static MethodHandle pthread_mutexattr_destroy$handle() {
        return pthread_mutexattr_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_mutexattr_destroy(pthread_mutexattr_t * _Nonnull)
     * }
     */
    public static MemorySegment pthread_mutexattr_destroy$address() {
        return pthread_mutexattr_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_mutexattr_destroy(pthread_mutexattr_t * _Nonnull)
     * }
     */
    public static int pthread_mutexattr_destroy(MemorySegment x0) {
        var mh$ = pthread_mutexattr_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_destroy", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_getprioceiling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_mutexattr_getprioceiling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_getprioceiling$descriptor() {
        return pthread_mutexattr_getprioceiling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static MethodHandle pthread_mutexattr_getprioceiling$handle() {
        return pthread_mutexattr_getprioceiling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static MemorySegment pthread_mutexattr_getprioceiling$address() {
        return pthread_mutexattr_getprioceiling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static int pthread_mutexattr_getprioceiling(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_mutexattr_getprioceiling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_getprioceiling", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_getprotocol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_mutexattr_getprotocol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_getprotocol$descriptor() {
        return pthread_mutexattr_getprotocol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static MethodHandle pthread_mutexattr_getprotocol$handle() {
        return pthread_mutexattr_getprotocol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static MemorySegment pthread_mutexattr_getprotocol$address() {
        return pthread_mutexattr_getprotocol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static int pthread_mutexattr_getprotocol(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_mutexattr_getprotocol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_getprotocol", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_getpshared {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_mutexattr_getpshared");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_mutexattr_getpshared(const pthread_mutexattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_getpshared$descriptor() {
        return pthread_mutexattr_getpshared.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_mutexattr_getpshared(const pthread_mutexattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static MethodHandle pthread_mutexattr_getpshared$handle() {
        return pthread_mutexattr_getpshared.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_mutexattr_getpshared(const pthread_mutexattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static MemorySegment pthread_mutexattr_getpshared$address() {
        return pthread_mutexattr_getpshared.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_mutexattr_getpshared(const pthread_mutexattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static int pthread_mutexattr_getpshared(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_mutexattr_getpshared.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_getpshared", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_gettype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_mutexattr_gettype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_mutexattr_gettype(const pthread_mutexattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_gettype$descriptor() {
        return pthread_mutexattr_gettype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_mutexattr_gettype(const pthread_mutexattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static MethodHandle pthread_mutexattr_gettype$handle() {
        return pthread_mutexattr_gettype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_mutexattr_gettype(const pthread_mutexattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static MemorySegment pthread_mutexattr_gettype$address() {
        return pthread_mutexattr_gettype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_mutexattr_gettype(const pthread_mutexattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static int pthread_mutexattr_gettype(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_mutexattr_gettype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_gettype", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_getpolicy_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_mutexattr_getpolicy_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_mutexattr_getpolicy_np(const pthread_mutexattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_getpolicy_np$descriptor() {
        return pthread_mutexattr_getpolicy_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_mutexattr_getpolicy_np(const pthread_mutexattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static MethodHandle pthread_mutexattr_getpolicy_np$handle() {
        return pthread_mutexattr_getpolicy_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_mutexattr_getpolicy_np(const pthread_mutexattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static MemorySegment pthread_mutexattr_getpolicy_np$address() {
        return pthread_mutexattr_getpolicy_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_mutexattr_getpolicy_np(const pthread_mutexattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static int pthread_mutexattr_getpolicy_np(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_mutexattr_getpolicy_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_getpolicy_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_mutexattr_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_mutexattr_init(pthread_mutexattr_t * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_init$descriptor() {
        return pthread_mutexattr_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_mutexattr_init(pthread_mutexattr_t * _Nonnull)
     * }
     */
    public static MethodHandle pthread_mutexattr_init$handle() {
        return pthread_mutexattr_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_mutexattr_init(pthread_mutexattr_t * _Nonnull)
     * }
     */
    public static MemorySegment pthread_mutexattr_init$address() {
        return pthread_mutexattr_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_mutexattr_init(pthread_mutexattr_t * _Nonnull)
     * }
     */
    public static int pthread_mutexattr_init(MemorySegment x0) {
        var mh$ = pthread_mutexattr_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_init", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_setprioceiling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_mutexattr_setprioceiling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_mutexattr_setprioceiling(pthread_mutexattr_t * _Nonnull, int)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_setprioceiling$descriptor() {
        return pthread_mutexattr_setprioceiling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_mutexattr_setprioceiling(pthread_mutexattr_t * _Nonnull, int)
     * }
     */
    public static MethodHandle pthread_mutexattr_setprioceiling$handle() {
        return pthread_mutexattr_setprioceiling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_mutexattr_setprioceiling(pthread_mutexattr_t * _Nonnull, int)
     * }
     */
    public static MemorySegment pthread_mutexattr_setprioceiling$address() {
        return pthread_mutexattr_setprioceiling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_mutexattr_setprioceiling(pthread_mutexattr_t * _Nonnull, int)
     * }
     */
    public static int pthread_mutexattr_setprioceiling(MemorySegment x0, int x1) {
        var mh$ = pthread_mutexattr_setprioceiling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_setprioceiling", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_setprotocol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_mutexattr_setprotocol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_mutexattr_setprotocol(pthread_mutexattr_t * _Nonnull, int)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_setprotocol$descriptor() {
        return pthread_mutexattr_setprotocol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_mutexattr_setprotocol(pthread_mutexattr_t * _Nonnull, int)
     * }
     */
    public static MethodHandle pthread_mutexattr_setprotocol$handle() {
        return pthread_mutexattr_setprotocol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_mutexattr_setprotocol(pthread_mutexattr_t * _Nonnull, int)
     * }
     */
    public static MemorySegment pthread_mutexattr_setprotocol$address() {
        return pthread_mutexattr_setprotocol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_mutexattr_setprotocol(pthread_mutexattr_t * _Nonnull, int)
     * }
     */
    public static int pthread_mutexattr_setprotocol(MemorySegment x0, int x1) {
        var mh$ = pthread_mutexattr_setprotocol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_setprotocol", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_setpshared {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_mutexattr_setpshared");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_mutexattr_setpshared(pthread_mutexattr_t * _Nonnull, int)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_setpshared$descriptor() {
        return pthread_mutexattr_setpshared.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_mutexattr_setpshared(pthread_mutexattr_t * _Nonnull, int)
     * }
     */
    public static MethodHandle pthread_mutexattr_setpshared$handle() {
        return pthread_mutexattr_setpshared.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_mutexattr_setpshared(pthread_mutexattr_t * _Nonnull, int)
     * }
     */
    public static MemorySegment pthread_mutexattr_setpshared$address() {
        return pthread_mutexattr_setpshared.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_mutexattr_setpshared(pthread_mutexattr_t * _Nonnull, int)
     * }
     */
    public static int pthread_mutexattr_setpshared(MemorySegment x0, int x1) {
        var mh$ = pthread_mutexattr_setpshared.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_setpshared", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_settype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_mutexattr_settype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_mutexattr_settype(pthread_mutexattr_t * _Nonnull, int)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_settype$descriptor() {
        return pthread_mutexattr_settype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_mutexattr_settype(pthread_mutexattr_t * _Nonnull, int)
     * }
     */
    public static MethodHandle pthread_mutexattr_settype$handle() {
        return pthread_mutexattr_settype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_mutexattr_settype(pthread_mutexattr_t * _Nonnull, int)
     * }
     */
    public static MemorySegment pthread_mutexattr_settype$address() {
        return pthread_mutexattr_settype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_mutexattr_settype(pthread_mutexattr_t * _Nonnull, int)
     * }
     */
    public static int pthread_mutexattr_settype(MemorySegment x0, int x1) {
        var mh$ = pthread_mutexattr_settype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_settype", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mutexattr_setpolicy_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_mutexattr_setpolicy_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_mutexattr_setpolicy_np(pthread_mutexattr_t * _Nonnull, int)
     * }
     */
    public static FunctionDescriptor pthread_mutexattr_setpolicy_np$descriptor() {
        return pthread_mutexattr_setpolicy_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_mutexattr_setpolicy_np(pthread_mutexattr_t * _Nonnull, int)
     * }
     */
    public static MethodHandle pthread_mutexattr_setpolicy_np$handle() {
        return pthread_mutexattr_setpolicy_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_mutexattr_setpolicy_np(pthread_mutexattr_t * _Nonnull, int)
     * }
     */
    public static MemorySegment pthread_mutexattr_setpolicy_np$address() {
        return pthread_mutexattr_setpolicy_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_mutexattr_setpolicy_np(pthread_mutexattr_t * _Nonnull, int)
     * }
     */
    public static int pthread_mutexattr_setpolicy_np(MemorySegment x0, int x1) {
        var mh$ = pthread_mutexattr_setpolicy_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mutexattr_setpolicy_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_once {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_once");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_once(pthread_once_t * _Nonnull, void (* _Nonnull)(void))
     * }
     */
    public static FunctionDescriptor pthread_once$descriptor() {
        return pthread_once.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_once(pthread_once_t * _Nonnull, void (* _Nonnull)(void))
     * }
     */
    public static MethodHandle pthread_once$handle() {
        return pthread_once.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_once(pthread_once_t * _Nonnull, void (* _Nonnull)(void))
     * }
     */
    public static MemorySegment pthread_once$address() {
        return pthread_once.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_once(pthread_once_t * _Nonnull, void (* _Nonnull)(void))
     * }
     */
    public static int pthread_once(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_once.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_once", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_rwlock_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_rwlock_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_rwlock_destroy(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_rwlock_destroy$descriptor() {
        return pthread_rwlock_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_rwlock_destroy(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static MethodHandle pthread_rwlock_destroy$handle() {
        return pthread_rwlock_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_rwlock_destroy(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static MemorySegment pthread_rwlock_destroy$address() {
        return pthread_rwlock_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_rwlock_destroy(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static int pthread_rwlock_destroy(MemorySegment x0) {
        var mh$ = pthread_rwlock_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_rwlock_destroy", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_rwlock_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_rwlock_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_rwlock_init(pthread_rwlock_t *restrict _Nonnull, const pthread_rwlockattr_t *restrict _Nullable)
     * }
     */
    public static FunctionDescriptor pthread_rwlock_init$descriptor() {
        return pthread_rwlock_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_rwlock_init(pthread_rwlock_t *restrict _Nonnull, const pthread_rwlockattr_t *restrict _Nullable)
     * }
     */
    public static MethodHandle pthread_rwlock_init$handle() {
        return pthread_rwlock_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_rwlock_init(pthread_rwlock_t *restrict _Nonnull, const pthread_rwlockattr_t *restrict _Nullable)
     * }
     */
    public static MemorySegment pthread_rwlock_init$address() {
        return pthread_rwlock_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_rwlock_init(pthread_rwlock_t *restrict _Nonnull, const pthread_rwlockattr_t *restrict _Nullable)
     * }
     */
    public static int pthread_rwlock_init(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_rwlock_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_rwlock_init", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_rwlock_rdlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_rwlock_rdlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_rwlock_rdlock(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_rwlock_rdlock$descriptor() {
        return pthread_rwlock_rdlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_rwlock_rdlock(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static MethodHandle pthread_rwlock_rdlock$handle() {
        return pthread_rwlock_rdlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_rwlock_rdlock(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static MemorySegment pthread_rwlock_rdlock$address() {
        return pthread_rwlock_rdlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_rwlock_rdlock(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static int pthread_rwlock_rdlock(MemorySegment x0) {
        var mh$ = pthread_rwlock_rdlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_rwlock_rdlock", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_rwlock_tryrdlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_rwlock_tryrdlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_rwlock_tryrdlock(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_rwlock_tryrdlock$descriptor() {
        return pthread_rwlock_tryrdlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_rwlock_tryrdlock(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static MethodHandle pthread_rwlock_tryrdlock$handle() {
        return pthread_rwlock_tryrdlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_rwlock_tryrdlock(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static MemorySegment pthread_rwlock_tryrdlock$address() {
        return pthread_rwlock_tryrdlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_rwlock_tryrdlock(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static int pthread_rwlock_tryrdlock(MemorySegment x0) {
        var mh$ = pthread_rwlock_tryrdlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_rwlock_tryrdlock", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_rwlock_trywrlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_rwlock_trywrlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_rwlock_trywrlock(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_rwlock_trywrlock$descriptor() {
        return pthread_rwlock_trywrlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_rwlock_trywrlock(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static MethodHandle pthread_rwlock_trywrlock$handle() {
        return pthread_rwlock_trywrlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_rwlock_trywrlock(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static MemorySegment pthread_rwlock_trywrlock$address() {
        return pthread_rwlock_trywrlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_rwlock_trywrlock(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static int pthread_rwlock_trywrlock(MemorySegment x0) {
        var mh$ = pthread_rwlock_trywrlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_rwlock_trywrlock", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_rwlock_wrlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_rwlock_wrlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_rwlock_wrlock(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_rwlock_wrlock$descriptor() {
        return pthread_rwlock_wrlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_rwlock_wrlock(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static MethodHandle pthread_rwlock_wrlock$handle() {
        return pthread_rwlock_wrlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_rwlock_wrlock(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static MemorySegment pthread_rwlock_wrlock$address() {
        return pthread_rwlock_wrlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_rwlock_wrlock(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static int pthread_rwlock_wrlock(MemorySegment x0) {
        var mh$ = pthread_rwlock_wrlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_rwlock_wrlock", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_rwlock_unlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_rwlock_unlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_rwlock_unlock(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_rwlock_unlock$descriptor() {
        return pthread_rwlock_unlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_rwlock_unlock(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static MethodHandle pthread_rwlock_unlock$handle() {
        return pthread_rwlock_unlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_rwlock_unlock(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static MemorySegment pthread_rwlock_unlock$address() {
        return pthread_rwlock_unlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_rwlock_unlock(pthread_rwlock_t * _Nonnull)
     * }
     */
    public static int pthread_rwlock_unlock(MemorySegment x0) {
        var mh$ = pthread_rwlock_unlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_rwlock_unlock", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_rwlockattr_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_rwlockattr_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_rwlockattr_destroy(pthread_rwlockattr_t * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_rwlockattr_destroy$descriptor() {
        return pthread_rwlockattr_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_rwlockattr_destroy(pthread_rwlockattr_t * _Nonnull)
     * }
     */
    public static MethodHandle pthread_rwlockattr_destroy$handle() {
        return pthread_rwlockattr_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_rwlockattr_destroy(pthread_rwlockattr_t * _Nonnull)
     * }
     */
    public static MemorySegment pthread_rwlockattr_destroy$address() {
        return pthread_rwlockattr_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_rwlockattr_destroy(pthread_rwlockattr_t * _Nonnull)
     * }
     */
    public static int pthread_rwlockattr_destroy(MemorySegment x0) {
        var mh$ = pthread_rwlockattr_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_rwlockattr_destroy", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_rwlockattr_getpshared {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_rwlockattr_getpshared");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_rwlockattr_getpshared$descriptor() {
        return pthread_rwlockattr_getpshared.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static MethodHandle pthread_rwlockattr_getpshared$handle() {
        return pthread_rwlockattr_getpshared.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static MemorySegment pthread_rwlockattr_getpshared$address() {
        return pthread_rwlockattr_getpshared.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *restrict _Nonnull, int *restrict _Nonnull)
     * }
     */
    public static int pthread_rwlockattr_getpshared(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_rwlockattr_getpshared.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_rwlockattr_getpshared", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_rwlockattr_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_rwlockattr_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_rwlockattr_init(pthread_rwlockattr_t * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_rwlockattr_init$descriptor() {
        return pthread_rwlockattr_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_rwlockattr_init(pthread_rwlockattr_t * _Nonnull)
     * }
     */
    public static MethodHandle pthread_rwlockattr_init$handle() {
        return pthread_rwlockattr_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_rwlockattr_init(pthread_rwlockattr_t * _Nonnull)
     * }
     */
    public static MemorySegment pthread_rwlockattr_init$address() {
        return pthread_rwlockattr_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_rwlockattr_init(pthread_rwlockattr_t * _Nonnull)
     * }
     */
    public static int pthread_rwlockattr_init(MemorySegment x0) {
        var mh$ = pthread_rwlockattr_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_rwlockattr_init", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_rwlockattr_setpshared {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_rwlockattr_setpshared");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_rwlockattr_setpshared(pthread_rwlockattr_t * _Nonnull, int)
     * }
     */
    public static FunctionDescriptor pthread_rwlockattr_setpshared$descriptor() {
        return pthread_rwlockattr_setpshared.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_rwlockattr_setpshared(pthread_rwlockattr_t * _Nonnull, int)
     * }
     */
    public static MethodHandle pthread_rwlockattr_setpshared$handle() {
        return pthread_rwlockattr_setpshared.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_rwlockattr_setpshared(pthread_rwlockattr_t * _Nonnull, int)
     * }
     */
    public static MemorySegment pthread_rwlockattr_setpshared$address() {
        return pthread_rwlockattr_setpshared.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_rwlockattr_setpshared(pthread_rwlockattr_t * _Nonnull, int)
     * }
     */
    public static int pthread_rwlockattr_setpshared(MemorySegment x0, int x1) {
        var mh$ = pthread_rwlockattr_setpshared.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_rwlockattr_setpshared", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_self {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_self");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pthread_t  _Nonnull pthread_self()
     * }
     */
    public static FunctionDescriptor pthread_self$descriptor() {
        return pthread_self.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pthread_t  _Nonnull pthread_self()
     * }
     */
    public static MethodHandle pthread_self$handle() {
        return pthread_self.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pthread_t  _Nonnull pthread_self()
     * }
     */
    public static MemorySegment pthread_self$address() {
        return pthread_self.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pthread_t  _Nonnull pthread_self()
     * }
     */
    public static MemorySegment pthread_self() {
        var mh$ = pthread_self.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_self");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_setcancelstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_setcancelstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_setcancelstate(int, int * _Nullable)
     * }
     */
    public static FunctionDescriptor pthread_setcancelstate$descriptor() {
        return pthread_setcancelstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_setcancelstate(int, int * _Nullable)
     * }
     */
    public static MethodHandle pthread_setcancelstate$handle() {
        return pthread_setcancelstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_setcancelstate(int, int * _Nullable)
     * }
     */
    public static MemorySegment pthread_setcancelstate$address() {
        return pthread_setcancelstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_setcancelstate(int, int * _Nullable)
     * }
     */
    public static int pthread_setcancelstate(int x0, MemorySegment x1) {
        var mh$ = pthread_setcancelstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_setcancelstate", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_setcanceltype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_setcanceltype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_setcanceltype(int, int * _Nullable)
     * }
     */
    public static FunctionDescriptor pthread_setcanceltype$descriptor() {
        return pthread_setcanceltype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_setcanceltype(int, int * _Nullable)
     * }
     */
    public static MethodHandle pthread_setcanceltype$handle() {
        return pthread_setcanceltype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_setcanceltype(int, int * _Nullable)
     * }
     */
    public static MemorySegment pthread_setcanceltype$address() {
        return pthread_setcanceltype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_setcanceltype(int, int * _Nullable)
     * }
     */
    public static int pthread_setcanceltype(int x0, MemorySegment x1) {
        var mh$ = pthread_setcanceltype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_setcanceltype", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_setconcurrency {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_setconcurrency");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_setconcurrency(int)
     * }
     */
    public static FunctionDescriptor pthread_setconcurrency$descriptor() {
        return pthread_setconcurrency.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_setconcurrency(int)
     * }
     */
    public static MethodHandle pthread_setconcurrency$handle() {
        return pthread_setconcurrency.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_setconcurrency(int)
     * }
     */
    public static MemorySegment pthread_setconcurrency$address() {
        return pthread_setconcurrency.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_setconcurrency(int)
     * }
     */
    public static int pthread_setconcurrency(int x0) {
        var mh$ = pthread_setconcurrency.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_setconcurrency", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_setschedparam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_setschedparam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_setschedparam(pthread_t _Nonnull, int, const struct sched_param * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_setschedparam$descriptor() {
        return pthread_setschedparam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_setschedparam(pthread_t _Nonnull, int, const struct sched_param * _Nonnull)
     * }
     */
    public static MethodHandle pthread_setschedparam$handle() {
        return pthread_setschedparam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_setschedparam(pthread_t _Nonnull, int, const struct sched_param * _Nonnull)
     * }
     */
    public static MemorySegment pthread_setschedparam$address() {
        return pthread_setschedparam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_setschedparam(pthread_t _Nonnull, int, const struct sched_param * _Nonnull)
     * }
     */
    public static int pthread_setschedparam(MemorySegment x0, int x1, MemorySegment x2) {
        var mh$ = pthread_setschedparam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_setschedparam", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_setspecific {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_setspecific");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_setspecific(pthread_key_t, const void * _Nullable)
     * }
     */
    public static FunctionDescriptor pthread_setspecific$descriptor() {
        return pthread_setspecific.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_setspecific(pthread_key_t, const void * _Nullable)
     * }
     */
    public static MethodHandle pthread_setspecific$handle() {
        return pthread_setspecific.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_setspecific(pthread_key_t, const void * _Nullable)
     * }
     */
    public static MemorySegment pthread_setspecific$address() {
        return pthread_setspecific.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_setspecific(pthread_key_t, const void * _Nullable)
     * }
     */
    public static int pthread_setspecific(long x0, MemorySegment x1) {
        var mh$ = pthread_setspecific.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_setspecific", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_testcancel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_testcancel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pthread_testcancel()
     * }
     */
    public static FunctionDescriptor pthread_testcancel$descriptor() {
        return pthread_testcancel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pthread_testcancel()
     * }
     */
    public static MethodHandle pthread_testcancel$handle() {
        return pthread_testcancel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pthread_testcancel()
     * }
     */
    public static MemorySegment pthread_testcancel$address() {
        return pthread_testcancel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pthread_testcancel()
     * }
     */
    public static void pthread_testcancel() {
        var mh$ = pthread_testcancel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_testcancel");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_is_threaded_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_is_threaded_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_is_threaded_np()
     * }
     */
    public static FunctionDescriptor pthread_is_threaded_np$descriptor() {
        return pthread_is_threaded_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_is_threaded_np()
     * }
     */
    public static MethodHandle pthread_is_threaded_np$handle() {
        return pthread_is_threaded_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_is_threaded_np()
     * }
     */
    public static MemorySegment pthread_is_threaded_np$address() {
        return pthread_is_threaded_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_is_threaded_np()
     * }
     */
    public static int pthread_is_threaded_np() {
        var mh$ = pthread_is_threaded_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_is_threaded_np");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_threadid_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_threadid_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_threadid_np(pthread_t _Nullable, __uint64_t * _Nullable)
     * }
     */
    public static FunctionDescriptor pthread_threadid_np$descriptor() {
        return pthread_threadid_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_threadid_np(pthread_t _Nullable, __uint64_t * _Nullable)
     * }
     */
    public static MethodHandle pthread_threadid_np$handle() {
        return pthread_threadid_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_threadid_np(pthread_t _Nullable, __uint64_t * _Nullable)
     * }
     */
    public static MemorySegment pthread_threadid_np$address() {
        return pthread_threadid_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_threadid_np(pthread_t _Nullable, __uint64_t * _Nullable)
     * }
     */
    public static int pthread_threadid_np(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_threadid_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_threadid_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_getname_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_getname_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_getname_np(pthread_t _Nonnull, char * _Nonnull, size_t)
     * }
     */
    public static FunctionDescriptor pthread_getname_np$descriptor() {
        return pthread_getname_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_getname_np(pthread_t _Nonnull, char * _Nonnull, size_t)
     * }
     */
    public static MethodHandle pthread_getname_np$handle() {
        return pthread_getname_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_getname_np(pthread_t _Nonnull, char * _Nonnull, size_t)
     * }
     */
    public static MemorySegment pthread_getname_np$address() {
        return pthread_getname_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_getname_np(pthread_t _Nonnull, char * _Nonnull, size_t)
     * }
     */
    public static int pthread_getname_np(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = pthread_getname_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_getname_np", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_setname_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_setname_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_setname_np(const char * _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_setname_np$descriptor() {
        return pthread_setname_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_setname_np(const char * _Nonnull)
     * }
     */
    public static MethodHandle pthread_setname_np$handle() {
        return pthread_setname_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_setname_np(const char * _Nonnull)
     * }
     */
    public static MemorySegment pthread_setname_np$address() {
        return pthread_setname_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_setname_np(const char * _Nonnull)
     * }
     */
    public static int pthread_setname_np(MemorySegment x0) {
        var mh$ = pthread_setname_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_setname_np", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_main_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_main_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_main_np()
     * }
     */
    public static FunctionDescriptor pthread_main_np$descriptor() {
        return pthread_main_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_main_np()
     * }
     */
    public static MethodHandle pthread_main_np$handle() {
        return pthread_main_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_main_np()
     * }
     */
    public static MemorySegment pthread_main_np$address() {
        return pthread_main_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_main_np()
     * }
     */
    public static int pthread_main_np() {
        var mh$ = pthread_main_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_main_np");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_mach_thread_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_mach_thread_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mach_port_t pthread_mach_thread_np(pthread_t _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_mach_thread_np$descriptor() {
        return pthread_mach_thread_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mach_port_t pthread_mach_thread_np(pthread_t _Nonnull)
     * }
     */
    public static MethodHandle pthread_mach_thread_np$handle() {
        return pthread_mach_thread_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mach_port_t pthread_mach_thread_np(pthread_t _Nonnull)
     * }
     */
    public static MemorySegment pthread_mach_thread_np$address() {
        return pthread_mach_thread_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mach_port_t pthread_mach_thread_np(pthread_t _Nonnull)
     * }
     */
    public static int pthread_mach_thread_np(MemorySegment x0) {
        var mh$ = pthread_mach_thread_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_mach_thread_np", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_get_stacksize_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_get_stacksize_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t pthread_get_stacksize_np(pthread_t _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_get_stacksize_np$descriptor() {
        return pthread_get_stacksize_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t pthread_get_stacksize_np(pthread_t _Nonnull)
     * }
     */
    public static MethodHandle pthread_get_stacksize_np$handle() {
        return pthread_get_stacksize_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t pthread_get_stacksize_np(pthread_t _Nonnull)
     * }
     */
    public static MemorySegment pthread_get_stacksize_np$address() {
        return pthread_get_stacksize_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t pthread_get_stacksize_np(pthread_t _Nonnull)
     * }
     */
    public static long pthread_get_stacksize_np(MemorySegment x0) {
        var mh$ = pthread_get_stacksize_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_get_stacksize_np", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_get_stackaddr_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_get_stackaddr_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void * _Nonnull pthread_get_stackaddr_np(pthread_t _Nonnull)
     * }
     */
    public static FunctionDescriptor pthread_get_stackaddr_np$descriptor() {
        return pthread_get_stackaddr_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void * _Nonnull pthread_get_stackaddr_np(pthread_t _Nonnull)
     * }
     */
    public static MethodHandle pthread_get_stackaddr_np$handle() {
        return pthread_get_stackaddr_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void * _Nonnull pthread_get_stackaddr_np(pthread_t _Nonnull)
     * }
     */
    public static MemorySegment pthread_get_stackaddr_np$address() {
        return pthread_get_stackaddr_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void * _Nonnull pthread_get_stackaddr_np(pthread_t _Nonnull)
     * }
     */
    public static MemorySegment pthread_get_stackaddr_np(MemorySegment x0) {
        var mh$ = pthread_get_stackaddr_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_get_stackaddr_np", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_cond_signal_thread_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_cond_signal_thread_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_cond_signal_thread_np(pthread_cond_t * _Nonnull, pthread_t _Nullable)
     * }
     */
    public static FunctionDescriptor pthread_cond_signal_thread_np$descriptor() {
        return pthread_cond_signal_thread_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_cond_signal_thread_np(pthread_cond_t * _Nonnull, pthread_t _Nullable)
     * }
     */
    public static MethodHandle pthread_cond_signal_thread_np$handle() {
        return pthread_cond_signal_thread_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_cond_signal_thread_np(pthread_cond_t * _Nonnull, pthread_t _Nullable)
     * }
     */
    public static MemorySegment pthread_cond_signal_thread_np$address() {
        return pthread_cond_signal_thread_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_cond_signal_thread_np(pthread_cond_t * _Nonnull, pthread_t _Nullable)
     * }
     */
    public static int pthread_cond_signal_thread_np(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_cond_signal_thread_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_cond_signal_thread_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_cond_timedwait_relative_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_cond_timedwait_relative_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_cond_timedwait_relative_np(pthread_cond_t * _Nonnull, pthread_mutex_t * _Nonnull, const struct timespec * _Nullable)
     * }
     */
    public static FunctionDescriptor pthread_cond_timedwait_relative_np$descriptor() {
        return pthread_cond_timedwait_relative_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_cond_timedwait_relative_np(pthread_cond_t * _Nonnull, pthread_mutex_t * _Nonnull, const struct timespec * _Nullable)
     * }
     */
    public static MethodHandle pthread_cond_timedwait_relative_np$handle() {
        return pthread_cond_timedwait_relative_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_cond_timedwait_relative_np(pthread_cond_t * _Nonnull, pthread_mutex_t * _Nonnull, const struct timespec * _Nullable)
     * }
     */
    public static MemorySegment pthread_cond_timedwait_relative_np$address() {
        return pthread_cond_timedwait_relative_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_cond_timedwait_relative_np(pthread_cond_t * _Nonnull, pthread_mutex_t * _Nonnull, const struct timespec * _Nullable)
     * }
     */
    public static int pthread_cond_timedwait_relative_np(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = pthread_cond_timedwait_relative_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_cond_timedwait_relative_np", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_create_suspended_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_create_suspended_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_create_suspended_np(pthread_t  _Nullable * _Nonnull, const pthread_attr_t * _Nullable, void * _Nullable (* _Nonnull)(void * _Nullable), void * _Nullable)
     * }
     */
    public static FunctionDescriptor pthread_create_suspended_np$descriptor() {
        return pthread_create_suspended_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_create_suspended_np(pthread_t  _Nullable * _Nonnull, const pthread_attr_t * _Nullable, void * _Nullable (* _Nonnull)(void * _Nullable), void * _Nullable)
     * }
     */
    public static MethodHandle pthread_create_suspended_np$handle() {
        return pthread_create_suspended_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_create_suspended_np(pthread_t  _Nullable * _Nonnull, const pthread_attr_t * _Nullable, void * _Nullable (* _Nonnull)(void * _Nullable), void * _Nullable)
     * }
     */
    public static MemorySegment pthread_create_suspended_np$address() {
        return pthread_create_suspended_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_create_suspended_np(pthread_t  _Nullable * _Nonnull, const pthread_attr_t * _Nullable, void * _Nullable (* _Nonnull)(void * _Nullable), void * _Nullable)
     * }
     */
    public static int pthread_create_suspended_np(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = pthread_create_suspended_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_create_suspended_np", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_kill {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_kill");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_kill(pthread_t _Nonnull, int)
     * }
     */
    public static FunctionDescriptor pthread_kill$descriptor() {
        return pthread_kill.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_kill(pthread_t _Nonnull, int)
     * }
     */
    public static MethodHandle pthread_kill$handle() {
        return pthread_kill.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_kill(pthread_t _Nonnull, int)
     * }
     */
    public static MemorySegment pthread_kill$address() {
        return pthread_kill.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_kill(pthread_t _Nonnull, int)
     * }
     */
    public static int pthread_kill(MemorySegment x0, int x1) {
        var mh$ = pthread_kill.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_kill", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_from_mach_thread_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_from_mach_thread_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pthread_t  _Nullable pthread_from_mach_thread_np(mach_port_t)
     * }
     */
    public static FunctionDescriptor pthread_from_mach_thread_np$descriptor() {
        return pthread_from_mach_thread_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pthread_t  _Nullable pthread_from_mach_thread_np(mach_port_t)
     * }
     */
    public static MethodHandle pthread_from_mach_thread_np$handle() {
        return pthread_from_mach_thread_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pthread_t  _Nullable pthread_from_mach_thread_np(mach_port_t)
     * }
     */
    public static MemorySegment pthread_from_mach_thread_np$address() {
        return pthread_from_mach_thread_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pthread_t  _Nullable pthread_from_mach_thread_np(mach_port_t)
     * }
     */
    public static MemorySegment pthread_from_mach_thread_np(int x0) {
        var mh$ = pthread_from_mach_thread_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_from_mach_thread_np", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_sigmask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_sigmask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_sigmask(int, const sigset_t * _Nullable, sigset_t * _Nullable)
     * }
     */
    public static FunctionDescriptor pthread_sigmask$descriptor() {
        return pthread_sigmask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_sigmask(int, const sigset_t * _Nullable, sigset_t * _Nullable)
     * }
     */
    public static MethodHandle pthread_sigmask$handle() {
        return pthread_sigmask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_sigmask(int, const sigset_t * _Nullable, sigset_t * _Nullable)
     * }
     */
    public static MemorySegment pthread_sigmask$address() {
        return pthread_sigmask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_sigmask(int, const sigset_t * _Nullable, sigset_t * _Nullable)
     * }
     */
    public static int pthread_sigmask(int x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = pthread_sigmask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_sigmask", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_yield_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_yield_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pthread_yield_np()
     * }
     */
    public static FunctionDescriptor pthread_yield_np$descriptor() {
        return pthread_yield_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pthread_yield_np()
     * }
     */
    public static MethodHandle pthread_yield_np$handle() {
        return pthread_yield_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pthread_yield_np()
     * }
     */
    public static MemorySegment pthread_yield_np$address() {
        return pthread_yield_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pthread_yield_np()
     * }
     */
    public static void pthread_yield_np() {
        var mh$ = pthread_yield_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_yield_np");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_jit_write_protect_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_jit_write_protect_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pthread_jit_write_protect_np(int enabled)
     * }
     */
    public static FunctionDescriptor pthread_jit_write_protect_np$descriptor() {
        return pthread_jit_write_protect_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pthread_jit_write_protect_np(int enabled)
     * }
     */
    public static MethodHandle pthread_jit_write_protect_np$handle() {
        return pthread_jit_write_protect_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pthread_jit_write_protect_np(int enabled)
     * }
     */
    public static MemorySegment pthread_jit_write_protect_np$address() {
        return pthread_jit_write_protect_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pthread_jit_write_protect_np(int enabled)
     * }
     */
    public static void pthread_jit_write_protect_np(int enabled) {
        var mh$ = pthread_jit_write_protect_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_jit_write_protect_np", enabled);
            }
            mh$.invokeExact(enabled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_jit_write_protect_supported_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_jit_write_protect_supported_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_jit_write_protect_supported_np()
     * }
     */
    public static FunctionDescriptor pthread_jit_write_protect_supported_np$descriptor() {
        return pthread_jit_write_protect_supported_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_jit_write_protect_supported_np()
     * }
     */
    public static MethodHandle pthread_jit_write_protect_supported_np$handle() {
        return pthread_jit_write_protect_supported_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_jit_write_protect_supported_np()
     * }
     */
    public static MemorySegment pthread_jit_write_protect_supported_np$address() {
        return pthread_jit_write_protect_supported_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_jit_write_protect_supported_np()
     * }
     */
    public static int pthread_jit_write_protect_supported_np() {
        var mh$ = pthread_jit_write_protect_supported_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_jit_write_protect_supported_np");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_jit_write_with_callback_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_jit_write_with_callback_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_jit_write_with_callback_np(pthread_jit_write_callback_t  _Nonnull callback, void * _Nullable ctx)
     * }
     */
    public static FunctionDescriptor pthread_jit_write_with_callback_np$descriptor() {
        return pthread_jit_write_with_callback_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_jit_write_with_callback_np(pthread_jit_write_callback_t  _Nonnull callback, void * _Nullable ctx)
     * }
     */
    public static MethodHandle pthread_jit_write_with_callback_np$handle() {
        return pthread_jit_write_with_callback_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_jit_write_with_callback_np(pthread_jit_write_callback_t  _Nonnull callback, void * _Nullable ctx)
     * }
     */
    public static MemorySegment pthread_jit_write_with_callback_np$address() {
        return pthread_jit_write_with_callback_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_jit_write_with_callback_np(pthread_jit_write_callback_t  _Nonnull callback, void * _Nullable ctx)
     * }
     */
    public static int pthread_jit_write_with_callback_np(MemorySegment callback, MemorySegment ctx) {
        var mh$ = pthread_jit_write_with_callback_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_jit_write_with_callback_np", callback, ctx);
            }
            return (int)mh$.invokeExact(callback, ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_jit_write_freeze_callbacks_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_jit_write_freeze_callbacks_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void pthread_jit_write_freeze_callbacks_np()
     * }
     */
    public static FunctionDescriptor pthread_jit_write_freeze_callbacks_np$descriptor() {
        return pthread_jit_write_freeze_callbacks_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void pthread_jit_write_freeze_callbacks_np()
     * }
     */
    public static MethodHandle pthread_jit_write_freeze_callbacks_np$handle() {
        return pthread_jit_write_freeze_callbacks_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void pthread_jit_write_freeze_callbacks_np()
     * }
     */
    public static MemorySegment pthread_jit_write_freeze_callbacks_np$address() {
        return pthread_jit_write_freeze_callbacks_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void pthread_jit_write_freeze_callbacks_np()
     * }
     */
    public static void pthread_jit_write_freeze_callbacks_np() {
        var mh$ = pthread_jit_write_freeze_callbacks_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_jit_write_freeze_callbacks_np");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_cpu_number_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_cpu_number_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_cpu_number_np(size_t * _Nonnull cpu_number_out)
     * }
     */
    public static FunctionDescriptor pthread_cpu_number_np$descriptor() {
        return pthread_cpu_number_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_cpu_number_np(size_t * _Nonnull cpu_number_out)
     * }
     */
    public static MethodHandle pthread_cpu_number_np$handle() {
        return pthread_cpu_number_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_cpu_number_np(size_t * _Nonnull cpu_number_out)
     * }
     */
    public static MemorySegment pthread_cpu_number_np$address() {
        return pthread_cpu_number_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_cpu_number_np(size_t * _Nonnull cpu_number_out)
     * }
     */
    public static int pthread_cpu_number_np(MemorySegment cpu_number_out) {
        var mh$ = pthread_cpu_number_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_cpu_number_np", cpu_number_out);
            }
            return (int)mh$.invokeExact(cpu_number_out);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyContext_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyContext_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyContext_Type
     * }
     */
    public static GroupLayout PyContext_Type$layout() {
        return PyContext_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyContext_Type
     * }
     */
    public static MemorySegment PyContext_Type() {
        return PyContext_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyContext_Type
     * }
     */
    public static void PyContext_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyContext_Type$constants.SEGMENT, 0L, PyContext_Type$constants.LAYOUT.byteSize());
    }

    private static class PyContextVar_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyContextVar_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyContextVar_Type
     * }
     */
    public static GroupLayout PyContextVar_Type$layout() {
        return PyContextVar_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyContextVar_Type
     * }
     */
    public static MemorySegment PyContextVar_Type() {
        return PyContextVar_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyContextVar_Type
     * }
     */
    public static void PyContextVar_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyContextVar_Type$constants.SEGMENT, 0L, PyContextVar_Type$constants.LAYOUT.byteSize());
    }

    private static class PyContextToken_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyContextToken_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyContextToken_Type
     * }
     */
    public static GroupLayout PyContextToken_Type$layout() {
        return PyContextToken_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyContextToken_Type
     * }
     */
    public static MemorySegment PyContextToken_Type() {
        return PyContextToken_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyContextToken_Type
     * }
     */
    public static void PyContextToken_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyContextToken_Type$constants.SEGMENT, 0L, PyContextToken_Type$constants.LAYOUT.byteSize());
    }

    private static class PyContext_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyContext_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyContext_New()
     * }
     */
    public static FunctionDescriptor PyContext_New$descriptor() {
        return PyContext_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyContext_New()
     * }
     */
    public static MethodHandle PyContext_New$handle() {
        return PyContext_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyContext_New()
     * }
     */
    public static MemorySegment PyContext_New$address() {
        return PyContext_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyContext_New()
     * }
     */
    public static MemorySegment PyContext_New() {
        var mh$ = PyContext_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyContext_New");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyContext_Copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyContext_Copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyContext_Copy(PyObject *)
     * }
     */
    public static FunctionDescriptor PyContext_Copy$descriptor() {
        return PyContext_Copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyContext_Copy(PyObject *)
     * }
     */
    public static MethodHandle PyContext_Copy$handle() {
        return PyContext_Copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyContext_Copy(PyObject *)
     * }
     */
    public static MemorySegment PyContext_Copy$address() {
        return PyContext_Copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyContext_Copy(PyObject *)
     * }
     */
    public static MemorySegment PyContext_Copy(MemorySegment x0) {
        var mh$ = PyContext_Copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyContext_Copy", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyContext_CopyCurrent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyContext_CopyCurrent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyContext_CopyCurrent()
     * }
     */
    public static FunctionDescriptor PyContext_CopyCurrent$descriptor() {
        return PyContext_CopyCurrent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyContext_CopyCurrent()
     * }
     */
    public static MethodHandle PyContext_CopyCurrent$handle() {
        return PyContext_CopyCurrent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyContext_CopyCurrent()
     * }
     */
    public static MemorySegment PyContext_CopyCurrent$address() {
        return PyContext_CopyCurrent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyContext_CopyCurrent()
     * }
     */
    public static MemorySegment PyContext_CopyCurrent() {
        var mh$ = PyContext_CopyCurrent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyContext_CopyCurrent");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyContext_Enter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyContext_Enter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyContext_Enter(PyObject *)
     * }
     */
    public static FunctionDescriptor PyContext_Enter$descriptor() {
        return PyContext_Enter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyContext_Enter(PyObject *)
     * }
     */
    public static MethodHandle PyContext_Enter$handle() {
        return PyContext_Enter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyContext_Enter(PyObject *)
     * }
     */
    public static MemorySegment PyContext_Enter$address() {
        return PyContext_Enter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyContext_Enter(PyObject *)
     * }
     */
    public static int PyContext_Enter(MemorySegment x0) {
        var mh$ = PyContext_Enter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyContext_Enter", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyContext_Exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyContext_Exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyContext_Exit(PyObject *)
     * }
     */
    public static FunctionDescriptor PyContext_Exit$descriptor() {
        return PyContext_Exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyContext_Exit(PyObject *)
     * }
     */
    public static MethodHandle PyContext_Exit$handle() {
        return PyContext_Exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyContext_Exit(PyObject *)
     * }
     */
    public static MemorySegment PyContext_Exit$address() {
        return PyContext_Exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyContext_Exit(PyObject *)
     * }
     */
    public static int PyContext_Exit(MemorySegment x0) {
        var mh$ = PyContext_Exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyContext_Exit", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyContextVar_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyContextVar_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyContextVar_New(const char *name, PyObject *default_value)
     * }
     */
    public static FunctionDescriptor PyContextVar_New$descriptor() {
        return PyContextVar_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyContextVar_New(const char *name, PyObject *default_value)
     * }
     */
    public static MethodHandle PyContextVar_New$handle() {
        return PyContextVar_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyContextVar_New(const char *name, PyObject *default_value)
     * }
     */
    public static MemorySegment PyContextVar_New$address() {
        return PyContextVar_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyContextVar_New(const char *name, PyObject *default_value)
     * }
     */
    public static MemorySegment PyContextVar_New(MemorySegment name, MemorySegment default_value) {
        var mh$ = PyContextVar_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyContextVar_New", name, default_value);
            }
            return (MemorySegment)mh$.invokeExact(name, default_value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyContextVar_Get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyContextVar_Get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyContextVar_Get(PyObject *var, PyObject *default_value, PyObject **value)
     * }
     */
    public static FunctionDescriptor PyContextVar_Get$descriptor() {
        return PyContextVar_Get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyContextVar_Get(PyObject *var, PyObject *default_value, PyObject **value)
     * }
     */
    public static MethodHandle PyContextVar_Get$handle() {
        return PyContextVar_Get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyContextVar_Get(PyObject *var, PyObject *default_value, PyObject **value)
     * }
     */
    public static MemorySegment PyContextVar_Get$address() {
        return PyContextVar_Get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyContextVar_Get(PyObject *var, PyObject *default_value, PyObject **value)
     * }
     */
    public static int PyContextVar_Get(MemorySegment var_, MemorySegment default_value, MemorySegment value) {
        var mh$ = PyContextVar_Get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyContextVar_Get", var_, default_value, value);
            }
            return (int)mh$.invokeExact(var_, default_value, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyContextVar_Set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyContextVar_Set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyContextVar_Set(PyObject *var, PyObject *value)
     * }
     */
    public static FunctionDescriptor PyContextVar_Set$descriptor() {
        return PyContextVar_Set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyContextVar_Set(PyObject *var, PyObject *value)
     * }
     */
    public static MethodHandle PyContextVar_Set$handle() {
        return PyContextVar_Set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyContextVar_Set(PyObject *var, PyObject *value)
     * }
     */
    public static MemorySegment PyContextVar_Set$address() {
        return PyContextVar_Set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyContextVar_Set(PyObject *var, PyObject *value)
     * }
     */
    public static MemorySegment PyContextVar_Set(MemorySegment var_, MemorySegment value) {
        var mh$ = PyContextVar_Set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyContextVar_Set", var_, value);
            }
            return (MemorySegment)mh$.invokeExact(var_, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyContextVar_Reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyContextVar_Reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyContextVar_Reset(PyObject *var, PyObject *token)
     * }
     */
    public static FunctionDescriptor PyContextVar_Reset$descriptor() {
        return PyContextVar_Reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyContextVar_Reset(PyObject *var, PyObject *token)
     * }
     */
    public static MethodHandle PyContextVar_Reset$handle() {
        return PyContextVar_Reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyContextVar_Reset(PyObject *var, PyObject *token)
     * }
     */
    public static MemorySegment PyContextVar_Reset$address() {
        return PyContextVar_Reset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyContextVar_Reset(PyObject *var, PyObject *token)
     * }
     */
    public static int PyContextVar_Reset(MemorySegment var_, MemorySegment token) {
        var mh$ = PyContextVar_Reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyContextVar_Reset", var_, token);
            }
            return (int)mh$.invokeExact(var_, token);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyContext_NewHamtForTests {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyContext_NewHamtForTests");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyContext_NewHamtForTests()
     * }
     */
    public static FunctionDescriptor _PyContext_NewHamtForTests$descriptor() {
        return _PyContext_NewHamtForTests.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyContext_NewHamtForTests()
     * }
     */
    public static MethodHandle _PyContext_NewHamtForTests$handle() {
        return _PyContext_NewHamtForTests.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyContext_NewHamtForTests()
     * }
     */
    public static MemorySegment _PyContext_NewHamtForTests$address() {
        return _PyContext_NewHamtForTests.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyContext_NewHamtForTests()
     * }
     */
    public static MemorySegment _PyContext_NewHamtForTests() {
        var mh$ = _PyContext_NewHamtForTests.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyContext_NewHamtForTests");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int PyArg_Parse(PyObject *, const char *, ...)
     * }
     */
    public static class PyArg_Parse {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyArg_Parse");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyArg_Parse(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int PyArg_Parse(PyObject *, const char *, ...)
         * }
         */
        public static PyArg_Parse makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyArg_Parse(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyArg_Parse", x0, x1, x2);
                }
                return (int)spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int PyArg_ParseTuple(PyObject *, const char *, ...)
     * }
     */
    public static class PyArg_ParseTuple {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyArg_ParseTuple");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyArg_ParseTuple(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int PyArg_ParseTuple(PyObject *, const char *, ...)
         * }
         */
        public static PyArg_ParseTuple makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyArg_ParseTuple(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyArg_ParseTuple", x0, x1, x2);
                }
                return (int)spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int PyArg_ParseTupleAndKeywords(PyObject *, PyObject *, const char *, char **, ...)
     * }
     */
    public static class PyArg_ParseTupleAndKeywords {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyArg_ParseTupleAndKeywords");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyArg_ParseTupleAndKeywords(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int PyArg_ParseTupleAndKeywords(PyObject *, PyObject *, const char *, char **, ...)
         * }
         */
        public static PyArg_ParseTupleAndKeywords makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyArg_ParseTupleAndKeywords(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, Object... x4) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyArg_ParseTupleAndKeywords", x0, x1, x2, x3, x4);
                }
                return (int)spreader.invokeExact(x0, x1, x2, x3, x4);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class PyArg_VaParse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyArg_VaParse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyArg_VaParse(PyObject *, const char *, va_list)
     * }
     */
    public static FunctionDescriptor PyArg_VaParse$descriptor() {
        return PyArg_VaParse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyArg_VaParse(PyObject *, const char *, va_list)
     * }
     */
    public static MethodHandle PyArg_VaParse$handle() {
        return PyArg_VaParse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyArg_VaParse(PyObject *, const char *, va_list)
     * }
     */
    public static MemorySegment PyArg_VaParse$address() {
        return PyArg_VaParse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyArg_VaParse(PyObject *, const char *, va_list)
     * }
     */
    public static int PyArg_VaParse(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyArg_VaParse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyArg_VaParse", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyArg_VaParseTupleAndKeywords {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyArg_VaParseTupleAndKeywords");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyArg_VaParseTupleAndKeywords(PyObject *, PyObject *, const char *, char **, va_list)
     * }
     */
    public static FunctionDescriptor PyArg_VaParseTupleAndKeywords$descriptor() {
        return PyArg_VaParseTupleAndKeywords.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyArg_VaParseTupleAndKeywords(PyObject *, PyObject *, const char *, char **, va_list)
     * }
     */
    public static MethodHandle PyArg_VaParseTupleAndKeywords$handle() {
        return PyArg_VaParseTupleAndKeywords.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyArg_VaParseTupleAndKeywords(PyObject *, PyObject *, const char *, char **, va_list)
     * }
     */
    public static MemorySegment PyArg_VaParseTupleAndKeywords$address() {
        return PyArg_VaParseTupleAndKeywords.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyArg_VaParseTupleAndKeywords(PyObject *, PyObject *, const char *, char **, va_list)
     * }
     */
    public static int PyArg_VaParseTupleAndKeywords(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PyArg_VaParseTupleAndKeywords.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyArg_VaParseTupleAndKeywords", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyArg_ValidateKeywordArguments {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyArg_ValidateKeywordArguments");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyArg_ValidateKeywordArguments(PyObject *)
     * }
     */
    public static FunctionDescriptor PyArg_ValidateKeywordArguments$descriptor() {
        return PyArg_ValidateKeywordArguments.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyArg_ValidateKeywordArguments(PyObject *)
     * }
     */
    public static MethodHandle PyArg_ValidateKeywordArguments$handle() {
        return PyArg_ValidateKeywordArguments.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyArg_ValidateKeywordArguments(PyObject *)
     * }
     */
    public static MemorySegment PyArg_ValidateKeywordArguments$address() {
        return PyArg_ValidateKeywordArguments.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyArg_ValidateKeywordArguments(PyObject *)
     * }
     */
    public static int PyArg_ValidateKeywordArguments(MemorySegment x0) {
        var mh$ = PyArg_ValidateKeywordArguments.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyArg_ValidateKeywordArguments", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int PyArg_UnpackTuple(PyObject *, const char *, Py_ssize_t, Py_ssize_t, ...)
     * }
     */
    public static class PyArg_UnpackTuple {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_LONG,
                Python_h.C_LONG
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyArg_UnpackTuple");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyArg_UnpackTuple(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int PyArg_UnpackTuple(PyObject *, const char *, Py_ssize_t, Py_ssize_t, ...)
         * }
         */
        public static PyArg_UnpackTuple makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyArg_UnpackTuple(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, long x2, long x3, Object... x4) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyArg_UnpackTuple", x0, x1, x2, x3, x4);
                }
                return (int)spreader.invokeExact(x0, x1, x2, x3, x4);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *Py_BuildValue(const char *, ...)
     * }
     */
    public static class Py_BuildValue {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("Py_BuildValue");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private Py_BuildValue(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *Py_BuildValue(const char *, ...)
         * }
         */
        public static Py_BuildValue makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new Py_BuildValue(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("Py_BuildValue", x0, x1);
                }
                return (MemorySegment)spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *_Py_BuildValue_SizeT(const char *, ...)
     * }
     */
    public static class _Py_BuildValue_SizeT {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("_Py_BuildValue_SizeT");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private _Py_BuildValue_SizeT(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *_Py_BuildValue_SizeT(const char *, ...)
         * }
         */
        public static _Py_BuildValue_SizeT makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new _Py_BuildValue_SizeT(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("_Py_BuildValue_SizeT", x0, x1);
                }
                return (MemorySegment)spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class Py_VaBuildValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_VaBuildValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *Py_VaBuildValue(const char *, va_list)
     * }
     */
    public static FunctionDescriptor Py_VaBuildValue$descriptor() {
        return Py_VaBuildValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *Py_VaBuildValue(const char *, va_list)
     * }
     */
    public static MethodHandle Py_VaBuildValue$handle() {
        return Py_VaBuildValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *Py_VaBuildValue(const char *, va_list)
     * }
     */
    public static MemorySegment Py_VaBuildValue$address() {
        return Py_VaBuildValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *Py_VaBuildValue(const char *, va_list)
     * }
     */
    public static MemorySegment Py_VaBuildValue(MemorySegment x0, MemorySegment x1) {
        var mh$ = Py_VaBuildValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_VaBuildValue", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_AddObjectRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_AddObjectRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyModule_AddObjectRef(PyObject *mod, const char *name, PyObject *value)
     * }
     */
    public static FunctionDescriptor PyModule_AddObjectRef$descriptor() {
        return PyModule_AddObjectRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyModule_AddObjectRef(PyObject *mod, const char *name, PyObject *value)
     * }
     */
    public static MethodHandle PyModule_AddObjectRef$handle() {
        return PyModule_AddObjectRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyModule_AddObjectRef(PyObject *mod, const char *name, PyObject *value)
     * }
     */
    public static MemorySegment PyModule_AddObjectRef$address() {
        return PyModule_AddObjectRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyModule_AddObjectRef(PyObject *mod, const char *name, PyObject *value)
     * }
     */
    public static int PyModule_AddObjectRef(MemorySegment mod, MemorySegment name, MemorySegment value) {
        var mh$ = PyModule_AddObjectRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_AddObjectRef", mod, name, value);
            }
            return (int)mh$.invokeExact(mod, name, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_AddObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_AddObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyModule_AddObject(PyObject *mod, const char *, PyObject *value)
     * }
     */
    public static FunctionDescriptor PyModule_AddObject$descriptor() {
        return PyModule_AddObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyModule_AddObject(PyObject *mod, const char *, PyObject *value)
     * }
     */
    public static MethodHandle PyModule_AddObject$handle() {
        return PyModule_AddObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyModule_AddObject(PyObject *mod, const char *, PyObject *value)
     * }
     */
    public static MemorySegment PyModule_AddObject$address() {
        return PyModule_AddObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyModule_AddObject(PyObject *mod, const char *, PyObject *value)
     * }
     */
    public static int PyModule_AddObject(MemorySegment mod, MemorySegment x1, MemorySegment value) {
        var mh$ = PyModule_AddObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_AddObject", mod, x1, value);
            }
            return (int)mh$.invokeExact(mod, x1, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_AddIntConstant {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_AddIntConstant");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyModule_AddIntConstant(PyObject *, const char *, long)
     * }
     */
    public static FunctionDescriptor PyModule_AddIntConstant$descriptor() {
        return PyModule_AddIntConstant.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyModule_AddIntConstant(PyObject *, const char *, long)
     * }
     */
    public static MethodHandle PyModule_AddIntConstant$handle() {
        return PyModule_AddIntConstant.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyModule_AddIntConstant(PyObject *, const char *, long)
     * }
     */
    public static MemorySegment PyModule_AddIntConstant$address() {
        return PyModule_AddIntConstant.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyModule_AddIntConstant(PyObject *, const char *, long)
     * }
     */
    public static int PyModule_AddIntConstant(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = PyModule_AddIntConstant.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_AddIntConstant", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_AddStringConstant {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_AddStringConstant");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyModule_AddStringConstant(PyObject *, const char *, const char *)
     * }
     */
    public static FunctionDescriptor PyModule_AddStringConstant$descriptor() {
        return PyModule_AddStringConstant.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyModule_AddStringConstant(PyObject *, const char *, const char *)
     * }
     */
    public static MethodHandle PyModule_AddStringConstant$handle() {
        return PyModule_AddStringConstant.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyModule_AddStringConstant(PyObject *, const char *, const char *)
     * }
     */
    public static MemorySegment PyModule_AddStringConstant$address() {
        return PyModule_AddStringConstant.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyModule_AddStringConstant(PyObject *, const char *, const char *)
     * }
     */
    public static int PyModule_AddStringConstant(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyModule_AddStringConstant.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_AddStringConstant", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_AddType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_AddType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyModule_AddType(PyObject *module, PyTypeObject *type)
     * }
     */
    public static FunctionDescriptor PyModule_AddType$descriptor() {
        return PyModule_AddType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyModule_AddType(PyObject *module, PyTypeObject *type)
     * }
     */
    public static MethodHandle PyModule_AddType$handle() {
        return PyModule_AddType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyModule_AddType(PyObject *module, PyTypeObject *type)
     * }
     */
    public static MemorySegment PyModule_AddType$address() {
        return PyModule_AddType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyModule_AddType(PyObject *module, PyTypeObject *type)
     * }
     */
    public static int PyModule_AddType(MemorySegment module, MemorySegment type) {
        var mh$ = PyModule_AddType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_AddType", module, type);
            }
            return (int)mh$.invokeExact(module, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_SetDocString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_SetDocString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyModule_SetDocString(PyObject *, const char *)
     * }
     */
    public static FunctionDescriptor PyModule_SetDocString$descriptor() {
        return PyModule_SetDocString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyModule_SetDocString(PyObject *, const char *)
     * }
     */
    public static MethodHandle PyModule_SetDocString$handle() {
        return PyModule_SetDocString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyModule_SetDocString(PyObject *, const char *)
     * }
     */
    public static MemorySegment PyModule_SetDocString$address() {
        return PyModule_SetDocString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyModule_SetDocString(PyObject *, const char *)
     * }
     */
    public static int PyModule_SetDocString(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyModule_SetDocString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_SetDocString", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_AddFunctions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_AddFunctions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyModule_AddFunctions(PyObject *, PyMethodDef *)
     * }
     */
    public static FunctionDescriptor PyModule_AddFunctions$descriptor() {
        return PyModule_AddFunctions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyModule_AddFunctions(PyObject *, PyMethodDef *)
     * }
     */
    public static MethodHandle PyModule_AddFunctions$handle() {
        return PyModule_AddFunctions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyModule_AddFunctions(PyObject *, PyMethodDef *)
     * }
     */
    public static MemorySegment PyModule_AddFunctions$address() {
        return PyModule_AddFunctions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyModule_AddFunctions(PyObject *, PyMethodDef *)
     * }
     */
    public static int PyModule_AddFunctions(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyModule_AddFunctions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_AddFunctions", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_ExecDef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_ExecDef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyModule_ExecDef(PyObject *module, PyModuleDef *def)
     * }
     */
    public static FunctionDescriptor PyModule_ExecDef$descriptor() {
        return PyModule_ExecDef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyModule_ExecDef(PyObject *module, PyModuleDef *def)
     * }
     */
    public static MethodHandle PyModule_ExecDef$handle() {
        return PyModule_ExecDef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyModule_ExecDef(PyObject *module, PyModuleDef *def)
     * }
     */
    public static MemorySegment PyModule_ExecDef$address() {
        return PyModule_ExecDef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyModule_ExecDef(PyObject *module, PyModuleDef *def)
     * }
     */
    public static int PyModule_ExecDef(MemorySegment module, MemorySegment def) {
        var mh$ = PyModule_ExecDef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_ExecDef", module, def);
            }
            return (int)mh$.invokeExact(module, def);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_Create2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_Create2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyModule_Create2(PyModuleDef *, int apiver)
     * }
     */
    public static FunctionDescriptor PyModule_Create2$descriptor() {
        return PyModule_Create2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyModule_Create2(PyModuleDef *, int apiver)
     * }
     */
    public static MethodHandle PyModule_Create2$handle() {
        return PyModule_Create2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyModule_Create2(PyModuleDef *, int apiver)
     * }
     */
    public static MemorySegment PyModule_Create2$address() {
        return PyModule_Create2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyModule_Create2(PyModuleDef *, int apiver)
     * }
     */
    public static MemorySegment PyModule_Create2(MemorySegment x0, int apiver) {
        var mh$ = PyModule_Create2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_Create2", x0, apiver);
            }
            return (MemorySegment)mh$.invokeExact(x0, apiver);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyModule_FromDefAndSpec2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyModule_FromDefAndSpec2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyModule_FromDefAndSpec2(PyModuleDef *def, PyObject *spec, int module_api_version)
     * }
     */
    public static FunctionDescriptor PyModule_FromDefAndSpec2$descriptor() {
        return PyModule_FromDefAndSpec2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyModule_FromDefAndSpec2(PyModuleDef *def, PyObject *spec, int module_api_version)
     * }
     */
    public static MethodHandle PyModule_FromDefAndSpec2$handle() {
        return PyModule_FromDefAndSpec2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyModule_FromDefAndSpec2(PyModuleDef *def, PyObject *spec, int module_api_version)
     * }
     */
    public static MemorySegment PyModule_FromDefAndSpec2$address() {
        return PyModule_FromDefAndSpec2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyModule_FromDefAndSpec2(PyModuleDef *def, PyObject *spec, int module_api_version)
     * }
     */
    public static MemorySegment PyModule_FromDefAndSpec2(MemorySegment def, MemorySegment spec, int module_api_version) {
        var mh$ = PyModule_FromDefAndSpec2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyModule_FromDefAndSpec2", def, spec, module_api_version);
            }
            return (MemorySegment)mh$.invokeExact(def, spec, module_api_version);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_VaBuildValue_SizeT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_VaBuildValue_SizeT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_Py_VaBuildValue_SizeT(const char *, va_list)
     * }
     */
    public static FunctionDescriptor _Py_VaBuildValue_SizeT$descriptor() {
        return _Py_VaBuildValue_SizeT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_Py_VaBuildValue_SizeT(const char *, va_list)
     * }
     */
    public static MethodHandle _Py_VaBuildValue_SizeT$handle() {
        return _Py_VaBuildValue_SizeT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_Py_VaBuildValue_SizeT(const char *, va_list)
     * }
     */
    public static MemorySegment _Py_VaBuildValue_SizeT$address() {
        return _Py_VaBuildValue_SizeT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_Py_VaBuildValue_SizeT(const char *, va_list)
     * }
     */
    public static MemorySegment _Py_VaBuildValue_SizeT(MemorySegment x0, MemorySegment x1) {
        var mh$ = _Py_VaBuildValue_SizeT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_VaBuildValue_SizeT", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_VaBuildStack_SizeT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_VaBuildStack_SizeT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject **_Py_VaBuildStack_SizeT(PyObject **small_stack, Py_ssize_t small_stack_len, const char *format, va_list va, Py_ssize_t *p_nargs)
     * }
     */
    public static FunctionDescriptor _Py_VaBuildStack_SizeT$descriptor() {
        return _Py_VaBuildStack_SizeT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject **_Py_VaBuildStack_SizeT(PyObject **small_stack, Py_ssize_t small_stack_len, const char *format, va_list va, Py_ssize_t *p_nargs)
     * }
     */
    public static MethodHandle _Py_VaBuildStack_SizeT$handle() {
        return _Py_VaBuildStack_SizeT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject **_Py_VaBuildStack_SizeT(PyObject **small_stack, Py_ssize_t small_stack_len, const char *format, va_list va, Py_ssize_t *p_nargs)
     * }
     */
    public static MemorySegment _Py_VaBuildStack_SizeT$address() {
        return _Py_VaBuildStack_SizeT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject **_Py_VaBuildStack_SizeT(PyObject **small_stack, Py_ssize_t small_stack_len, const char *format, va_list va, Py_ssize_t *p_nargs)
     * }
     */
    public static MemorySegment _Py_VaBuildStack_SizeT(MemorySegment small_stack, long small_stack_len, MemorySegment format, MemorySegment va, MemorySegment p_nargs) {
        var mh$ = _Py_VaBuildStack_SizeT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_VaBuildStack_SizeT", small_stack, small_stack_len, format, va, p_nargs);
            }
            return (MemorySegment)mh$.invokeExact(small_stack, small_stack_len, format, va, p_nargs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int _PyArg_UnpackStack(PyObject *const *args, Py_ssize_t nargs, const char *name, Py_ssize_t min, Py_ssize_t max, ...)
     * }
     */
    public static class _PyArg_UnpackStack {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_LONG,
                Python_h.C_POINTER,
                Python_h.C_LONG,
                Python_h.C_LONG
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("_PyArg_UnpackStack");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private _PyArg_UnpackStack(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int _PyArg_UnpackStack(PyObject *const *args, Py_ssize_t nargs, const char *name, Py_ssize_t min, Py_ssize_t max, ...)
         * }
         */
        public static _PyArg_UnpackStack makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new _PyArg_UnpackStack(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment args, long nargs, MemorySegment name, long min, long max, Object... x5) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("_PyArg_UnpackStack", args, nargs, name, min, max, x5);
                }
                return (int)spreader.invokeExact(args, nargs, name, min, max, x5);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class _PyArg_NoKeywords {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyArg_NoKeywords");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyArg_NoKeywords(const char *funcname, PyObject *kwargs)
     * }
     */
    public static FunctionDescriptor _PyArg_NoKeywords$descriptor() {
        return _PyArg_NoKeywords.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyArg_NoKeywords(const char *funcname, PyObject *kwargs)
     * }
     */
    public static MethodHandle _PyArg_NoKeywords$handle() {
        return _PyArg_NoKeywords.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyArg_NoKeywords(const char *funcname, PyObject *kwargs)
     * }
     */
    public static MemorySegment _PyArg_NoKeywords$address() {
        return _PyArg_NoKeywords.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyArg_NoKeywords(const char *funcname, PyObject *kwargs)
     * }
     */
    public static int _PyArg_NoKeywords(MemorySegment funcname, MemorySegment kwargs) {
        var mh$ = _PyArg_NoKeywords.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyArg_NoKeywords", funcname, kwargs);
            }
            return (int)mh$.invokeExact(funcname, kwargs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyArg_NoKwnames {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyArg_NoKwnames");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyArg_NoKwnames(const char *funcname, PyObject *kwnames)
     * }
     */
    public static FunctionDescriptor _PyArg_NoKwnames$descriptor() {
        return _PyArg_NoKwnames.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyArg_NoKwnames(const char *funcname, PyObject *kwnames)
     * }
     */
    public static MethodHandle _PyArg_NoKwnames$handle() {
        return _PyArg_NoKwnames.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyArg_NoKwnames(const char *funcname, PyObject *kwnames)
     * }
     */
    public static MemorySegment _PyArg_NoKwnames$address() {
        return _PyArg_NoKwnames.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyArg_NoKwnames(const char *funcname, PyObject *kwnames)
     * }
     */
    public static int _PyArg_NoKwnames(MemorySegment funcname, MemorySegment kwnames) {
        var mh$ = _PyArg_NoKwnames.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyArg_NoKwnames", funcname, kwnames);
            }
            return (int)mh$.invokeExact(funcname, kwnames);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyArg_NoPositional {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyArg_NoPositional");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyArg_NoPositional(const char *funcname, PyObject *args)
     * }
     */
    public static FunctionDescriptor _PyArg_NoPositional$descriptor() {
        return _PyArg_NoPositional.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyArg_NoPositional(const char *funcname, PyObject *args)
     * }
     */
    public static MethodHandle _PyArg_NoPositional$handle() {
        return _PyArg_NoPositional.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyArg_NoPositional(const char *funcname, PyObject *args)
     * }
     */
    public static MemorySegment _PyArg_NoPositional$address() {
        return _PyArg_NoPositional.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyArg_NoPositional(const char *funcname, PyObject *args)
     * }
     */
    public static int _PyArg_NoPositional(MemorySegment funcname, MemorySegment args) {
        var mh$ = _PyArg_NoPositional.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyArg_NoPositional", funcname, args);
            }
            return (int)mh$.invokeExact(funcname, args);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyArg_BadArgument {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyArg_BadArgument");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyArg_BadArgument(const char *, const char *, const char *, PyObject *)
     * }
     */
    public static FunctionDescriptor _PyArg_BadArgument$descriptor() {
        return _PyArg_BadArgument.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyArg_BadArgument(const char *, const char *, const char *, PyObject *)
     * }
     */
    public static MethodHandle _PyArg_BadArgument$handle() {
        return _PyArg_BadArgument.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyArg_BadArgument(const char *, const char *, const char *, PyObject *)
     * }
     */
    public static MemorySegment _PyArg_BadArgument$address() {
        return _PyArg_BadArgument.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyArg_BadArgument(const char *, const char *, const char *, PyObject *)
     * }
     */
    public static void _PyArg_BadArgument(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = _PyArg_BadArgument.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyArg_BadArgument", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyArg_CheckPositional {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyArg_CheckPositional");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyArg_CheckPositional(const char *, Py_ssize_t, Py_ssize_t, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor _PyArg_CheckPositional$descriptor() {
        return _PyArg_CheckPositional.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyArg_CheckPositional(const char *, Py_ssize_t, Py_ssize_t, Py_ssize_t)
     * }
     */
    public static MethodHandle _PyArg_CheckPositional$handle() {
        return _PyArg_CheckPositional.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyArg_CheckPositional(const char *, Py_ssize_t, Py_ssize_t, Py_ssize_t)
     * }
     */
    public static MemorySegment _PyArg_CheckPositional$address() {
        return _PyArg_CheckPositional.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyArg_CheckPositional(const char *, Py_ssize_t, Py_ssize_t, Py_ssize_t)
     * }
     */
    public static int _PyArg_CheckPositional(MemorySegment x0, long x1, long x2, long x3) {
        var mh$ = _PyArg_CheckPositional.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyArg_CheckPositional", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_VaBuildStack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_VaBuildStack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject **_Py_VaBuildStack(PyObject **small_stack, Py_ssize_t small_stack_len, const char *format, va_list va, Py_ssize_t *p_nargs)
     * }
     */
    public static FunctionDescriptor _Py_VaBuildStack$descriptor() {
        return _Py_VaBuildStack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject **_Py_VaBuildStack(PyObject **small_stack, Py_ssize_t small_stack_len, const char *format, va_list va, Py_ssize_t *p_nargs)
     * }
     */
    public static MethodHandle _Py_VaBuildStack$handle() {
        return _Py_VaBuildStack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject **_Py_VaBuildStack(PyObject **small_stack, Py_ssize_t small_stack_len, const char *format, va_list va, Py_ssize_t *p_nargs)
     * }
     */
    public static MemorySegment _Py_VaBuildStack$address() {
        return _Py_VaBuildStack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject **_Py_VaBuildStack(PyObject **small_stack, Py_ssize_t small_stack_len, const char *format, va_list va, Py_ssize_t *p_nargs)
     * }
     */
    public static MemorySegment _Py_VaBuildStack(MemorySegment small_stack, long small_stack_len, MemorySegment format, MemorySegment va, MemorySegment p_nargs) {
        var mh$ = _Py_VaBuildStack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_VaBuildStack", small_stack, small_stack_len, format, va, p_nargs);
            }
            return (MemorySegment)mh$.invokeExact(small_stack, small_stack_len, format, va, p_nargs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int _PyArg_ParseTupleAndKeywordsFast(PyObject *, PyObject *, struct _PyArg_Parser *, ...)
     * }
     */
    public static class _PyArg_ParseTupleAndKeywordsFast {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("_PyArg_ParseTupleAndKeywordsFast");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private _PyArg_ParseTupleAndKeywordsFast(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int _PyArg_ParseTupleAndKeywordsFast(PyObject *, PyObject *, struct _PyArg_Parser *, ...)
         * }
         */
        public static _PyArg_ParseTupleAndKeywordsFast makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new _PyArg_ParseTupleAndKeywordsFast(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, MemorySegment x2, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("_PyArg_ParseTupleAndKeywordsFast", x0, x1, x2, x3);
                }
                return (int)spreader.invokeExact(x0, x1, x2, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int _PyArg_ParseStack(PyObject *const *args, Py_ssize_t nargs, const char *format, ...)
     * }
     */
    public static class _PyArg_ParseStack {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_LONG,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("_PyArg_ParseStack");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private _PyArg_ParseStack(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int _PyArg_ParseStack(PyObject *const *args, Py_ssize_t nargs, const char *format, ...)
         * }
         */
        public static _PyArg_ParseStack makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new _PyArg_ParseStack(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment args, long nargs, MemorySegment format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("_PyArg_ParseStack", args, nargs, format, x3);
                }
                return (int)spreader.invokeExact(args, nargs, format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int _PyArg_ParseStackAndKeywords(PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames, struct _PyArg_Parser *, ...)
     * }
     */
    public static class _PyArg_ParseStackAndKeywords {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_LONG,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("_PyArg_ParseStackAndKeywords");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private _PyArg_ParseStackAndKeywords(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int _PyArg_ParseStackAndKeywords(PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames, struct _PyArg_Parser *, ...)
         * }
         */
        public static _PyArg_ParseStackAndKeywords makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new _PyArg_ParseStackAndKeywords(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment args, long nargs, MemorySegment kwnames, MemorySegment x3, Object... x4) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("_PyArg_ParseStackAndKeywords", args, nargs, kwnames, x3, x4);
                }
                return (int)spreader.invokeExact(args, nargs, kwnames, x3, x4);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class _PyArg_VaParseTupleAndKeywordsFast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyArg_VaParseTupleAndKeywordsFast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyArg_VaParseTupleAndKeywordsFast(PyObject *, PyObject *, struct _PyArg_Parser *, va_list)
     * }
     */
    public static FunctionDescriptor _PyArg_VaParseTupleAndKeywordsFast$descriptor() {
        return _PyArg_VaParseTupleAndKeywordsFast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyArg_VaParseTupleAndKeywordsFast(PyObject *, PyObject *, struct _PyArg_Parser *, va_list)
     * }
     */
    public static MethodHandle _PyArg_VaParseTupleAndKeywordsFast$handle() {
        return _PyArg_VaParseTupleAndKeywordsFast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyArg_VaParseTupleAndKeywordsFast(PyObject *, PyObject *, struct _PyArg_Parser *, va_list)
     * }
     */
    public static MemorySegment _PyArg_VaParseTupleAndKeywordsFast$address() {
        return _PyArg_VaParseTupleAndKeywordsFast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyArg_VaParseTupleAndKeywordsFast(PyObject *, PyObject *, struct _PyArg_Parser *, va_list)
     * }
     */
    public static int _PyArg_VaParseTupleAndKeywordsFast(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = _PyArg_VaParseTupleAndKeywordsFast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyArg_VaParseTupleAndKeywordsFast", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyArg_UnpackKeywords {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyArg_UnpackKeywords");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *const *_PyArg_UnpackKeywords(PyObject *const *args, Py_ssize_t nargs, PyObject *kwargs, PyObject *kwnames, struct _PyArg_Parser *parser, int minpos, int maxpos, int minkw, PyObject **buf)
     * }
     */
    public static FunctionDescriptor _PyArg_UnpackKeywords$descriptor() {
        return _PyArg_UnpackKeywords.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *const *_PyArg_UnpackKeywords(PyObject *const *args, Py_ssize_t nargs, PyObject *kwargs, PyObject *kwnames, struct _PyArg_Parser *parser, int minpos, int maxpos, int minkw, PyObject **buf)
     * }
     */
    public static MethodHandle _PyArg_UnpackKeywords$handle() {
        return _PyArg_UnpackKeywords.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *const *_PyArg_UnpackKeywords(PyObject *const *args, Py_ssize_t nargs, PyObject *kwargs, PyObject *kwnames, struct _PyArg_Parser *parser, int minpos, int maxpos, int minkw, PyObject **buf)
     * }
     */
    public static MemorySegment _PyArg_UnpackKeywords$address() {
        return _PyArg_UnpackKeywords.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *const *_PyArg_UnpackKeywords(PyObject *const *args, Py_ssize_t nargs, PyObject *kwargs, PyObject *kwnames, struct _PyArg_Parser *parser, int minpos, int maxpos, int minkw, PyObject **buf)
     * }
     */
    public static MemorySegment _PyArg_UnpackKeywords(MemorySegment args, long nargs, MemorySegment kwargs, MemorySegment kwnames, MemorySegment parser, int minpos, int maxpos, int minkw, MemorySegment buf) {
        var mh$ = _PyArg_UnpackKeywords.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyArg_UnpackKeywords", args, nargs, kwargs, kwnames, parser, minpos, maxpos, minkw, buf);
            }
            return (MemorySegment)mh$.invokeExact(args, nargs, kwargs, kwnames, parser, minpos, maxpos, minkw, buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyArg_UnpackKeywordsWithVararg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyArg_UnpackKeywordsWithVararg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *const *_PyArg_UnpackKeywordsWithVararg(PyObject *const *args, Py_ssize_t nargs, PyObject *kwargs, PyObject *kwnames, struct _PyArg_Parser *parser, int minpos, int maxpos, int minkw, int vararg, PyObject **buf)
     * }
     */
    public static FunctionDescriptor _PyArg_UnpackKeywordsWithVararg$descriptor() {
        return _PyArg_UnpackKeywordsWithVararg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *const *_PyArg_UnpackKeywordsWithVararg(PyObject *const *args, Py_ssize_t nargs, PyObject *kwargs, PyObject *kwnames, struct _PyArg_Parser *parser, int minpos, int maxpos, int minkw, int vararg, PyObject **buf)
     * }
     */
    public static MethodHandle _PyArg_UnpackKeywordsWithVararg$handle() {
        return _PyArg_UnpackKeywordsWithVararg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *const *_PyArg_UnpackKeywordsWithVararg(PyObject *const *args, Py_ssize_t nargs, PyObject *kwargs, PyObject *kwnames, struct _PyArg_Parser *parser, int minpos, int maxpos, int minkw, int vararg, PyObject **buf)
     * }
     */
    public static MemorySegment _PyArg_UnpackKeywordsWithVararg$address() {
        return _PyArg_UnpackKeywordsWithVararg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *const *_PyArg_UnpackKeywordsWithVararg(PyObject *const *args, Py_ssize_t nargs, PyObject *kwargs, PyObject *kwnames, struct _PyArg_Parser *parser, int minpos, int maxpos, int minkw, int vararg, PyObject **buf)
     * }
     */
    public static MemorySegment _PyArg_UnpackKeywordsWithVararg(MemorySegment args, long nargs, MemorySegment kwargs, MemorySegment kwnames, MemorySegment parser, int minpos, int maxpos, int minkw, int vararg, MemorySegment buf) {
        var mh$ = _PyArg_UnpackKeywordsWithVararg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyArg_UnpackKeywordsWithVararg", args, nargs, kwargs, kwnames, parser, minpos, maxpos, minkw, vararg, buf);
            }
            return (MemorySegment)mh$.invokeExact(args, nargs, kwargs, kwnames, parser, minpos, maxpos, minkw, vararg, buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyModule_CreateInitialized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyModule_CreateInitialized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyModule_CreateInitialized(PyModuleDef *, int apiver)
     * }
     */
    public static FunctionDescriptor _PyModule_CreateInitialized$descriptor() {
        return _PyModule_CreateInitialized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyModule_CreateInitialized(PyModuleDef *, int apiver)
     * }
     */
    public static MethodHandle _PyModule_CreateInitialized$handle() {
        return _PyModule_CreateInitialized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyModule_CreateInitialized(PyModuleDef *, int apiver)
     * }
     */
    public static MemorySegment _PyModule_CreateInitialized$address() {
        return _PyModule_CreateInitialized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyModule_CreateInitialized(PyModuleDef *, int apiver)
     * }
     */
    public static MemorySegment _PyModule_CreateInitialized(MemorySegment x0, int apiver) {
        var mh$ = _PyModule_CreateInitialized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyModule_CreateInitialized", x0, apiver);
            }
            return (MemorySegment)mh$.invokeExact(x0, apiver);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_PackageContext$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_Py_PackageContext").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const char *_Py_PackageContext
     * }
     */
    public static AddressLayout _Py_PackageContext$layout() {
        return _Py_PackageContext$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const char *_Py_PackageContext
     * }
     */
    public static MemorySegment _Py_PackageContext$segment() {
        return _Py_PackageContext$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const char *_Py_PackageContext
     * }
     */
    public static MemorySegment _Py_PackageContext() {
        return _Py_PackageContext$constants.SEGMENT.get(_Py_PackageContext$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const char *_Py_PackageContext
     * }
     */
    public static void _Py_PackageContext(MemorySegment varValue) {
        _Py_PackageContext$constants.SEGMENT.set(_Py_PackageContext$constants.LAYOUT, 0L, varValue);
    }

    private static class PyCompile_OpcodeStackEffect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCompile_OpcodeStackEffect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyCompile_OpcodeStackEffect(int opcode, int oparg)
     * }
     */
    public static FunctionDescriptor PyCompile_OpcodeStackEffect$descriptor() {
        return PyCompile_OpcodeStackEffect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyCompile_OpcodeStackEffect(int opcode, int oparg)
     * }
     */
    public static MethodHandle PyCompile_OpcodeStackEffect$handle() {
        return PyCompile_OpcodeStackEffect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyCompile_OpcodeStackEffect(int opcode, int oparg)
     * }
     */
    public static MemorySegment PyCompile_OpcodeStackEffect$address() {
        return PyCompile_OpcodeStackEffect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyCompile_OpcodeStackEffect(int opcode, int oparg)
     * }
     */
    public static int PyCompile_OpcodeStackEffect(int opcode, int oparg) {
        var mh$ = PyCompile_OpcodeStackEffect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCompile_OpcodeStackEffect", opcode, oparg);
            }
            return (int)mh$.invokeExact(opcode, oparg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCompile_OpcodeStackEffectWithJump {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCompile_OpcodeStackEffectWithJump");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyCompile_OpcodeStackEffectWithJump(int opcode, int oparg, int jump)
     * }
     */
    public static FunctionDescriptor PyCompile_OpcodeStackEffectWithJump$descriptor() {
        return PyCompile_OpcodeStackEffectWithJump.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyCompile_OpcodeStackEffectWithJump(int opcode, int oparg, int jump)
     * }
     */
    public static MethodHandle PyCompile_OpcodeStackEffectWithJump$handle() {
        return PyCompile_OpcodeStackEffectWithJump.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyCompile_OpcodeStackEffectWithJump(int opcode, int oparg, int jump)
     * }
     */
    public static MemorySegment PyCompile_OpcodeStackEffectWithJump$address() {
        return PyCompile_OpcodeStackEffectWithJump.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyCompile_OpcodeStackEffectWithJump(int opcode, int oparg, int jump)
     * }
     */
    public static int PyCompile_OpcodeStackEffectWithJump(int opcode, int oparg, int jump) {
        var mh$ = PyCompile_OpcodeStackEffectWithJump.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCompile_OpcodeStackEffectWithJump", opcode, oparg, jump);
            }
            return (int)mh$.invokeExact(opcode, oparg, jump);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_CompileString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_CompileString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *Py_CompileString(const char *, const char *, int)
     * }
     */
    public static FunctionDescriptor Py_CompileString$descriptor() {
        return Py_CompileString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *Py_CompileString(const char *, const char *, int)
     * }
     */
    public static MethodHandle Py_CompileString$handle() {
        return Py_CompileString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *Py_CompileString(const char *, const char *, int)
     * }
     */
    public static MemorySegment Py_CompileString$address() {
        return Py_CompileString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *Py_CompileString(const char *, const char *, int)
     * }
     */
    public static MemorySegment Py_CompileString(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = Py_CompileString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_CompileString", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_Print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_Print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_Print()
     * }
     */
    public static FunctionDescriptor PyErr_Print$descriptor() {
        return PyErr_Print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_Print()
     * }
     */
    public static MethodHandle PyErr_Print$handle() {
        return PyErr_Print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_Print()
     * }
     */
    public static MemorySegment PyErr_Print$address() {
        return PyErr_Print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_Print()
     * }
     */
    public static void PyErr_Print() {
        var mh$ = PyErr_Print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_Print");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_PrintEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_PrintEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_PrintEx(int)
     * }
     */
    public static FunctionDescriptor PyErr_PrintEx$descriptor() {
        return PyErr_PrintEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_PrintEx(int)
     * }
     */
    public static MethodHandle PyErr_PrintEx$handle() {
        return PyErr_PrintEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_PrintEx(int)
     * }
     */
    public static MemorySegment PyErr_PrintEx$address() {
        return PyErr_PrintEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_PrintEx(int)
     * }
     */
    public static void PyErr_PrintEx(int x0) {
        var mh$ = PyErr_PrintEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_PrintEx", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyErr_Display {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyErr_Display");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyErr_Display(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyErr_Display$descriptor() {
        return PyErr_Display.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyErr_Display(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyErr_Display$handle() {
        return PyErr_Display.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyErr_Display(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyErr_Display$address() {
        return PyErr_Display.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyErr_Display(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static void PyErr_Display(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyErr_Display.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyErr_Display", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyOS_InputHook$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyOS_InputHook").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int (*PyOS_InputHook)(void)
     * }
     */
    public static AddressLayout PyOS_InputHook$layout() {
        return PyOS_InputHook$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int (*PyOS_InputHook)(void)
     * }
     */
    public static MemorySegment PyOS_InputHook$segment() {
        return PyOS_InputHook$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int (*PyOS_InputHook)(void)
     * }
     */
    public static MemorySegment PyOS_InputHook() {
        return PyOS_InputHook$constants.SEGMENT.get(PyOS_InputHook$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int (*PyOS_InputHook)(void)
     * }
     */
    public static void PyOS_InputHook(MemorySegment varValue) {
        PyOS_InputHook$constants.SEGMENT.set(PyOS_InputHook$constants.LAYOUT, 0L, varValue);
    }

    private static class PyRun_SimpleStringFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyRun_SimpleStringFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyRun_SimpleStringFlags(const char *, PyCompilerFlags *)
     * }
     */
    public static FunctionDescriptor PyRun_SimpleStringFlags$descriptor() {
        return PyRun_SimpleStringFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyRun_SimpleStringFlags(const char *, PyCompilerFlags *)
     * }
     */
    public static MethodHandle PyRun_SimpleStringFlags$handle() {
        return PyRun_SimpleStringFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyRun_SimpleStringFlags(const char *, PyCompilerFlags *)
     * }
     */
    public static MemorySegment PyRun_SimpleStringFlags$address() {
        return PyRun_SimpleStringFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyRun_SimpleStringFlags(const char *, PyCompilerFlags *)
     * }
     */
    public static int PyRun_SimpleStringFlags(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyRun_SimpleStringFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyRun_SimpleStringFlags", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyRun_SimpleFileObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyRun_SimpleFileObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyRun_SimpleFileObject(FILE *fp, PyObject *filename, int closeit, PyCompilerFlags *flags)
     * }
     */
    public static FunctionDescriptor _PyRun_SimpleFileObject$descriptor() {
        return _PyRun_SimpleFileObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyRun_SimpleFileObject(FILE *fp, PyObject *filename, int closeit, PyCompilerFlags *flags)
     * }
     */
    public static MethodHandle _PyRun_SimpleFileObject$handle() {
        return _PyRun_SimpleFileObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyRun_SimpleFileObject(FILE *fp, PyObject *filename, int closeit, PyCompilerFlags *flags)
     * }
     */
    public static MemorySegment _PyRun_SimpleFileObject$address() {
        return _PyRun_SimpleFileObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyRun_SimpleFileObject(FILE *fp, PyObject *filename, int closeit, PyCompilerFlags *flags)
     * }
     */
    public static int _PyRun_SimpleFileObject(MemorySegment fp, MemorySegment filename, int closeit, MemorySegment flags) {
        var mh$ = _PyRun_SimpleFileObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyRun_SimpleFileObject", fp, filename, closeit, flags);
            }
            return (int)mh$.invokeExact(fp, filename, closeit, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyRun_AnyFileExFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyRun_AnyFileExFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyRun_AnyFileExFlags(FILE *fp, const char *filename, int closeit, PyCompilerFlags *flags)
     * }
     */
    public static FunctionDescriptor PyRun_AnyFileExFlags$descriptor() {
        return PyRun_AnyFileExFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyRun_AnyFileExFlags(FILE *fp, const char *filename, int closeit, PyCompilerFlags *flags)
     * }
     */
    public static MethodHandle PyRun_AnyFileExFlags$handle() {
        return PyRun_AnyFileExFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyRun_AnyFileExFlags(FILE *fp, const char *filename, int closeit, PyCompilerFlags *flags)
     * }
     */
    public static MemorySegment PyRun_AnyFileExFlags$address() {
        return PyRun_AnyFileExFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyRun_AnyFileExFlags(FILE *fp, const char *filename, int closeit, PyCompilerFlags *flags)
     * }
     */
    public static int PyRun_AnyFileExFlags(MemorySegment fp, MemorySegment filename, int closeit, MemorySegment flags) {
        var mh$ = PyRun_AnyFileExFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyRun_AnyFileExFlags", fp, filename, closeit, flags);
            }
            return (int)mh$.invokeExact(fp, filename, closeit, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyRun_AnyFileObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyRun_AnyFileObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyRun_AnyFileObject(FILE *fp, PyObject *filename, int closeit, PyCompilerFlags *flags)
     * }
     */
    public static FunctionDescriptor _PyRun_AnyFileObject$descriptor() {
        return _PyRun_AnyFileObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyRun_AnyFileObject(FILE *fp, PyObject *filename, int closeit, PyCompilerFlags *flags)
     * }
     */
    public static MethodHandle _PyRun_AnyFileObject$handle() {
        return _PyRun_AnyFileObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyRun_AnyFileObject(FILE *fp, PyObject *filename, int closeit, PyCompilerFlags *flags)
     * }
     */
    public static MemorySegment _PyRun_AnyFileObject$address() {
        return _PyRun_AnyFileObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyRun_AnyFileObject(FILE *fp, PyObject *filename, int closeit, PyCompilerFlags *flags)
     * }
     */
    public static int _PyRun_AnyFileObject(MemorySegment fp, MemorySegment filename, int closeit, MemorySegment flags) {
        var mh$ = _PyRun_AnyFileObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyRun_AnyFileObject", fp, filename, closeit, flags);
            }
            return (int)mh$.invokeExact(fp, filename, closeit, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyRun_SimpleFileExFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyRun_SimpleFileExFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyRun_SimpleFileExFlags(FILE *fp, const char *filename, int closeit, PyCompilerFlags *flags)
     * }
     */
    public static FunctionDescriptor PyRun_SimpleFileExFlags$descriptor() {
        return PyRun_SimpleFileExFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyRun_SimpleFileExFlags(FILE *fp, const char *filename, int closeit, PyCompilerFlags *flags)
     * }
     */
    public static MethodHandle PyRun_SimpleFileExFlags$handle() {
        return PyRun_SimpleFileExFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyRun_SimpleFileExFlags(FILE *fp, const char *filename, int closeit, PyCompilerFlags *flags)
     * }
     */
    public static MemorySegment PyRun_SimpleFileExFlags$address() {
        return PyRun_SimpleFileExFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyRun_SimpleFileExFlags(FILE *fp, const char *filename, int closeit, PyCompilerFlags *flags)
     * }
     */
    public static int PyRun_SimpleFileExFlags(MemorySegment fp, MemorySegment filename, int closeit, MemorySegment flags) {
        var mh$ = PyRun_SimpleFileExFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyRun_SimpleFileExFlags", fp, filename, closeit, flags);
            }
            return (int)mh$.invokeExact(fp, filename, closeit, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyRun_InteractiveOneFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyRun_InteractiveOneFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyRun_InteractiveOneFlags(FILE *fp, const char *filename, PyCompilerFlags *flags)
     * }
     */
    public static FunctionDescriptor PyRun_InteractiveOneFlags$descriptor() {
        return PyRun_InteractiveOneFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyRun_InteractiveOneFlags(FILE *fp, const char *filename, PyCompilerFlags *flags)
     * }
     */
    public static MethodHandle PyRun_InteractiveOneFlags$handle() {
        return PyRun_InteractiveOneFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyRun_InteractiveOneFlags(FILE *fp, const char *filename, PyCompilerFlags *flags)
     * }
     */
    public static MemorySegment PyRun_InteractiveOneFlags$address() {
        return PyRun_InteractiveOneFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyRun_InteractiveOneFlags(FILE *fp, const char *filename, PyCompilerFlags *flags)
     * }
     */
    public static int PyRun_InteractiveOneFlags(MemorySegment fp, MemorySegment filename, MemorySegment flags) {
        var mh$ = PyRun_InteractiveOneFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyRun_InteractiveOneFlags", fp, filename, flags);
            }
            return (int)mh$.invokeExact(fp, filename, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyRun_InteractiveOneObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyRun_InteractiveOneObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyRun_InteractiveOneObject(FILE *fp, PyObject *filename, PyCompilerFlags *flags)
     * }
     */
    public static FunctionDescriptor PyRun_InteractiveOneObject$descriptor() {
        return PyRun_InteractiveOneObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyRun_InteractiveOneObject(FILE *fp, PyObject *filename, PyCompilerFlags *flags)
     * }
     */
    public static MethodHandle PyRun_InteractiveOneObject$handle() {
        return PyRun_InteractiveOneObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyRun_InteractiveOneObject(FILE *fp, PyObject *filename, PyCompilerFlags *flags)
     * }
     */
    public static MemorySegment PyRun_InteractiveOneObject$address() {
        return PyRun_InteractiveOneObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyRun_InteractiveOneObject(FILE *fp, PyObject *filename, PyCompilerFlags *flags)
     * }
     */
    public static int PyRun_InteractiveOneObject(MemorySegment fp, MemorySegment filename, MemorySegment flags) {
        var mh$ = PyRun_InteractiveOneObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyRun_InteractiveOneObject", fp, filename, flags);
            }
            return (int)mh$.invokeExact(fp, filename, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyRun_InteractiveLoopFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyRun_InteractiveLoopFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyRun_InteractiveLoopFlags(FILE *fp, const char *filename, PyCompilerFlags *flags)
     * }
     */
    public static FunctionDescriptor PyRun_InteractiveLoopFlags$descriptor() {
        return PyRun_InteractiveLoopFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyRun_InteractiveLoopFlags(FILE *fp, const char *filename, PyCompilerFlags *flags)
     * }
     */
    public static MethodHandle PyRun_InteractiveLoopFlags$handle() {
        return PyRun_InteractiveLoopFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyRun_InteractiveLoopFlags(FILE *fp, const char *filename, PyCompilerFlags *flags)
     * }
     */
    public static MemorySegment PyRun_InteractiveLoopFlags$address() {
        return PyRun_InteractiveLoopFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyRun_InteractiveLoopFlags(FILE *fp, const char *filename, PyCompilerFlags *flags)
     * }
     */
    public static int PyRun_InteractiveLoopFlags(MemorySegment fp, MemorySegment filename, MemorySegment flags) {
        var mh$ = PyRun_InteractiveLoopFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyRun_InteractiveLoopFlags", fp, filename, flags);
            }
            return (int)mh$.invokeExact(fp, filename, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyRun_InteractiveLoopObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyRun_InteractiveLoopObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyRun_InteractiveLoopObject(FILE *fp, PyObject *filename, PyCompilerFlags *flags)
     * }
     */
    public static FunctionDescriptor _PyRun_InteractiveLoopObject$descriptor() {
        return _PyRun_InteractiveLoopObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyRun_InteractiveLoopObject(FILE *fp, PyObject *filename, PyCompilerFlags *flags)
     * }
     */
    public static MethodHandle _PyRun_InteractiveLoopObject$handle() {
        return _PyRun_InteractiveLoopObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyRun_InteractiveLoopObject(FILE *fp, PyObject *filename, PyCompilerFlags *flags)
     * }
     */
    public static MemorySegment _PyRun_InteractiveLoopObject$address() {
        return _PyRun_InteractiveLoopObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyRun_InteractiveLoopObject(FILE *fp, PyObject *filename, PyCompilerFlags *flags)
     * }
     */
    public static int _PyRun_InteractiveLoopObject(MemorySegment fp, MemorySegment filename, MemorySegment flags) {
        var mh$ = _PyRun_InteractiveLoopObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyRun_InteractiveLoopObject", fp, filename, flags);
            }
            return (int)mh$.invokeExact(fp, filename, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyRun_StringFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyRun_StringFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyRun_StringFlags(const char *, int, PyObject *, PyObject *, PyCompilerFlags *)
     * }
     */
    public static FunctionDescriptor PyRun_StringFlags$descriptor() {
        return PyRun_StringFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyRun_StringFlags(const char *, int, PyObject *, PyObject *, PyCompilerFlags *)
     * }
     */
    public static MethodHandle PyRun_StringFlags$handle() {
        return PyRun_StringFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyRun_StringFlags(const char *, int, PyObject *, PyObject *, PyCompilerFlags *)
     * }
     */
    public static MemorySegment PyRun_StringFlags$address() {
        return PyRun_StringFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyRun_StringFlags(const char *, int, PyObject *, PyObject *, PyCompilerFlags *)
     * }
     */
    public static MemorySegment PyRun_StringFlags(MemorySegment x0, int x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PyRun_StringFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyRun_StringFlags", x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyRun_FileExFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyRun_FileExFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyRun_FileExFlags(FILE *fp, const char *filename, int start, PyObject *globals, PyObject *locals, int closeit, PyCompilerFlags *flags)
     * }
     */
    public static FunctionDescriptor PyRun_FileExFlags$descriptor() {
        return PyRun_FileExFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyRun_FileExFlags(FILE *fp, const char *filename, int start, PyObject *globals, PyObject *locals, int closeit, PyCompilerFlags *flags)
     * }
     */
    public static MethodHandle PyRun_FileExFlags$handle() {
        return PyRun_FileExFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyRun_FileExFlags(FILE *fp, const char *filename, int start, PyObject *globals, PyObject *locals, int closeit, PyCompilerFlags *flags)
     * }
     */
    public static MemorySegment PyRun_FileExFlags$address() {
        return PyRun_FileExFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyRun_FileExFlags(FILE *fp, const char *filename, int start, PyObject *globals, PyObject *locals, int closeit, PyCompilerFlags *flags)
     * }
     */
    public static MemorySegment PyRun_FileExFlags(MemorySegment fp, MemorySegment filename, int start, MemorySegment globals, MemorySegment locals, int closeit, MemorySegment flags) {
        var mh$ = PyRun_FileExFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyRun_FileExFlags", fp, filename, start, globals, locals, closeit, flags);
            }
            return (MemorySegment)mh$.invokeExact(fp, filename, start, globals, locals, closeit, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_CompileStringExFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_CompileStringExFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *Py_CompileStringExFlags(const char *str, const char *filename, int start, PyCompilerFlags *flags, int optimize)
     * }
     */
    public static FunctionDescriptor Py_CompileStringExFlags$descriptor() {
        return Py_CompileStringExFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *Py_CompileStringExFlags(const char *str, const char *filename, int start, PyCompilerFlags *flags, int optimize)
     * }
     */
    public static MethodHandle Py_CompileStringExFlags$handle() {
        return Py_CompileStringExFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *Py_CompileStringExFlags(const char *str, const char *filename, int start, PyCompilerFlags *flags, int optimize)
     * }
     */
    public static MemorySegment Py_CompileStringExFlags$address() {
        return Py_CompileStringExFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *Py_CompileStringExFlags(const char *str, const char *filename, int start, PyCompilerFlags *flags, int optimize)
     * }
     */
    public static MemorySegment Py_CompileStringExFlags(MemorySegment str, MemorySegment filename, int start, MemorySegment flags, int optimize) {
        var mh$ = Py_CompileStringExFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_CompileStringExFlags", str, filename, start, flags, optimize);
            }
            return (MemorySegment)mh$.invokeExact(str, filename, start, flags, optimize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_CompileStringObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_CompileStringObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *Py_CompileStringObject(const char *str, PyObject *filename, int start, PyCompilerFlags *flags, int optimize)
     * }
     */
    public static FunctionDescriptor Py_CompileStringObject$descriptor() {
        return Py_CompileStringObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *Py_CompileStringObject(const char *str, PyObject *filename, int start, PyCompilerFlags *flags, int optimize)
     * }
     */
    public static MethodHandle Py_CompileStringObject$handle() {
        return Py_CompileStringObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *Py_CompileStringObject(const char *str, PyObject *filename, int start, PyCompilerFlags *flags, int optimize)
     * }
     */
    public static MemorySegment Py_CompileStringObject$address() {
        return Py_CompileStringObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *Py_CompileStringObject(const char *str, PyObject *filename, int start, PyCompilerFlags *flags, int optimize)
     * }
     */
    public static MemorySegment Py_CompileStringObject(MemorySegment str, MemorySegment filename, int start, MemorySegment flags, int optimize) {
        var mh$ = Py_CompileStringObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_CompileStringObject", str, filename, start, flags, optimize);
            }
            return (MemorySegment)mh$.invokeExact(str, filename, start, flags, optimize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_SourceAsString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_SourceAsString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *_Py_SourceAsString(PyObject *cmd, const char *funcname, const char *what, PyCompilerFlags *cf, PyObject **cmd_copy)
     * }
     */
    public static FunctionDescriptor _Py_SourceAsString$descriptor() {
        return _Py_SourceAsString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *_Py_SourceAsString(PyObject *cmd, const char *funcname, const char *what, PyCompilerFlags *cf, PyObject **cmd_copy)
     * }
     */
    public static MethodHandle _Py_SourceAsString$handle() {
        return _Py_SourceAsString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *_Py_SourceAsString(PyObject *cmd, const char *funcname, const char *what, PyCompilerFlags *cf, PyObject **cmd_copy)
     * }
     */
    public static MemorySegment _Py_SourceAsString$address() {
        return _Py_SourceAsString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *_Py_SourceAsString(PyObject *cmd, const char *funcname, const char *what, PyCompilerFlags *cf, PyObject **cmd_copy)
     * }
     */
    public static MemorySegment _Py_SourceAsString(MemorySegment cmd, MemorySegment funcname, MemorySegment what, MemorySegment cf, MemorySegment cmd_copy) {
        var mh$ = _Py_SourceAsString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_SourceAsString", cmd, funcname, what, cf, cmd_copy);
            }
            return (MemorySegment)mh$.invokeExact(cmd, funcname, what, cf, cmd_copy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyRun_String {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyRun_String");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyRun_String(const char *str, int s, PyObject *g, PyObject *l)
     * }
     */
    public static FunctionDescriptor PyRun_String$descriptor() {
        return PyRun_String.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyRun_String(const char *str, int s, PyObject *g, PyObject *l)
     * }
     */
    public static MethodHandle PyRun_String$handle() {
        return PyRun_String.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyRun_String(const char *str, int s, PyObject *g, PyObject *l)
     * }
     */
    public static MemorySegment PyRun_String$address() {
        return PyRun_String.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyRun_String(const char *str, int s, PyObject *g, PyObject *l)
     * }
     */
    public static MemorySegment PyRun_String(MemorySegment str, int s, MemorySegment g, MemorySegment l) {
        var mh$ = PyRun_String.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyRun_String", str, s, g, l);
            }
            return (MemorySegment)mh$.invokeExact(str, s, g, l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyRun_AnyFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyRun_AnyFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyRun_AnyFile(FILE *fp, const char *name)
     * }
     */
    public static FunctionDescriptor PyRun_AnyFile$descriptor() {
        return PyRun_AnyFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyRun_AnyFile(FILE *fp, const char *name)
     * }
     */
    public static MethodHandle PyRun_AnyFile$handle() {
        return PyRun_AnyFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyRun_AnyFile(FILE *fp, const char *name)
     * }
     */
    public static MemorySegment PyRun_AnyFile$address() {
        return PyRun_AnyFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyRun_AnyFile(FILE *fp, const char *name)
     * }
     */
    public static int PyRun_AnyFile(MemorySegment fp, MemorySegment name) {
        var mh$ = PyRun_AnyFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyRun_AnyFile", fp, name);
            }
            return (int)mh$.invokeExact(fp, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyRun_AnyFileEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyRun_AnyFileEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyRun_AnyFileEx(FILE *fp, const char *name, int closeit)
     * }
     */
    public static FunctionDescriptor PyRun_AnyFileEx$descriptor() {
        return PyRun_AnyFileEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyRun_AnyFileEx(FILE *fp, const char *name, int closeit)
     * }
     */
    public static MethodHandle PyRun_AnyFileEx$handle() {
        return PyRun_AnyFileEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyRun_AnyFileEx(FILE *fp, const char *name, int closeit)
     * }
     */
    public static MemorySegment PyRun_AnyFileEx$address() {
        return PyRun_AnyFileEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyRun_AnyFileEx(FILE *fp, const char *name, int closeit)
     * }
     */
    public static int PyRun_AnyFileEx(MemorySegment fp, MemorySegment name, int closeit) {
        var mh$ = PyRun_AnyFileEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyRun_AnyFileEx", fp, name, closeit);
            }
            return (int)mh$.invokeExact(fp, name, closeit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyRun_AnyFileFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyRun_AnyFileFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyRun_AnyFileFlags(FILE *, const char *, PyCompilerFlags *)
     * }
     */
    public static FunctionDescriptor PyRun_AnyFileFlags$descriptor() {
        return PyRun_AnyFileFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyRun_AnyFileFlags(FILE *, const char *, PyCompilerFlags *)
     * }
     */
    public static MethodHandle PyRun_AnyFileFlags$handle() {
        return PyRun_AnyFileFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyRun_AnyFileFlags(FILE *, const char *, PyCompilerFlags *)
     * }
     */
    public static MemorySegment PyRun_AnyFileFlags$address() {
        return PyRun_AnyFileFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyRun_AnyFileFlags(FILE *, const char *, PyCompilerFlags *)
     * }
     */
    public static int PyRun_AnyFileFlags(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyRun_AnyFileFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyRun_AnyFileFlags", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyRun_SimpleString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyRun_SimpleString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyRun_SimpleString(const char *s)
     * }
     */
    public static FunctionDescriptor PyRun_SimpleString$descriptor() {
        return PyRun_SimpleString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyRun_SimpleString(const char *s)
     * }
     */
    public static MethodHandle PyRun_SimpleString$handle() {
        return PyRun_SimpleString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyRun_SimpleString(const char *s)
     * }
     */
    public static MemorySegment PyRun_SimpleString$address() {
        return PyRun_SimpleString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyRun_SimpleString(const char *s)
     * }
     */
    public static int PyRun_SimpleString(MemorySegment s) {
        var mh$ = PyRun_SimpleString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyRun_SimpleString", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyRun_SimpleFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyRun_SimpleFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyRun_SimpleFile(FILE *f, const char *p)
     * }
     */
    public static FunctionDescriptor PyRun_SimpleFile$descriptor() {
        return PyRun_SimpleFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyRun_SimpleFile(FILE *f, const char *p)
     * }
     */
    public static MethodHandle PyRun_SimpleFile$handle() {
        return PyRun_SimpleFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyRun_SimpleFile(FILE *f, const char *p)
     * }
     */
    public static MemorySegment PyRun_SimpleFile$address() {
        return PyRun_SimpleFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyRun_SimpleFile(FILE *f, const char *p)
     * }
     */
    public static int PyRun_SimpleFile(MemorySegment f, MemorySegment p) {
        var mh$ = PyRun_SimpleFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyRun_SimpleFile", f, p);
            }
            return (int)mh$.invokeExact(f, p);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyRun_SimpleFileEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyRun_SimpleFileEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyRun_SimpleFileEx(FILE *f, const char *p, int c)
     * }
     */
    public static FunctionDescriptor PyRun_SimpleFileEx$descriptor() {
        return PyRun_SimpleFileEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyRun_SimpleFileEx(FILE *f, const char *p, int c)
     * }
     */
    public static MethodHandle PyRun_SimpleFileEx$handle() {
        return PyRun_SimpleFileEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyRun_SimpleFileEx(FILE *f, const char *p, int c)
     * }
     */
    public static MemorySegment PyRun_SimpleFileEx$address() {
        return PyRun_SimpleFileEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyRun_SimpleFileEx(FILE *f, const char *p, int c)
     * }
     */
    public static int PyRun_SimpleFileEx(MemorySegment f, MemorySegment p, int c) {
        var mh$ = PyRun_SimpleFileEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyRun_SimpleFileEx", f, p, c);
            }
            return (int)mh$.invokeExact(f, p, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyRun_InteractiveOne {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyRun_InteractiveOne");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyRun_InteractiveOne(FILE *f, const char *p)
     * }
     */
    public static FunctionDescriptor PyRun_InteractiveOne$descriptor() {
        return PyRun_InteractiveOne.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyRun_InteractiveOne(FILE *f, const char *p)
     * }
     */
    public static MethodHandle PyRun_InteractiveOne$handle() {
        return PyRun_InteractiveOne.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyRun_InteractiveOne(FILE *f, const char *p)
     * }
     */
    public static MemorySegment PyRun_InteractiveOne$address() {
        return PyRun_InteractiveOne.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyRun_InteractiveOne(FILE *f, const char *p)
     * }
     */
    public static int PyRun_InteractiveOne(MemorySegment f, MemorySegment p) {
        var mh$ = PyRun_InteractiveOne.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyRun_InteractiveOne", f, p);
            }
            return (int)mh$.invokeExact(f, p);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyRun_InteractiveLoop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyRun_InteractiveLoop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyRun_InteractiveLoop(FILE *f, const char *p)
     * }
     */
    public static FunctionDescriptor PyRun_InteractiveLoop$descriptor() {
        return PyRun_InteractiveLoop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyRun_InteractiveLoop(FILE *f, const char *p)
     * }
     */
    public static MethodHandle PyRun_InteractiveLoop$handle() {
        return PyRun_InteractiveLoop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyRun_InteractiveLoop(FILE *f, const char *p)
     * }
     */
    public static MemorySegment PyRun_InteractiveLoop$address() {
        return PyRun_InteractiveLoop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyRun_InteractiveLoop(FILE *f, const char *p)
     * }
     */
    public static int PyRun_InteractiveLoop(MemorySegment f, MemorySegment p) {
        var mh$ = PyRun_InteractiveLoop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyRun_InteractiveLoop", f, p);
            }
            return (int)mh$.invokeExact(f, p);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyRun_File {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyRun_File");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyRun_File(FILE *fp, const char *p, int s, PyObject *g, PyObject *l)
     * }
     */
    public static FunctionDescriptor PyRun_File$descriptor() {
        return PyRun_File.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyRun_File(FILE *fp, const char *p, int s, PyObject *g, PyObject *l)
     * }
     */
    public static MethodHandle PyRun_File$handle() {
        return PyRun_File.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyRun_File(FILE *fp, const char *p, int s, PyObject *g, PyObject *l)
     * }
     */
    public static MemorySegment PyRun_File$address() {
        return PyRun_File.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyRun_File(FILE *fp, const char *p, int s, PyObject *g, PyObject *l)
     * }
     */
    public static MemorySegment PyRun_File(MemorySegment fp, MemorySegment p, int s, MemorySegment g, MemorySegment l) {
        var mh$ = PyRun_File.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyRun_File", fp, p, s, g, l);
            }
            return (MemorySegment)mh$.invokeExact(fp, p, s, g, l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyRun_FileEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyRun_FileEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyRun_FileEx(FILE *fp, const char *p, int s, PyObject *g, PyObject *l, int c)
     * }
     */
    public static FunctionDescriptor PyRun_FileEx$descriptor() {
        return PyRun_FileEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyRun_FileEx(FILE *fp, const char *p, int s, PyObject *g, PyObject *l, int c)
     * }
     */
    public static MethodHandle PyRun_FileEx$handle() {
        return PyRun_FileEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyRun_FileEx(FILE *fp, const char *p, int s, PyObject *g, PyObject *l, int c)
     * }
     */
    public static MemorySegment PyRun_FileEx$address() {
        return PyRun_FileEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyRun_FileEx(FILE *fp, const char *p, int s, PyObject *g, PyObject *l, int c)
     * }
     */
    public static MemorySegment PyRun_FileEx(MemorySegment fp, MemorySegment p, int s, MemorySegment g, MemorySegment l, int c) {
        var mh$ = PyRun_FileEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyRun_FileEx", fp, p, s, g, l, c);
            }
            return (MemorySegment)mh$.invokeExact(fp, p, s, g, l, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyRun_FileFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyRun_FileFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyRun_FileFlags(FILE *fp, const char *p, int s, PyObject *g, PyObject *l, PyCompilerFlags *flags)
     * }
     */
    public static FunctionDescriptor PyRun_FileFlags$descriptor() {
        return PyRun_FileFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyRun_FileFlags(FILE *fp, const char *p, int s, PyObject *g, PyObject *l, PyCompilerFlags *flags)
     * }
     */
    public static MethodHandle PyRun_FileFlags$handle() {
        return PyRun_FileFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyRun_FileFlags(FILE *fp, const char *p, int s, PyObject *g, PyObject *l, PyCompilerFlags *flags)
     * }
     */
    public static MemorySegment PyRun_FileFlags$address() {
        return PyRun_FileFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyRun_FileFlags(FILE *fp, const char *p, int s, PyObject *g, PyObject *l, PyCompilerFlags *flags)
     * }
     */
    public static MemorySegment PyRun_FileFlags(MemorySegment fp, MemorySegment p, int s, MemorySegment g, MemorySegment l, MemorySegment flags) {
        var mh$ = PyRun_FileFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyRun_FileFlags", fp, p, s, g, l, flags);
            }
            return (MemorySegment)mh$.invokeExact(fp, p, s, g, l, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyOS_Readline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyOS_Readline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *PyOS_Readline(FILE *, FILE *, const char *)
     * }
     */
    public static FunctionDescriptor PyOS_Readline$descriptor() {
        return PyOS_Readline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *PyOS_Readline(FILE *, FILE *, const char *)
     * }
     */
    public static MethodHandle PyOS_Readline$handle() {
        return PyOS_Readline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *PyOS_Readline(FILE *, FILE *, const char *)
     * }
     */
    public static MemorySegment PyOS_Readline$address() {
        return PyOS_Readline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *PyOS_Readline(FILE *, FILE *, const char *)
     * }
     */
    public static MemorySegment PyOS_Readline(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyOS_Readline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyOS_Readline", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyOS_ReadlineTState$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_PyOS_ReadlineTState").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyThreadState *_PyOS_ReadlineTState
     * }
     */
    public static AddressLayout _PyOS_ReadlineTState$layout() {
        return _PyOS_ReadlineTState$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern PyThreadState *_PyOS_ReadlineTState
     * }
     */
    public static MemorySegment _PyOS_ReadlineTState$segment() {
        return _PyOS_ReadlineTState$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyThreadState *_PyOS_ReadlineTState
     * }
     */
    public static MemorySegment _PyOS_ReadlineTState() {
        return _PyOS_ReadlineTState$constants.SEGMENT.get(_PyOS_ReadlineTState$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyThreadState *_PyOS_ReadlineTState
     * }
     */
    public static void _PyOS_ReadlineTState(MemorySegment varValue) {
        _PyOS_ReadlineTState$constants.SEGMENT.set(_PyOS_ReadlineTState$constants.LAYOUT, 0L, varValue);
    }

    private static class PyOS_ReadlineFunctionPointer$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyOS_ReadlineFunctionPointer").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *(*PyOS_ReadlineFunctionPointer)(FILE *, FILE *, const char *)
     * }
     */
    public static AddressLayout PyOS_ReadlineFunctionPointer$layout() {
        return PyOS_ReadlineFunctionPointer$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern char *(*PyOS_ReadlineFunctionPointer)(FILE *, FILE *, const char *)
     * }
     */
    public static MemorySegment PyOS_ReadlineFunctionPointer$segment() {
        return PyOS_ReadlineFunctionPointer$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *(*PyOS_ReadlineFunctionPointer)(FILE *, FILE *, const char *)
     * }
     */
    public static MemorySegment PyOS_ReadlineFunctionPointer() {
        return PyOS_ReadlineFunctionPointer$constants.SEGMENT.get(PyOS_ReadlineFunctionPointer$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *(*PyOS_ReadlineFunctionPointer)(FILE *, FILE *, const char *)
     * }
     */
    public static void PyOS_ReadlineFunctionPointer(MemorySegment varValue) {
        PyOS_ReadlineFunctionPointer$constants.SEGMENT.set(PyOS_ReadlineFunctionPointer$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_Initialize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_Initialize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_Initialize()
     * }
     */
    public static FunctionDescriptor Py_Initialize$descriptor() {
        return Py_Initialize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_Initialize()
     * }
     */
    public static MethodHandle Py_Initialize$handle() {
        return Py_Initialize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_Initialize()
     * }
     */
    public static MemorySegment Py_Initialize$address() {
        return Py_Initialize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_Initialize()
     * }
     */
    public static void Py_Initialize() {
        var mh$ = Py_Initialize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_Initialize");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_InitializeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_InitializeEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_InitializeEx(int)
     * }
     */
    public static FunctionDescriptor Py_InitializeEx$descriptor() {
        return Py_InitializeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_InitializeEx(int)
     * }
     */
    public static MethodHandle Py_InitializeEx$handle() {
        return Py_InitializeEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_InitializeEx(int)
     * }
     */
    public static MemorySegment Py_InitializeEx$address() {
        return Py_InitializeEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_InitializeEx(int)
     * }
     */
    public static void Py_InitializeEx(int x0) {
        var mh$ = Py_InitializeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_InitializeEx", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_Finalize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_Finalize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_Finalize()
     * }
     */
    public static FunctionDescriptor Py_Finalize$descriptor() {
        return Py_Finalize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_Finalize()
     * }
     */
    public static MethodHandle Py_Finalize$handle() {
        return Py_Finalize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_Finalize()
     * }
     */
    public static MemorySegment Py_Finalize$address() {
        return Py_Finalize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_Finalize()
     * }
     */
    public static void Py_Finalize() {
        var mh$ = Py_Finalize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_Finalize");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_FinalizeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_FinalizeEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_FinalizeEx()
     * }
     */
    public static FunctionDescriptor Py_FinalizeEx$descriptor() {
        return Py_FinalizeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_FinalizeEx()
     * }
     */
    public static MethodHandle Py_FinalizeEx$handle() {
        return Py_FinalizeEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_FinalizeEx()
     * }
     */
    public static MemorySegment Py_FinalizeEx$address() {
        return Py_FinalizeEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_FinalizeEx()
     * }
     */
    public static int Py_FinalizeEx() {
        var mh$ = Py_FinalizeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_FinalizeEx");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_IsInitialized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_IsInitialized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_IsInitialized()
     * }
     */
    public static FunctionDescriptor Py_IsInitialized$descriptor() {
        return Py_IsInitialized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_IsInitialized()
     * }
     */
    public static MethodHandle Py_IsInitialized$handle() {
        return Py_IsInitialized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_IsInitialized()
     * }
     */
    public static MemorySegment Py_IsInitialized$address() {
        return Py_IsInitialized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_IsInitialized()
     * }
     */
    public static int Py_IsInitialized() {
        var mh$ = Py_IsInitialized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_IsInitialized");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_NewInterpreter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_NewInterpreter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyThreadState *Py_NewInterpreter()
     * }
     */
    public static FunctionDescriptor Py_NewInterpreter$descriptor() {
        return Py_NewInterpreter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyThreadState *Py_NewInterpreter()
     * }
     */
    public static MethodHandle Py_NewInterpreter$handle() {
        return Py_NewInterpreter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyThreadState *Py_NewInterpreter()
     * }
     */
    public static MemorySegment Py_NewInterpreter$address() {
        return Py_NewInterpreter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyThreadState *Py_NewInterpreter()
     * }
     */
    public static MemorySegment Py_NewInterpreter() {
        var mh$ = Py_NewInterpreter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_NewInterpreter");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_EndInterpreter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_EndInterpreter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_EndInterpreter(PyThreadState *)
     * }
     */
    public static FunctionDescriptor Py_EndInterpreter$descriptor() {
        return Py_EndInterpreter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_EndInterpreter(PyThreadState *)
     * }
     */
    public static MethodHandle Py_EndInterpreter$handle() {
        return Py_EndInterpreter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_EndInterpreter(PyThreadState *)
     * }
     */
    public static MemorySegment Py_EndInterpreter$address() {
        return Py_EndInterpreter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_EndInterpreter(PyThreadState *)
     * }
     */
    public static void Py_EndInterpreter(MemorySegment x0) {
        var mh$ = Py_EndInterpreter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_EndInterpreter", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_AtExit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_AtExit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_AtExit(void (*func)(void))
     * }
     */
    public static FunctionDescriptor Py_AtExit$descriptor() {
        return Py_AtExit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_AtExit(void (*func)(void))
     * }
     */
    public static MethodHandle Py_AtExit$handle() {
        return Py_AtExit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_AtExit(void (*func)(void))
     * }
     */
    public static MemorySegment Py_AtExit$address() {
        return Py_AtExit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_AtExit(void (*func)(void))
     * }
     */
    public static int Py_AtExit(MemorySegment func) {
        var mh$ = Py_AtExit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_AtExit", func);
            }
            return (int)mh$.invokeExact(func);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_Exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_Exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_Exit(int)
     * }
     */
    public static FunctionDescriptor Py_Exit$descriptor() {
        return Py_Exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_Exit(int)
     * }
     */
    public static MethodHandle Py_Exit$handle() {
        return Py_Exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_Exit(int)
     * }
     */
    public static MemorySegment Py_Exit$address() {
        return Py_Exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_Exit(int)
     * }
     */
    public static void Py_Exit(int x0) {
        var mh$ = Py_Exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_Exit", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_Main {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_Main");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_Main(int argc, wchar_t **argv)
     * }
     */
    public static FunctionDescriptor Py_Main$descriptor() {
        return Py_Main.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_Main(int argc, wchar_t **argv)
     * }
     */
    public static MethodHandle Py_Main$handle() {
        return Py_Main.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_Main(int argc, wchar_t **argv)
     * }
     */
    public static MemorySegment Py_Main$address() {
        return Py_Main.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_Main(int argc, wchar_t **argv)
     * }
     */
    public static int Py_Main(int argc, MemorySegment argv) {
        var mh$ = Py_Main.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_Main", argc, argv);
            }
            return (int)mh$.invokeExact(argc, argv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_BytesMain {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_BytesMain");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_BytesMain(int argc, char **argv)
     * }
     */
    public static FunctionDescriptor Py_BytesMain$descriptor() {
        return Py_BytesMain.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_BytesMain(int argc, char **argv)
     * }
     */
    public static MethodHandle Py_BytesMain$handle() {
        return Py_BytesMain.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_BytesMain(int argc, char **argv)
     * }
     */
    public static MemorySegment Py_BytesMain$address() {
        return Py_BytesMain.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_BytesMain(int argc, char **argv)
     * }
     */
    public static int Py_BytesMain(int argc, MemorySegment argv) {
        var mh$ = Py_BytesMain.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_BytesMain", argc, argv);
            }
            return (int)mh$.invokeExact(argc, argv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_SetProgramName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_SetProgramName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_SetProgramName(const wchar_t *)
     * }
     */
    public static FunctionDescriptor Py_SetProgramName$descriptor() {
        return Py_SetProgramName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_SetProgramName(const wchar_t *)
     * }
     */
    public static MethodHandle Py_SetProgramName$handle() {
        return Py_SetProgramName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_SetProgramName(const wchar_t *)
     * }
     */
    public static MemorySegment Py_SetProgramName$address() {
        return Py_SetProgramName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_SetProgramName(const wchar_t *)
     * }
     */
    public static void Py_SetProgramName(MemorySegment x0) {
        var mh$ = Py_SetProgramName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_SetProgramName", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_GetProgramName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_GetProgramName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *Py_GetProgramName()
     * }
     */
    public static FunctionDescriptor Py_GetProgramName$descriptor() {
        return Py_GetProgramName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *Py_GetProgramName()
     * }
     */
    public static MethodHandle Py_GetProgramName$handle() {
        return Py_GetProgramName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *Py_GetProgramName()
     * }
     */
    public static MemorySegment Py_GetProgramName$address() {
        return Py_GetProgramName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *Py_GetProgramName()
     * }
     */
    public static MemorySegment Py_GetProgramName() {
        var mh$ = Py_GetProgramName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_GetProgramName");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_SetPythonHome {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_SetPythonHome");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_SetPythonHome(const wchar_t *)
     * }
     */
    public static FunctionDescriptor Py_SetPythonHome$descriptor() {
        return Py_SetPythonHome.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_SetPythonHome(const wchar_t *)
     * }
     */
    public static MethodHandle Py_SetPythonHome$handle() {
        return Py_SetPythonHome.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_SetPythonHome(const wchar_t *)
     * }
     */
    public static MemorySegment Py_SetPythonHome$address() {
        return Py_SetPythonHome.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_SetPythonHome(const wchar_t *)
     * }
     */
    public static void Py_SetPythonHome(MemorySegment x0) {
        var mh$ = Py_SetPythonHome.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_SetPythonHome", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_GetPythonHome {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_GetPythonHome");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *Py_GetPythonHome()
     * }
     */
    public static FunctionDescriptor Py_GetPythonHome$descriptor() {
        return Py_GetPythonHome.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *Py_GetPythonHome()
     * }
     */
    public static MethodHandle Py_GetPythonHome$handle() {
        return Py_GetPythonHome.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *Py_GetPythonHome()
     * }
     */
    public static MemorySegment Py_GetPythonHome$address() {
        return Py_GetPythonHome.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *Py_GetPythonHome()
     * }
     */
    public static MemorySegment Py_GetPythonHome() {
        var mh$ = Py_GetPythonHome.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_GetPythonHome");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_GetProgramFullPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_GetProgramFullPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *Py_GetProgramFullPath()
     * }
     */
    public static FunctionDescriptor Py_GetProgramFullPath$descriptor() {
        return Py_GetProgramFullPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *Py_GetProgramFullPath()
     * }
     */
    public static MethodHandle Py_GetProgramFullPath$handle() {
        return Py_GetProgramFullPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *Py_GetProgramFullPath()
     * }
     */
    public static MemorySegment Py_GetProgramFullPath$address() {
        return Py_GetProgramFullPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *Py_GetProgramFullPath()
     * }
     */
    public static MemorySegment Py_GetProgramFullPath() {
        var mh$ = Py_GetProgramFullPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_GetProgramFullPath");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_GetPrefix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_GetPrefix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *Py_GetPrefix()
     * }
     */
    public static FunctionDescriptor Py_GetPrefix$descriptor() {
        return Py_GetPrefix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *Py_GetPrefix()
     * }
     */
    public static MethodHandle Py_GetPrefix$handle() {
        return Py_GetPrefix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *Py_GetPrefix()
     * }
     */
    public static MemorySegment Py_GetPrefix$address() {
        return Py_GetPrefix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *Py_GetPrefix()
     * }
     */
    public static MemorySegment Py_GetPrefix() {
        var mh$ = Py_GetPrefix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_GetPrefix");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_GetExecPrefix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_GetExecPrefix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *Py_GetExecPrefix()
     * }
     */
    public static FunctionDescriptor Py_GetExecPrefix$descriptor() {
        return Py_GetExecPrefix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *Py_GetExecPrefix()
     * }
     */
    public static MethodHandle Py_GetExecPrefix$handle() {
        return Py_GetExecPrefix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *Py_GetExecPrefix()
     * }
     */
    public static MemorySegment Py_GetExecPrefix$address() {
        return Py_GetExecPrefix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *Py_GetExecPrefix()
     * }
     */
    public static MemorySegment Py_GetExecPrefix() {
        var mh$ = Py_GetExecPrefix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_GetExecPrefix");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_GetPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_GetPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *Py_GetPath()
     * }
     */
    public static FunctionDescriptor Py_GetPath$descriptor() {
        return Py_GetPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *Py_GetPath()
     * }
     */
    public static MethodHandle Py_GetPath$handle() {
        return Py_GetPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *Py_GetPath()
     * }
     */
    public static MemorySegment Py_GetPath$address() {
        return Py_GetPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *Py_GetPath()
     * }
     */
    public static MemorySegment Py_GetPath() {
        var mh$ = Py_GetPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_GetPath");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_SetPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_SetPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_SetPath(const wchar_t *)
     * }
     */
    public static FunctionDescriptor Py_SetPath$descriptor() {
        return Py_SetPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_SetPath(const wchar_t *)
     * }
     */
    public static MethodHandle Py_SetPath$handle() {
        return Py_SetPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_SetPath(const wchar_t *)
     * }
     */
    public static MemorySegment Py_SetPath$address() {
        return Py_SetPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_SetPath(const wchar_t *)
     * }
     */
    public static void Py_SetPath(MemorySegment x0) {
        var mh$ = Py_SetPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_SetPath", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_GetVersion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_GetVersion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *Py_GetVersion()
     * }
     */
    public static FunctionDescriptor Py_GetVersion$descriptor() {
        return Py_GetVersion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *Py_GetVersion()
     * }
     */
    public static MethodHandle Py_GetVersion$handle() {
        return Py_GetVersion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *Py_GetVersion()
     * }
     */
    public static MemorySegment Py_GetVersion$address() {
        return Py_GetVersion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *Py_GetVersion()
     * }
     */
    public static MemorySegment Py_GetVersion() {
        var mh$ = Py_GetVersion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_GetVersion");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_GetPlatform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_GetPlatform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *Py_GetPlatform()
     * }
     */
    public static FunctionDescriptor Py_GetPlatform$descriptor() {
        return Py_GetPlatform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *Py_GetPlatform()
     * }
     */
    public static MethodHandle Py_GetPlatform$handle() {
        return Py_GetPlatform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *Py_GetPlatform()
     * }
     */
    public static MemorySegment Py_GetPlatform$address() {
        return Py_GetPlatform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *Py_GetPlatform()
     * }
     */
    public static MemorySegment Py_GetPlatform() {
        var mh$ = Py_GetPlatform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_GetPlatform");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_GetCopyright {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_GetCopyright");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *Py_GetCopyright()
     * }
     */
    public static FunctionDescriptor Py_GetCopyright$descriptor() {
        return Py_GetCopyright.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *Py_GetCopyright()
     * }
     */
    public static MethodHandle Py_GetCopyright$handle() {
        return Py_GetCopyright.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *Py_GetCopyright()
     * }
     */
    public static MemorySegment Py_GetCopyright$address() {
        return Py_GetCopyright.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *Py_GetCopyright()
     * }
     */
    public static MemorySegment Py_GetCopyright() {
        var mh$ = Py_GetCopyright.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_GetCopyright");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_GetCompiler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_GetCompiler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *Py_GetCompiler()
     * }
     */
    public static FunctionDescriptor Py_GetCompiler$descriptor() {
        return Py_GetCompiler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *Py_GetCompiler()
     * }
     */
    public static MethodHandle Py_GetCompiler$handle() {
        return Py_GetCompiler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *Py_GetCompiler()
     * }
     */
    public static MemorySegment Py_GetCompiler$address() {
        return Py_GetCompiler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *Py_GetCompiler()
     * }
     */
    public static MemorySegment Py_GetCompiler() {
        var mh$ = Py_GetCompiler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_GetCompiler");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_GetBuildInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_GetBuildInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *Py_GetBuildInfo()
     * }
     */
    public static FunctionDescriptor Py_GetBuildInfo$descriptor() {
        return Py_GetBuildInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *Py_GetBuildInfo()
     * }
     */
    public static MethodHandle Py_GetBuildInfo$handle() {
        return Py_GetBuildInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *Py_GetBuildInfo()
     * }
     */
    public static MemorySegment Py_GetBuildInfo$address() {
        return Py_GetBuildInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *Py_GetBuildInfo()
     * }
     */
    public static MemorySegment Py_GetBuildInfo() {
        var mh$ = Py_GetBuildInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_GetBuildInfo");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyOS_getsig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyOS_getsig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyOS_sighandler_t PyOS_getsig(int)
     * }
     */
    public static FunctionDescriptor PyOS_getsig$descriptor() {
        return PyOS_getsig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyOS_sighandler_t PyOS_getsig(int)
     * }
     */
    public static MethodHandle PyOS_getsig$handle() {
        return PyOS_getsig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyOS_sighandler_t PyOS_getsig(int)
     * }
     */
    public static MemorySegment PyOS_getsig$address() {
        return PyOS_getsig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyOS_sighandler_t PyOS_getsig(int)
     * }
     */
    public static MemorySegment PyOS_getsig(int x0) {
        var mh$ = PyOS_getsig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyOS_getsig", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyOS_setsig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyOS_setsig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyOS_sighandler_t PyOS_setsig(int, PyOS_sighandler_t)
     * }
     */
    public static FunctionDescriptor PyOS_setsig$descriptor() {
        return PyOS_setsig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyOS_sighandler_t PyOS_setsig(int, PyOS_sighandler_t)
     * }
     */
    public static MethodHandle PyOS_setsig$handle() {
        return PyOS_setsig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyOS_sighandler_t PyOS_setsig(int, PyOS_sighandler_t)
     * }
     */
    public static MemorySegment PyOS_setsig$address() {
        return PyOS_setsig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyOS_sighandler_t PyOS_setsig(int, PyOS_sighandler_t)
     * }
     */
    public static MemorySegment PyOS_setsig(int x0, MemorySegment x1) {
        var mh$ = PyOS_setsig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyOS_setsig", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_Version$constants {
        public static final OfLong LAYOUT = Python_h.C_LONG;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_Version").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const unsigned long Py_Version
     * }
     */
    public static OfLong Py_Version$layout() {
        return Py_Version$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const unsigned long Py_Version
     * }
     */
    public static MemorySegment Py_Version$segment() {
        return Py_Version$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const unsigned long Py_Version
     * }
     */
    public static long Py_Version() {
        return Py_Version$constants.SEGMENT.get(Py_Version$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const unsigned long Py_Version
     * }
     */
    public static void Py_Version(long varValue) {
        Py_Version$constants.SEGMENT.set(Py_Version$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_FrozenMain {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_FrozenMain");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_FrozenMain(int argc, char **argv)
     * }
     */
    public static FunctionDescriptor Py_FrozenMain$descriptor() {
        return Py_FrozenMain.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_FrozenMain(int argc, char **argv)
     * }
     */
    public static MethodHandle Py_FrozenMain$handle() {
        return Py_FrozenMain.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_FrozenMain(int argc, char **argv)
     * }
     */
    public static MemorySegment Py_FrozenMain$address() {
        return Py_FrozenMain.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_FrozenMain(int argc, char **argv)
     * }
     */
    public static int Py_FrozenMain(int argc, MemorySegment argv) {
        var mh$ = Py_FrozenMain.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_FrozenMain", argc, argv);
            }
            return (int)mh$.invokeExact(argc, argv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_SetStandardStreamEncoding {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_SetStandardStreamEncoding");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_SetStandardStreamEncoding(const char *encoding, const char *errors)
     * }
     */
    public static FunctionDescriptor Py_SetStandardStreamEncoding$descriptor() {
        return Py_SetStandardStreamEncoding.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_SetStandardStreamEncoding(const char *encoding, const char *errors)
     * }
     */
    public static MethodHandle Py_SetStandardStreamEncoding$handle() {
        return Py_SetStandardStreamEncoding.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_SetStandardStreamEncoding(const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment Py_SetStandardStreamEncoding$address() {
        return Py_SetStandardStreamEncoding.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_SetStandardStreamEncoding(const char *encoding, const char *errors)
     * }
     */
    public static int Py_SetStandardStreamEncoding(MemorySegment encoding, MemorySegment errors) {
        var mh$ = Py_SetStandardStreamEncoding.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_SetStandardStreamEncoding", encoding, errors);
            }
            return (int)mh$.invokeExact(encoding, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_PreInitialize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PyStatus.layout(),
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_PreInitialize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyStatus Py_PreInitialize(const PyPreConfig *src_config)
     * }
     */
    public static FunctionDescriptor Py_PreInitialize$descriptor() {
        return Py_PreInitialize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyStatus Py_PreInitialize(const PyPreConfig *src_config)
     * }
     */
    public static MethodHandle Py_PreInitialize$handle() {
        return Py_PreInitialize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyStatus Py_PreInitialize(const PyPreConfig *src_config)
     * }
     */
    public static MemorySegment Py_PreInitialize$address() {
        return Py_PreInitialize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyStatus Py_PreInitialize(const PyPreConfig *src_config)
     * }
     */
    public static MemorySegment Py_PreInitialize(SegmentAllocator allocator, MemorySegment src_config) {
        var mh$ = Py_PreInitialize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_PreInitialize", allocator, src_config);
            }
            return (MemorySegment)mh$.invokeExact(allocator, src_config);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_PreInitializeFromBytesArgs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PyStatus.layout(),
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_PreInitializeFromBytesArgs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyStatus Py_PreInitializeFromBytesArgs(const PyPreConfig *src_config, Py_ssize_t argc, char **argv)
     * }
     */
    public static FunctionDescriptor Py_PreInitializeFromBytesArgs$descriptor() {
        return Py_PreInitializeFromBytesArgs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyStatus Py_PreInitializeFromBytesArgs(const PyPreConfig *src_config, Py_ssize_t argc, char **argv)
     * }
     */
    public static MethodHandle Py_PreInitializeFromBytesArgs$handle() {
        return Py_PreInitializeFromBytesArgs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyStatus Py_PreInitializeFromBytesArgs(const PyPreConfig *src_config, Py_ssize_t argc, char **argv)
     * }
     */
    public static MemorySegment Py_PreInitializeFromBytesArgs$address() {
        return Py_PreInitializeFromBytesArgs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyStatus Py_PreInitializeFromBytesArgs(const PyPreConfig *src_config, Py_ssize_t argc, char **argv)
     * }
     */
    public static MemorySegment Py_PreInitializeFromBytesArgs(SegmentAllocator allocator, MemorySegment src_config, long argc, MemorySegment argv) {
        var mh$ = Py_PreInitializeFromBytesArgs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_PreInitializeFromBytesArgs", allocator, src_config, argc, argv);
            }
            return (MemorySegment)mh$.invokeExact(allocator, src_config, argc, argv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_PreInitializeFromArgs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PyStatus.layout(),
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_PreInitializeFromArgs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyStatus Py_PreInitializeFromArgs(const PyPreConfig *src_config, Py_ssize_t argc, wchar_t **argv)
     * }
     */
    public static FunctionDescriptor Py_PreInitializeFromArgs$descriptor() {
        return Py_PreInitializeFromArgs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyStatus Py_PreInitializeFromArgs(const PyPreConfig *src_config, Py_ssize_t argc, wchar_t **argv)
     * }
     */
    public static MethodHandle Py_PreInitializeFromArgs$handle() {
        return Py_PreInitializeFromArgs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyStatus Py_PreInitializeFromArgs(const PyPreConfig *src_config, Py_ssize_t argc, wchar_t **argv)
     * }
     */
    public static MemorySegment Py_PreInitializeFromArgs$address() {
        return Py_PreInitializeFromArgs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyStatus Py_PreInitializeFromArgs(const PyPreConfig *src_config, Py_ssize_t argc, wchar_t **argv)
     * }
     */
    public static MemorySegment Py_PreInitializeFromArgs(SegmentAllocator allocator, MemorySegment src_config, long argc, MemorySegment argv) {
        var mh$ = Py_PreInitializeFromArgs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_PreInitializeFromArgs", allocator, src_config, argc, argv);
            }
            return (MemorySegment)mh$.invokeExact(allocator, src_config, argc, argv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_IsCoreInitialized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_IsCoreInitialized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _Py_IsCoreInitialized()
     * }
     */
    public static FunctionDescriptor _Py_IsCoreInitialized$descriptor() {
        return _Py_IsCoreInitialized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _Py_IsCoreInitialized()
     * }
     */
    public static MethodHandle _Py_IsCoreInitialized$handle() {
        return _Py_IsCoreInitialized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _Py_IsCoreInitialized()
     * }
     */
    public static MemorySegment _Py_IsCoreInitialized$address() {
        return _Py_IsCoreInitialized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _Py_IsCoreInitialized()
     * }
     */
    public static int _Py_IsCoreInitialized() {
        var mh$ = _Py_IsCoreInitialized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_IsCoreInitialized");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_InitializeFromConfig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PyStatus.layout(),
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_InitializeFromConfig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyStatus Py_InitializeFromConfig(const PyConfig *config)
     * }
     */
    public static FunctionDescriptor Py_InitializeFromConfig$descriptor() {
        return Py_InitializeFromConfig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyStatus Py_InitializeFromConfig(const PyConfig *config)
     * }
     */
    public static MethodHandle Py_InitializeFromConfig$handle() {
        return Py_InitializeFromConfig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyStatus Py_InitializeFromConfig(const PyConfig *config)
     * }
     */
    public static MemorySegment Py_InitializeFromConfig$address() {
        return Py_InitializeFromConfig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyStatus Py_InitializeFromConfig(const PyConfig *config)
     * }
     */
    public static MemorySegment Py_InitializeFromConfig(SegmentAllocator allocator, MemorySegment config) {
        var mh$ = Py_InitializeFromConfig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_InitializeFromConfig", allocator, config);
            }
            return (MemorySegment)mh$.invokeExact(allocator, config);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_InitializeMain {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PyStatus.layout()    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_InitializeMain");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyStatus _Py_InitializeMain()
     * }
     */
    public static FunctionDescriptor _Py_InitializeMain$descriptor() {
        return _Py_InitializeMain.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyStatus _Py_InitializeMain()
     * }
     */
    public static MethodHandle _Py_InitializeMain$handle() {
        return _Py_InitializeMain.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyStatus _Py_InitializeMain()
     * }
     */
    public static MemorySegment _Py_InitializeMain$address() {
        return _Py_InitializeMain.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyStatus _Py_InitializeMain()
     * }
     */
    public static MemorySegment _Py_InitializeMain(SegmentAllocator allocator) {
        var mh$ = _Py_InitializeMain.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_InitializeMain", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_RunMain {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_RunMain");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_RunMain()
     * }
     */
    public static FunctionDescriptor Py_RunMain$descriptor() {
        return Py_RunMain.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_RunMain()
     * }
     */
    public static MethodHandle Py_RunMain$handle() {
        return Py_RunMain.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_RunMain()
     * }
     */
    public static MemorySegment Py_RunMain$address() {
        return Py_RunMain.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_RunMain()
     * }
     */
    public static int Py_RunMain() {
        var mh$ = Py_RunMain.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_RunMain");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_ExitStatusException {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            PyStatus.layout()
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_ExitStatusException");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_ExitStatusException(PyStatus err)
     * }
     */
    public static FunctionDescriptor Py_ExitStatusException$descriptor() {
        return Py_ExitStatusException.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_ExitStatusException(PyStatus err)
     * }
     */
    public static MethodHandle Py_ExitStatusException$handle() {
        return Py_ExitStatusException.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_ExitStatusException(PyStatus err)
     * }
     */
    public static MemorySegment Py_ExitStatusException$address() {
        return Py_ExitStatusException.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_ExitStatusException(PyStatus err)
     * }
     */
    public static void Py_ExitStatusException(MemorySegment err) {
        var mh$ = Py_ExitStatusException.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_ExitStatusException", err);
            }
            mh$.invokeExact(err);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_RestoreSignals {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_RestoreSignals");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _Py_RestoreSignals()
     * }
     */
    public static FunctionDescriptor _Py_RestoreSignals$descriptor() {
        return _Py_RestoreSignals.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _Py_RestoreSignals()
     * }
     */
    public static MethodHandle _Py_RestoreSignals$handle() {
        return _Py_RestoreSignals.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _Py_RestoreSignals()
     * }
     */
    public static MemorySegment _Py_RestoreSignals$address() {
        return _Py_RestoreSignals.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _Py_RestoreSignals()
     * }
     */
    public static void _Py_RestoreSignals() {
        var mh$ = _Py_RestoreSignals.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_RestoreSignals");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_FdIsInteractive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_FdIsInteractive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_FdIsInteractive(FILE *, const char *)
     * }
     */
    public static FunctionDescriptor Py_FdIsInteractive$descriptor() {
        return Py_FdIsInteractive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_FdIsInteractive(FILE *, const char *)
     * }
     */
    public static MethodHandle Py_FdIsInteractive$handle() {
        return Py_FdIsInteractive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_FdIsInteractive(FILE *, const char *)
     * }
     */
    public static MemorySegment Py_FdIsInteractive$address() {
        return Py_FdIsInteractive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_FdIsInteractive(FILE *, const char *)
     * }
     */
    public static int Py_FdIsInteractive(MemorySegment x0, MemorySegment x1) {
        var mh$ = Py_FdIsInteractive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_FdIsInteractive", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_FdIsInteractive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_FdIsInteractive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _Py_FdIsInteractive(FILE *fp, PyObject *filename)
     * }
     */
    public static FunctionDescriptor _Py_FdIsInteractive$descriptor() {
        return _Py_FdIsInteractive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _Py_FdIsInteractive(FILE *fp, PyObject *filename)
     * }
     */
    public static MethodHandle _Py_FdIsInteractive$handle() {
        return _Py_FdIsInteractive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _Py_FdIsInteractive(FILE *fp, PyObject *filename)
     * }
     */
    public static MemorySegment _Py_FdIsInteractive$address() {
        return _Py_FdIsInteractive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _Py_FdIsInteractive(FILE *fp, PyObject *filename)
     * }
     */
    public static int _Py_FdIsInteractive(MemorySegment fp, MemorySegment filename) {
        var mh$ = _Py_FdIsInteractive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_FdIsInteractive", fp, filename);
            }
            return (int)mh$.invokeExact(fp, filename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_SetProgramFullPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_SetProgramFullPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _Py_SetProgramFullPath(const wchar_t *)
     * }
     */
    public static FunctionDescriptor _Py_SetProgramFullPath$descriptor() {
        return _Py_SetProgramFullPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _Py_SetProgramFullPath(const wchar_t *)
     * }
     */
    public static MethodHandle _Py_SetProgramFullPath$handle() {
        return _Py_SetProgramFullPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _Py_SetProgramFullPath(const wchar_t *)
     * }
     */
    public static MemorySegment _Py_SetProgramFullPath$address() {
        return _Py_SetProgramFullPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _Py_SetProgramFullPath(const wchar_t *)
     * }
     */
    public static void _Py_SetProgramFullPath(MemorySegment x0) {
        var mh$ = _Py_SetProgramFullPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_SetProgramFullPath", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_gitidentifier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_gitidentifier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *_Py_gitidentifier()
     * }
     */
    public static FunctionDescriptor _Py_gitidentifier$descriptor() {
        return _Py_gitidentifier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *_Py_gitidentifier()
     * }
     */
    public static MethodHandle _Py_gitidentifier$handle() {
        return _Py_gitidentifier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *_Py_gitidentifier()
     * }
     */
    public static MemorySegment _Py_gitidentifier$address() {
        return _Py_gitidentifier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *_Py_gitidentifier()
     * }
     */
    public static MemorySegment _Py_gitidentifier() {
        var mh$ = _Py_gitidentifier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_gitidentifier");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_gitversion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_gitversion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *_Py_gitversion()
     * }
     */
    public static FunctionDescriptor _Py_gitversion$descriptor() {
        return _Py_gitversion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *_Py_gitversion()
     * }
     */
    public static MethodHandle _Py_gitversion$handle() {
        return _Py_gitversion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *_Py_gitversion()
     * }
     */
    public static MemorySegment _Py_gitversion$address() {
        return _Py_gitversion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *_Py_gitversion()
     * }
     */
    public static MemorySegment _Py_gitversion() {
        var mh$ = _Py_gitversion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_gitversion");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_IsFinalizing {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_IsFinalizing");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _Py_IsFinalizing()
     * }
     */
    public static FunctionDescriptor _Py_IsFinalizing$descriptor() {
        return _Py_IsFinalizing.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _Py_IsFinalizing()
     * }
     */
    public static MethodHandle _Py_IsFinalizing$handle() {
        return _Py_IsFinalizing.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _Py_IsFinalizing()
     * }
     */
    public static MemorySegment _Py_IsFinalizing$address() {
        return _Py_IsFinalizing.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _Py_IsFinalizing()
     * }
     */
    public static int _Py_IsFinalizing() {
        var mh$ = _Py_IsFinalizing.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_IsFinalizing");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyOS_URandom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyOS_URandom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyOS_URandom(void *buffer, Py_ssize_t size)
     * }
     */
    public static FunctionDescriptor _PyOS_URandom$descriptor() {
        return _PyOS_URandom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyOS_URandom(void *buffer, Py_ssize_t size)
     * }
     */
    public static MethodHandle _PyOS_URandom$handle() {
        return _PyOS_URandom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyOS_URandom(void *buffer, Py_ssize_t size)
     * }
     */
    public static MemorySegment _PyOS_URandom$address() {
        return _PyOS_URandom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyOS_URandom(void *buffer, Py_ssize_t size)
     * }
     */
    public static int _PyOS_URandom(MemorySegment buffer, long size) {
        var mh$ = _PyOS_URandom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyOS_URandom", buffer, size);
            }
            return (int)mh$.invokeExact(buffer, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyOS_URandomNonblock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyOS_URandomNonblock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyOS_URandomNonblock(void *buffer, Py_ssize_t size)
     * }
     */
    public static FunctionDescriptor _PyOS_URandomNonblock$descriptor() {
        return _PyOS_URandomNonblock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyOS_URandomNonblock(void *buffer, Py_ssize_t size)
     * }
     */
    public static MethodHandle _PyOS_URandomNonblock$handle() {
        return _PyOS_URandomNonblock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyOS_URandomNonblock(void *buffer, Py_ssize_t size)
     * }
     */
    public static MemorySegment _PyOS_URandomNonblock$address() {
        return _PyOS_URandomNonblock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyOS_URandomNonblock(void *buffer, Py_ssize_t size)
     * }
     */
    public static int _PyOS_URandomNonblock(MemorySegment buffer, long size) {
        var mh$ = _PyOS_URandomNonblock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyOS_URandomNonblock", buffer, size);
            }
            return (int)mh$.invokeExact(buffer, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_CoerceLegacyLocale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_CoerceLegacyLocale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _Py_CoerceLegacyLocale(int warn)
     * }
     */
    public static FunctionDescriptor _Py_CoerceLegacyLocale$descriptor() {
        return _Py_CoerceLegacyLocale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _Py_CoerceLegacyLocale(int warn)
     * }
     */
    public static MethodHandle _Py_CoerceLegacyLocale$handle() {
        return _Py_CoerceLegacyLocale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _Py_CoerceLegacyLocale(int warn)
     * }
     */
    public static MemorySegment _Py_CoerceLegacyLocale$address() {
        return _Py_CoerceLegacyLocale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _Py_CoerceLegacyLocale(int warn)
     * }
     */
    public static int _Py_CoerceLegacyLocale(int warn) {
        var mh$ = _Py_CoerceLegacyLocale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_CoerceLegacyLocale", warn);
            }
            return (int)mh$.invokeExact(warn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_LegacyLocaleDetected {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_LegacyLocaleDetected");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _Py_LegacyLocaleDetected(int warn)
     * }
     */
    public static FunctionDescriptor _Py_LegacyLocaleDetected$descriptor() {
        return _Py_LegacyLocaleDetected.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _Py_LegacyLocaleDetected(int warn)
     * }
     */
    public static MethodHandle _Py_LegacyLocaleDetected$handle() {
        return _Py_LegacyLocaleDetected.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _Py_LegacyLocaleDetected(int warn)
     * }
     */
    public static MemorySegment _Py_LegacyLocaleDetected$address() {
        return _Py_LegacyLocaleDetected.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _Py_LegacyLocaleDetected(int warn)
     * }
     */
    public static int _Py_LegacyLocaleDetected(int warn) {
        var mh$ = _Py_LegacyLocaleDetected.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_LegacyLocaleDetected", warn);
            }
            return (int)mh$.invokeExact(warn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_SetLocaleFromEnv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_SetLocaleFromEnv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_Py_SetLocaleFromEnv(int category)
     * }
     */
    public static FunctionDescriptor _Py_SetLocaleFromEnv$descriptor() {
        return _Py_SetLocaleFromEnv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_Py_SetLocaleFromEnv(int category)
     * }
     */
    public static MethodHandle _Py_SetLocaleFromEnv$handle() {
        return _Py_SetLocaleFromEnv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_Py_SetLocaleFromEnv(int category)
     * }
     */
    public static MemorySegment _Py_SetLocaleFromEnv$address() {
        return _Py_SetLocaleFromEnv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_Py_SetLocaleFromEnv(int category)
     * }
     */
    public static MemorySegment _Py_SetLocaleFromEnv(int category) {
        var mh$ = _Py_SetLocaleFromEnv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_SetLocaleFromEnv", category);
            }
            return (MemorySegment)mh$.invokeExact(category);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_NewInterpreter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_NewInterpreter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyThreadState *_Py_NewInterpreter(int isolated_subinterpreter)
     * }
     */
    public static FunctionDescriptor _Py_NewInterpreter$descriptor() {
        return _Py_NewInterpreter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyThreadState *_Py_NewInterpreter(int isolated_subinterpreter)
     * }
     */
    public static MethodHandle _Py_NewInterpreter$handle() {
        return _Py_NewInterpreter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyThreadState *_Py_NewInterpreter(int isolated_subinterpreter)
     * }
     */
    public static MemorySegment _Py_NewInterpreter$address() {
        return _Py_NewInterpreter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyThreadState *_Py_NewInterpreter(int isolated_subinterpreter)
     * }
     */
    public static MemorySegment _Py_NewInterpreter(int isolated_subinterpreter) {
        var mh$ = _Py_NewInterpreter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_NewInterpreter", isolated_subinterpreter);
            }
            return (MemorySegment)mh$.invokeExact(isolated_subinterpreter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_EvalCode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_EvalCode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyEval_EvalCode(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyEval_EvalCode$descriptor() {
        return PyEval_EvalCode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyEval_EvalCode(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyEval_EvalCode$handle() {
        return PyEval_EvalCode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyEval_EvalCode(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyEval_EvalCode$address() {
        return PyEval_EvalCode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyEval_EvalCode(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyEval_EvalCode(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyEval_EvalCode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_EvalCode", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_EvalCodeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_EvalCodeEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyEval_EvalCodeEx(PyObject *co, PyObject *globals, PyObject *locals, PyObject *const *args, int argc, PyObject *const *kwds, int kwdc, PyObject *const *defs, int defc, PyObject *kwdefs, PyObject *closure)
     * }
     */
    public static FunctionDescriptor PyEval_EvalCodeEx$descriptor() {
        return PyEval_EvalCodeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyEval_EvalCodeEx(PyObject *co, PyObject *globals, PyObject *locals, PyObject *const *args, int argc, PyObject *const *kwds, int kwdc, PyObject *const *defs, int defc, PyObject *kwdefs, PyObject *closure)
     * }
     */
    public static MethodHandle PyEval_EvalCodeEx$handle() {
        return PyEval_EvalCodeEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyEval_EvalCodeEx(PyObject *co, PyObject *globals, PyObject *locals, PyObject *const *args, int argc, PyObject *const *kwds, int kwdc, PyObject *const *defs, int defc, PyObject *kwdefs, PyObject *closure)
     * }
     */
    public static MemorySegment PyEval_EvalCodeEx$address() {
        return PyEval_EvalCodeEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyEval_EvalCodeEx(PyObject *co, PyObject *globals, PyObject *locals, PyObject *const *args, int argc, PyObject *const *kwds, int kwdc, PyObject *const *defs, int defc, PyObject *kwdefs, PyObject *closure)
     * }
     */
    public static MemorySegment PyEval_EvalCodeEx(MemorySegment co, MemorySegment globals, MemorySegment locals, MemorySegment args, int argc, MemorySegment kwds, int kwdc, MemorySegment defs, int defc, MemorySegment kwdefs, MemorySegment closure) {
        var mh$ = PyEval_EvalCodeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_EvalCodeEx", co, globals, locals, args, argc, kwds, kwdc, defs, defc, kwdefs, closure);
            }
            return (MemorySegment)mh$.invokeExact(co, globals, locals, args, argc, kwds, kwdc, defs, defc, kwdefs, closure);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_CallObjectWithKeywords {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_CallObjectWithKeywords");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyEval_CallObjectWithKeywords(PyObject *callable, PyObject *args, PyObject *kwargs)
     * }
     */
    public static FunctionDescriptor PyEval_CallObjectWithKeywords$descriptor() {
        return PyEval_CallObjectWithKeywords.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyEval_CallObjectWithKeywords(PyObject *callable, PyObject *args, PyObject *kwargs)
     * }
     */
    public static MethodHandle PyEval_CallObjectWithKeywords$handle() {
        return PyEval_CallObjectWithKeywords.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyEval_CallObjectWithKeywords(PyObject *callable, PyObject *args, PyObject *kwargs)
     * }
     */
    public static MemorySegment PyEval_CallObjectWithKeywords$address() {
        return PyEval_CallObjectWithKeywords.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyEval_CallObjectWithKeywords(PyObject *callable, PyObject *args, PyObject *kwargs)
     * }
     */
    public static MemorySegment PyEval_CallObjectWithKeywords(MemorySegment callable, MemorySegment args, MemorySegment kwargs) {
        var mh$ = PyEval_CallObjectWithKeywords.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_CallObjectWithKeywords", callable, args, kwargs);
            }
            return (MemorySegment)mh$.invokeExact(callable, args, kwargs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *PyEval_CallFunction(PyObject *callable, const char *format, ...)
     * }
     */
    public static class PyEval_CallFunction {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_CallFunction");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyEval_CallFunction(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *PyEval_CallFunction(PyObject *callable, const char *format, ...)
         * }
         */
        public static PyEval_CallFunction makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyEval_CallFunction(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment callable, MemorySegment format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyEval_CallFunction", callable, format, x2);
                }
                return (MemorySegment)spreader.invokeExact(callable, format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *PyEval_CallMethod(PyObject *obj, const char *name, const char *format, ...)
     * }
     */
    public static class PyEval_CallMethod {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_CallMethod");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyEval_CallMethod(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *PyEval_CallMethod(PyObject *obj, const char *name, const char *format, ...)
         * }
         */
        public static PyEval_CallMethod makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyEval_CallMethod(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment obj, MemorySegment name, MemorySegment format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyEval_CallMethod", obj, name, format, x3);
                }
                return (MemorySegment)spreader.invokeExact(obj, name, format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class PyEval_GetBuiltins {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_GetBuiltins");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyEval_GetBuiltins()
     * }
     */
    public static FunctionDescriptor PyEval_GetBuiltins$descriptor() {
        return PyEval_GetBuiltins.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyEval_GetBuiltins()
     * }
     */
    public static MethodHandle PyEval_GetBuiltins$handle() {
        return PyEval_GetBuiltins.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyEval_GetBuiltins()
     * }
     */
    public static MemorySegment PyEval_GetBuiltins$address() {
        return PyEval_GetBuiltins.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyEval_GetBuiltins()
     * }
     */
    public static MemorySegment PyEval_GetBuiltins() {
        var mh$ = PyEval_GetBuiltins.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_GetBuiltins");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_GetGlobals {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_GetGlobals");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyEval_GetGlobals()
     * }
     */
    public static FunctionDescriptor PyEval_GetGlobals$descriptor() {
        return PyEval_GetGlobals.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyEval_GetGlobals()
     * }
     */
    public static MethodHandle PyEval_GetGlobals$handle() {
        return PyEval_GetGlobals.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyEval_GetGlobals()
     * }
     */
    public static MemorySegment PyEval_GetGlobals$address() {
        return PyEval_GetGlobals.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyEval_GetGlobals()
     * }
     */
    public static MemorySegment PyEval_GetGlobals() {
        var mh$ = PyEval_GetGlobals.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_GetGlobals");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_GetLocals {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_GetLocals");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyEval_GetLocals()
     * }
     */
    public static FunctionDescriptor PyEval_GetLocals$descriptor() {
        return PyEval_GetLocals.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyEval_GetLocals()
     * }
     */
    public static MethodHandle PyEval_GetLocals$handle() {
        return PyEval_GetLocals.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyEval_GetLocals()
     * }
     */
    public static MemorySegment PyEval_GetLocals$address() {
        return PyEval_GetLocals.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyEval_GetLocals()
     * }
     */
    public static MemorySegment PyEval_GetLocals() {
        var mh$ = PyEval_GetLocals.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_GetLocals");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_GetFrame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_GetFrame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyFrameObject *PyEval_GetFrame()
     * }
     */
    public static FunctionDescriptor PyEval_GetFrame$descriptor() {
        return PyEval_GetFrame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyFrameObject *PyEval_GetFrame()
     * }
     */
    public static MethodHandle PyEval_GetFrame$handle() {
        return PyEval_GetFrame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyFrameObject *PyEval_GetFrame()
     * }
     */
    public static MemorySegment PyEval_GetFrame$address() {
        return PyEval_GetFrame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyFrameObject *PyEval_GetFrame()
     * }
     */
    public static MemorySegment PyEval_GetFrame() {
        var mh$ = PyEval_GetFrame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_GetFrame");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_AddPendingCall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_AddPendingCall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_AddPendingCall(int (*func)(void *), void *arg)
     * }
     */
    public static FunctionDescriptor Py_AddPendingCall$descriptor() {
        return Py_AddPendingCall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_AddPendingCall(int (*func)(void *), void *arg)
     * }
     */
    public static MethodHandle Py_AddPendingCall$handle() {
        return Py_AddPendingCall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_AddPendingCall(int (*func)(void *), void *arg)
     * }
     */
    public static MemorySegment Py_AddPendingCall$address() {
        return Py_AddPendingCall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_AddPendingCall(int (*func)(void *), void *arg)
     * }
     */
    public static int Py_AddPendingCall(MemorySegment func, MemorySegment arg) {
        var mh$ = Py_AddPendingCall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_AddPendingCall", func, arg);
            }
            return (int)mh$.invokeExact(func, arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_MakePendingCalls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_MakePendingCalls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_MakePendingCalls()
     * }
     */
    public static FunctionDescriptor Py_MakePendingCalls$descriptor() {
        return Py_MakePendingCalls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_MakePendingCalls()
     * }
     */
    public static MethodHandle Py_MakePendingCalls$handle() {
        return Py_MakePendingCalls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_MakePendingCalls()
     * }
     */
    public static MemorySegment Py_MakePendingCalls$address() {
        return Py_MakePendingCalls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_MakePendingCalls()
     * }
     */
    public static int Py_MakePendingCalls() {
        var mh$ = Py_MakePendingCalls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_MakePendingCalls");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_SetRecursionLimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_SetRecursionLimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_SetRecursionLimit(int)
     * }
     */
    public static FunctionDescriptor Py_SetRecursionLimit$descriptor() {
        return Py_SetRecursionLimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_SetRecursionLimit(int)
     * }
     */
    public static MethodHandle Py_SetRecursionLimit$handle() {
        return Py_SetRecursionLimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_SetRecursionLimit(int)
     * }
     */
    public static MemorySegment Py_SetRecursionLimit$address() {
        return Py_SetRecursionLimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_SetRecursionLimit(int)
     * }
     */
    public static void Py_SetRecursionLimit(int x0) {
        var mh$ = Py_SetRecursionLimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_SetRecursionLimit", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_GetRecursionLimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_GetRecursionLimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_GetRecursionLimit()
     * }
     */
    public static FunctionDescriptor Py_GetRecursionLimit$descriptor() {
        return Py_GetRecursionLimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_GetRecursionLimit()
     * }
     */
    public static MethodHandle Py_GetRecursionLimit$handle() {
        return Py_GetRecursionLimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_GetRecursionLimit()
     * }
     */
    public static MemorySegment Py_GetRecursionLimit$address() {
        return Py_GetRecursionLimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_GetRecursionLimit()
     * }
     */
    public static int Py_GetRecursionLimit() {
        var mh$ = Py_GetRecursionLimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_GetRecursionLimit");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_EnterRecursiveCall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_EnterRecursiveCall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_EnterRecursiveCall(const char *where)
     * }
     */
    public static FunctionDescriptor Py_EnterRecursiveCall$descriptor() {
        return Py_EnterRecursiveCall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_EnterRecursiveCall(const char *where)
     * }
     */
    public static MethodHandle Py_EnterRecursiveCall$handle() {
        return Py_EnterRecursiveCall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_EnterRecursiveCall(const char *where)
     * }
     */
    public static MemorySegment Py_EnterRecursiveCall$address() {
        return Py_EnterRecursiveCall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_EnterRecursiveCall(const char *where)
     * }
     */
    public static int Py_EnterRecursiveCall(MemorySegment where) {
        var mh$ = Py_EnterRecursiveCall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_EnterRecursiveCall", where);
            }
            return (int)mh$.invokeExact(where);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_LeaveRecursiveCall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_LeaveRecursiveCall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_LeaveRecursiveCall()
     * }
     */
    public static FunctionDescriptor Py_LeaveRecursiveCall$descriptor() {
        return Py_LeaveRecursiveCall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_LeaveRecursiveCall()
     * }
     */
    public static MethodHandle Py_LeaveRecursiveCall$handle() {
        return Py_LeaveRecursiveCall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_LeaveRecursiveCall()
     * }
     */
    public static MemorySegment Py_LeaveRecursiveCall$address() {
        return Py_LeaveRecursiveCall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_LeaveRecursiveCall()
     * }
     */
    public static void Py_LeaveRecursiveCall() {
        var mh$ = Py_LeaveRecursiveCall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_LeaveRecursiveCall");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_GetFuncName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_GetFuncName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *PyEval_GetFuncName(PyObject *)
     * }
     */
    public static FunctionDescriptor PyEval_GetFuncName$descriptor() {
        return PyEval_GetFuncName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *PyEval_GetFuncName(PyObject *)
     * }
     */
    public static MethodHandle PyEval_GetFuncName$handle() {
        return PyEval_GetFuncName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *PyEval_GetFuncName(PyObject *)
     * }
     */
    public static MemorySegment PyEval_GetFuncName$address() {
        return PyEval_GetFuncName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *PyEval_GetFuncName(PyObject *)
     * }
     */
    public static MemorySegment PyEval_GetFuncName(MemorySegment x0) {
        var mh$ = PyEval_GetFuncName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_GetFuncName", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_GetFuncDesc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_GetFuncDesc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *PyEval_GetFuncDesc(PyObject *)
     * }
     */
    public static FunctionDescriptor PyEval_GetFuncDesc$descriptor() {
        return PyEval_GetFuncDesc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *PyEval_GetFuncDesc(PyObject *)
     * }
     */
    public static MethodHandle PyEval_GetFuncDesc$handle() {
        return PyEval_GetFuncDesc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *PyEval_GetFuncDesc(PyObject *)
     * }
     */
    public static MemorySegment PyEval_GetFuncDesc$address() {
        return PyEval_GetFuncDesc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *PyEval_GetFuncDesc(PyObject *)
     * }
     */
    public static MemorySegment PyEval_GetFuncDesc(MemorySegment x0) {
        var mh$ = PyEval_GetFuncDesc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_GetFuncDesc", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_EvalFrame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_EvalFrame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyEval_EvalFrame(PyFrameObject *)
     * }
     */
    public static FunctionDescriptor PyEval_EvalFrame$descriptor() {
        return PyEval_EvalFrame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyEval_EvalFrame(PyFrameObject *)
     * }
     */
    public static MethodHandle PyEval_EvalFrame$handle() {
        return PyEval_EvalFrame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyEval_EvalFrame(PyFrameObject *)
     * }
     */
    public static MemorySegment PyEval_EvalFrame$address() {
        return PyEval_EvalFrame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyEval_EvalFrame(PyFrameObject *)
     * }
     */
    public static MemorySegment PyEval_EvalFrame(MemorySegment x0) {
        var mh$ = PyEval_EvalFrame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_EvalFrame", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_EvalFrameEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_EvalFrameEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyEval_EvalFrameEx(PyFrameObject *f, int exc)
     * }
     */
    public static FunctionDescriptor PyEval_EvalFrameEx$descriptor() {
        return PyEval_EvalFrameEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyEval_EvalFrameEx(PyFrameObject *f, int exc)
     * }
     */
    public static MethodHandle PyEval_EvalFrameEx$handle() {
        return PyEval_EvalFrameEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyEval_EvalFrameEx(PyFrameObject *f, int exc)
     * }
     */
    public static MemorySegment PyEval_EvalFrameEx$address() {
        return PyEval_EvalFrameEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyEval_EvalFrameEx(PyFrameObject *f, int exc)
     * }
     */
    public static MemorySegment PyEval_EvalFrameEx(MemorySegment f, int exc) {
        var mh$ = PyEval_EvalFrameEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_EvalFrameEx", f, exc);
            }
            return (MemorySegment)mh$.invokeExact(f, exc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_SaveThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_SaveThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyThreadState *PyEval_SaveThread()
     * }
     */
    public static FunctionDescriptor PyEval_SaveThread$descriptor() {
        return PyEval_SaveThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyThreadState *PyEval_SaveThread()
     * }
     */
    public static MethodHandle PyEval_SaveThread$handle() {
        return PyEval_SaveThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyThreadState *PyEval_SaveThread()
     * }
     */
    public static MemorySegment PyEval_SaveThread$address() {
        return PyEval_SaveThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyThreadState *PyEval_SaveThread()
     * }
     */
    public static MemorySegment PyEval_SaveThread() {
        var mh$ = PyEval_SaveThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_SaveThread");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_RestoreThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_RestoreThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyEval_RestoreThread(PyThreadState *)
     * }
     */
    public static FunctionDescriptor PyEval_RestoreThread$descriptor() {
        return PyEval_RestoreThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyEval_RestoreThread(PyThreadState *)
     * }
     */
    public static MethodHandle PyEval_RestoreThread$handle() {
        return PyEval_RestoreThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyEval_RestoreThread(PyThreadState *)
     * }
     */
    public static MemorySegment PyEval_RestoreThread$address() {
        return PyEval_RestoreThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyEval_RestoreThread(PyThreadState *)
     * }
     */
    public static void PyEval_RestoreThread(MemorySegment x0) {
        var mh$ = PyEval_RestoreThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_RestoreThread", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_ThreadsInitialized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_ThreadsInitialized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyEval_ThreadsInitialized()
     * }
     */
    public static FunctionDescriptor PyEval_ThreadsInitialized$descriptor() {
        return PyEval_ThreadsInitialized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyEval_ThreadsInitialized()
     * }
     */
    public static MethodHandle PyEval_ThreadsInitialized$handle() {
        return PyEval_ThreadsInitialized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyEval_ThreadsInitialized()
     * }
     */
    public static MemorySegment PyEval_ThreadsInitialized$address() {
        return PyEval_ThreadsInitialized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyEval_ThreadsInitialized()
     * }
     */
    public static int PyEval_ThreadsInitialized() {
        var mh$ = PyEval_ThreadsInitialized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_ThreadsInitialized");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_InitThreads {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_InitThreads");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyEval_InitThreads()
     * }
     */
    public static FunctionDescriptor PyEval_InitThreads$descriptor() {
        return PyEval_InitThreads.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyEval_InitThreads()
     * }
     */
    public static MethodHandle PyEval_InitThreads$handle() {
        return PyEval_InitThreads.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyEval_InitThreads()
     * }
     */
    public static MemorySegment PyEval_InitThreads$address() {
        return PyEval_InitThreads.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyEval_InitThreads()
     * }
     */
    public static void PyEval_InitThreads() {
        var mh$ = PyEval_InitThreads.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_InitThreads");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_AcquireLock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_AcquireLock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyEval_AcquireLock()
     * }
     */
    public static FunctionDescriptor PyEval_AcquireLock$descriptor() {
        return PyEval_AcquireLock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyEval_AcquireLock()
     * }
     */
    public static MethodHandle PyEval_AcquireLock$handle() {
        return PyEval_AcquireLock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyEval_AcquireLock()
     * }
     */
    public static MemorySegment PyEval_AcquireLock$address() {
        return PyEval_AcquireLock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyEval_AcquireLock()
     * }
     */
    public static void PyEval_AcquireLock() {
        var mh$ = PyEval_AcquireLock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_AcquireLock");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_ReleaseLock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_ReleaseLock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyEval_ReleaseLock()
     * }
     */
    public static FunctionDescriptor PyEval_ReleaseLock$descriptor() {
        return PyEval_ReleaseLock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyEval_ReleaseLock()
     * }
     */
    public static MethodHandle PyEval_ReleaseLock$handle() {
        return PyEval_ReleaseLock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyEval_ReleaseLock()
     * }
     */
    public static MemorySegment PyEval_ReleaseLock$address() {
        return PyEval_ReleaseLock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyEval_ReleaseLock()
     * }
     */
    public static void PyEval_ReleaseLock() {
        var mh$ = PyEval_ReleaseLock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_ReleaseLock");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_AcquireThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_AcquireThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyEval_AcquireThread(PyThreadState *tstate)
     * }
     */
    public static FunctionDescriptor PyEval_AcquireThread$descriptor() {
        return PyEval_AcquireThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyEval_AcquireThread(PyThreadState *tstate)
     * }
     */
    public static MethodHandle PyEval_AcquireThread$handle() {
        return PyEval_AcquireThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyEval_AcquireThread(PyThreadState *tstate)
     * }
     */
    public static MemorySegment PyEval_AcquireThread$address() {
        return PyEval_AcquireThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyEval_AcquireThread(PyThreadState *tstate)
     * }
     */
    public static void PyEval_AcquireThread(MemorySegment tstate) {
        var mh$ = PyEval_AcquireThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_AcquireThread", tstate);
            }
            mh$.invokeExact(tstate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_ReleaseThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_ReleaseThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyEval_ReleaseThread(PyThreadState *tstate)
     * }
     */
    public static FunctionDescriptor PyEval_ReleaseThread$descriptor() {
        return PyEval_ReleaseThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyEval_ReleaseThread(PyThreadState *tstate)
     * }
     */
    public static MethodHandle PyEval_ReleaseThread$handle() {
        return PyEval_ReleaseThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyEval_ReleaseThread(PyThreadState *tstate)
     * }
     */
    public static MemorySegment PyEval_ReleaseThread$address() {
        return PyEval_ReleaseThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyEval_ReleaseThread(PyThreadState *tstate)
     * }
     */
    public static void PyEval_ReleaseThread(MemorySegment tstate) {
        var mh$ = PyEval_ReleaseThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_ReleaseThread", tstate);
            }
            mh$.invokeExact(tstate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_SetProfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_SetProfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyEval_SetProfile(Py_tracefunc, PyObject *)
     * }
     */
    public static FunctionDescriptor PyEval_SetProfile$descriptor() {
        return PyEval_SetProfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyEval_SetProfile(Py_tracefunc, PyObject *)
     * }
     */
    public static MethodHandle PyEval_SetProfile$handle() {
        return PyEval_SetProfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyEval_SetProfile(Py_tracefunc, PyObject *)
     * }
     */
    public static MemorySegment PyEval_SetProfile$address() {
        return PyEval_SetProfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyEval_SetProfile(Py_tracefunc, PyObject *)
     * }
     */
    public static void PyEval_SetProfile(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyEval_SetProfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_SetProfile", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyEval_SetProfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyEval_SetProfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int _PyEval_SetProfile(PyThreadState *tstate, Py_tracefunc func, PyObject *arg)
     * }
     */
    public static FunctionDescriptor _PyEval_SetProfile$descriptor() {
        return _PyEval_SetProfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int _PyEval_SetProfile(PyThreadState *tstate, Py_tracefunc func, PyObject *arg)
     * }
     */
    public static MethodHandle _PyEval_SetProfile$handle() {
        return _PyEval_SetProfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int _PyEval_SetProfile(PyThreadState *tstate, Py_tracefunc func, PyObject *arg)
     * }
     */
    public static MemorySegment _PyEval_SetProfile$address() {
        return _PyEval_SetProfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int _PyEval_SetProfile(PyThreadState *tstate, Py_tracefunc func, PyObject *arg)
     * }
     */
    public static int _PyEval_SetProfile(MemorySegment tstate, MemorySegment func, MemorySegment arg) {
        var mh$ = _PyEval_SetProfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyEval_SetProfile", tstate, func, arg);
            }
            return (int)mh$.invokeExact(tstate, func, arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_SetTrace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_SetTrace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyEval_SetTrace(Py_tracefunc, PyObject *)
     * }
     */
    public static FunctionDescriptor PyEval_SetTrace$descriptor() {
        return PyEval_SetTrace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyEval_SetTrace(Py_tracefunc, PyObject *)
     * }
     */
    public static MethodHandle PyEval_SetTrace$handle() {
        return PyEval_SetTrace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyEval_SetTrace(Py_tracefunc, PyObject *)
     * }
     */
    public static MemorySegment PyEval_SetTrace$address() {
        return PyEval_SetTrace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyEval_SetTrace(Py_tracefunc, PyObject *)
     * }
     */
    public static void PyEval_SetTrace(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyEval_SetTrace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_SetTrace", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyEval_SetTrace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyEval_SetTrace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyEval_SetTrace(PyThreadState *tstate, Py_tracefunc func, PyObject *arg)
     * }
     */
    public static FunctionDescriptor _PyEval_SetTrace$descriptor() {
        return _PyEval_SetTrace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyEval_SetTrace(PyThreadState *tstate, Py_tracefunc func, PyObject *arg)
     * }
     */
    public static MethodHandle _PyEval_SetTrace$handle() {
        return _PyEval_SetTrace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyEval_SetTrace(PyThreadState *tstate, Py_tracefunc func, PyObject *arg)
     * }
     */
    public static MemorySegment _PyEval_SetTrace$address() {
        return _PyEval_SetTrace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyEval_SetTrace(PyThreadState *tstate, Py_tracefunc func, PyObject *arg)
     * }
     */
    public static int _PyEval_SetTrace(MemorySegment tstate, MemorySegment func, MemorySegment arg) {
        var mh$ = _PyEval_SetTrace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyEval_SetTrace", tstate, func, arg);
            }
            return (int)mh$.invokeExact(tstate, func, arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyEval_GetBuiltin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyEval_GetBuiltin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyEval_GetBuiltin(PyObject *)
     * }
     */
    public static FunctionDescriptor _PyEval_GetBuiltin$descriptor() {
        return _PyEval_GetBuiltin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyEval_GetBuiltin(PyObject *)
     * }
     */
    public static MethodHandle _PyEval_GetBuiltin$handle() {
        return _PyEval_GetBuiltin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyEval_GetBuiltin(PyObject *)
     * }
     */
    public static MemorySegment _PyEval_GetBuiltin$address() {
        return _PyEval_GetBuiltin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyEval_GetBuiltin(PyObject *)
     * }
     */
    public static MemorySegment _PyEval_GetBuiltin(MemorySegment x0) {
        var mh$ = _PyEval_GetBuiltin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyEval_GetBuiltin", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyEval_GetBuiltinId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyEval_GetBuiltinId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyEval_GetBuiltinId(_Py_Identifier *)
     * }
     */
    public static FunctionDescriptor _PyEval_GetBuiltinId$descriptor() {
        return _PyEval_GetBuiltinId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyEval_GetBuiltinId(_Py_Identifier *)
     * }
     */
    public static MethodHandle _PyEval_GetBuiltinId$handle() {
        return _PyEval_GetBuiltinId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyEval_GetBuiltinId(_Py_Identifier *)
     * }
     */
    public static MemorySegment _PyEval_GetBuiltinId$address() {
        return _PyEval_GetBuiltinId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyEval_GetBuiltinId(_Py_Identifier *)
     * }
     */
    public static MemorySegment _PyEval_GetBuiltinId(MemorySegment x0) {
        var mh$ = _PyEval_GetBuiltinId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyEval_GetBuiltinId", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyEval_MergeCompilerFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyEval_MergeCompilerFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyEval_MergeCompilerFlags(PyCompilerFlags *cf)
     * }
     */
    public static FunctionDescriptor PyEval_MergeCompilerFlags$descriptor() {
        return PyEval_MergeCompilerFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyEval_MergeCompilerFlags(PyCompilerFlags *cf)
     * }
     */
    public static MethodHandle PyEval_MergeCompilerFlags$handle() {
        return PyEval_MergeCompilerFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyEval_MergeCompilerFlags(PyCompilerFlags *cf)
     * }
     */
    public static MemorySegment PyEval_MergeCompilerFlags$address() {
        return PyEval_MergeCompilerFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyEval_MergeCompilerFlags(PyCompilerFlags *cf)
     * }
     */
    public static int PyEval_MergeCompilerFlags(MemorySegment cf) {
        var mh$ = PyEval_MergeCompilerFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyEval_MergeCompilerFlags", cf);
            }
            return (int)mh$.invokeExact(cf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyEval_EvalFrameDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyEval_EvalFrameDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyEval_EvalFrameDefault(PyThreadState *tstate, struct _PyInterpreterFrame *f, int exc)
     * }
     */
    public static FunctionDescriptor _PyEval_EvalFrameDefault$descriptor() {
        return _PyEval_EvalFrameDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyEval_EvalFrameDefault(PyThreadState *tstate, struct _PyInterpreterFrame *f, int exc)
     * }
     */
    public static MethodHandle _PyEval_EvalFrameDefault$handle() {
        return _PyEval_EvalFrameDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyEval_EvalFrameDefault(PyThreadState *tstate, struct _PyInterpreterFrame *f, int exc)
     * }
     */
    public static MemorySegment _PyEval_EvalFrameDefault$address() {
        return _PyEval_EvalFrameDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyEval_EvalFrameDefault(PyThreadState *tstate, struct _PyInterpreterFrame *f, int exc)
     * }
     */
    public static MemorySegment _PyEval_EvalFrameDefault(MemorySegment tstate, MemorySegment f, int exc) {
        var mh$ = _PyEval_EvalFrameDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyEval_EvalFrameDefault", tstate, f, exc);
            }
            return (MemorySegment)mh$.invokeExact(tstate, f, exc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyEval_SetSwitchInterval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyEval_SetSwitchInterval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyEval_SetSwitchInterval(unsigned long microseconds)
     * }
     */
    public static FunctionDescriptor _PyEval_SetSwitchInterval$descriptor() {
        return _PyEval_SetSwitchInterval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyEval_SetSwitchInterval(unsigned long microseconds)
     * }
     */
    public static MethodHandle _PyEval_SetSwitchInterval$handle() {
        return _PyEval_SetSwitchInterval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyEval_SetSwitchInterval(unsigned long microseconds)
     * }
     */
    public static MemorySegment _PyEval_SetSwitchInterval$address() {
        return _PyEval_SetSwitchInterval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyEval_SetSwitchInterval(unsigned long microseconds)
     * }
     */
    public static void _PyEval_SetSwitchInterval(long microseconds) {
        var mh$ = _PyEval_SetSwitchInterval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyEval_SetSwitchInterval", microseconds);
            }
            mh$.invokeExact(microseconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyEval_GetSwitchInterval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyEval_GetSwitchInterval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long _PyEval_GetSwitchInterval()
     * }
     */
    public static FunctionDescriptor _PyEval_GetSwitchInterval$descriptor() {
        return _PyEval_GetSwitchInterval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long _PyEval_GetSwitchInterval()
     * }
     */
    public static MethodHandle _PyEval_GetSwitchInterval$handle() {
        return _PyEval_GetSwitchInterval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long _PyEval_GetSwitchInterval()
     * }
     */
    public static MemorySegment _PyEval_GetSwitchInterval$address() {
        return _PyEval_GetSwitchInterval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long _PyEval_GetSwitchInterval()
     * }
     */
    public static long _PyEval_GetSwitchInterval() {
        var mh$ = _PyEval_GetSwitchInterval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyEval_GetSwitchInterval");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyEval_RequestCodeExtraIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyEval_RequestCodeExtraIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t _PyEval_RequestCodeExtraIndex(freefunc)
     * }
     */
    public static FunctionDescriptor _PyEval_RequestCodeExtraIndex$descriptor() {
        return _PyEval_RequestCodeExtraIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t _PyEval_RequestCodeExtraIndex(freefunc)
     * }
     */
    public static MethodHandle _PyEval_RequestCodeExtraIndex$handle() {
        return _PyEval_RequestCodeExtraIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t _PyEval_RequestCodeExtraIndex(freefunc)
     * }
     */
    public static MemorySegment _PyEval_RequestCodeExtraIndex$address() {
        return _PyEval_RequestCodeExtraIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t _PyEval_RequestCodeExtraIndex(freefunc)
     * }
     */
    public static long _PyEval_RequestCodeExtraIndex(MemorySegment x0) {
        var mh$ = _PyEval_RequestCodeExtraIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyEval_RequestCodeExtraIndex", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyEval_SliceIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyEval_SliceIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyEval_SliceIndex(PyObject *, Py_ssize_t *)
     * }
     */
    public static FunctionDescriptor _PyEval_SliceIndex$descriptor() {
        return _PyEval_SliceIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyEval_SliceIndex(PyObject *, Py_ssize_t *)
     * }
     */
    public static MethodHandle _PyEval_SliceIndex$handle() {
        return _PyEval_SliceIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyEval_SliceIndex(PyObject *, Py_ssize_t *)
     * }
     */
    public static MemorySegment _PyEval_SliceIndex$address() {
        return _PyEval_SliceIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyEval_SliceIndex(PyObject *, Py_ssize_t *)
     * }
     */
    public static int _PyEval_SliceIndex(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyEval_SliceIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyEval_SliceIndex", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyEval_SliceIndexNotNone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyEval_SliceIndexNotNone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyEval_SliceIndexNotNone(PyObject *, Py_ssize_t *)
     * }
     */
    public static FunctionDescriptor _PyEval_SliceIndexNotNone$descriptor() {
        return _PyEval_SliceIndexNotNone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyEval_SliceIndexNotNone(PyObject *, Py_ssize_t *)
     * }
     */
    public static MethodHandle _PyEval_SliceIndexNotNone$handle() {
        return _PyEval_SliceIndexNotNone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyEval_SliceIndexNotNone(PyObject *, Py_ssize_t *)
     * }
     */
    public static MemorySegment _PyEval_SliceIndexNotNone$address() {
        return _PyEval_SliceIndexNotNone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyEval_SliceIndexNotNone(PyObject *, Py_ssize_t *)
     * }
     */
    public static int _PyEval_SliceIndexNotNone(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyEval_SliceIndexNotNone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyEval_SliceIndexNotNone", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySys_GetObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySys_GetObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PySys_GetObject(const char *)
     * }
     */
    public static FunctionDescriptor PySys_GetObject$descriptor() {
        return PySys_GetObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PySys_GetObject(const char *)
     * }
     */
    public static MethodHandle PySys_GetObject$handle() {
        return PySys_GetObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PySys_GetObject(const char *)
     * }
     */
    public static MemorySegment PySys_GetObject$address() {
        return PySys_GetObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PySys_GetObject(const char *)
     * }
     */
    public static MemorySegment PySys_GetObject(MemorySegment x0) {
        var mh$ = PySys_GetObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySys_GetObject", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySys_SetObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySys_SetObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySys_SetObject(const char *, PyObject *)
     * }
     */
    public static FunctionDescriptor PySys_SetObject$descriptor() {
        return PySys_SetObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySys_SetObject(const char *, PyObject *)
     * }
     */
    public static MethodHandle PySys_SetObject$handle() {
        return PySys_SetObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySys_SetObject(const char *, PyObject *)
     * }
     */
    public static MemorySegment PySys_SetObject$address() {
        return PySys_SetObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySys_SetObject(const char *, PyObject *)
     * }
     */
    public static int PySys_SetObject(MemorySegment x0, MemorySegment x1) {
        var mh$ = PySys_SetObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySys_SetObject", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySys_SetArgv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySys_SetArgv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PySys_SetArgv(int, wchar_t **)
     * }
     */
    public static FunctionDescriptor PySys_SetArgv$descriptor() {
        return PySys_SetArgv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PySys_SetArgv(int, wchar_t **)
     * }
     */
    public static MethodHandle PySys_SetArgv$handle() {
        return PySys_SetArgv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PySys_SetArgv(int, wchar_t **)
     * }
     */
    public static MemorySegment PySys_SetArgv$address() {
        return PySys_SetArgv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PySys_SetArgv(int, wchar_t **)
     * }
     */
    public static void PySys_SetArgv(int x0, MemorySegment x1) {
        var mh$ = PySys_SetArgv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySys_SetArgv", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySys_SetArgvEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySys_SetArgvEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PySys_SetArgvEx(int, wchar_t **, int)
     * }
     */
    public static FunctionDescriptor PySys_SetArgvEx$descriptor() {
        return PySys_SetArgvEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PySys_SetArgvEx(int, wchar_t **, int)
     * }
     */
    public static MethodHandle PySys_SetArgvEx$handle() {
        return PySys_SetArgvEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PySys_SetArgvEx(int, wchar_t **, int)
     * }
     */
    public static MemorySegment PySys_SetArgvEx$address() {
        return PySys_SetArgvEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PySys_SetArgvEx(int, wchar_t **, int)
     * }
     */
    public static void PySys_SetArgvEx(int x0, MemorySegment x1, int x2) {
        var mh$ = PySys_SetArgvEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySys_SetArgvEx", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySys_SetPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySys_SetPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PySys_SetPath(const wchar_t *)
     * }
     */
    public static FunctionDescriptor PySys_SetPath$descriptor() {
        return PySys_SetPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PySys_SetPath(const wchar_t *)
     * }
     */
    public static MethodHandle PySys_SetPath$handle() {
        return PySys_SetPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PySys_SetPath(const wchar_t *)
     * }
     */
    public static MemorySegment PySys_SetPath$address() {
        return PySys_SetPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PySys_SetPath(const wchar_t *)
     * }
     */
    public static void PySys_SetPath(MemorySegment x0) {
        var mh$ = PySys_SetPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySys_SetPath", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void PySys_WriteStdout(const char *format, ...)
     * }
     */
    public static class PySys_WriteStdout {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PySys_WriteStdout");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PySys_WriteStdout(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void PySys_WriteStdout(const char *format, ...)
         * }
         */
        public static PySys_WriteStdout makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PySys_WriteStdout(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PySys_WriteStdout", format, x1);
                }
                spreader.invokeExact(format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void PySys_WriteStderr(const char *format, ...)
     * }
     */
    public static class PySys_WriteStderr {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PySys_WriteStderr");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PySys_WriteStderr(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void PySys_WriteStderr(const char *format, ...)
         * }
         */
        public static PySys_WriteStderr makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PySys_WriteStderr(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PySys_WriteStderr", format, x1);
                }
                spreader.invokeExact(format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void PySys_FormatStdout(const char *format, ...)
     * }
     */
    public static class PySys_FormatStdout {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PySys_FormatStdout");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PySys_FormatStdout(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void PySys_FormatStdout(const char *format, ...)
         * }
         */
        public static PySys_FormatStdout makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PySys_FormatStdout(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PySys_FormatStdout", format, x1);
                }
                spreader.invokeExact(format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void PySys_FormatStderr(const char *format, ...)
     * }
     */
    public static class PySys_FormatStderr {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PySys_FormatStderr");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PySys_FormatStderr(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void PySys_FormatStderr(const char *format, ...)
         * }
         */
        public static PySys_FormatStderr makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PySys_FormatStderr(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PySys_FormatStderr", format, x1);
                }
                spreader.invokeExact(format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class PySys_ResetWarnOptions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySys_ResetWarnOptions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PySys_ResetWarnOptions()
     * }
     */
    public static FunctionDescriptor PySys_ResetWarnOptions$descriptor() {
        return PySys_ResetWarnOptions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PySys_ResetWarnOptions()
     * }
     */
    public static MethodHandle PySys_ResetWarnOptions$handle() {
        return PySys_ResetWarnOptions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PySys_ResetWarnOptions()
     * }
     */
    public static MemorySegment PySys_ResetWarnOptions$address() {
        return PySys_ResetWarnOptions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PySys_ResetWarnOptions()
     * }
     */
    public static void PySys_ResetWarnOptions() {
        var mh$ = PySys_ResetWarnOptions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySys_ResetWarnOptions");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySys_AddWarnOption {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySys_AddWarnOption");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PySys_AddWarnOption(const wchar_t *)
     * }
     */
    public static FunctionDescriptor PySys_AddWarnOption$descriptor() {
        return PySys_AddWarnOption.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PySys_AddWarnOption(const wchar_t *)
     * }
     */
    public static MethodHandle PySys_AddWarnOption$handle() {
        return PySys_AddWarnOption.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PySys_AddWarnOption(const wchar_t *)
     * }
     */
    public static MemorySegment PySys_AddWarnOption$address() {
        return PySys_AddWarnOption.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PySys_AddWarnOption(const wchar_t *)
     * }
     */
    public static void PySys_AddWarnOption(MemorySegment x0) {
        var mh$ = PySys_AddWarnOption.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySys_AddWarnOption", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySys_AddWarnOptionUnicode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySys_AddWarnOptionUnicode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PySys_AddWarnOptionUnicode(PyObject *)
     * }
     */
    public static FunctionDescriptor PySys_AddWarnOptionUnicode$descriptor() {
        return PySys_AddWarnOptionUnicode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PySys_AddWarnOptionUnicode(PyObject *)
     * }
     */
    public static MethodHandle PySys_AddWarnOptionUnicode$handle() {
        return PySys_AddWarnOptionUnicode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PySys_AddWarnOptionUnicode(PyObject *)
     * }
     */
    public static MemorySegment PySys_AddWarnOptionUnicode$address() {
        return PySys_AddWarnOptionUnicode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PySys_AddWarnOptionUnicode(PyObject *)
     * }
     */
    public static void PySys_AddWarnOptionUnicode(MemorySegment x0) {
        var mh$ = PySys_AddWarnOptionUnicode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySys_AddWarnOptionUnicode", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySys_HasWarnOptions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySys_HasWarnOptions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySys_HasWarnOptions()
     * }
     */
    public static FunctionDescriptor PySys_HasWarnOptions$descriptor() {
        return PySys_HasWarnOptions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySys_HasWarnOptions()
     * }
     */
    public static MethodHandle PySys_HasWarnOptions$handle() {
        return PySys_HasWarnOptions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySys_HasWarnOptions()
     * }
     */
    public static MemorySegment PySys_HasWarnOptions$address() {
        return PySys_HasWarnOptions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySys_HasWarnOptions()
     * }
     */
    public static int PySys_HasWarnOptions() {
        var mh$ = PySys_HasWarnOptions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySys_HasWarnOptions");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySys_AddXOption {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySys_AddXOption");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PySys_AddXOption(const wchar_t *)
     * }
     */
    public static FunctionDescriptor PySys_AddXOption$descriptor() {
        return PySys_AddXOption.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PySys_AddXOption(const wchar_t *)
     * }
     */
    public static MethodHandle PySys_AddXOption$handle() {
        return PySys_AddXOption.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PySys_AddXOption(const wchar_t *)
     * }
     */
    public static MemorySegment PySys_AddXOption$address() {
        return PySys_AddXOption.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PySys_AddXOption(const wchar_t *)
     * }
     */
    public static void PySys_AddXOption(MemorySegment x0) {
        var mh$ = PySys_AddXOption.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySys_AddXOption", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PySys_GetXOptions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySys_GetXOptions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PySys_GetXOptions()
     * }
     */
    public static FunctionDescriptor PySys_GetXOptions$descriptor() {
        return PySys_GetXOptions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PySys_GetXOptions()
     * }
     */
    public static MethodHandle PySys_GetXOptions$handle() {
        return PySys_GetXOptions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PySys_GetXOptions()
     * }
     */
    public static MemorySegment PySys_GetXOptions$address() {
        return PySys_GetXOptions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PySys_GetXOptions()
     * }
     */
    public static MemorySegment PySys_GetXOptions() {
        var mh$ = PySys_GetXOptions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySys_GetXOptions");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PySys_GetAttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PySys_GetAttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PySys_GetAttr(PyThreadState *tstate, PyObject *name)
     * }
     */
    public static FunctionDescriptor _PySys_GetAttr$descriptor() {
        return _PySys_GetAttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PySys_GetAttr(PyThreadState *tstate, PyObject *name)
     * }
     */
    public static MethodHandle _PySys_GetAttr$handle() {
        return _PySys_GetAttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PySys_GetAttr(PyThreadState *tstate, PyObject *name)
     * }
     */
    public static MemorySegment _PySys_GetAttr$address() {
        return _PySys_GetAttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PySys_GetAttr(PyThreadState *tstate, PyObject *name)
     * }
     */
    public static MemorySegment _PySys_GetAttr(MemorySegment tstate, MemorySegment name) {
        var mh$ = _PySys_GetAttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PySys_GetAttr", tstate, name);
            }
            return (MemorySegment)mh$.invokeExact(tstate, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PySys_GetSizeOf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PySys_GetSizeOf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _PySys_GetSizeOf(PyObject *)
     * }
     */
    public static FunctionDescriptor _PySys_GetSizeOf$descriptor() {
        return _PySys_GetSizeOf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _PySys_GetSizeOf(PyObject *)
     * }
     */
    public static MethodHandle _PySys_GetSizeOf$handle() {
        return _PySys_GetSizeOf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _PySys_GetSizeOf(PyObject *)
     * }
     */
    public static MemorySegment _PySys_GetSizeOf$address() {
        return _PySys_GetSizeOf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _PySys_GetSizeOf(PyObject *)
     * }
     */
    public static long _PySys_GetSizeOf(MemorySegment x0) {
        var mh$ = _PySys_GetSizeOf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PySys_GetSizeOf", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int PySys_Audit(const char *event, const char *argFormat, ...)
     * }
     */
    public static class PySys_Audit {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PySys_Audit");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PySys_Audit(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int PySys_Audit(const char *event, const char *argFormat, ...)
         * }
         */
        public static PySys_Audit makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PySys_Audit(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment event, MemorySegment argFormat, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PySys_Audit", event, argFormat, x2);
                }
                return (int)spreader.invokeExact(event, argFormat, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class PySys_AddAuditHook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PySys_AddAuditHook");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PySys_AddAuditHook(Py_AuditHookFunction, void *)
     * }
     */
    public static FunctionDescriptor PySys_AddAuditHook$descriptor() {
        return PySys_AddAuditHook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PySys_AddAuditHook(Py_AuditHookFunction, void *)
     * }
     */
    public static MethodHandle PySys_AddAuditHook$handle() {
        return PySys_AddAuditHook.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PySys_AddAuditHook(Py_AuditHookFunction, void *)
     * }
     */
    public static MemorySegment PySys_AddAuditHook$address() {
        return PySys_AddAuditHook.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PySys_AddAuditHook(Py_AuditHookFunction, void *)
     * }
     */
    public static int PySys_AddAuditHook(MemorySegment x0, MemorySegment x1) {
        var mh$ = PySys_AddAuditHook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PySys_AddAuditHook", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyOS_FSPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyOS_FSPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyOS_FSPath(PyObject *path)
     * }
     */
    public static FunctionDescriptor PyOS_FSPath$descriptor() {
        return PyOS_FSPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyOS_FSPath(PyObject *path)
     * }
     */
    public static MethodHandle PyOS_FSPath$handle() {
        return PyOS_FSPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyOS_FSPath(PyObject *path)
     * }
     */
    public static MemorySegment PyOS_FSPath$address() {
        return PyOS_FSPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyOS_FSPath(PyObject *path)
     * }
     */
    public static MemorySegment PyOS_FSPath(MemorySegment path) {
        var mh$ = PyOS_FSPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyOS_FSPath", path);
            }
            return (MemorySegment)mh$.invokeExact(path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyOS_InterruptOccurred {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyOS_InterruptOccurred");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyOS_InterruptOccurred()
     * }
     */
    public static FunctionDescriptor PyOS_InterruptOccurred$descriptor() {
        return PyOS_InterruptOccurred.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyOS_InterruptOccurred()
     * }
     */
    public static MethodHandle PyOS_InterruptOccurred$handle() {
        return PyOS_InterruptOccurred.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyOS_InterruptOccurred()
     * }
     */
    public static MemorySegment PyOS_InterruptOccurred$address() {
        return PyOS_InterruptOccurred.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyOS_InterruptOccurred()
     * }
     */
    public static int PyOS_InterruptOccurred() {
        var mh$ = PyOS_InterruptOccurred.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyOS_InterruptOccurred");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyOS_BeforeFork {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyOS_BeforeFork");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyOS_BeforeFork()
     * }
     */
    public static FunctionDescriptor PyOS_BeforeFork$descriptor() {
        return PyOS_BeforeFork.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyOS_BeforeFork()
     * }
     */
    public static MethodHandle PyOS_BeforeFork$handle() {
        return PyOS_BeforeFork.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyOS_BeforeFork()
     * }
     */
    public static MemorySegment PyOS_BeforeFork$address() {
        return PyOS_BeforeFork.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyOS_BeforeFork()
     * }
     */
    public static void PyOS_BeforeFork() {
        var mh$ = PyOS_BeforeFork.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyOS_BeforeFork");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyOS_AfterFork_Parent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyOS_AfterFork_Parent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyOS_AfterFork_Parent()
     * }
     */
    public static FunctionDescriptor PyOS_AfterFork_Parent$descriptor() {
        return PyOS_AfterFork_Parent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyOS_AfterFork_Parent()
     * }
     */
    public static MethodHandle PyOS_AfterFork_Parent$handle() {
        return PyOS_AfterFork_Parent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyOS_AfterFork_Parent()
     * }
     */
    public static MemorySegment PyOS_AfterFork_Parent$address() {
        return PyOS_AfterFork_Parent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyOS_AfterFork_Parent()
     * }
     */
    public static void PyOS_AfterFork_Parent() {
        var mh$ = PyOS_AfterFork_Parent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyOS_AfterFork_Parent");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyOS_AfterFork_Child {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyOS_AfterFork_Child");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyOS_AfterFork_Child()
     * }
     */
    public static FunctionDescriptor PyOS_AfterFork_Child$descriptor() {
        return PyOS_AfterFork_Child.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyOS_AfterFork_Child()
     * }
     */
    public static MethodHandle PyOS_AfterFork_Child$handle() {
        return PyOS_AfterFork_Child.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyOS_AfterFork_Child()
     * }
     */
    public static MemorySegment PyOS_AfterFork_Child$address() {
        return PyOS_AfterFork_Child.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyOS_AfterFork_Child()
     * }
     */
    public static void PyOS_AfterFork_Child() {
        var mh$ = PyOS_AfterFork_Child.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyOS_AfterFork_Child");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyOS_AfterFork {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyOS_AfterFork");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyOS_AfterFork()
     * }
     */
    public static FunctionDescriptor PyOS_AfterFork$descriptor() {
        return PyOS_AfterFork.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyOS_AfterFork()
     * }
     */
    public static MethodHandle PyOS_AfterFork$handle() {
        return PyOS_AfterFork.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyOS_AfterFork()
     * }
     */
    public static MemorySegment PyOS_AfterFork$address() {
        return PyOS_AfterFork.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyOS_AfterFork()
     * }
     */
    public static void PyOS_AfterFork() {
        var mh$ = PyOS_AfterFork.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyOS_AfterFork");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyOS_IsMainThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyOS_IsMainThread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyOS_IsMainThread()
     * }
     */
    public static FunctionDescriptor _PyOS_IsMainThread$descriptor() {
        return _PyOS_IsMainThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyOS_IsMainThread()
     * }
     */
    public static MethodHandle _PyOS_IsMainThread$handle() {
        return _PyOS_IsMainThread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyOS_IsMainThread()
     * }
     */
    public static MemorySegment _PyOS_IsMainThread$address() {
        return _PyOS_IsMainThread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyOS_IsMainThread()
     * }
     */
    public static int _PyOS_IsMainThread() {
        var mh$ = _PyOS_IsMainThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyOS_IsMainThread");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_GetMagicNumber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_GetMagicNumber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long PyImport_GetMagicNumber()
     * }
     */
    public static FunctionDescriptor PyImport_GetMagicNumber$descriptor() {
        return PyImport_GetMagicNumber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long PyImport_GetMagicNumber()
     * }
     */
    public static MethodHandle PyImport_GetMagicNumber$handle() {
        return PyImport_GetMagicNumber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long PyImport_GetMagicNumber()
     * }
     */
    public static MemorySegment PyImport_GetMagicNumber$address() {
        return PyImport_GetMagicNumber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long PyImport_GetMagicNumber()
     * }
     */
    public static long PyImport_GetMagicNumber() {
        var mh$ = PyImport_GetMagicNumber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_GetMagicNumber");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_GetMagicTag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_GetMagicTag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *PyImport_GetMagicTag()
     * }
     */
    public static FunctionDescriptor PyImport_GetMagicTag$descriptor() {
        return PyImport_GetMagicTag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *PyImport_GetMagicTag()
     * }
     */
    public static MethodHandle PyImport_GetMagicTag$handle() {
        return PyImport_GetMagicTag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *PyImport_GetMagicTag()
     * }
     */
    public static MemorySegment PyImport_GetMagicTag$address() {
        return PyImport_GetMagicTag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *PyImport_GetMagicTag()
     * }
     */
    public static MemorySegment PyImport_GetMagicTag() {
        var mh$ = PyImport_GetMagicTag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_GetMagicTag");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_ExecCodeModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ExecCodeModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModule(const char *name, PyObject *co)
     * }
     */
    public static FunctionDescriptor PyImport_ExecCodeModule$descriptor() {
        return PyImport_ExecCodeModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModule(const char *name, PyObject *co)
     * }
     */
    public static MethodHandle PyImport_ExecCodeModule$handle() {
        return PyImport_ExecCodeModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModule(const char *name, PyObject *co)
     * }
     */
    public static MemorySegment PyImport_ExecCodeModule$address() {
        return PyImport_ExecCodeModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModule(const char *name, PyObject *co)
     * }
     */
    public static MemorySegment PyImport_ExecCodeModule(MemorySegment name, MemorySegment co) {
        var mh$ = PyImport_ExecCodeModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ExecCodeModule", name, co);
            }
            return (MemorySegment)mh$.invokeExact(name, co);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_ExecCodeModuleEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ExecCodeModuleEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleEx(const char *name, PyObject *co, const char *pathname)
     * }
     */
    public static FunctionDescriptor PyImport_ExecCodeModuleEx$descriptor() {
        return PyImport_ExecCodeModuleEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleEx(const char *name, PyObject *co, const char *pathname)
     * }
     */
    public static MethodHandle PyImport_ExecCodeModuleEx$handle() {
        return PyImport_ExecCodeModuleEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleEx(const char *name, PyObject *co, const char *pathname)
     * }
     */
    public static MemorySegment PyImport_ExecCodeModuleEx$address() {
        return PyImport_ExecCodeModuleEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleEx(const char *name, PyObject *co, const char *pathname)
     * }
     */
    public static MemorySegment PyImport_ExecCodeModuleEx(MemorySegment name, MemorySegment co, MemorySegment pathname) {
        var mh$ = PyImport_ExecCodeModuleEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ExecCodeModuleEx", name, co, pathname);
            }
            return (MemorySegment)mh$.invokeExact(name, co, pathname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_ExecCodeModuleWithPathnames {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ExecCodeModuleWithPathnames");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleWithPathnames(const char *name, PyObject *co, const char *pathname, const char *cpathname)
     * }
     */
    public static FunctionDescriptor PyImport_ExecCodeModuleWithPathnames$descriptor() {
        return PyImport_ExecCodeModuleWithPathnames.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleWithPathnames(const char *name, PyObject *co, const char *pathname, const char *cpathname)
     * }
     */
    public static MethodHandle PyImport_ExecCodeModuleWithPathnames$handle() {
        return PyImport_ExecCodeModuleWithPathnames.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleWithPathnames(const char *name, PyObject *co, const char *pathname, const char *cpathname)
     * }
     */
    public static MemorySegment PyImport_ExecCodeModuleWithPathnames$address() {
        return PyImport_ExecCodeModuleWithPathnames.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleWithPathnames(const char *name, PyObject *co, const char *pathname, const char *cpathname)
     * }
     */
    public static MemorySegment PyImport_ExecCodeModuleWithPathnames(MemorySegment name, MemorySegment co, MemorySegment pathname, MemorySegment cpathname) {
        var mh$ = PyImport_ExecCodeModuleWithPathnames.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ExecCodeModuleWithPathnames", name, co, pathname, cpathname);
            }
            return (MemorySegment)mh$.invokeExact(name, co, pathname, cpathname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_ExecCodeModuleObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ExecCodeModuleObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleObject(PyObject *name, PyObject *co, PyObject *pathname, PyObject *cpathname)
     * }
     */
    public static FunctionDescriptor PyImport_ExecCodeModuleObject$descriptor() {
        return PyImport_ExecCodeModuleObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleObject(PyObject *name, PyObject *co, PyObject *pathname, PyObject *cpathname)
     * }
     */
    public static MethodHandle PyImport_ExecCodeModuleObject$handle() {
        return PyImport_ExecCodeModuleObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleObject(PyObject *name, PyObject *co, PyObject *pathname, PyObject *cpathname)
     * }
     */
    public static MemorySegment PyImport_ExecCodeModuleObject$address() {
        return PyImport_ExecCodeModuleObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_ExecCodeModuleObject(PyObject *name, PyObject *co, PyObject *pathname, PyObject *cpathname)
     * }
     */
    public static MemorySegment PyImport_ExecCodeModuleObject(MemorySegment name, MemorySegment co, MemorySegment pathname, MemorySegment cpathname) {
        var mh$ = PyImport_ExecCodeModuleObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ExecCodeModuleObject", name, co, pathname, cpathname);
            }
            return (MemorySegment)mh$.invokeExact(name, co, pathname, cpathname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_GetModuleDict {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_GetModuleDict");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_GetModuleDict()
     * }
     */
    public static FunctionDescriptor PyImport_GetModuleDict$descriptor() {
        return PyImport_GetModuleDict.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_GetModuleDict()
     * }
     */
    public static MethodHandle PyImport_GetModuleDict$handle() {
        return PyImport_GetModuleDict.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_GetModuleDict()
     * }
     */
    public static MemorySegment PyImport_GetModuleDict$address() {
        return PyImport_GetModuleDict.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_GetModuleDict()
     * }
     */
    public static MemorySegment PyImport_GetModuleDict() {
        var mh$ = PyImport_GetModuleDict.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_GetModuleDict");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_GetModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_GetModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_GetModule(PyObject *name)
     * }
     */
    public static FunctionDescriptor PyImport_GetModule$descriptor() {
        return PyImport_GetModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_GetModule(PyObject *name)
     * }
     */
    public static MethodHandle PyImport_GetModule$handle() {
        return PyImport_GetModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_GetModule(PyObject *name)
     * }
     */
    public static MemorySegment PyImport_GetModule$address() {
        return PyImport_GetModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_GetModule(PyObject *name)
     * }
     */
    public static MemorySegment PyImport_GetModule(MemorySegment name) {
        var mh$ = PyImport_GetModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_GetModule", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_AddModuleObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_AddModuleObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_AddModuleObject(PyObject *name)
     * }
     */
    public static FunctionDescriptor PyImport_AddModuleObject$descriptor() {
        return PyImport_AddModuleObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_AddModuleObject(PyObject *name)
     * }
     */
    public static MethodHandle PyImport_AddModuleObject$handle() {
        return PyImport_AddModuleObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_AddModuleObject(PyObject *name)
     * }
     */
    public static MemorySegment PyImport_AddModuleObject$address() {
        return PyImport_AddModuleObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_AddModuleObject(PyObject *name)
     * }
     */
    public static MemorySegment PyImport_AddModuleObject(MemorySegment name) {
        var mh$ = PyImport_AddModuleObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_AddModuleObject", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_AddModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_AddModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_AddModule(const char *name)
     * }
     */
    public static FunctionDescriptor PyImport_AddModule$descriptor() {
        return PyImport_AddModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_AddModule(const char *name)
     * }
     */
    public static MethodHandle PyImport_AddModule$handle() {
        return PyImport_AddModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_AddModule(const char *name)
     * }
     */
    public static MemorySegment PyImport_AddModule$address() {
        return PyImport_AddModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_AddModule(const char *name)
     * }
     */
    public static MemorySegment PyImport_AddModule(MemorySegment name) {
        var mh$ = PyImport_AddModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_AddModule", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_ImportModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ImportModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModule(const char *name)
     * }
     */
    public static FunctionDescriptor PyImport_ImportModule$descriptor() {
        return PyImport_ImportModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModule(const char *name)
     * }
     */
    public static MethodHandle PyImport_ImportModule$handle() {
        return PyImport_ImportModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModule(const char *name)
     * }
     */
    public static MemorySegment PyImport_ImportModule$address() {
        return PyImport_ImportModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModule(const char *name)
     * }
     */
    public static MemorySegment PyImport_ImportModule(MemorySegment name) {
        var mh$ = PyImport_ImportModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ImportModule", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_ImportModuleNoBlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ImportModuleNoBlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleNoBlock(const char *name)
     * }
     */
    public static FunctionDescriptor PyImport_ImportModuleNoBlock$descriptor() {
        return PyImport_ImportModuleNoBlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleNoBlock(const char *name)
     * }
     */
    public static MethodHandle PyImport_ImportModuleNoBlock$handle() {
        return PyImport_ImportModuleNoBlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleNoBlock(const char *name)
     * }
     */
    public static MemorySegment PyImport_ImportModuleNoBlock$address() {
        return PyImport_ImportModuleNoBlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleNoBlock(const char *name)
     * }
     */
    public static MemorySegment PyImport_ImportModuleNoBlock(MemorySegment name) {
        var mh$ = PyImport_ImportModuleNoBlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ImportModuleNoBlock", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_ImportModuleLevel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ImportModuleLevel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleLevel(const char *name, PyObject *globals, PyObject *locals, PyObject *fromlist, int level)
     * }
     */
    public static FunctionDescriptor PyImport_ImportModuleLevel$descriptor() {
        return PyImport_ImportModuleLevel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleLevel(const char *name, PyObject *globals, PyObject *locals, PyObject *fromlist, int level)
     * }
     */
    public static MethodHandle PyImport_ImportModuleLevel$handle() {
        return PyImport_ImportModuleLevel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleLevel(const char *name, PyObject *globals, PyObject *locals, PyObject *fromlist, int level)
     * }
     */
    public static MemorySegment PyImport_ImportModuleLevel$address() {
        return PyImport_ImportModuleLevel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleLevel(const char *name, PyObject *globals, PyObject *locals, PyObject *fromlist, int level)
     * }
     */
    public static MemorySegment PyImport_ImportModuleLevel(MemorySegment name, MemorySegment globals, MemorySegment locals, MemorySegment fromlist, int level) {
        var mh$ = PyImport_ImportModuleLevel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ImportModuleLevel", name, globals, locals, fromlist, level);
            }
            return (MemorySegment)mh$.invokeExact(name, globals, locals, fromlist, level);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_ImportModuleLevelObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ImportModuleLevelObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleLevelObject(PyObject *name, PyObject *globals, PyObject *locals, PyObject *fromlist, int level)
     * }
     */
    public static FunctionDescriptor PyImport_ImportModuleLevelObject$descriptor() {
        return PyImport_ImportModuleLevelObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleLevelObject(PyObject *name, PyObject *globals, PyObject *locals, PyObject *fromlist, int level)
     * }
     */
    public static MethodHandle PyImport_ImportModuleLevelObject$handle() {
        return PyImport_ImportModuleLevelObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleLevelObject(PyObject *name, PyObject *globals, PyObject *locals, PyObject *fromlist, int level)
     * }
     */
    public static MemorySegment PyImport_ImportModuleLevelObject$address() {
        return PyImport_ImportModuleLevelObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_ImportModuleLevelObject(PyObject *name, PyObject *globals, PyObject *locals, PyObject *fromlist, int level)
     * }
     */
    public static MemorySegment PyImport_ImportModuleLevelObject(MemorySegment name, MemorySegment globals, MemorySegment locals, MemorySegment fromlist, int level) {
        var mh$ = PyImport_ImportModuleLevelObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ImportModuleLevelObject", name, globals, locals, fromlist, level);
            }
            return (MemorySegment)mh$.invokeExact(name, globals, locals, fromlist, level);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_GetImporter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_GetImporter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_GetImporter(PyObject *path)
     * }
     */
    public static FunctionDescriptor PyImport_GetImporter$descriptor() {
        return PyImport_GetImporter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_GetImporter(PyObject *path)
     * }
     */
    public static MethodHandle PyImport_GetImporter$handle() {
        return PyImport_GetImporter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_GetImporter(PyObject *path)
     * }
     */
    public static MemorySegment PyImport_GetImporter$address() {
        return PyImport_GetImporter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_GetImporter(PyObject *path)
     * }
     */
    public static MemorySegment PyImport_GetImporter(MemorySegment path) {
        var mh$ = PyImport_GetImporter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_GetImporter", path);
            }
            return (MemorySegment)mh$.invokeExact(path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_Import {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_Import");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_Import(PyObject *name)
     * }
     */
    public static FunctionDescriptor PyImport_Import$descriptor() {
        return PyImport_Import.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_Import(PyObject *name)
     * }
     */
    public static MethodHandle PyImport_Import$handle() {
        return PyImport_Import.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_Import(PyObject *name)
     * }
     */
    public static MemorySegment PyImport_Import$address() {
        return PyImport_Import.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_Import(PyObject *name)
     * }
     */
    public static MemorySegment PyImport_Import(MemorySegment name) {
        var mh$ = PyImport_Import.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_Import", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_ReloadModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ReloadModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyImport_ReloadModule(PyObject *m)
     * }
     */
    public static FunctionDescriptor PyImport_ReloadModule$descriptor() {
        return PyImport_ReloadModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyImport_ReloadModule(PyObject *m)
     * }
     */
    public static MethodHandle PyImport_ReloadModule$handle() {
        return PyImport_ReloadModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyImport_ReloadModule(PyObject *m)
     * }
     */
    public static MemorySegment PyImport_ReloadModule$address() {
        return PyImport_ReloadModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyImport_ReloadModule(PyObject *m)
     * }
     */
    public static MemorySegment PyImport_ReloadModule(MemorySegment m) {
        var mh$ = PyImport_ReloadModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ReloadModule", m);
            }
            return (MemorySegment)mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_ImportFrozenModuleObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ImportFrozenModuleObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyImport_ImportFrozenModuleObject(PyObject *name)
     * }
     */
    public static FunctionDescriptor PyImport_ImportFrozenModuleObject$descriptor() {
        return PyImport_ImportFrozenModuleObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyImport_ImportFrozenModuleObject(PyObject *name)
     * }
     */
    public static MethodHandle PyImport_ImportFrozenModuleObject$handle() {
        return PyImport_ImportFrozenModuleObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyImport_ImportFrozenModuleObject(PyObject *name)
     * }
     */
    public static MemorySegment PyImport_ImportFrozenModuleObject$address() {
        return PyImport_ImportFrozenModuleObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyImport_ImportFrozenModuleObject(PyObject *name)
     * }
     */
    public static int PyImport_ImportFrozenModuleObject(MemorySegment name) {
        var mh$ = PyImport_ImportFrozenModuleObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ImportFrozenModuleObject", name);
            }
            return (int)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_ImportFrozenModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ImportFrozenModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyImport_ImportFrozenModule(const char *name)
     * }
     */
    public static FunctionDescriptor PyImport_ImportFrozenModule$descriptor() {
        return PyImport_ImportFrozenModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyImport_ImportFrozenModule(const char *name)
     * }
     */
    public static MethodHandle PyImport_ImportFrozenModule$handle() {
        return PyImport_ImportFrozenModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyImport_ImportFrozenModule(const char *name)
     * }
     */
    public static MemorySegment PyImport_ImportFrozenModule$address() {
        return PyImport_ImportFrozenModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyImport_ImportFrozenModule(const char *name)
     * }
     */
    public static int PyImport_ImportFrozenModule(MemorySegment name) {
        var mh$ = PyImport_ImportFrozenModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ImportFrozenModule", name);
            }
            return (int)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_AppendInittab {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_AppendInittab");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyImport_AppendInittab(const char *name, PyObject *(*initfunc)(void))
     * }
     */
    public static FunctionDescriptor PyImport_AppendInittab$descriptor() {
        return PyImport_AppendInittab.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyImport_AppendInittab(const char *name, PyObject *(*initfunc)(void))
     * }
     */
    public static MethodHandle PyImport_AppendInittab$handle() {
        return PyImport_AppendInittab.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyImport_AppendInittab(const char *name, PyObject *(*initfunc)(void))
     * }
     */
    public static MemorySegment PyImport_AppendInittab$address() {
        return PyImport_AppendInittab.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyImport_AppendInittab(const char *name, PyObject *(*initfunc)(void))
     * }
     */
    public static int PyImport_AppendInittab(MemorySegment name, MemorySegment initfunc) {
        var mh$ = PyImport_AppendInittab.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_AppendInittab", name, initfunc);
            }
            return (int)mh$.invokeExact(name, initfunc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyInit__imp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyInit__imp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyInit__imp()
     * }
     */
    public static FunctionDescriptor PyInit__imp$descriptor() {
        return PyInit__imp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyInit__imp()
     * }
     */
    public static MethodHandle PyInit__imp$handle() {
        return PyInit__imp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyInit__imp()
     * }
     */
    public static MemorySegment PyInit__imp$address() {
        return PyInit__imp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyInit__imp()
     * }
     */
    public static MemorySegment PyInit__imp() {
        var mh$ = PyInit__imp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyInit__imp");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyImport_IsInitialized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyImport_IsInitialized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyImport_IsInitialized(PyInterpreterState *)
     * }
     */
    public static FunctionDescriptor _PyImport_IsInitialized$descriptor() {
        return _PyImport_IsInitialized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyImport_IsInitialized(PyInterpreterState *)
     * }
     */
    public static MethodHandle _PyImport_IsInitialized$handle() {
        return _PyImport_IsInitialized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyImport_IsInitialized(PyInterpreterState *)
     * }
     */
    public static MemorySegment _PyImport_IsInitialized$address() {
        return _PyImport_IsInitialized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyImport_IsInitialized(PyInterpreterState *)
     * }
     */
    public static int _PyImport_IsInitialized(MemorySegment x0) {
        var mh$ = _PyImport_IsInitialized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyImport_IsInitialized", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyImport_GetModuleId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyImport_GetModuleId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyImport_GetModuleId(_Py_Identifier *name)
     * }
     */
    public static FunctionDescriptor _PyImport_GetModuleId$descriptor() {
        return _PyImport_GetModuleId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyImport_GetModuleId(_Py_Identifier *name)
     * }
     */
    public static MethodHandle _PyImport_GetModuleId$handle() {
        return _PyImport_GetModuleId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyImport_GetModuleId(_Py_Identifier *name)
     * }
     */
    public static MemorySegment _PyImport_GetModuleId$address() {
        return _PyImport_GetModuleId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyImport_GetModuleId(_Py_Identifier *name)
     * }
     */
    public static MemorySegment _PyImport_GetModuleId(MemorySegment name) {
        var mh$ = _PyImport_GetModuleId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyImport_GetModuleId", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyImport_SetModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyImport_SetModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyImport_SetModule(PyObject *name, PyObject *module)
     * }
     */
    public static FunctionDescriptor _PyImport_SetModule$descriptor() {
        return _PyImport_SetModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyImport_SetModule(PyObject *name, PyObject *module)
     * }
     */
    public static MethodHandle _PyImport_SetModule$handle() {
        return _PyImport_SetModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyImport_SetModule(PyObject *name, PyObject *module)
     * }
     */
    public static MemorySegment _PyImport_SetModule$address() {
        return _PyImport_SetModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyImport_SetModule(PyObject *name, PyObject *module)
     * }
     */
    public static int _PyImport_SetModule(MemorySegment name, MemorySegment module) {
        var mh$ = _PyImport_SetModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyImport_SetModule", name, module);
            }
            return (int)mh$.invokeExact(name, module);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyImport_SetModuleString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyImport_SetModuleString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyImport_SetModuleString(const char *name, PyObject *module)
     * }
     */
    public static FunctionDescriptor _PyImport_SetModuleString$descriptor() {
        return _PyImport_SetModuleString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyImport_SetModuleString(const char *name, PyObject *module)
     * }
     */
    public static MethodHandle _PyImport_SetModuleString$handle() {
        return _PyImport_SetModuleString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyImport_SetModuleString(const char *name, PyObject *module)
     * }
     */
    public static MemorySegment _PyImport_SetModuleString$address() {
        return _PyImport_SetModuleString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyImport_SetModuleString(const char *name, PyObject *module)
     * }
     */
    public static int _PyImport_SetModuleString(MemorySegment name, MemorySegment module) {
        var mh$ = _PyImport_SetModuleString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyImport_SetModuleString", name, module);
            }
            return (int)mh$.invokeExact(name, module);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyImport_AcquireLock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyImport_AcquireLock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyImport_AcquireLock()
     * }
     */
    public static FunctionDescriptor _PyImport_AcquireLock$descriptor() {
        return _PyImport_AcquireLock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyImport_AcquireLock()
     * }
     */
    public static MethodHandle _PyImport_AcquireLock$handle() {
        return _PyImport_AcquireLock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyImport_AcquireLock()
     * }
     */
    public static MemorySegment _PyImport_AcquireLock$address() {
        return _PyImport_AcquireLock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyImport_AcquireLock()
     * }
     */
    public static void _PyImport_AcquireLock() {
        var mh$ = _PyImport_AcquireLock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyImport_AcquireLock");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyImport_ReleaseLock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyImport_ReleaseLock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyImport_ReleaseLock()
     * }
     */
    public static FunctionDescriptor _PyImport_ReleaseLock$descriptor() {
        return _PyImport_ReleaseLock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyImport_ReleaseLock()
     * }
     */
    public static MethodHandle _PyImport_ReleaseLock$handle() {
        return _PyImport_ReleaseLock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyImport_ReleaseLock()
     * }
     */
    public static MemorySegment _PyImport_ReleaseLock$address() {
        return _PyImport_ReleaseLock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyImport_ReleaseLock()
     * }
     */
    public static int _PyImport_ReleaseLock() {
        var mh$ = _PyImport_ReleaseLock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyImport_ReleaseLock");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyImport_FixupBuiltin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyImport_FixupBuiltin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyImport_FixupBuiltin(PyObject *mod, const char *name, PyObject *modules)
     * }
     */
    public static FunctionDescriptor _PyImport_FixupBuiltin$descriptor() {
        return _PyImport_FixupBuiltin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyImport_FixupBuiltin(PyObject *mod, const char *name, PyObject *modules)
     * }
     */
    public static MethodHandle _PyImport_FixupBuiltin$handle() {
        return _PyImport_FixupBuiltin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyImport_FixupBuiltin(PyObject *mod, const char *name, PyObject *modules)
     * }
     */
    public static MemorySegment _PyImport_FixupBuiltin$address() {
        return _PyImport_FixupBuiltin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyImport_FixupBuiltin(PyObject *mod, const char *name, PyObject *modules)
     * }
     */
    public static int _PyImport_FixupBuiltin(MemorySegment mod, MemorySegment name, MemorySegment modules) {
        var mh$ = _PyImport_FixupBuiltin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyImport_FixupBuiltin", mod, name, modules);
            }
            return (int)mh$.invokeExact(mod, name, modules);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyImport_FixupExtensionObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyImport_FixupExtensionObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyImport_FixupExtensionObject(PyObject *, PyObject *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor _PyImport_FixupExtensionObject$descriptor() {
        return _PyImport_FixupExtensionObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyImport_FixupExtensionObject(PyObject *, PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle _PyImport_FixupExtensionObject$handle() {
        return _PyImport_FixupExtensionObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyImport_FixupExtensionObject(PyObject *, PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment _PyImport_FixupExtensionObject$address() {
        return _PyImport_FixupExtensionObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyImport_FixupExtensionObject(PyObject *, PyObject *, PyObject *, PyObject *)
     * }
     */
    public static int _PyImport_FixupExtensionObject(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = _PyImport_FixupExtensionObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyImport_FixupExtensionObject", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_Inittab$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyImport_Inittab").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern struct _inittab *PyImport_Inittab
     * }
     */
    public static AddressLayout PyImport_Inittab$layout() {
        return PyImport_Inittab$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern struct _inittab *PyImport_Inittab
     * }
     */
    public static MemorySegment PyImport_Inittab$segment() {
        return PyImport_Inittab$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern struct _inittab *PyImport_Inittab
     * }
     */
    public static MemorySegment PyImport_Inittab() {
        return PyImport_Inittab$constants.SEGMENT.get(PyImport_Inittab$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern struct _inittab *PyImport_Inittab
     * }
     */
    public static void PyImport_Inittab(MemorySegment varValue) {
        PyImport_Inittab$constants.SEGMENT.set(PyImport_Inittab$constants.LAYOUT, 0L, varValue);
    }

    private static class PyImport_ExtendInittab {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyImport_ExtendInittab");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyImport_ExtendInittab(struct _inittab *newtab)
     * }
     */
    public static FunctionDescriptor PyImport_ExtendInittab$descriptor() {
        return PyImport_ExtendInittab.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyImport_ExtendInittab(struct _inittab *newtab)
     * }
     */
    public static MethodHandle PyImport_ExtendInittab$handle() {
        return PyImport_ExtendInittab.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyImport_ExtendInittab(struct _inittab *newtab)
     * }
     */
    public static MemorySegment PyImport_ExtendInittab$address() {
        return PyImport_ExtendInittab.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyImport_ExtendInittab(struct _inittab *newtab)
     * }
     */
    public static int PyImport_ExtendInittab(MemorySegment newtab) {
        var mh$ = PyImport_ExtendInittab.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyImport_ExtendInittab", newtab);
            }
            return (int)mh$.invokeExact(newtab);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyImport_FrozenModules$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyImport_FrozenModules").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct _frozen *PyImport_FrozenModules
     * }
     */
    public static AddressLayout PyImport_FrozenModules$layout() {
        return PyImport_FrozenModules$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const struct _frozen *PyImport_FrozenModules
     * }
     */
    public static MemorySegment PyImport_FrozenModules$segment() {
        return PyImport_FrozenModules$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct _frozen *PyImport_FrozenModules
     * }
     */
    public static MemorySegment PyImport_FrozenModules() {
        return PyImport_FrozenModules$constants.SEGMENT.get(PyImport_FrozenModules$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct _frozen *PyImport_FrozenModules
     * }
     */
    public static void PyImport_FrozenModules(MemorySegment varValue) {
        PyImport_FrozenModules$constants.SEGMENT.set(PyImport_FrozenModules$constants.LAYOUT, 0L, varValue);
    }

    private static class _PyImport_GetModuleAttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyImport_GetModuleAttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern PyObject *_PyImport_GetModuleAttr(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor _PyImport_GetModuleAttr$descriptor() {
        return _PyImport_GetModuleAttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern PyObject *_PyImport_GetModuleAttr(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle _PyImport_GetModuleAttr$handle() {
        return _PyImport_GetModuleAttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern PyObject *_PyImport_GetModuleAttr(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment _PyImport_GetModuleAttr$address() {
        return _PyImport_GetModuleAttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern PyObject *_PyImport_GetModuleAttr(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment _PyImport_GetModuleAttr(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyImport_GetModuleAttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyImport_GetModuleAttr", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyImport_GetModuleAttrString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyImport_GetModuleAttrString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern PyObject *_PyImport_GetModuleAttrString(const char *, const char *)
     * }
     */
    public static FunctionDescriptor _PyImport_GetModuleAttrString$descriptor() {
        return _PyImport_GetModuleAttrString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern PyObject *_PyImport_GetModuleAttrString(const char *, const char *)
     * }
     */
    public static MethodHandle _PyImport_GetModuleAttrString$handle() {
        return _PyImport_GetModuleAttrString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern PyObject *_PyImport_GetModuleAttrString(const char *, const char *)
     * }
     */
    public static MemorySegment _PyImport_GetModuleAttrString$address() {
        return _PyImport_GetModuleAttrString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern PyObject *_PyImport_GetModuleAttrString(const char *, const char *)
     * }
     */
    public static MemorySegment _PyImport_GetModuleAttrString(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyImport_GetModuleAttrString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyImport_GetModuleAttrString", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_CallNoArgs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_CallNoArgs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_CallNoArgs(PyObject *func)
     * }
     */
    public static FunctionDescriptor PyObject_CallNoArgs$descriptor() {
        return PyObject_CallNoArgs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_CallNoArgs(PyObject *func)
     * }
     */
    public static MethodHandle PyObject_CallNoArgs$handle() {
        return PyObject_CallNoArgs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_CallNoArgs(PyObject *func)
     * }
     */
    public static MemorySegment PyObject_CallNoArgs$address() {
        return PyObject_CallNoArgs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_CallNoArgs(PyObject *func)
     * }
     */
    public static MemorySegment PyObject_CallNoArgs(MemorySegment func) {
        var mh$ = PyObject_CallNoArgs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_CallNoArgs", func);
            }
            return (MemorySegment)mh$.invokeExact(func);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_Call(PyObject *callable, PyObject *args, PyObject *kwargs)
     * }
     */
    public static FunctionDescriptor PyObject_Call$descriptor() {
        return PyObject_Call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_Call(PyObject *callable, PyObject *args, PyObject *kwargs)
     * }
     */
    public static MethodHandle PyObject_Call$handle() {
        return PyObject_Call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_Call(PyObject *callable, PyObject *args, PyObject *kwargs)
     * }
     */
    public static MemorySegment PyObject_Call$address() {
        return PyObject_Call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_Call(PyObject *callable, PyObject *args, PyObject *kwargs)
     * }
     */
    public static MemorySegment PyObject_Call(MemorySegment callable, MemorySegment args, MemorySegment kwargs) {
        var mh$ = PyObject_Call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Call", callable, args, kwargs);
            }
            return (MemorySegment)mh$.invokeExact(callable, args, kwargs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_CallObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_CallObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_CallObject(PyObject *callable, PyObject *args)
     * }
     */
    public static FunctionDescriptor PyObject_CallObject$descriptor() {
        return PyObject_CallObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_CallObject(PyObject *callable, PyObject *args)
     * }
     */
    public static MethodHandle PyObject_CallObject$handle() {
        return PyObject_CallObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_CallObject(PyObject *callable, PyObject *args)
     * }
     */
    public static MemorySegment PyObject_CallObject$address() {
        return PyObject_CallObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_CallObject(PyObject *callable, PyObject *args)
     * }
     */
    public static MemorySegment PyObject_CallObject(MemorySegment callable, MemorySegment args) {
        var mh$ = PyObject_CallObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_CallObject", callable, args);
            }
            return (MemorySegment)mh$.invokeExact(callable, args);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *PyObject_CallFunction(PyObject *callable, const char *format, ...)
     * }
     */
    public static class PyObject_CallFunction {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_CallFunction");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyObject_CallFunction(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *PyObject_CallFunction(PyObject *callable, const char *format, ...)
         * }
         */
        public static PyObject_CallFunction makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyObject_CallFunction(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment callable, MemorySegment format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyObject_CallFunction", callable, format, x2);
                }
                return (MemorySegment)spreader.invokeExact(callable, format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *PyObject_CallMethod(PyObject *obj, const char *name, const char *format, ...)
     * }
     */
    public static class PyObject_CallMethod {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_CallMethod");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyObject_CallMethod(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *PyObject_CallMethod(PyObject *obj, const char *name, const char *format, ...)
         * }
         */
        public static PyObject_CallMethod makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyObject_CallMethod(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment obj, MemorySegment name, MemorySegment format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyObject_CallMethod", obj, name, format, x3);
                }
                return (MemorySegment)spreader.invokeExact(obj, name, format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *_PyObject_CallFunction_SizeT(PyObject *callable, const char *format, ...)
     * }
     */
    public static class _PyObject_CallFunction_SizeT {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_CallFunction_SizeT");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private _PyObject_CallFunction_SizeT(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *_PyObject_CallFunction_SizeT(PyObject *callable, const char *format, ...)
         * }
         */
        public static _PyObject_CallFunction_SizeT makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new _PyObject_CallFunction_SizeT(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment callable, MemorySegment format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("_PyObject_CallFunction_SizeT", callable, format, x2);
                }
                return (MemorySegment)spreader.invokeExact(callable, format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *_PyObject_CallMethod_SizeT(PyObject *obj, const char *name, const char *format, ...)
     * }
     */
    public static class _PyObject_CallMethod_SizeT {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_CallMethod_SizeT");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private _PyObject_CallMethod_SizeT(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *_PyObject_CallMethod_SizeT(PyObject *obj, const char *name, const char *format, ...)
         * }
         */
        public static _PyObject_CallMethod_SizeT makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new _PyObject_CallMethod_SizeT(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment obj, MemorySegment name, MemorySegment format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("_PyObject_CallMethod_SizeT", obj, name, format, x3);
                }
                return (MemorySegment)spreader.invokeExact(obj, name, format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *PyObject_CallFunctionObjArgs(PyObject *callable, ...)
     * }
     */
    public static class PyObject_CallFunctionObjArgs {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_CallFunctionObjArgs");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyObject_CallFunctionObjArgs(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *PyObject_CallFunctionObjArgs(PyObject *callable, ...)
         * }
         */
        public static PyObject_CallFunctionObjArgs makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyObject_CallFunctionObjArgs(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment callable, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyObject_CallFunctionObjArgs", callable, x1);
                }
                return (MemorySegment)spreader.invokeExact(callable, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *PyObject_CallMethodObjArgs(PyObject *obj, PyObject *name, ...)
     * }
     */
    public static class PyObject_CallMethodObjArgs {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_CallMethodObjArgs");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyObject_CallMethodObjArgs(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *PyObject_CallMethodObjArgs(PyObject *obj, PyObject *name, ...)
         * }
         */
        public static PyObject_CallMethodObjArgs makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyObject_CallMethodObjArgs(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment obj, MemorySegment name, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyObject_CallMethodObjArgs", obj, name, x2);
                }
                return (MemorySegment)spreader.invokeExact(obj, name, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class PyObject_Type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_Type(PyObject *o)
     * }
     */
    public static FunctionDescriptor PyObject_Type$descriptor() {
        return PyObject_Type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_Type(PyObject *o)
     * }
     */
    public static MethodHandle PyObject_Type$handle() {
        return PyObject_Type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_Type(PyObject *o)
     * }
     */
    public static MemorySegment PyObject_Type$address() {
        return PyObject_Type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_Type(PyObject *o)
     * }
     */
    public static MemorySegment PyObject_Type(MemorySegment o) {
        var mh$ = PyObject_Type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Type", o);
            }
            return (MemorySegment)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyObject_Size(PyObject *o)
     * }
     */
    public static FunctionDescriptor PyObject_Size$descriptor() {
        return PyObject_Size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyObject_Size(PyObject *o)
     * }
     */
    public static MethodHandle PyObject_Size$handle() {
        return PyObject_Size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyObject_Size(PyObject *o)
     * }
     */
    public static MemorySegment PyObject_Size$address() {
        return PyObject_Size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyObject_Size(PyObject *o)
     * }
     */
    public static long PyObject_Size(MemorySegment o) {
        var mh$ = PyObject_Size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Size", o);
            }
            return (long)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Length {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Length");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyObject_Length(PyObject *o)
     * }
     */
    public static FunctionDescriptor PyObject_Length$descriptor() {
        return PyObject_Length.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyObject_Length(PyObject *o)
     * }
     */
    public static MethodHandle PyObject_Length$handle() {
        return PyObject_Length.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyObject_Length(PyObject *o)
     * }
     */
    public static MemorySegment PyObject_Length$address() {
        return PyObject_Length.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyObject_Length(PyObject *o)
     * }
     */
    public static long PyObject_Length(MemorySegment o) {
        var mh$ = PyObject_Length.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Length", o);
            }
            return (long)mh$.invokeExact(o);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GetItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GetItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetItem(PyObject *o, PyObject *key)
     * }
     */
    public static FunctionDescriptor PyObject_GetItem$descriptor() {
        return PyObject_GetItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetItem(PyObject *o, PyObject *key)
     * }
     */
    public static MethodHandle PyObject_GetItem$handle() {
        return PyObject_GetItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetItem(PyObject *o, PyObject *key)
     * }
     */
    public static MemorySegment PyObject_GetItem$address() {
        return PyObject_GetItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_GetItem(PyObject *o, PyObject *key)
     * }
     */
    public static MemorySegment PyObject_GetItem(MemorySegment o, MemorySegment key) {
        var mh$ = PyObject_GetItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GetItem", o, key);
            }
            return (MemorySegment)mh$.invokeExact(o, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

