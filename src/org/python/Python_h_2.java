// Generated by jextract

package org.python;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class Python_h_2 extends Python_h_3 {

    Python_h_2() {
        // Should not be called directly
    }

    private static class strncmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strncmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor strncmp$descriptor() {
        return strncmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MethodHandle strncmp$handle() {
        return strncmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MemorySegment strncmp$address() {
        return strncmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static int strncmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = strncmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static FunctionDescriptor strncpy$descriptor() {
        return strncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MethodHandle strncpy$handle() {
        return strncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MemorySegment strncpy$address() {
        return strncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MemorySegment strncpy(MemorySegment __dst, MemorySegment __src, long __n) {
        var mh$ = strncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncpy", __dst, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strpbrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strpbrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strpbrk(const char *__s, const char *__charset)
     * }
     */
    public static FunctionDescriptor strpbrk$descriptor() {
        return strpbrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strpbrk(const char *__s, const char *__charset)
     * }
     */
    public static MethodHandle strpbrk$handle() {
        return strpbrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strpbrk(const char *__s, const char *__charset)
     * }
     */
    public static MemorySegment strpbrk$address() {
        return strpbrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strpbrk(const char *__s, const char *__charset)
     * }
     */
    public static MemorySegment strpbrk(MemorySegment __s, MemorySegment __charset) {
        var mh$ = strpbrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strpbrk", __s, __charset);
            }
            return (MemorySegment)mh$.invokeExact(__s, __charset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strrchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strrchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strrchr(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor strrchr$descriptor() {
        return strrchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strrchr(const char *__s, int __c)
     * }
     */
    public static MethodHandle strrchr$handle() {
        return strrchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strrchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strrchr$address() {
        return strrchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strrchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strrchr(MemorySegment __s, int __c) {
        var mh$ = strrchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strrchr", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strspn(const char *__s, const char *__charset)
     * }
     */
    public static FunctionDescriptor strspn$descriptor() {
        return strspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strspn(const char *__s, const char *__charset)
     * }
     */
    public static MethodHandle strspn$handle() {
        return strspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strspn(const char *__s, const char *__charset)
     * }
     */
    public static MemorySegment strspn$address() {
        return strspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strspn(const char *__s, const char *__charset)
     * }
     */
    public static long strspn(MemorySegment __s, MemorySegment __charset) {
        var mh$ = strspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strspn", __s, __charset);
            }
            return (long)mh$.invokeExact(__s, __charset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strstr(const char *__big, const char *__little)
     * }
     */
    public static FunctionDescriptor strstr$descriptor() {
        return strstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strstr(const char *__big, const char *__little)
     * }
     */
    public static MethodHandle strstr$handle() {
        return strstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strstr(const char *__big, const char *__little)
     * }
     */
    public static MemorySegment strstr$address() {
        return strstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strstr(const char *__big, const char *__little)
     * }
     */
    public static MemorySegment strstr(MemorySegment __big, MemorySegment __little) {
        var mh$ = strstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strstr", __big, __little);
            }
            return (MemorySegment)mh$.invokeExact(__big, __little);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtok {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strtok");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strtok(char *__str, const char *__sep)
     * }
     */
    public static FunctionDescriptor strtok$descriptor() {
        return strtok.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strtok(char *__str, const char *__sep)
     * }
     */
    public static MethodHandle strtok$handle() {
        return strtok.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strtok(char *__str, const char *__sep)
     * }
     */
    public static MemorySegment strtok$address() {
        return strtok.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strtok(char *__str, const char *__sep)
     * }
     */
    public static MemorySegment strtok(MemorySegment __str, MemorySegment __sep) {
        var mh$ = strtok.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtok", __str, __sep);
            }
            return (MemorySegment)mh$.invokeExact(__str, __sep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strxfrm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strxfrm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strxfrm(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor strxfrm$descriptor() {
        return strxfrm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strxfrm(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MethodHandle strxfrm$handle() {
        return strxfrm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strxfrm(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MemorySegment strxfrm$address() {
        return strxfrm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strxfrm(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static long strxfrm(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = strxfrm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strxfrm", __s1, __s2, __n);
            }
            return (long)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtok_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strtok_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strtok_r(char *__str, const char *__sep, char **__lasts)
     * }
     */
    public static FunctionDescriptor strtok_r$descriptor() {
        return strtok_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strtok_r(char *__str, const char *__sep, char **__lasts)
     * }
     */
    public static MethodHandle strtok_r$handle() {
        return strtok_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strtok_r(char *__str, const char *__sep, char **__lasts)
     * }
     */
    public static MemorySegment strtok_r$address() {
        return strtok_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strtok_r(char *__str, const char *__sep, char **__lasts)
     * }
     */
    public static MemorySegment strtok_r(MemorySegment __str, MemorySegment __sep, MemorySegment __lasts) {
        var mh$ = strtok_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtok_r", __str, __sep, __lasts);
            }
            return (MemorySegment)mh$.invokeExact(__str, __sep, __lasts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strerror_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)
     * }
     */
    public static FunctionDescriptor strerror_r$descriptor() {
        return strerror_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)
     * }
     */
    public static MethodHandle strerror_r$handle() {
        return strerror_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)
     * }
     */
    public static MemorySegment strerror_r$address() {
        return strerror_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)
     * }
     */
    public static int strerror_r(int __errnum, MemorySegment __strerrbuf, long __buflen) {
        var mh$ = strerror_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror_r", __errnum, __strerrbuf, __buflen);
            }
            return (int)mh$.invokeExact(__errnum, __strerrbuf, __buflen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strdup(const char *__s1)
     * }
     */
    public static FunctionDescriptor strdup$descriptor() {
        return strdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strdup(const char *__s1)
     * }
     */
    public static MethodHandle strdup$handle() {
        return strdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strdup(const char *__s1)
     * }
     */
    public static MemorySegment strdup$address() {
        return strdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strdup(const char *__s1)
     * }
     */
    public static MemorySegment strdup(MemorySegment __s1) {
        var mh$ = strdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strdup", __s1);
            }
            return (MemorySegment)mh$.invokeExact(__s1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memccpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("memccpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memccpy(void *__dst, const void *__src, int __c, size_t __n)
     * }
     */
    public static FunctionDescriptor memccpy$descriptor() {
        return memccpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memccpy(void *__dst, const void *__src, int __c, size_t __n)
     * }
     */
    public static MethodHandle memccpy$handle() {
        return memccpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memccpy(void *__dst, const void *__src, int __c, size_t __n)
     * }
     */
    public static MemorySegment memccpy$address() {
        return memccpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memccpy(void *__dst, const void *__src, int __c, size_t __n)
     * }
     */
    public static MemorySegment memccpy(MemorySegment __dst, MemorySegment __src, int __c, long __n) {
        var mh$ = memccpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memccpy", __dst, __src, __c, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src, __c, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("stpcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *stpcpy(char *__dst, const char *__src)
     * }
     */
    public static FunctionDescriptor stpcpy$descriptor() {
        return stpcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *stpcpy(char *__dst, const char *__src)
     * }
     */
    public static MethodHandle stpcpy$handle() {
        return stpcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *stpcpy(char *__dst, const char *__src)
     * }
     */
    public static MemorySegment stpcpy$address() {
        return stpcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *stpcpy(char *__dst, const char *__src)
     * }
     */
    public static MemorySegment stpcpy(MemorySegment __dst, MemorySegment __src) {
        var mh$ = stpcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpcpy", __dst, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("stpncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *stpncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static FunctionDescriptor stpncpy$descriptor() {
        return stpncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *stpncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MethodHandle stpncpy$handle() {
        return stpncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *stpncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MemorySegment stpncpy$address() {
        return stpncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *stpncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MemorySegment stpncpy(MemorySegment __dst, MemorySegment __src, long __n) {
        var mh$ = stpncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpncpy", __dst, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strndup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strndup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strndup(const char *__s1, size_t __n)
     * }
     */
    public static FunctionDescriptor strndup$descriptor() {
        return strndup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strndup(const char *__s1, size_t __n)
     * }
     */
    public static MethodHandle strndup$handle() {
        return strndup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strndup(const char *__s1, size_t __n)
     * }
     */
    public static MemorySegment strndup$address() {
        return strndup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strndup(const char *__s1, size_t __n)
     * }
     */
    public static MemorySegment strndup(MemorySegment __s1, long __n) {
        var mh$ = strndup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strndup", __s1, __n);
            }
            return (MemorySegment)mh$.invokeExact(__s1, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strnlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strnlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t strnlen(const char *__s1, size_t __n)
     * }
     */
    public static FunctionDescriptor strnlen$descriptor() {
        return strnlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t strnlen(const char *__s1, size_t __n)
     * }
     */
    public static MethodHandle strnlen$handle() {
        return strnlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t strnlen(const char *__s1, size_t __n)
     * }
     */
    public static MemorySegment strnlen$address() {
        return strnlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t strnlen(const char *__s1, size_t __n)
     * }
     */
    public static long strnlen(MemorySegment __s1, long __n) {
        var mh$ = strnlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strnlen", __s1, __n);
            }
            return (long)mh$.invokeExact(__s1, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsignal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strsignal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strsignal(int __sig)
     * }
     */
    public static FunctionDescriptor strsignal$descriptor() {
        return strsignal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strsignal(int __sig)
     * }
     */
    public static MethodHandle strsignal$handle() {
        return strsignal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strsignal(int __sig)
     * }
     */
    public static MemorySegment strsignal$address() {
        return strsignal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strsignal(int __sig)
     * }
     */
    public static MemorySegment strsignal(int __sig) {
        var mh$ = strsignal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsignal", __sig);
            }
            return (MemorySegment)mh$.invokeExact(__sig);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_size_t rsize_t
     * }
     */
    public static final OfLong rsize_t = Python_h.C_LONG;

    private static class memset_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_INT,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("memset_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
     * }
     */
    public static FunctionDescriptor memset_s$descriptor() {
        return memset_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
     * }
     */
    public static MethodHandle memset_s$handle() {
        return memset_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
     * }
     */
    public static MemorySegment memset_s$address() {
        return memset_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
     * }
     */
    public static int memset_s(MemorySegment __s, long __smax, int __c, long __n) {
        var mh$ = memset_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset_s", __s, __smax, __c, __n);
            }
            return (int)mh$.invokeExact(__s, __smax, __c, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memmem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("memmem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memmem(const void *__big, size_t __big_len, const void *__little, size_t __little_len)
     * }
     */
    public static FunctionDescriptor memmem$descriptor() {
        return memmem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memmem(const void *__big, size_t __big_len, const void *__little, size_t __little_len)
     * }
     */
    public static MethodHandle memmem$handle() {
        return memmem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memmem(const void *__big, size_t __big_len, const void *__little, size_t __little_len)
     * }
     */
    public static MemorySegment memmem$address() {
        return memmem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memmem(const void *__big, size_t __big_len, const void *__little, size_t __little_len)
     * }
     */
    public static MemorySegment memmem(MemorySegment __big, long __big_len, MemorySegment __little, long __little_len) {
        var mh$ = memmem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memmem", __big, __big_len, __little, __little_len);
            }
            return (MemorySegment)mh$.invokeExact(__big, __big_len, __little, __little_len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset_pattern4 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("memset_pattern4");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void memset_pattern4(void *__b, const void *__pattern4, size_t __len)
     * }
     */
    public static FunctionDescriptor memset_pattern4$descriptor() {
        return memset_pattern4.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void memset_pattern4(void *__b, const void *__pattern4, size_t __len)
     * }
     */
    public static MethodHandle memset_pattern4$handle() {
        return memset_pattern4.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void memset_pattern4(void *__b, const void *__pattern4, size_t __len)
     * }
     */
    public static MemorySegment memset_pattern4$address() {
        return memset_pattern4.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void memset_pattern4(void *__b, const void *__pattern4, size_t __len)
     * }
     */
    public static void memset_pattern4(MemorySegment __b, MemorySegment __pattern4, long __len) {
        var mh$ = memset_pattern4.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset_pattern4", __b, __pattern4, __len);
            }
            mh$.invokeExact(__b, __pattern4, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset_pattern8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("memset_pattern8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void memset_pattern8(void *__b, const void *__pattern8, size_t __len)
     * }
     */
    public static FunctionDescriptor memset_pattern8$descriptor() {
        return memset_pattern8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void memset_pattern8(void *__b, const void *__pattern8, size_t __len)
     * }
     */
    public static MethodHandle memset_pattern8$handle() {
        return memset_pattern8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void memset_pattern8(void *__b, const void *__pattern8, size_t __len)
     * }
     */
    public static MemorySegment memset_pattern8$address() {
        return memset_pattern8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void memset_pattern8(void *__b, const void *__pattern8, size_t __len)
     * }
     */
    public static void memset_pattern8(MemorySegment __b, MemorySegment __pattern8, long __len) {
        var mh$ = memset_pattern8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset_pattern8", __b, __pattern8, __len);
            }
            mh$.invokeExact(__b, __pattern8, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset_pattern16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("memset_pattern16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
     * }
     */
    public static FunctionDescriptor memset_pattern16$descriptor() {
        return memset_pattern16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
     * }
     */
    public static MethodHandle memset_pattern16$handle() {
        return memset_pattern16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
     * }
     */
    public static MemorySegment memset_pattern16$address() {
        return memset_pattern16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
     * }
     */
    public static void memset_pattern16(MemorySegment __b, MemorySegment __pattern16, long __len) {
        var mh$ = memset_pattern16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset_pattern16", __b, __pattern16, __len);
            }
            mh$.invokeExact(__b, __pattern16, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcasestr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strcasestr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strcasestr(const char *__big, const char *__little)
     * }
     */
    public static FunctionDescriptor strcasestr$descriptor() {
        return strcasestr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strcasestr(const char *__big, const char *__little)
     * }
     */
    public static MethodHandle strcasestr$handle() {
        return strcasestr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strcasestr(const char *__big, const char *__little)
     * }
     */
    public static MemorySegment strcasestr$address() {
        return strcasestr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strcasestr(const char *__big, const char *__little)
     * }
     */
    public static MemorySegment strcasestr(MemorySegment __big, MemorySegment __little) {
        var mh$ = strcasestr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcasestr", __big, __little);
            }
            return (MemorySegment)mh$.invokeExact(__big, __little);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strnstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strnstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strnstr(const char *__big, const char *__little, size_t __len)
     * }
     */
    public static FunctionDescriptor strnstr$descriptor() {
        return strnstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strnstr(const char *__big, const char *__little, size_t __len)
     * }
     */
    public static MethodHandle strnstr$handle() {
        return strnstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strnstr(const char *__big, const char *__little, size_t __len)
     * }
     */
    public static MemorySegment strnstr$address() {
        return strnstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strnstr(const char *__big, const char *__little, size_t __len)
     * }
     */
    public static MemorySegment strnstr(MemorySegment __big, MemorySegment __little, long __len) {
        var mh$ = strnstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strnstr", __big, __little, __len);
            }
            return (MemorySegment)mh$.invokeExact(__big, __little, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlcat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strlcat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strlcat(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static FunctionDescriptor strlcat$descriptor() {
        return strlcat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strlcat(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static MethodHandle strlcat$handle() {
        return strlcat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strlcat(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static MemorySegment strlcat$address() {
        return strlcat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strlcat(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static long strlcat(MemorySegment __dst, MemorySegment __source, long __size) {
        var mh$ = strlcat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlcat", __dst, __source, __size);
            }
            return (long)mh$.invokeExact(__dst, __source, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strlcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strlcpy(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static FunctionDescriptor strlcpy$descriptor() {
        return strlcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strlcpy(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static MethodHandle strlcpy$handle() {
        return strlcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strlcpy(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static MemorySegment strlcpy$address() {
        return strlcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strlcpy(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static long strlcpy(MemorySegment __dst, MemorySegment __source, long __size) {
        var mh$ = strlcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlcpy", __dst, __source, __size);
            }
            return (long)mh$.invokeExact(__dst, __source, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strmode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strmode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void strmode(int __mode, char *__bp)
     * }
     */
    public static FunctionDescriptor strmode$descriptor() {
        return strmode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void strmode(int __mode, char *__bp)
     * }
     */
    public static MethodHandle strmode$handle() {
        return strmode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void strmode(int __mode, char *__bp)
     * }
     */
    public static MemorySegment strmode$address() {
        return strmode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void strmode(int __mode, char *__bp)
     * }
     */
    public static void strmode(int __mode, MemorySegment __bp) {
        var mh$ = strmode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strmode", __mode, __bp);
            }
            mh$.invokeExact(__mode, __bp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strsep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strsep(char **__stringp, const char *__delim)
     * }
     */
    public static FunctionDescriptor strsep$descriptor() {
        return strsep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strsep(char **__stringp, const char *__delim)
     * }
     */
    public static MethodHandle strsep$handle() {
        return strsep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strsep(char **__stringp, const char *__delim)
     * }
     */
    public static MemorySegment strsep$address() {
        return strsep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strsep(char **__stringp, const char *__delim)
     * }
     */
    public static MemorySegment strsep(MemorySegment __stringp, MemorySegment __delim) {
        var mh$ = strsep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsep", __stringp, __delim);
            }
            return (MemorySegment)mh$.invokeExact(__stringp, __delim);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class swab {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("swab");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void swab(const void *restrict, void *restrict, ssize_t)
     * }
     */
    public static FunctionDescriptor swab$descriptor() {
        return swab.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void swab(const void *restrict, void *restrict, ssize_t)
     * }
     */
    public static MethodHandle swab$handle() {
        return swab.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void swab(const void *restrict, void *restrict, ssize_t)
     * }
     */
    public static MemorySegment swab$address() {
        return swab.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void swab(const void *restrict, void *restrict, ssize_t)
     * }
     */
    public static void swab(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = swab.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("swab", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timingsafe_bcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("timingsafe_bcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int timingsafe_bcmp(const void *__b1, const void *__b2, size_t __len)
     * }
     */
    public static FunctionDescriptor timingsafe_bcmp$descriptor() {
        return timingsafe_bcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int timingsafe_bcmp(const void *__b1, const void *__b2, size_t __len)
     * }
     */
    public static MethodHandle timingsafe_bcmp$handle() {
        return timingsafe_bcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int timingsafe_bcmp(const void *__b1, const void *__b2, size_t __len)
     * }
     */
    public static MemorySegment timingsafe_bcmp$address() {
        return timingsafe_bcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int timingsafe_bcmp(const void *__b1, const void *__b2, size_t __len)
     * }
     */
    public static int timingsafe_bcmp(MemorySegment __b1, MemorySegment __b2, long __len) {
        var mh$ = timingsafe_bcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timingsafe_bcmp", __b1, __b2, __len);
            }
            return (int)mh$.invokeExact(__b1, __b2, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsignal_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strsignal_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strsignal_r(int __sig, char *__strsignalbuf, size_t __buflen)
     * }
     */
    public static FunctionDescriptor strsignal_r$descriptor() {
        return strsignal_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strsignal_r(int __sig, char *__strsignalbuf, size_t __buflen)
     * }
     */
    public static MethodHandle strsignal_r$handle() {
        return strsignal_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strsignal_r(int __sig, char *__strsignalbuf, size_t __buflen)
     * }
     */
    public static MemorySegment strsignal_r$address() {
        return strsignal_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strsignal_r(int __sig, char *__strsignalbuf, size_t __buflen)
     * }
     */
    public static int strsignal_r(int __sig, MemorySegment __strsignalbuf, long __buflen) {
        var mh$ = strsignal_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsignal_r", __sig, __strsignalbuf, __buflen);
            }
            return (int)mh$.invokeExact(__sig, __strsignalbuf, __buflen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("bcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int bcmp(const void *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor bcmp$descriptor() {
        return bcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int bcmp(const void *, const void *, size_t)
     * }
     */
    public static MethodHandle bcmp$handle() {
        return bcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int bcmp(const void *, const void *, size_t)
     * }
     */
    public static MemorySegment bcmp$address() {
        return bcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int bcmp(const void *, const void *, size_t)
     * }
     */
    public static int bcmp(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = bcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bcmp", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("bcopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void bcopy(const void *, void *, size_t)
     * }
     */
    public static FunctionDescriptor bcopy$descriptor() {
        return bcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void bcopy(const void *, void *, size_t)
     * }
     */
    public static MethodHandle bcopy$handle() {
        return bcopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void bcopy(const void *, void *, size_t)
     * }
     */
    public static MemorySegment bcopy$address() {
        return bcopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void bcopy(const void *, void *, size_t)
     * }
     */
    public static void bcopy(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = bcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bcopy", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bzero {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("bzero");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void bzero(void *, size_t)
     * }
     */
    public static FunctionDescriptor bzero$descriptor() {
        return bzero.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void bzero(void *, size_t)
     * }
     */
    public static MethodHandle bzero$handle() {
        return bzero.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void bzero(void *, size_t)
     * }
     */
    public static MemorySegment bzero$address() {
        return bzero.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void bzero(void *, size_t)
     * }
     */
    public static void bzero(MemorySegment x0, long x1) {
        var mh$ = bzero.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bzero", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *index(const char *, int)
     * }
     */
    public static FunctionDescriptor index$descriptor() {
        return index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *index(const char *, int)
     * }
     */
    public static MethodHandle index$handle() {
        return index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *index(const char *, int)
     * }
     */
    public static MemorySegment index$address() {
        return index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *index(const char *, int)
     * }
     */
    public static MemorySegment index(MemorySegment x0, int x1) {
        var mh$ = index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("index", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rindex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("rindex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *rindex(const char *, int)
     * }
     */
    public static FunctionDescriptor rindex$descriptor() {
        return rindex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *rindex(const char *, int)
     * }
     */
    public static MethodHandle rindex$handle() {
        return rindex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *rindex(const char *, int)
     * }
     */
    public static MemorySegment rindex$address() {
        return rindex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *rindex(const char *, int)
     * }
     */
    public static MemorySegment rindex(MemorySegment x0, int x1) {
        var mh$ = rindex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rindex", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ffs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ffs(int)
     * }
     */
    public static FunctionDescriptor ffs$descriptor() {
        return ffs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ffs(int)
     * }
     */
    public static MethodHandle ffs$handle() {
        return ffs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ffs(int)
     * }
     */
    public static MemorySegment ffs$address() {
        return ffs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ffs(int)
     * }
     */
    public static int ffs(int x0) {
        var mh$ = ffs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffs", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcasecmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strcasecmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strcasecmp(const char *, const char *)
     * }
     */
    public static FunctionDescriptor strcasecmp$descriptor() {
        return strcasecmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strcasecmp(const char *, const char *)
     * }
     */
    public static MethodHandle strcasecmp$handle() {
        return strcasecmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strcasecmp(const char *, const char *)
     * }
     */
    public static MemorySegment strcasecmp$address() {
        return strcasecmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strcasecmp(const char *, const char *)
     * }
     */
    public static int strcasecmp(MemorySegment x0, MemorySegment x1) {
        var mh$ = strcasecmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcasecmp", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncasecmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strncasecmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strncasecmp(const char *, const char *, size_t)
     * }
     */
    public static FunctionDescriptor strncasecmp$descriptor() {
        return strncasecmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strncasecmp(const char *, const char *, size_t)
     * }
     */
    public static MethodHandle strncasecmp$handle() {
        return strncasecmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strncasecmp(const char *, const char *, size_t)
     * }
     */
    public static MemorySegment strncasecmp$address() {
        return strncasecmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strncasecmp(const char *, const char *, size_t)
     * }
     */
    public static int strncasecmp(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = strncasecmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncasecmp", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffsl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ffsl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ffsl(long)
     * }
     */
    public static FunctionDescriptor ffsl$descriptor() {
        return ffsl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ffsl(long)
     * }
     */
    public static MethodHandle ffsl$handle() {
        return ffsl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ffsl(long)
     * }
     */
    public static MemorySegment ffsl$address() {
        return ffsl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ffsl(long)
     * }
     */
    public static int ffsl(long x0) {
        var mh$ = ffsl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffsl", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffsll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ffsll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ffsll(long long)
     * }
     */
    public static FunctionDescriptor ffsll$descriptor() {
        return ffsll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ffsll(long long)
     * }
     */
    public static MethodHandle ffsll$handle() {
        return ffsll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ffsll(long long)
     * }
     */
    public static MemorySegment ffsll$address() {
        return ffsll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ffsll(long long)
     * }
     */
    public static int ffsll(long x0) {
        var mh$ = ffsll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffsll", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fls(int)
     * }
     */
    public static FunctionDescriptor fls$descriptor() {
        return fls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fls(int)
     * }
     */
    public static MethodHandle fls$handle() {
        return fls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fls(int)
     * }
     */
    public static MemorySegment fls$address() {
        return fls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fls(int)
     * }
     */
    public static int fls(int x0) {
        var mh$ = fls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fls", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flsl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("flsl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int flsl(long)
     * }
     */
    public static FunctionDescriptor flsl$descriptor() {
        return flsl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int flsl(long)
     * }
     */
    public static MethodHandle flsl$handle() {
        return flsl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int flsl(long)
     * }
     */
    public static MemorySegment flsl$address() {
        return flsl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int flsl(long)
     * }
     */
    public static int flsl(long x0) {
        var mh$ = flsl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flsl", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flsll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("flsll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int flsll(long long)
     * }
     */
    public static FunctionDescriptor flsll$descriptor() {
        return flsll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int flsll(long long)
     * }
     */
    public static MethodHandle flsll$handle() {
        return flsll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int flsll(long long)
     * }
     */
    public static MemorySegment flsll$address() {
        return flsll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int flsll(long long)
     * }
     */
    public static int flsll(long x0) {
        var mh$ = flsll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flsll", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getattrlistbulk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getattrlistbulk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getattrlistbulk(int, void *, void *, size_t, uint64_t)
     * }
     */
    public static FunctionDescriptor getattrlistbulk$descriptor() {
        return getattrlistbulk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getattrlistbulk(int, void *, void *, size_t, uint64_t)
     * }
     */
    public static MethodHandle getattrlistbulk$handle() {
        return getattrlistbulk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getattrlistbulk(int, void *, void *, size_t, uint64_t)
     * }
     */
    public static MemorySegment getattrlistbulk$address() {
        return getattrlistbulk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getattrlistbulk(int, void *, void *, size_t, uint64_t)
     * }
     */
    public static int getattrlistbulk(int x0, MemorySegment x1, MemorySegment x2, long x3, long x4) {
        var mh$ = getattrlistbulk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getattrlistbulk", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getattrlistat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getattrlistat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getattrlistat(int, const char *, void *, void *, size_t, unsigned long)
     * }
     */
    public static FunctionDescriptor getattrlistat$descriptor() {
        return getattrlistat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getattrlistat(int, const char *, void *, void *, size_t, unsigned long)
     * }
     */
    public static MethodHandle getattrlistat$handle() {
        return getattrlistat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getattrlistat(int, const char *, void *, void *, size_t, unsigned long)
     * }
     */
    public static MemorySegment getattrlistat$address() {
        return getattrlistat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getattrlistat(int, const char *, void *, void *, size_t, unsigned long)
     * }
     */
    public static int getattrlistat(int x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, long x5) {
        var mh$ = getattrlistat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getattrlistat", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setattrlistat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setattrlistat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setattrlistat(int, const char *, void *, void *, size_t, uint32_t)
     * }
     */
    public static FunctionDescriptor setattrlistat$descriptor() {
        return setattrlistat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setattrlistat(int, const char *, void *, void *, size_t, uint32_t)
     * }
     */
    public static MethodHandle setattrlistat$handle() {
        return setattrlistat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setattrlistat(int, const char *, void *, void *, size_t, uint32_t)
     * }
     */
    public static MemorySegment setattrlistat$address() {
        return setattrlistat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setattrlistat(int, const char *, void *, void *, size_t, uint32_t)
     * }
     */
    public static int setattrlistat(int x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = setattrlistat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setattrlistat", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class freadlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("freadlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t freadlink(int, char *restrict, size_t)
     * }
     */
    public static FunctionDescriptor freadlink$descriptor() {
        return freadlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t freadlink(int, char *restrict, size_t)
     * }
     */
    public static MethodHandle freadlink$handle() {
        return freadlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t freadlink(int, char *restrict, size_t)
     * }
     */
    public static MemorySegment freadlink$address() {
        return freadlink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t freadlink(int, char *restrict, size_t)
     * }
     */
    public static long freadlink(int x0, MemorySegment x1, long x2) {
        var mh$ = freadlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("freadlink", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_gid_t gid_t
     * }
     */
    public static final OfInt gid_t = Python_h.C_INT;

    private static class faccessat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("faccessat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int faccessat(int, const char *, int, int)
     * }
     */
    public static FunctionDescriptor faccessat$descriptor() {
        return faccessat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int faccessat(int, const char *, int, int)
     * }
     */
    public static MethodHandle faccessat$handle() {
        return faccessat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int faccessat(int, const char *, int, int)
     * }
     */
    public static MemorySegment faccessat$address() {
        return faccessat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int faccessat(int, const char *, int, int)
     * }
     */
    public static int faccessat(int x0, MemorySegment x1, int x2, int x3) {
        var mh$ = faccessat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("faccessat", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fchownat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fchownat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fchownat(int, const char *, uid_t, gid_t, int)
     * }
     */
    public static FunctionDescriptor fchownat$descriptor() {
        return fchownat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fchownat(int, const char *, uid_t, gid_t, int)
     * }
     */
    public static MethodHandle fchownat$handle() {
        return fchownat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fchownat(int, const char *, uid_t, gid_t, int)
     * }
     */
    public static MemorySegment fchownat$address() {
        return fchownat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fchownat(int, const char *, uid_t, gid_t, int)
     * }
     */
    public static int fchownat(int x0, MemorySegment x1, int x2, int x3, int x4) {
        var mh$ = fchownat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fchownat", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class linkat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("linkat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int linkat(int, const char *, int, const char *, int)
     * }
     */
    public static FunctionDescriptor linkat$descriptor() {
        return linkat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int linkat(int, const char *, int, const char *, int)
     * }
     */
    public static MethodHandle linkat$handle() {
        return linkat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int linkat(int, const char *, int, const char *, int)
     * }
     */
    public static MemorySegment linkat$address() {
        return linkat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int linkat(int, const char *, int, const char *, int)
     * }
     */
    public static int linkat(int x0, MemorySegment x1, int x2, MemorySegment x3, int x4) {
        var mh$ = linkat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("linkat", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class readlinkat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("readlinkat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t readlinkat(int, const char *, char *, size_t)
     * }
     */
    public static FunctionDescriptor readlinkat$descriptor() {
        return readlinkat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t readlinkat(int, const char *, char *, size_t)
     * }
     */
    public static MethodHandle readlinkat$handle() {
        return readlinkat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t readlinkat(int, const char *, char *, size_t)
     * }
     */
    public static MemorySegment readlinkat$address() {
        return readlinkat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t readlinkat(int, const char *, char *, size_t)
     * }
     */
    public static long readlinkat(int x0, MemorySegment x1, MemorySegment x2, long x3) {
        var mh$ = readlinkat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("readlinkat", x0, x1, x2, x3);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class symlinkat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("symlinkat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int symlinkat(const char *, int, const char *)
     * }
     */
    public static FunctionDescriptor symlinkat$descriptor() {
        return symlinkat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int symlinkat(const char *, int, const char *)
     * }
     */
    public static MethodHandle symlinkat$handle() {
        return symlinkat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int symlinkat(const char *, int, const char *)
     * }
     */
    public static MemorySegment symlinkat$address() {
        return symlinkat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int symlinkat(const char *, int, const char *)
     * }
     */
    public static int symlinkat(MemorySegment x0, int x1, MemorySegment x2) {
        var mh$ = symlinkat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("symlinkat", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unlinkat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("unlinkat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int unlinkat(int, const char *, int)
     * }
     */
    public static FunctionDescriptor unlinkat$descriptor() {
        return unlinkat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int unlinkat(int, const char *, int)
     * }
     */
    public static MethodHandle unlinkat$handle() {
        return unlinkat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int unlinkat(int, const char *, int)
     * }
     */
    public static MemorySegment unlinkat$address() {
        return unlinkat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int unlinkat(int, const char *, int)
     * }
     */
    public static int unlinkat(int x0, MemorySegment x1, int x2) {
        var mh$ = unlinkat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unlinkat", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_useconds_t useconds_t
     * }
     */
    public static final OfInt useconds_t = Python_h.C_INT;

    private static class _exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _exit(int)
     * }
     */
    public static FunctionDescriptor _exit$descriptor() {
        return _exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _exit(int)
     * }
     */
    public static MethodHandle _exit$handle() {
        return _exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _exit(int)
     * }
     */
    public static MemorySegment _exit$address() {
        return _exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _exit(int)
     * }
     */
    public static void _exit(int x0) {
        var mh$ = _exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_exit", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class access {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("access");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int access(const char *, int)
     * }
     */
    public static FunctionDescriptor access$descriptor() {
        return access.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int access(const char *, int)
     * }
     */
    public static MethodHandle access$handle() {
        return access.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int access(const char *, int)
     * }
     */
    public static MemorySegment access$address() {
        return access.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int access(const char *, int)
     * }
     */
    public static int access(MemorySegment x0, int x1) {
        var mh$ = access.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("access", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class alarm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("alarm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int alarm(unsigned int)
     * }
     */
    public static FunctionDescriptor alarm$descriptor() {
        return alarm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int alarm(unsigned int)
     * }
     */
    public static MethodHandle alarm$handle() {
        return alarm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int alarm(unsigned int)
     * }
     */
    public static MemorySegment alarm$address() {
        return alarm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int alarm(unsigned int)
     * }
     */
    public static int alarm(int x0) {
        var mh$ = alarm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("alarm", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chdir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("chdir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chdir(const char *)
     * }
     */
    public static FunctionDescriptor chdir$descriptor() {
        return chdir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chdir(const char *)
     * }
     */
    public static MethodHandle chdir$handle() {
        return chdir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chdir(const char *)
     * }
     */
    public static MemorySegment chdir$address() {
        return chdir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chdir(const char *)
     * }
     */
    public static int chdir(MemorySegment x0) {
        var mh$ = chdir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chdir", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chown {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("chown");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chown(const char *, uid_t, gid_t)
     * }
     */
    public static FunctionDescriptor chown$descriptor() {
        return chown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chown(const char *, uid_t, gid_t)
     * }
     */
    public static MethodHandle chown$handle() {
        return chown.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chown(const char *, uid_t, gid_t)
     * }
     */
    public static MemorySegment chown$address() {
        return chown.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chown(const char *, uid_t, gid_t)
     * }
     */
    public static int chown(MemorySegment x0, int x1, int x2) {
        var mh$ = chown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chown", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class close {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("close");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int close(int)
     * }
     */
    public static FunctionDescriptor close$descriptor() {
        return close.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int close(int)
     * }
     */
    public static MethodHandle close$handle() {
        return close.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int close(int)
     * }
     */
    public static MemorySegment close$address() {
        return close.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int close(int)
     * }
     */
    public static int close(int x0) {
        var mh$ = close.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("close", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("dup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dup(int)
     * }
     */
    public static FunctionDescriptor dup$descriptor() {
        return dup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dup(int)
     * }
     */
    public static MethodHandle dup$handle() {
        return dup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dup(int)
     * }
     */
    public static MemorySegment dup$address() {
        return dup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dup(int)
     * }
     */
    public static int dup(int x0) {
        var mh$ = dup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dup", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dup2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("dup2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dup2(int, int)
     * }
     */
    public static FunctionDescriptor dup2$descriptor() {
        return dup2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dup2(int, int)
     * }
     */
    public static MethodHandle dup2$handle() {
        return dup2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dup2(int, int)
     * }
     */
    public static MemorySegment dup2$address() {
        return dup2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dup2(int, int)
     * }
     */
    public static int dup2(int x0, int x1) {
        var mh$ = dup2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dup2", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int execl(const char *__path, const char *__arg0, ...)
     * }
     */
    public static class execl {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("execl");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private execl(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int execl(const char *__path, const char *__arg0, ...)
         * }
         */
        public static execl makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new execl(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __path, MemorySegment __arg0, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("execl", __path, __arg0, x2);
                }
                return (int)spreader.invokeExact(__path, __arg0, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int execle(const char *__path, const char *__arg0, ...)
     * }
     */
    public static class execle {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("execle");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private execle(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int execle(const char *__path, const char *__arg0, ...)
         * }
         */
        public static execle makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new execle(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __path, MemorySegment __arg0, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("execle", __path, __arg0, x2);
                }
                return (int)spreader.invokeExact(__path, __arg0, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int execlp(const char *__file, const char *__arg0, ...)
     * }
     */
    public static class execlp {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("execlp");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private execlp(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int execlp(const char *__file, const char *__arg0, ...)
         * }
         */
        public static execlp makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new execlp(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __file, MemorySegment __arg0, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("execlp", __file, __arg0, x2);
                }
                return (int)spreader.invokeExact(__file, __arg0, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class execv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("execv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int execv(const char *__path, char *const *__argv)
     * }
     */
    public static FunctionDescriptor execv$descriptor() {
        return execv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int execv(const char *__path, char *const *__argv)
     * }
     */
    public static MethodHandle execv$handle() {
        return execv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int execv(const char *__path, char *const *__argv)
     * }
     */
    public static MemorySegment execv$address() {
        return execv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int execv(const char *__path, char *const *__argv)
     * }
     */
    public static int execv(MemorySegment __path, MemorySegment __argv) {
        var mh$ = execv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("execv", __path, __argv);
            }
            return (int)mh$.invokeExact(__path, __argv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class execve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("execve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int execve(const char *__file, char *const *__argv, char *const *__envp)
     * }
     */
    public static FunctionDescriptor execve$descriptor() {
        return execve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int execve(const char *__file, char *const *__argv, char *const *__envp)
     * }
     */
    public static MethodHandle execve$handle() {
        return execve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int execve(const char *__file, char *const *__argv, char *const *__envp)
     * }
     */
    public static MemorySegment execve$address() {
        return execve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int execve(const char *__file, char *const *__argv, char *const *__envp)
     * }
     */
    public static int execve(MemorySegment __file, MemorySegment __argv, MemorySegment __envp) {
        var mh$ = execve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("execve", __file, __argv, __envp);
            }
            return (int)mh$.invokeExact(__file, __argv, __envp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class execvp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("execvp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int execvp(const char *__file, char *const *__argv)
     * }
     */
    public static FunctionDescriptor execvp$descriptor() {
        return execvp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int execvp(const char *__file, char *const *__argv)
     * }
     */
    public static MethodHandle execvp$handle() {
        return execvp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int execvp(const char *__file, char *const *__argv)
     * }
     */
    public static MemorySegment execvp$address() {
        return execvp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int execvp(const char *__file, char *const *__argv)
     * }
     */
    public static int execvp(MemorySegment __file, MemorySegment __argv) {
        var mh$ = execvp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("execvp", __file, __argv);
            }
            return (int)mh$.invokeExact(__file, __argv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fork {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fork");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t fork()
     * }
     */
    public static FunctionDescriptor fork$descriptor() {
        return fork.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t fork()
     * }
     */
    public static MethodHandle fork$handle() {
        return fork.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t fork()
     * }
     */
    public static MemorySegment fork$address() {
        return fork.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t fork()
     * }
     */
    public static int fork() {
        var mh$ = fork.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fork");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fpathconf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fpathconf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long fpathconf(int, int)
     * }
     */
    public static FunctionDescriptor fpathconf$descriptor() {
        return fpathconf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long fpathconf(int, int)
     * }
     */
    public static MethodHandle fpathconf$handle() {
        return fpathconf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long fpathconf(int, int)
     * }
     */
    public static MemorySegment fpathconf$address() {
        return fpathconf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long fpathconf(int, int)
     * }
     */
    public static long fpathconf(int x0, int x1) {
        var mh$ = fpathconf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fpathconf", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getcwd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getcwd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getcwd(char *, size_t)
     * }
     */
    public static FunctionDescriptor getcwd$descriptor() {
        return getcwd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getcwd(char *, size_t)
     * }
     */
    public static MethodHandle getcwd$handle() {
        return getcwd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getcwd(char *, size_t)
     * }
     */
    public static MemorySegment getcwd$address() {
        return getcwd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getcwd(char *, size_t)
     * }
     */
    public static MemorySegment getcwd(MemorySegment x0, long x1) {
        var mh$ = getcwd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getcwd", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getegid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getegid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * gid_t getegid()
     * }
     */
    public static FunctionDescriptor getegid$descriptor() {
        return getegid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * gid_t getegid()
     * }
     */
    public static MethodHandle getegid$handle() {
        return getegid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * gid_t getegid()
     * }
     */
    public static MemorySegment getegid$address() {
        return getegid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * gid_t getegid()
     * }
     */
    public static int getegid() {
        var mh$ = getegid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getegid");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class geteuid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("geteuid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uid_t geteuid()
     * }
     */
    public static FunctionDescriptor geteuid$descriptor() {
        return geteuid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uid_t geteuid()
     * }
     */
    public static MethodHandle geteuid$handle() {
        return geteuid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uid_t geteuid()
     * }
     */
    public static MemorySegment geteuid$address() {
        return geteuid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uid_t geteuid()
     * }
     */
    public static int geteuid() {
        var mh$ = geteuid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("geteuid");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getgid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getgid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * gid_t getgid()
     * }
     */
    public static FunctionDescriptor getgid$descriptor() {
        return getgid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * gid_t getgid()
     * }
     */
    public static MethodHandle getgid$handle() {
        return getgid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * gid_t getgid()
     * }
     */
    public static MemorySegment getgid$address() {
        return getgid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * gid_t getgid()
     * }
     */
    public static int getgid() {
        var mh$ = getgid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getgid");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getgroups {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getgroups$DARWIN_EXTSN");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getgroups(int, gid_t [])
     * }
     */
    public static FunctionDescriptor getgroups$descriptor() {
        return getgroups.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getgroups(int, gid_t [])
     * }
     */
    public static MethodHandle getgroups$handle() {
        return getgroups.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getgroups(int, gid_t [])
     * }
     */
    public static MemorySegment getgroups$address() {
        return getgroups.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getgroups(int, gid_t [])
     * }
     */
    public static int getgroups(int x0, MemorySegment x1) {
        var mh$ = getgroups.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getgroups", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getlogin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getlogin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getlogin()
     * }
     */
    public static FunctionDescriptor getlogin$descriptor() {
        return getlogin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getlogin()
     * }
     */
    public static MethodHandle getlogin$handle() {
        return getlogin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getlogin()
     * }
     */
    public static MemorySegment getlogin$address() {
        return getlogin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getlogin()
     * }
     */
    public static MemorySegment getlogin() {
        var mh$ = getlogin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getlogin");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpgrp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getpgrp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t getpgrp()
     * }
     */
    public static FunctionDescriptor getpgrp$descriptor() {
        return getpgrp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t getpgrp()
     * }
     */
    public static MethodHandle getpgrp$handle() {
        return getpgrp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t getpgrp()
     * }
     */
    public static MemorySegment getpgrp$address() {
        return getpgrp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t getpgrp()
     * }
     */
    public static int getpgrp() {
        var mh$ = getpgrp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpgrp");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getpid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t getpid()
     * }
     */
    public static FunctionDescriptor getpid$descriptor() {
        return getpid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t getpid()
     * }
     */
    public static MethodHandle getpid$handle() {
        return getpid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t getpid()
     * }
     */
    public static MemorySegment getpid$address() {
        return getpid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t getpid()
     * }
     */
    public static int getpid() {
        var mh$ = getpid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpid");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getppid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getppid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t getppid()
     * }
     */
    public static FunctionDescriptor getppid$descriptor() {
        return getppid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t getppid()
     * }
     */
    public static MethodHandle getppid$handle() {
        return getppid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t getppid()
     * }
     */
    public static MemorySegment getppid$address() {
        return getppid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t getppid()
     * }
     */
    public static int getppid() {
        var mh$ = getppid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getppid");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getuid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getuid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uid_t getuid()
     * }
     */
    public static FunctionDescriptor getuid$descriptor() {
        return getuid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uid_t getuid()
     * }
     */
    public static MethodHandle getuid$handle() {
        return getuid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uid_t getuid()
     * }
     */
    public static MemorySegment getuid$address() {
        return getuid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uid_t getuid()
     * }
     */
    public static int getuid() {
        var mh$ = getuid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getuid");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isatty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("isatty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int isatty(int)
     * }
     */
    public static FunctionDescriptor isatty$descriptor() {
        return isatty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int isatty(int)
     * }
     */
    public static MethodHandle isatty$handle() {
        return isatty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int isatty(int)
     * }
     */
    public static MemorySegment isatty$address() {
        return isatty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int isatty(int)
     * }
     */
    public static int isatty(int x0) {
        var mh$ = isatty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isatty", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class link {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("link");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int link(const char *, const char *)
     * }
     */
    public static FunctionDescriptor link$descriptor() {
        return link.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int link(const char *, const char *)
     * }
     */
    public static MethodHandle link$handle() {
        return link.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int link(const char *, const char *)
     * }
     */
    public static MemorySegment link$address() {
        return link.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int link(const char *, const char *)
     * }
     */
    public static int link(MemorySegment x0, MemorySegment x1) {
        var mh$ = link.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("link", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lseek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_INT,
            Python_h.C_LONG_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lseek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * off_t lseek(int, off_t, int)
     * }
     */
    public static FunctionDescriptor lseek$descriptor() {
        return lseek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * off_t lseek(int, off_t, int)
     * }
     */
    public static MethodHandle lseek$handle() {
        return lseek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * off_t lseek(int, off_t, int)
     * }
     */
    public static MemorySegment lseek$address() {
        return lseek.ADDR;
    }

    /**
     * {@snippet lang=c :
     * off_t lseek(int, off_t, int)
     * }
     */
    public static long lseek(int x0, long x1, int x2) {
        var mh$ = lseek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lseek", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pathconf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pathconf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long pathconf(const char *, int)
     * }
     */
    public static FunctionDescriptor pathconf$descriptor() {
        return pathconf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long pathconf(const char *, int)
     * }
     */
    public static MethodHandle pathconf$handle() {
        return pathconf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long pathconf(const char *, int)
     * }
     */
    public static MemorySegment pathconf$address() {
        return pathconf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long pathconf(const char *, int)
     * }
     */
    public static long pathconf(MemorySegment x0, int x1) {
        var mh$ = pathconf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pathconf", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pause {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pause");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pause()
     * }
     */
    public static FunctionDescriptor pause$descriptor() {
        return pause.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pause()
     * }
     */
    public static MethodHandle pause$handle() {
        return pause.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pause()
     * }
     */
    public static MemorySegment pause$address() {
        return pause.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pause()
     * }
     */
    public static int pause() {
        var mh$ = pause.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pause");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pipe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pipe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pipe(int [2])
     * }
     */
    public static FunctionDescriptor pipe$descriptor() {
        return pipe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pipe(int [2])
     * }
     */
    public static MethodHandle pipe$handle() {
        return pipe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pipe(int [2])
     * }
     */
    public static MemorySegment pipe$address() {
        return pipe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pipe(int [2])
     * }
     */
    public static int pipe(MemorySegment x0) {
        var mh$ = pipe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pipe", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class read {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("read");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t read(int, void *, size_t)
     * }
     */
    public static FunctionDescriptor read$descriptor() {
        return read.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t read(int, void *, size_t)
     * }
     */
    public static MethodHandle read$handle() {
        return read.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t read(int, void *, size_t)
     * }
     */
    public static MemorySegment read$address() {
        return read.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t read(int, void *, size_t)
     * }
     */
    public static long read(int x0, MemorySegment x1, long x2) {
        var mh$ = read.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("read", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmdir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("rmdir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rmdir(const char *)
     * }
     */
    public static FunctionDescriptor rmdir$descriptor() {
        return rmdir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rmdir(const char *)
     * }
     */
    public static MethodHandle rmdir$handle() {
        return rmdir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rmdir(const char *)
     * }
     */
    public static MemorySegment rmdir$address() {
        return rmdir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rmdir(const char *)
     * }
     */
    public static int rmdir(MemorySegment x0) {
        var mh$ = rmdir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmdir", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setgid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setgid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setgid(gid_t)
     * }
     */
    public static FunctionDescriptor setgid$descriptor() {
        return setgid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setgid(gid_t)
     * }
     */
    public static MethodHandle setgid$handle() {
        return setgid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setgid(gid_t)
     * }
     */
    public static MemorySegment setgid$address() {
        return setgid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setgid(gid_t)
     * }
     */
    public static int setgid(int x0) {
        var mh$ = setgid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setgid", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setpgid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setpgid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setpgid(pid_t, pid_t)
     * }
     */
    public static FunctionDescriptor setpgid$descriptor() {
        return setpgid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setpgid(pid_t, pid_t)
     * }
     */
    public static MethodHandle setpgid$handle() {
        return setpgid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setpgid(pid_t, pid_t)
     * }
     */
    public static MemorySegment setpgid$address() {
        return setpgid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setpgid(pid_t, pid_t)
     * }
     */
    public static int setpgid(int x0, int x1) {
        var mh$ = setpgid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setpgid", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setsid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setsid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t setsid()
     * }
     */
    public static FunctionDescriptor setsid$descriptor() {
        return setsid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t setsid()
     * }
     */
    public static MethodHandle setsid$handle() {
        return setsid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t setsid()
     * }
     */
    public static MemorySegment setsid$address() {
        return setsid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t setsid()
     * }
     */
    public static int setsid() {
        var mh$ = setsid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setsid");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setuid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setuid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setuid(uid_t)
     * }
     */
    public static FunctionDescriptor setuid$descriptor() {
        return setuid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setuid(uid_t)
     * }
     */
    public static MethodHandle setuid$handle() {
        return setuid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setuid(uid_t)
     * }
     */
    public static MemorySegment setuid$address() {
        return setuid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setuid(uid_t)
     * }
     */
    public static int setuid(int x0) {
        var mh$ = setuid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setuid", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int sleep(unsigned int)
     * }
     */
    public static FunctionDescriptor sleep$descriptor() {
        return sleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int sleep(unsigned int)
     * }
     */
    public static MethodHandle sleep$handle() {
        return sleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int sleep(unsigned int)
     * }
     */
    public static MemorySegment sleep$address() {
        return sleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int sleep(unsigned int)
     * }
     */
    public static int sleep(int x0) {
        var mh$ = sleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sleep", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sysconf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sysconf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long sysconf(int)
     * }
     */
    public static FunctionDescriptor sysconf$descriptor() {
        return sysconf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long sysconf(int)
     * }
     */
    public static MethodHandle sysconf$handle() {
        return sysconf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long sysconf(int)
     * }
     */
    public static MemorySegment sysconf$address() {
        return sysconf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long sysconf(int)
     * }
     */
    public static long sysconf(int x0) {
        var mh$ = sysconf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sysconf", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tcgetpgrp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tcgetpgrp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t tcgetpgrp(int)
     * }
     */
    public static FunctionDescriptor tcgetpgrp$descriptor() {
        return tcgetpgrp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t tcgetpgrp(int)
     * }
     */
    public static MethodHandle tcgetpgrp$handle() {
        return tcgetpgrp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t tcgetpgrp(int)
     * }
     */
    public static MemorySegment tcgetpgrp$address() {
        return tcgetpgrp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t tcgetpgrp(int)
     * }
     */
    public static int tcgetpgrp(int x0) {
        var mh$ = tcgetpgrp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tcgetpgrp", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tcsetpgrp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tcsetpgrp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int tcsetpgrp(int, pid_t)
     * }
     */
    public static FunctionDescriptor tcsetpgrp$descriptor() {
        return tcsetpgrp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int tcsetpgrp(int, pid_t)
     * }
     */
    public static MethodHandle tcsetpgrp$handle() {
        return tcsetpgrp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int tcsetpgrp(int, pid_t)
     * }
     */
    public static MemorySegment tcsetpgrp$address() {
        return tcsetpgrp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int tcsetpgrp(int, pid_t)
     * }
     */
    public static int tcsetpgrp(int x0, int x1) {
        var mh$ = tcsetpgrp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tcsetpgrp", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ttyname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ttyname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ttyname(int)
     * }
     */
    public static FunctionDescriptor ttyname$descriptor() {
        return ttyname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ttyname(int)
     * }
     */
    public static MethodHandle ttyname$handle() {
        return ttyname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ttyname(int)
     * }
     */
    public static MemorySegment ttyname$address() {
        return ttyname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ttyname(int)
     * }
     */
    public static MemorySegment ttyname(int x0) {
        var mh$ = ttyname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ttyname", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ttyname_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ttyname_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ttyname_r(int, char *, size_t)
     * }
     */
    public static FunctionDescriptor ttyname_r$descriptor() {
        return ttyname_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ttyname_r(int, char *, size_t)
     * }
     */
    public static MethodHandle ttyname_r$handle() {
        return ttyname_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ttyname_r(int, char *, size_t)
     * }
     */
    public static MemorySegment ttyname_r$address() {
        return ttyname_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ttyname_r(int, char *, size_t)
     * }
     */
    public static int ttyname_r(int x0, MemorySegment x1, long x2) {
        var mh$ = ttyname_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ttyname_r", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("unlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int unlink(const char *)
     * }
     */
    public static FunctionDescriptor unlink$descriptor() {
        return unlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int unlink(const char *)
     * }
     */
    public static MethodHandle unlink$handle() {
        return unlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int unlink(const char *)
     * }
     */
    public static MemorySegment unlink$address() {
        return unlink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int unlink(const char *)
     * }
     */
    public static int unlink(MemorySegment x0) {
        var mh$ = unlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unlink", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class write {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("write");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t write(int __fd, const void *__buf, size_t __nbyte)
     * }
     */
    public static FunctionDescriptor write$descriptor() {
        return write.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t write(int __fd, const void *__buf, size_t __nbyte)
     * }
     */
    public static MethodHandle write$handle() {
        return write.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t write(int __fd, const void *__buf, size_t __nbyte)
     * }
     */
    public static MemorySegment write$address() {
        return write.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t write(int __fd, const void *__buf, size_t __nbyte)
     * }
     */
    public static long write(int __fd, MemorySegment __buf, long __nbyte) {
        var mh$ = write.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("write", __fd, __buf, __nbyte);
            }
            return (long)mh$.invokeExact(__fd, __buf, __nbyte);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class confstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("confstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t confstr(int, char *, size_t)
     * }
     */
    public static FunctionDescriptor confstr$descriptor() {
        return confstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t confstr(int, char *, size_t)
     * }
     */
    public static MethodHandle confstr$handle() {
        return confstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t confstr(int, char *, size_t)
     * }
     */
    public static MemorySegment confstr$address() {
        return confstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t confstr(int, char *, size_t)
     * }
     */
    public static long confstr(int x0, MemorySegment x1, long x2) {
        var mh$ = confstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("confstr", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getopt(int, char *const [], const char *)
     * }
     */
    public static FunctionDescriptor getopt$descriptor() {
        return getopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getopt(int, char *const [], const char *)
     * }
     */
    public static MethodHandle getopt$handle() {
        return getopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getopt(int, char *const [], const char *)
     * }
     */
    public static MemorySegment getopt$address() {
        return getopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getopt(int, char *const [], const char *)
     * }
     */
    public static int getopt(int x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = getopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getopt", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class optarg$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("optarg").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *optarg
     * }
     */
    public static AddressLayout optarg$layout() {
        return optarg$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern char *optarg
     * }
     */
    public static MemorySegment optarg$segment() {
        return optarg$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *optarg
     * }
     */
    public static MemorySegment optarg() {
        return optarg$constants.SEGMENT.get(optarg$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *optarg
     * }
     */
    public static void optarg(MemorySegment varValue) {
        optarg$constants.SEGMENT.set(optarg$constants.LAYOUT, 0L, varValue);
    }

    private static class optind$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("optind").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int optind
     * }
     */
    public static OfInt optind$layout() {
        return optind$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int optind
     * }
     */
    public static MemorySegment optind$segment() {
        return optind$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int optind
     * }
     */
    public static int optind() {
        return optind$constants.SEGMENT.get(optind$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int optind
     * }
     */
    public static void optind(int varValue) {
        optind$constants.SEGMENT.set(optind$constants.LAYOUT, 0L, varValue);
    }

    private static class opterr$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("opterr").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int opterr
     * }
     */
    public static OfInt opterr$layout() {
        return opterr$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int opterr
     * }
     */
    public static MemorySegment opterr$segment() {
        return opterr$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int opterr
     * }
     */
    public static int opterr() {
        return opterr$constants.SEGMENT.get(opterr$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int opterr
     * }
     */
    public static void opterr(int varValue) {
        opterr$constants.SEGMENT.set(opterr$constants.LAYOUT, 0L, varValue);
    }

    private static class optopt$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("optopt").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int optopt
     * }
     */
    public static OfInt optopt$layout() {
        return optopt$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int optopt
     * }
     */
    public static MemorySegment optopt$segment() {
        return optopt$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int optopt
     * }
     */
    public static int optopt() {
        return optopt$constants.SEGMENT.get(optopt$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int optopt
     * }
     */
    public static void optopt(int varValue) {
        optopt$constants.SEGMENT.set(optopt$constants.LAYOUT, 0L, varValue);
    }

    private static class brk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("brk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *brk(const void *)
     * }
     */
    public static FunctionDescriptor brk$descriptor() {
        return brk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *brk(const void *)
     * }
     */
    public static MethodHandle brk$handle() {
        return brk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *brk(const void *)
     * }
     */
    public static MemorySegment brk$address() {
        return brk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *brk(const void *)
     * }
     */
    public static MemorySegment brk(MemorySegment x0) {
        var mh$ = brk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("brk", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chroot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("chroot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chroot(const char *)
     * }
     */
    public static FunctionDescriptor chroot$descriptor() {
        return chroot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chroot(const char *)
     * }
     */
    public static MethodHandle chroot$handle() {
        return chroot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chroot(const char *)
     * }
     */
    public static MemorySegment chroot$address() {
        return chroot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chroot(const char *)
     * }
     */
    public static int chroot(MemorySegment x0) {
        var mh$ = chroot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chroot", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class crypt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("crypt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *crypt(const char *, const char *)
     * }
     */
    public static FunctionDescriptor crypt$descriptor() {
        return crypt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *crypt(const char *, const char *)
     * }
     */
    public static MethodHandle crypt$handle() {
        return crypt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *crypt(const char *, const char *)
     * }
     */
    public static MemorySegment crypt$address() {
        return crypt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *crypt(const char *, const char *)
     * }
     */
    public static MemorySegment crypt(MemorySegment x0, MemorySegment x1) {
        var mh$ = crypt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("crypt", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class encrypt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("encrypt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void encrypt(char *, int)
     * }
     */
    public static FunctionDescriptor encrypt$descriptor() {
        return encrypt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void encrypt(char *, int)
     * }
     */
    public static MethodHandle encrypt$handle() {
        return encrypt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void encrypt(char *, int)
     * }
     */
    public static MemorySegment encrypt$address() {
        return encrypt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void encrypt(char *, int)
     * }
     */
    public static void encrypt(MemorySegment x0, int x1) {
        var mh$ = encrypt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("encrypt", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fchdir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fchdir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fchdir(int)
     * }
     */
    public static FunctionDescriptor fchdir$descriptor() {
        return fchdir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fchdir(int)
     * }
     */
    public static MethodHandle fchdir$handle() {
        return fchdir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fchdir(int)
     * }
     */
    public static MemorySegment fchdir$address() {
        return fchdir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fchdir(int)
     * }
     */
    public static int fchdir(int x0) {
        var mh$ = fchdir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fchdir", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gethostid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("gethostid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long gethostid()
     * }
     */
    public static FunctionDescriptor gethostid$descriptor() {
        return gethostid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long gethostid()
     * }
     */
    public static MethodHandle gethostid$handle() {
        return gethostid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long gethostid()
     * }
     */
    public static MemorySegment gethostid$address() {
        return gethostid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long gethostid()
     * }
     */
    public static long gethostid() {
        var mh$ = gethostid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gethostid");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpgid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getpgid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t getpgid(pid_t)
     * }
     */
    public static FunctionDescriptor getpgid$descriptor() {
        return getpgid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t getpgid(pid_t)
     * }
     */
    public static MethodHandle getpgid$handle() {
        return getpgid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t getpgid(pid_t)
     * }
     */
    public static MemorySegment getpgid$address() {
        return getpgid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t getpgid(pid_t)
     * }
     */
    public static int getpgid(int x0) {
        var mh$ = getpgid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpgid", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getsid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t getsid(pid_t)
     * }
     */
    public static FunctionDescriptor getsid$descriptor() {
        return getsid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t getsid(pid_t)
     * }
     */
    public static MethodHandle getsid$handle() {
        return getsid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t getsid(pid_t)
     * }
     */
    public static MemorySegment getsid$address() {
        return getsid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t getsid(pid_t)
     * }
     */
    public static int getsid(int x0) {
        var mh$ = getsid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsid", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getdtablesize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getdtablesize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getdtablesize()
     * }
     */
    public static FunctionDescriptor getdtablesize$descriptor() {
        return getdtablesize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getdtablesize()
     * }
     */
    public static MethodHandle getdtablesize$handle() {
        return getdtablesize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getdtablesize()
     * }
     */
    public static MemorySegment getdtablesize$address() {
        return getdtablesize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getdtablesize()
     * }
     */
    public static int getdtablesize() {
        var mh$ = getdtablesize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getdtablesize");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpagesize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getpagesize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getpagesize()
     * }
     */
    public static FunctionDescriptor getpagesize$descriptor() {
        return getpagesize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getpagesize()
     * }
     */
    public static MethodHandle getpagesize$handle() {
        return getpagesize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getpagesize()
     * }
     */
    public static MemorySegment getpagesize$address() {
        return getpagesize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getpagesize()
     * }
     */
    public static int getpagesize() {
        var mh$ = getpagesize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpagesize");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getpass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getpass(const char *)
     * }
     */
    public static FunctionDescriptor getpass$descriptor() {
        return getpass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getpass(const char *)
     * }
     */
    public static MethodHandle getpass$handle() {
        return getpass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getpass(const char *)
     * }
     */
    public static MemorySegment getpass$address() {
        return getpass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getpass(const char *)
     * }
     */
    public static MemorySegment getpass(MemorySegment x0) {
        var mh$ = getpass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpass", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getwd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getwd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getwd(char *)
     * }
     */
    public static FunctionDescriptor getwd$descriptor() {
        return getwd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getwd(char *)
     * }
     */
    public static MethodHandle getwd$handle() {
        return getwd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getwd(char *)
     * }
     */
    public static MemorySegment getwd$address() {
        return getwd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getwd(char *)
     * }
     */
    public static MemorySegment getwd(MemorySegment x0) {
        var mh$ = getwd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getwd", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lchown {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lchown");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lchown(const char *, uid_t, gid_t)
     * }
     */
    public static FunctionDescriptor lchown$descriptor() {
        return lchown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lchown(const char *, uid_t, gid_t)
     * }
     */
    public static MethodHandle lchown$handle() {
        return lchown.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int lchown(const char *, uid_t, gid_t)
     * }
     */
    public static MemorySegment lchown$address() {
        return lchown.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int lchown(const char *, uid_t, gid_t)
     * }
     */
    public static int lchown(MemorySegment x0, int x1, int x2) {
        var mh$ = lchown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lchown", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lockf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lockf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lockf(int, int, off_t)
     * }
     */
    public static FunctionDescriptor lockf$descriptor() {
        return lockf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lockf(int, int, off_t)
     * }
     */
    public static MethodHandle lockf$handle() {
        return lockf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int lockf(int, int, off_t)
     * }
     */
    public static MemorySegment lockf$address() {
        return lockf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int lockf(int, int, off_t)
     * }
     */
    public static int lockf(int x0, int x1, long x2) {
        var mh$ = lockf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lockf", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("nice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int nice(int)
     * }
     */
    public static FunctionDescriptor nice$descriptor() {
        return nice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int nice(int)
     * }
     */
    public static MethodHandle nice$handle() {
        return nice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int nice(int)
     * }
     */
    public static MemorySegment nice$address() {
        return nice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int nice(int)
     * }
     */
    public static int nice(int x0) {
        var mh$ = nice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nice", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t pread(int __fd, void *__buf, size_t __nbyte, off_t __offset)
     * }
     */
    public static FunctionDescriptor pread$descriptor() {
        return pread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t pread(int __fd, void *__buf, size_t __nbyte, off_t __offset)
     * }
     */
    public static MethodHandle pread$handle() {
        return pread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t pread(int __fd, void *__buf, size_t __nbyte, off_t __offset)
     * }
     */
    public static MemorySegment pread$address() {
        return pread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t pread(int __fd, void *__buf, size_t __nbyte, off_t __offset)
     * }
     */
    public static long pread(int __fd, MemorySegment __buf, long __nbyte, long __offset) {
        var mh$ = pread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pread", __fd, __buf, __nbyte, __offset);
            }
            return (long)mh$.invokeExact(__fd, __buf, __nbyte, __offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pwrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pwrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t pwrite(int __fd, const void *__buf, size_t __nbyte, off_t __offset)
     * }
     */
    public static FunctionDescriptor pwrite$descriptor() {
        return pwrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t pwrite(int __fd, const void *__buf, size_t __nbyte, off_t __offset)
     * }
     */
    public static MethodHandle pwrite$handle() {
        return pwrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t pwrite(int __fd, const void *__buf, size_t __nbyte, off_t __offset)
     * }
     */
    public static MemorySegment pwrite$address() {
        return pwrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t pwrite(int __fd, const void *__buf, size_t __nbyte, off_t __offset)
     * }
     */
    public static long pwrite(int __fd, MemorySegment __buf, long __nbyte, long __offset) {
        var mh$ = pwrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pwrite", __fd, __buf, __nbyte, __offset);
            }
            return (long)mh$.invokeExact(__fd, __buf, __nbyte, __offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sbrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sbrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *sbrk(int)
     * }
     */
    public static FunctionDescriptor sbrk$descriptor() {
        return sbrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *sbrk(int)
     * }
     */
    public static MethodHandle sbrk$handle() {
        return sbrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *sbrk(int)
     * }
     */
    public static MemorySegment sbrk$address() {
        return sbrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *sbrk(int)
     * }
     */
    public static MemorySegment sbrk(int x0) {
        var mh$ = sbrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sbrk", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setpgrp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setpgrp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t setpgrp()
     * }
     */
    public static FunctionDescriptor setpgrp$descriptor() {
        return setpgrp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t setpgrp()
     * }
     */
    public static MethodHandle setpgrp$handle() {
        return setpgrp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t setpgrp()
     * }
     */
    public static MemorySegment setpgrp$address() {
        return setpgrp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t setpgrp()
     * }
     */
    public static int setpgrp() {
        var mh$ = setpgrp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setpgrp");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setregid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setregid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setregid(gid_t, gid_t)
     * }
     */
    public static FunctionDescriptor setregid$descriptor() {
        return setregid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setregid(gid_t, gid_t)
     * }
     */
    public static MethodHandle setregid$handle() {
        return setregid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setregid(gid_t, gid_t)
     * }
     */
    public static MemorySegment setregid$address() {
        return setregid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setregid(gid_t, gid_t)
     * }
     */
    public static int setregid(int x0, int x1) {
        var mh$ = setregid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setregid", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setreuid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setreuid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setreuid(uid_t, uid_t)
     * }
     */
    public static FunctionDescriptor setreuid$descriptor() {
        return setreuid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setreuid(uid_t, uid_t)
     * }
     */
    public static MethodHandle setreuid$handle() {
        return setreuid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setreuid(uid_t, uid_t)
     * }
     */
    public static MemorySegment setreuid$address() {
        return setreuid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setreuid(uid_t, uid_t)
     * }
     */
    public static int setreuid(int x0, int x1) {
        var mh$ = setreuid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setreuid", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sync {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sync");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sync()
     * }
     */
    public static FunctionDescriptor sync$descriptor() {
        return sync.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sync()
     * }
     */
    public static MethodHandle sync$handle() {
        return sync.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sync()
     * }
     */
    public static MemorySegment sync$address() {
        return sync.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sync()
     * }
     */
    public static void sync() {
        var mh$ = sync.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sync");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class truncate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("truncate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int truncate(const char *, off_t)
     * }
     */
    public static FunctionDescriptor truncate$descriptor() {
        return truncate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int truncate(const char *, off_t)
     * }
     */
    public static MethodHandle truncate$handle() {
        return truncate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int truncate(const char *, off_t)
     * }
     */
    public static MemorySegment truncate$address() {
        return truncate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int truncate(const char *, off_t)
     * }
     */
    public static int truncate(MemorySegment x0, long x1) {
        var mh$ = truncate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("truncate", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ualarm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ualarm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * useconds_t ualarm(useconds_t, useconds_t)
     * }
     */
    public static FunctionDescriptor ualarm$descriptor() {
        return ualarm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * useconds_t ualarm(useconds_t, useconds_t)
     * }
     */
    public static MethodHandle ualarm$handle() {
        return ualarm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * useconds_t ualarm(useconds_t, useconds_t)
     * }
     */
    public static MemorySegment ualarm$address() {
        return ualarm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * useconds_t ualarm(useconds_t, useconds_t)
     * }
     */
    public static int ualarm(int x0, int x1) {
        var mh$ = ualarm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ualarm", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class usleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("usleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int usleep(useconds_t)
     * }
     */
    public static FunctionDescriptor usleep$descriptor() {
        return usleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int usleep(useconds_t)
     * }
     */
    public static MethodHandle usleep$handle() {
        return usleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int usleep(useconds_t)
     * }
     */
    public static MemorySegment usleep$address() {
        return usleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int usleep(useconds_t)
     * }
     */
    public static int usleep(int x0) {
        var mh$ = usleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("usleep", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vfork {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("vfork");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vfork()
     * }
     */
    public static FunctionDescriptor vfork$descriptor() {
        return vfork.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vfork()
     * }
     */
    public static MethodHandle vfork$handle() {
        return vfork.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vfork()
     * }
     */
    public static MemorySegment vfork$address() {
        return vfork.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vfork()
     * }
     */
    public static int vfork() {
        var mh$ = vfork.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfork");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsync {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fsync");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fsync(int)
     * }
     */
    public static FunctionDescriptor fsync$descriptor() {
        return fsync.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fsync(int)
     * }
     */
    public static MethodHandle fsync$handle() {
        return fsync.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fsync(int)
     * }
     */
    public static MemorySegment fsync$address() {
        return fsync.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fsync(int)
     * }
     */
    public static int fsync(int x0) {
        var mh$ = fsync.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsync", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftruncate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ftruncate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ftruncate(int, off_t)
     * }
     */
    public static FunctionDescriptor ftruncate$descriptor() {
        return ftruncate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ftruncate(int, off_t)
     * }
     */
    public static MethodHandle ftruncate$handle() {
        return ftruncate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ftruncate(int, off_t)
     * }
     */
    public static MemorySegment ftruncate$address() {
        return ftruncate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ftruncate(int, off_t)
     * }
     */
    public static int ftruncate(int x0, long x1) {
        var mh$ = ftruncate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftruncate", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getlogin_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getlogin_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getlogin_r(char *, size_t)
     * }
     */
    public static FunctionDescriptor getlogin_r$descriptor() {
        return getlogin_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getlogin_r(char *, size_t)
     * }
     */
    public static MethodHandle getlogin_r$handle() {
        return getlogin_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getlogin_r(char *, size_t)
     * }
     */
    public static MemorySegment getlogin_r$address() {
        return getlogin_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getlogin_r(char *, size_t)
     * }
     */
    public static int getlogin_r(MemorySegment x0, long x1) {
        var mh$ = getlogin_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getlogin_r", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fchown {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fchown");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fchown(int, uid_t, gid_t)
     * }
     */
    public static FunctionDescriptor fchown$descriptor() {
        return fchown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fchown(int, uid_t, gid_t)
     * }
     */
    public static MethodHandle fchown$handle() {
        return fchown.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fchown(int, uid_t, gid_t)
     * }
     */
    public static MemorySegment fchown$address() {
        return fchown.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fchown(int, uid_t, gid_t)
     * }
     */
    public static int fchown(int x0, int x1, int x2) {
        var mh$ = fchown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fchown", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gethostname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("gethostname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int gethostname(char *, size_t)
     * }
     */
    public static FunctionDescriptor gethostname$descriptor() {
        return gethostname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int gethostname(char *, size_t)
     * }
     */
    public static MethodHandle gethostname$handle() {
        return gethostname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int gethostname(char *, size_t)
     * }
     */
    public static MemorySegment gethostname$address() {
        return gethostname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int gethostname(char *, size_t)
     * }
     */
    public static int gethostname(MemorySegment x0, long x1) {
        var mh$ = gethostname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gethostname", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class readlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("readlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t readlink(const char *restrict, char *restrict, size_t)
     * }
     */
    public static FunctionDescriptor readlink$descriptor() {
        return readlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t readlink(const char *restrict, char *restrict, size_t)
     * }
     */
    public static MethodHandle readlink$handle() {
        return readlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t readlink(const char *restrict, char *restrict, size_t)
     * }
     */
    public static MemorySegment readlink$address() {
        return readlink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t readlink(const char *restrict, char *restrict, size_t)
     * }
     */
    public static long readlink(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = readlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("readlink", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setegid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setegid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setegid(gid_t)
     * }
     */
    public static FunctionDescriptor setegid$descriptor() {
        return setegid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setegid(gid_t)
     * }
     */
    public static MethodHandle setegid$handle() {
        return setegid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setegid(gid_t)
     * }
     */
    public static MemorySegment setegid$address() {
        return setegid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setegid(gid_t)
     * }
     */
    public static int setegid(int x0) {
        var mh$ = setegid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setegid", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class seteuid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("seteuid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int seteuid(uid_t)
     * }
     */
    public static FunctionDescriptor seteuid$descriptor() {
        return seteuid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int seteuid(uid_t)
     * }
     */
    public static MethodHandle seteuid$handle() {
        return seteuid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int seteuid(uid_t)
     * }
     */
    public static MemorySegment seteuid$address() {
        return seteuid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int seteuid(uid_t)
     * }
     */
    public static int seteuid(int x0) {
        var mh$ = seteuid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("seteuid", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class symlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("symlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int symlink(const char *, const char *)
     * }
     */
    public static FunctionDescriptor symlink$descriptor() {
        return symlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int symlink(const char *, const char *)
     * }
     */
    public static MethodHandle symlink$handle() {
        return symlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int symlink(const char *, const char *)
     * }
     */
    public static MemorySegment symlink$address() {
        return symlink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int symlink(const char *, const char *)
     * }
     */
    public static int symlink(MemorySegment x0, MemorySegment x1) {
        var mh$ = symlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("symlink", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __darwin_check_fd_set_overflow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__darwin_check_fd_set_overflow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __darwin_check_fd_set_overflow(int, const void *, int)
     * }
     */
    public static FunctionDescriptor __darwin_check_fd_set_overflow$descriptor() {
        return __darwin_check_fd_set_overflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __darwin_check_fd_set_overflow(int, const void *, int)
     * }
     */
    public static MethodHandle __darwin_check_fd_set_overflow$handle() {
        return __darwin_check_fd_set_overflow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __darwin_check_fd_set_overflow(int, const void *, int)
     * }
     */
    public static MemorySegment __darwin_check_fd_set_overflow$address() {
        return __darwin_check_fd_set_overflow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __darwin_check_fd_set_overflow(int, const void *, int)
     * }
     */
    public static int __darwin_check_fd_set_overflow(int x0, MemorySegment x1, int x2) {
        var mh$ = __darwin_check_fd_set_overflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__darwin_check_fd_set_overflow", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_time_t time_t
     * }
     */
    public static final OfLong time_t = Python_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_suseconds_t suseconds_t
     * }
     */
    public static final OfInt suseconds_t = Python_h.C_INT;

    private static class pselect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pselect$DARWIN_EXTSN");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pselect(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, const struct timespec *restrict, const sigset_t *restrict)
     * }
     */
    public static FunctionDescriptor pselect$descriptor() {
        return pselect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pselect(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, const struct timespec *restrict, const sigset_t *restrict)
     * }
     */
    public static MethodHandle pselect$handle() {
        return pselect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pselect(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, const struct timespec *restrict, const sigset_t *restrict)
     * }
     */
    public static MemorySegment pselect$address() {
        return pselect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pselect(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, const struct timespec *restrict, const sigset_t *restrict)
     * }
     */
    public static int pselect(int x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = pselect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pselect", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class select {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("select$DARWIN_EXTSN");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int select(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, struct timeval *restrict)
     * }
     */
    public static FunctionDescriptor select$descriptor() {
        return select.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int select(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, struct timeval *restrict)
     * }
     */
    public static MethodHandle select$handle() {
        return select.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int select(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, struct timeval *restrict)
     * }
     */
    public static MemorySegment select$address() {
        return select.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int select(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, struct timeval *restrict)
     * }
     */
    public static int select(int x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = select.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("select", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class accessx_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("accessx_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int accessx_np(const struct accessx_descriptor *, size_t, int *, uid_t)
     * }
     */
    public static FunctionDescriptor accessx_np$descriptor() {
        return accessx_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int accessx_np(const struct accessx_descriptor *, size_t, int *, uid_t)
     * }
     */
    public static MethodHandle accessx_np$handle() {
        return accessx_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int accessx_np(const struct accessx_descriptor *, size_t, int *, uid_t)
     * }
     */
    public static MemorySegment accessx_np$address() {
        return accessx_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int accessx_np(const struct accessx_descriptor *, size_t, int *, uid_t)
     * }
     */
    public static int accessx_np(MemorySegment x0, long x1, MemorySegment x2, int x3) {
        var mh$ = accessx_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("accessx_np", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acct {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("acct");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int acct(const char *)
     * }
     */
    public static FunctionDescriptor acct$descriptor() {
        return acct.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int acct(const char *)
     * }
     */
    public static MethodHandle acct$handle() {
        return acct.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int acct(const char *)
     * }
     */
    public static MemorySegment acct$address() {
        return acct.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int acct(const char *)
     * }
     */
    public static int acct(MemorySegment x0) {
        var mh$ = acct.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acct", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class add_profil {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("add_profil");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int add_profil(char *, size_t, unsigned long, unsigned int)
     * }
     */
    public static FunctionDescriptor add_profil$descriptor() {
        return add_profil.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int add_profil(char *, size_t, unsigned long, unsigned int)
     * }
     */
    public static MethodHandle add_profil$handle() {
        return add_profil.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int add_profil(char *, size_t, unsigned long, unsigned int)
     * }
     */
    public static MemorySegment add_profil$address() {
        return add_profil.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int add_profil(char *, size_t, unsigned long, unsigned int)
     * }
     */
    public static int add_profil(MemorySegment x0, long x1, long x2, int x3) {
        var mh$ = add_profil.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("add_profil", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class endusershell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("endusershell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void endusershell()
     * }
     */
    public static FunctionDescriptor endusershell$descriptor() {
        return endusershell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void endusershell()
     * }
     */
    public static MethodHandle endusershell$handle() {
        return endusershell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void endusershell()
     * }
     */
    public static MemorySegment endusershell$address() {
        return endusershell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void endusershell()
     * }
     */
    public static void endusershell() {
        var mh$ = endusershell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("endusershell");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class execvP$ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("execvP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int execvP(const char *__file, const char *__searchpath, char *const *__argv)
     * }
     */
    public static FunctionDescriptor execvP$descriptor() {
        return execvP$.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int execvP(const char *__file, const char *__searchpath, char *const *__argv)
     * }
     */
    public static MethodHandle execvP$handle() {
        return execvP$.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int execvP(const char *__file, const char *__searchpath, char *const *__argv)
     * }
     */
    public static MemorySegment execvP$address() {
        return execvP$.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int execvP(const char *__file, const char *__searchpath, char *const *__argv)
     * }
     */
    public static int execvP(MemorySegment __file, MemorySegment __searchpath, MemorySegment __argv) {
        var mh$ = execvP$.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("execvP", __file, __searchpath, __argv);
            }
            return (int)mh$.invokeExact(__file, __searchpath, __argv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fflagstostr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fflagstostr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *fflagstostr(unsigned long)
     * }
     */
    public static FunctionDescriptor fflagstostr$descriptor() {
        return fflagstostr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *fflagstostr(unsigned long)
     * }
     */
    public static MethodHandle fflagstostr$handle() {
        return fflagstostr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *fflagstostr(unsigned long)
     * }
     */
    public static MemorySegment fflagstostr$address() {
        return fflagstostr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *fflagstostr(unsigned long)
     * }
     */
    public static MemorySegment fflagstostr(long x0) {
        var mh$ = fflagstostr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fflagstostr", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getdomainname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getdomainname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getdomainname(char *, int)
     * }
     */
    public static FunctionDescriptor getdomainname$descriptor() {
        return getdomainname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getdomainname(char *, int)
     * }
     */
    public static MethodHandle getdomainname$handle() {
        return getdomainname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getdomainname(char *, int)
     * }
     */
    public static MemorySegment getdomainname$address() {
        return getdomainname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getdomainname(char *, int)
     * }
     */
    public static int getdomainname(MemorySegment x0, int x1) {
        var mh$ = getdomainname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getdomainname", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getgrouplist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getgrouplist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getgrouplist(const char *, int, int *, int *)
     * }
     */
    public static FunctionDescriptor getgrouplist$descriptor() {
        return getgrouplist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getgrouplist(const char *, int, int *, int *)
     * }
     */
    public static MethodHandle getgrouplist$handle() {
        return getgrouplist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getgrouplist(const char *, int, int *, int *)
     * }
     */
    public static MemorySegment getgrouplist$address() {
        return getgrouplist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getgrouplist(const char *, int, int *, int *)
     * }
     */
    public static int getgrouplist(MemorySegment x0, int x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = getgrouplist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getgrouplist", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gethostuuid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("gethostuuid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int gethostuuid(uuid_t, const struct timespec *)
     * }
     */
    public static FunctionDescriptor gethostuuid$descriptor() {
        return gethostuuid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int gethostuuid(uuid_t, const struct timespec *)
     * }
     */
    public static MethodHandle gethostuuid$handle() {
        return gethostuuid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int gethostuuid(uuid_t, const struct timespec *)
     * }
     */
    public static MemorySegment gethostuuid$address() {
        return gethostuuid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int gethostuuid(uuid_t, const struct timespec *)
     * }
     */
    public static int gethostuuid(MemorySegment x0, MemorySegment x1) {
        var mh$ = gethostuuid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gethostuuid", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getmode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_POINTER,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getmode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mode_t getmode(const void *, mode_t)
     * }
     */
    public static FunctionDescriptor getmode$descriptor() {
        return getmode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mode_t getmode(const void *, mode_t)
     * }
     */
    public static MethodHandle getmode$handle() {
        return getmode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mode_t getmode(const void *, mode_t)
     * }
     */
    public static MemorySegment getmode$address() {
        return getmode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mode_t getmode(const void *, mode_t)
     * }
     */
    public static short getmode(MemorySegment x0, short x1) {
        var mh$ = getmode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getmode", x0, x1);
            }
            return (short)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpeereid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getpeereid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getpeereid(int, uid_t *, gid_t *)
     * }
     */
    public static FunctionDescriptor getpeereid$descriptor() {
        return getpeereid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getpeereid(int, uid_t *, gid_t *)
     * }
     */
    public static MethodHandle getpeereid$handle() {
        return getpeereid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getpeereid(int, uid_t *, gid_t *)
     * }
     */
    public static MemorySegment getpeereid$address() {
        return getpeereid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getpeereid(int, uid_t *, gid_t *)
     * }
     */
    public static int getpeereid(int x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = getpeereid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpeereid", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsgroups_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getsgroups_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getsgroups_np(int *, uuid_t)
     * }
     */
    public static FunctionDescriptor getsgroups_np$descriptor() {
        return getsgroups_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getsgroups_np(int *, uuid_t)
     * }
     */
    public static MethodHandle getsgroups_np$handle() {
        return getsgroups_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getsgroups_np(int *, uuid_t)
     * }
     */
    public static MemorySegment getsgroups_np$address() {
        return getsgroups_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getsgroups_np(int *, uuid_t)
     * }
     */
    public static int getsgroups_np(MemorySegment x0, MemorySegment x1) {
        var mh$ = getsgroups_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsgroups_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getusershell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getusershell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getusershell()
     * }
     */
    public static FunctionDescriptor getusershell$descriptor() {
        return getusershell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getusershell()
     * }
     */
    public static MethodHandle getusershell$handle() {
        return getusershell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getusershell()
     * }
     */
    public static MemorySegment getusershell$address() {
        return getusershell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getusershell()
     * }
     */
    public static MemorySegment getusershell() {
        var mh$ = getusershell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getusershell");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getwgroups_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getwgroups_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getwgroups_np(int *, uuid_t)
     * }
     */
    public static FunctionDescriptor getwgroups_np$descriptor() {
        return getwgroups_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getwgroups_np(int *, uuid_t)
     * }
     */
    public static MethodHandle getwgroups_np$handle() {
        return getwgroups_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getwgroups_np(int *, uuid_t)
     * }
     */
    public static MemorySegment getwgroups_np$address() {
        return getwgroups_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getwgroups_np(int *, uuid_t)
     * }
     */
    public static int getwgroups_np(MemorySegment x0, MemorySegment x1) {
        var mh$ = getwgroups_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getwgroups_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class initgroups {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("initgroups");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int initgroups(const char *, int)
     * }
     */
    public static FunctionDescriptor initgroups$descriptor() {
        return initgroups.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int initgroups(const char *, int)
     * }
     */
    public static MethodHandle initgroups$handle() {
        return initgroups.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int initgroups(const char *, int)
     * }
     */
    public static MemorySegment initgroups$address() {
        return initgroups.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int initgroups(const char *, int)
     * }
     */
    public static int initgroups(MemorySegment x0, int x1) {
        var mh$ = initgroups.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initgroups", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class issetugid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("issetugid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int issetugid()
     * }
     */
    public static FunctionDescriptor issetugid$descriptor() {
        return issetugid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int issetugid()
     * }
     */
    public static MethodHandle issetugid$handle() {
        return issetugid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int issetugid()
     * }
     */
    public static MemorySegment issetugid$address() {
        return issetugid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int issetugid()
     * }
     */
    public static int issetugid() {
        var mh$ = issetugid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("issetugid");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkdtemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mkdtemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *mkdtemp(char *)
     * }
     */
    public static FunctionDescriptor mkdtemp$descriptor() {
        return mkdtemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *mkdtemp(char *)
     * }
     */
    public static MethodHandle mkdtemp$handle() {
        return mkdtemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *mkdtemp(char *)
     * }
     */
    public static MemorySegment mkdtemp$address() {
        return mkdtemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *mkdtemp(char *)
     * }
     */
    public static MemorySegment mkdtemp(MemorySegment x0) {
        var mh$ = mkdtemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkdtemp", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mknod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_SHORT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mknod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mknod(const char *, mode_t, dev_t)
     * }
     */
    public static FunctionDescriptor mknod$descriptor() {
        return mknod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mknod(const char *, mode_t, dev_t)
     * }
     */
    public static MethodHandle mknod$handle() {
        return mknod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mknod(const char *, mode_t, dev_t)
     * }
     */
    public static MemorySegment mknod$address() {
        return mknod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mknod(const char *, mode_t, dev_t)
     * }
     */
    public static int mknod(MemorySegment x0, short x1, int x2) {
        var mh$ = mknod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mknod", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkpath_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mkpath_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkpath_np(const char *path, mode_t omode)
     * }
     */
    public static FunctionDescriptor mkpath_np$descriptor() {
        return mkpath_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkpath_np(const char *path, mode_t omode)
     * }
     */
    public static MethodHandle mkpath_np$handle() {
        return mkpath_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkpath_np(const char *path, mode_t omode)
     * }
     */
    public static MemorySegment mkpath_np$address() {
        return mkpath_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkpath_np(const char *path, mode_t omode)
     * }
     */
    public static int mkpath_np(MemorySegment path, short omode) {
        var mh$ = mkpath_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkpath_np", path, omode);
            }
            return (int)mh$.invokeExact(path, omode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkpathat_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mkpathat_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkpathat_np(int dfd, const char *path, mode_t omode)
     * }
     */
    public static FunctionDescriptor mkpathat_np$descriptor() {
        return mkpathat_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkpathat_np(int dfd, const char *path, mode_t omode)
     * }
     */
    public static MethodHandle mkpathat_np$handle() {
        return mkpathat_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkpathat_np(int dfd, const char *path, mode_t omode)
     * }
     */
    public static MemorySegment mkpathat_np$address() {
        return mkpathat_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkpathat_np(int dfd, const char *path, mode_t omode)
     * }
     */
    public static int mkpathat_np(int dfd, MemorySegment path, short omode) {
        var mh$ = mkpathat_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkpathat_np", dfd, path, omode);
            }
            return (int)mh$.invokeExact(dfd, path, omode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstemps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mkstemps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkstemps(char *, int)
     * }
     */
    public static FunctionDescriptor mkstemps$descriptor() {
        return mkstemps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkstemps(char *, int)
     * }
     */
    public static MethodHandle mkstemps$handle() {
        return mkstemps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkstemps(char *, int)
     * }
     */
    public static MemorySegment mkstemps$address() {
        return mkstemps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkstemps(char *, int)
     * }
     */
    public static int mkstemps(MemorySegment x0, int x1) {
        var mh$ = mkstemps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstemps", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkostemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mkostemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkostemp(char *path, int oflags)
     * }
     */
    public static FunctionDescriptor mkostemp$descriptor() {
        return mkostemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkostemp(char *path, int oflags)
     * }
     */
    public static MethodHandle mkostemp$handle() {
        return mkostemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkostemp(char *path, int oflags)
     * }
     */
    public static MemorySegment mkostemp$address() {
        return mkostemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkostemp(char *path, int oflags)
     * }
     */
    public static int mkostemp(MemorySegment path, int oflags) {
        var mh$ = mkostemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkostemp", path, oflags);
            }
            return (int)mh$.invokeExact(path, oflags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkostemps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mkostemps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkostemps(char *path, int slen, int oflags)
     * }
     */
    public static FunctionDescriptor mkostemps$descriptor() {
        return mkostemps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkostemps(char *path, int slen, int oflags)
     * }
     */
    public static MethodHandle mkostemps$handle() {
        return mkostemps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkostemps(char *path, int slen, int oflags)
     * }
     */
    public static MemorySegment mkostemps$address() {
        return mkostemps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkostemps(char *path, int slen, int oflags)
     * }
     */
    public static int mkostemps(MemorySegment path, int slen, int oflags) {
        var mh$ = mkostemps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkostemps", path, slen, oflags);
            }
            return (int)mh$.invokeExact(path, slen, oflags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstemp_dprotected_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mkstemp_dprotected_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkstemp_dprotected_np(char *path, int dpclass, int dpflags)
     * }
     */
    public static FunctionDescriptor mkstemp_dprotected_np$descriptor() {
        return mkstemp_dprotected_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkstemp_dprotected_np(char *path, int dpclass, int dpflags)
     * }
     */
    public static MethodHandle mkstemp_dprotected_np$handle() {
        return mkstemp_dprotected_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkstemp_dprotected_np(char *path, int dpclass, int dpflags)
     * }
     */
    public static MemorySegment mkstemp_dprotected_np$address() {
        return mkstemp_dprotected_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkstemp_dprotected_np(char *path, int dpclass, int dpflags)
     * }
     */
    public static int mkstemp_dprotected_np(MemorySegment path, int dpclass, int dpflags) {
        var mh$ = mkstemp_dprotected_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstemp_dprotected_np", path, dpclass, dpflags);
            }
            return (int)mh$.invokeExact(path, dpclass, dpflags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkdtempat_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mkdtempat_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *mkdtempat_np(int dfd, char *path)
     * }
     */
    public static FunctionDescriptor mkdtempat_np$descriptor() {
        return mkdtempat_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *mkdtempat_np(int dfd, char *path)
     * }
     */
    public static MethodHandle mkdtempat_np$handle() {
        return mkdtempat_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *mkdtempat_np(int dfd, char *path)
     * }
     */
    public static MemorySegment mkdtempat_np$address() {
        return mkdtempat_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *mkdtempat_np(int dfd, char *path)
     * }
     */
    public static MemorySegment mkdtempat_np(int dfd, MemorySegment path) {
        var mh$ = mkdtempat_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkdtempat_np", dfd, path);
            }
            return (MemorySegment)mh$.invokeExact(dfd, path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstempsat_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mkstempsat_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkstempsat_np(int dfd, char *path, int slen)
     * }
     */
    public static FunctionDescriptor mkstempsat_np$descriptor() {
        return mkstempsat_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkstempsat_np(int dfd, char *path, int slen)
     * }
     */
    public static MethodHandle mkstempsat_np$handle() {
        return mkstempsat_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkstempsat_np(int dfd, char *path, int slen)
     * }
     */
    public static MemorySegment mkstempsat_np$address() {
        return mkstempsat_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkstempsat_np(int dfd, char *path, int slen)
     * }
     */
    public static int mkstempsat_np(int dfd, MemorySegment path, int slen) {
        var mh$ = mkstempsat_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstempsat_np", dfd, path, slen);
            }
            return (int)mh$.invokeExact(dfd, path, slen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkostempsat_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mkostempsat_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkostempsat_np(int dfd, char *path, int slen, int oflags)
     * }
     */
    public static FunctionDescriptor mkostempsat_np$descriptor() {
        return mkostempsat_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkostempsat_np(int dfd, char *path, int slen, int oflags)
     * }
     */
    public static MethodHandle mkostempsat_np$handle() {
        return mkostempsat_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkostempsat_np(int dfd, char *path, int slen, int oflags)
     * }
     */
    public static MemorySegment mkostempsat_np$address() {
        return mkostempsat_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkostempsat_np(int dfd, char *path, int slen, int oflags)
     * }
     */
    public static int mkostempsat_np(int dfd, MemorySegment path, int slen, int oflags) {
        var mh$ = mkostempsat_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkostempsat_np", dfd, path, slen, oflags);
            }
            return (int)mh$.invokeExact(dfd, path, slen, oflags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nfssvc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("nfssvc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int nfssvc(int, void *)
     * }
     */
    public static FunctionDescriptor nfssvc$descriptor() {
        return nfssvc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int nfssvc(int, void *)
     * }
     */
    public static MethodHandle nfssvc$handle() {
        return nfssvc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int nfssvc(int, void *)
     * }
     */
    public static MemorySegment nfssvc$address() {
        return nfssvc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int nfssvc(int, void *)
     * }
     */
    public static int nfssvc(int x0, MemorySegment x1) {
        var mh$ = nfssvc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nfssvc", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class profil {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("profil");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int profil(char *, size_t, unsigned long, unsigned int)
     * }
     */
    public static FunctionDescriptor profil$descriptor() {
        return profil.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int profil(char *, size_t, unsigned long, unsigned int)
     * }
     */
    public static MethodHandle profil$handle() {
        return profil.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int profil(char *, size_t, unsigned long, unsigned int)
     * }
     */
    public static MemorySegment profil$address() {
        return profil.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int profil(char *, size_t, unsigned long, unsigned int)
     * }
     */
    public static int profil(MemorySegment x0, long x1, long x2, int x3) {
        var mh$ = profil.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("profil", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_setugid_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_setugid_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_setugid_np(uid_t, gid_t)
     * }
     */
    public static FunctionDescriptor pthread_setugid_np$descriptor() {
        return pthread_setugid_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_setugid_np(uid_t, gid_t)
     * }
     */
    public static MethodHandle pthread_setugid_np$handle() {
        return pthread_setugid_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_setugid_np(uid_t, gid_t)
     * }
     */
    public static MemorySegment pthread_setugid_np$address() {
        return pthread_setugid_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_setugid_np(uid_t, gid_t)
     * }
     */
    public static int pthread_setugid_np(int x0, int x1) {
        var mh$ = pthread_setugid_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_setugid_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_getugid_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pthread_getugid_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_getugid_np(uid_t *, gid_t *)
     * }
     */
    public static FunctionDescriptor pthread_getugid_np$descriptor() {
        return pthread_getugid_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_getugid_np(uid_t *, gid_t *)
     * }
     */
    public static MethodHandle pthread_getugid_np$handle() {
        return pthread_getugid_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_getugid_np(uid_t *, gid_t *)
     * }
     */
    public static MemorySegment pthread_getugid_np$address() {
        return pthread_getugid_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_getugid_np(uid_t *, gid_t *)
     * }
     */
    public static int pthread_getugid_np(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_getugid_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_getugid_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class reboot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("reboot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int reboot(int)
     * }
     */
    public static FunctionDescriptor reboot$descriptor() {
        return reboot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int reboot(int)
     * }
     */
    public static MethodHandle reboot$handle() {
        return reboot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int reboot(int)
     * }
     */
    public static MemorySegment reboot$address() {
        return reboot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int reboot(int)
     * }
     */
    public static int reboot(int x0) {
        var mh$ = reboot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("reboot", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class revoke {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("revoke");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int revoke(const char *)
     * }
     */
    public static FunctionDescriptor revoke$descriptor() {
        return revoke.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int revoke(const char *)
     * }
     */
    public static MethodHandle revoke$handle() {
        return revoke.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int revoke(const char *)
     * }
     */
    public static MemorySegment revoke$address() {
        return revoke.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int revoke(const char *)
     * }
     */
    public static int revoke(MemorySegment x0) {
        var mh$ = revoke.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("revoke", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcmd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("rcmd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rcmd(char **, int, const char *, const char *, const char *, int *)
     * }
     */
    public static FunctionDescriptor rcmd$descriptor() {
        return rcmd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rcmd(char **, int, const char *, const char *, const char *, int *)
     * }
     */
    public static MethodHandle rcmd$handle() {
        return rcmd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rcmd(char **, int, const char *, const char *, const char *, int *)
     * }
     */
    public static MemorySegment rcmd$address() {
        return rcmd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rcmd(char **, int, const char *, const char *, const char *, int *)
     * }
     */
    public static int rcmd(MemorySegment x0, int x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = rcmd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcmd", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcmd_af {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("rcmd_af");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rcmd_af(char **, int, const char *, const char *, const char *, int *, int)
     * }
     */
    public static FunctionDescriptor rcmd_af$descriptor() {
        return rcmd_af.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rcmd_af(char **, int, const char *, const char *, const char *, int *, int)
     * }
     */
    public static MethodHandle rcmd_af$handle() {
        return rcmd_af.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rcmd_af(char **, int, const char *, const char *, const char *, int *, int)
     * }
     */
    public static MemorySegment rcmd_af$address() {
        return rcmd_af.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rcmd_af(char **, int, const char *, const char *, const char *, int *, int)
     * }
     */
    public static int rcmd_af(MemorySegment x0, int x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, int x6) {
        var mh$ = rcmd_af.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcmd_af", x0, x1, x2, x3, x4, x5, x6);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rresvport {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("rresvport");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rresvport(int *)
     * }
     */
    public static FunctionDescriptor rresvport$descriptor() {
        return rresvport.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rresvport(int *)
     * }
     */
    public static MethodHandle rresvport$handle() {
        return rresvport.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rresvport(int *)
     * }
     */
    public static MemorySegment rresvport$address() {
        return rresvport.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rresvport(int *)
     * }
     */
    public static int rresvport(MemorySegment x0) {
        var mh$ = rresvport.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rresvport", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rresvport_af {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("rresvport_af");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rresvport_af(int *, int)
     * }
     */
    public static FunctionDescriptor rresvport_af$descriptor() {
        return rresvport_af.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rresvport_af(int *, int)
     * }
     */
    public static MethodHandle rresvport_af$handle() {
        return rresvport_af.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rresvport_af(int *, int)
     * }
     */
    public static MemorySegment rresvport_af$address() {
        return rresvport_af.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rresvport_af(int *, int)
     * }
     */
    public static int rresvport_af(MemorySegment x0, int x1) {
        var mh$ = rresvport_af.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rresvport_af", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iruserok {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_LONG,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("iruserok");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int iruserok(unsigned long, int, const char *, const char *)
     * }
     */
    public static FunctionDescriptor iruserok$descriptor() {
        return iruserok.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int iruserok(unsigned long, int, const char *, const char *)
     * }
     */
    public static MethodHandle iruserok$handle() {
        return iruserok.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int iruserok(unsigned long, int, const char *, const char *)
     * }
     */
    public static MemorySegment iruserok$address() {
        return iruserok.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int iruserok(unsigned long, int, const char *, const char *)
     * }
     */
    public static int iruserok(long x0, int x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = iruserok.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iruserok", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iruserok_sa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("iruserok_sa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int iruserok_sa(const void *, int, int, const char *, const char *)
     * }
     */
    public static FunctionDescriptor iruserok_sa$descriptor() {
        return iruserok_sa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int iruserok_sa(const void *, int, int, const char *, const char *)
     * }
     */
    public static MethodHandle iruserok_sa$handle() {
        return iruserok_sa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int iruserok_sa(const void *, int, int, const char *, const char *)
     * }
     */
    public static MemorySegment iruserok_sa$address() {
        return iruserok_sa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int iruserok_sa(const void *, int, int, const char *, const char *)
     * }
     */
    public static int iruserok_sa(MemorySegment x0, int x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = iruserok_sa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iruserok_sa", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ruserok {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ruserok");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ruserok(const char *, int, const char *, const char *)
     * }
     */
    public static FunctionDescriptor ruserok$descriptor() {
        return ruserok.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ruserok(const char *, int, const char *, const char *)
     * }
     */
    public static MethodHandle ruserok$handle() {
        return ruserok.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ruserok(const char *, int, const char *, const char *)
     * }
     */
    public static MemorySegment ruserok$address() {
        return ruserok.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ruserok(const char *, int, const char *, const char *)
     * }
     */
    public static int ruserok(MemorySegment x0, int x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ruserok.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ruserok", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setdomainname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setdomainname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setdomainname(const char *, int)
     * }
     */
    public static FunctionDescriptor setdomainname$descriptor() {
        return setdomainname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setdomainname(const char *, int)
     * }
     */
    public static MethodHandle setdomainname$handle() {
        return setdomainname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setdomainname(const char *, int)
     * }
     */
    public static MemorySegment setdomainname$address() {
        return setdomainname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setdomainname(const char *, int)
     * }
     */
    public static int setdomainname(MemorySegment x0, int x1) {
        var mh$ = setdomainname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setdomainname", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setgroups {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setgroups");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setgroups(int, const gid_t *)
     * }
     */
    public static FunctionDescriptor setgroups$descriptor() {
        return setgroups.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setgroups(int, const gid_t *)
     * }
     */
    public static MethodHandle setgroups$handle() {
        return setgroups.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setgroups(int, const gid_t *)
     * }
     */
    public static MemorySegment setgroups$address() {
        return setgroups.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setgroups(int, const gid_t *)
     * }
     */
    public static int setgroups(int x0, MemorySegment x1) {
        var mh$ = setgroups.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setgroups", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sethostid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sethostid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sethostid(long)
     * }
     */
    public static FunctionDescriptor sethostid$descriptor() {
        return sethostid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sethostid(long)
     * }
     */
    public static MethodHandle sethostid$handle() {
        return sethostid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sethostid(long)
     * }
     */
    public static MemorySegment sethostid$address() {
        return sethostid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sethostid(long)
     * }
     */
    public static void sethostid(long x0) {
        var mh$ = sethostid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sethostid", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sethostname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sethostname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sethostname(const char *, int)
     * }
     */
    public static FunctionDescriptor sethostname$descriptor() {
        return sethostname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sethostname(const char *, int)
     * }
     */
    public static MethodHandle sethostname$handle() {
        return sethostname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sethostname(const char *, int)
     * }
     */
    public static MemorySegment sethostname$address() {
        return sethostname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sethostname(const char *, int)
     * }
     */
    public static int sethostname(MemorySegment x0, int x1) {
        var mh$ = sethostname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sethostname", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setlogin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setlogin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setlogin(const char *)
     * }
     */
    public static FunctionDescriptor setlogin$descriptor() {
        return setlogin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setlogin(const char *)
     * }
     */
    public static MethodHandle setlogin$handle() {
        return setlogin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setlogin(const char *)
     * }
     */
    public static MemorySegment setlogin$address() {
        return setlogin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setlogin(const char *)
     * }
     */
    public static int setlogin(MemorySegment x0) {
        var mh$ = setlogin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setlogin", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setmode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setmode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *setmode(const char *)
     * }
     */
    public static FunctionDescriptor setmode$descriptor() {
        return setmode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *setmode(const char *)
     * }
     */
    public static MethodHandle setmode$handle() {
        return setmode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *setmode(const char *)
     * }
     */
    public static MemorySegment setmode$address() {
        return setmode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *setmode(const char *)
     * }
     */
    public static MemorySegment setmode(MemorySegment x0) {
        var mh$ = setmode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setmode", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setrgid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setrgid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setrgid(gid_t)
     * }
     */
    public static FunctionDescriptor setrgid$descriptor() {
        return setrgid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setrgid(gid_t)
     * }
     */
    public static MethodHandle setrgid$handle() {
        return setrgid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setrgid(gid_t)
     * }
     */
    public static MemorySegment setrgid$address() {
        return setrgid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setrgid(gid_t)
     * }
     */
    public static int setrgid(int x0) {
        var mh$ = setrgid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setrgid", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setruid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setruid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setruid(uid_t)
     * }
     */
    public static FunctionDescriptor setruid$descriptor() {
        return setruid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setruid(uid_t)
     * }
     */
    public static MethodHandle setruid$handle() {
        return setruid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setruid(uid_t)
     * }
     */
    public static MemorySegment setruid$address() {
        return setruid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setruid(uid_t)
     * }
     */
    public static int setruid(int x0) {
        var mh$ = setruid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setruid", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setsgroups_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setsgroups_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setsgroups_np(int, const uuid_t)
     * }
     */
    public static FunctionDescriptor setsgroups_np$descriptor() {
        return setsgroups_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setsgroups_np(int, const uuid_t)
     * }
     */
    public static MethodHandle setsgroups_np$handle() {
        return setsgroups_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setsgroups_np(int, const uuid_t)
     * }
     */
    public static MemorySegment setsgroups_np$address() {
        return setsgroups_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setsgroups_np(int, const uuid_t)
     * }
     */
    public static int setsgroups_np(int x0, MemorySegment x1) {
        var mh$ = setsgroups_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setsgroups_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setusershell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setusershell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setusershell()
     * }
     */
    public static FunctionDescriptor setusershell$descriptor() {
        return setusershell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setusershell()
     * }
     */
    public static MethodHandle setusershell$handle() {
        return setusershell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setusershell()
     * }
     */
    public static MemorySegment setusershell$address() {
        return setusershell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setusershell()
     * }
     */
    public static void setusershell() {
        var mh$ = setusershell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setusershell");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setwgroups_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setwgroups_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setwgroups_np(int, const uuid_t)
     * }
     */
    public static FunctionDescriptor setwgroups_np$descriptor() {
        return setwgroups_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setwgroups_np(int, const uuid_t)
     * }
     */
    public static MethodHandle setwgroups_np$handle() {
        return setwgroups_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setwgroups_np(int, const uuid_t)
     * }
     */
    public static MemorySegment setwgroups_np$address() {
        return setwgroups_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setwgroups_np(int, const uuid_t)
     * }
     */
    public static int setwgroups_np(int x0, MemorySegment x1) {
        var mh$ = setwgroups_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setwgroups_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtofflags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strtofflags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strtofflags(char **, unsigned long *, unsigned long *)
     * }
     */
    public static FunctionDescriptor strtofflags$descriptor() {
        return strtofflags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strtofflags(char **, unsigned long *, unsigned long *)
     * }
     */
    public static MethodHandle strtofflags$handle() {
        return strtofflags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strtofflags(char **, unsigned long *, unsigned long *)
     * }
     */
    public static MemorySegment strtofflags$address() {
        return strtofflags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strtofflags(char **, unsigned long *, unsigned long *)
     * }
     */
    public static int strtofflags(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = strtofflags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtofflags", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class swapon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("swapon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int swapon(const char *)
     * }
     */
    public static FunctionDescriptor swapon$descriptor() {
        return swapon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int swapon(const char *)
     * }
     */
    public static MethodHandle swapon$handle() {
        return swapon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int swapon(const char *)
     * }
     */
    public static MemorySegment swapon$address() {
        return swapon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int swapon(const char *)
     * }
     */
    public static int swapon(MemorySegment x0) {
        var mh$ = swapon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("swapon", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ttyslot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ttyslot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ttyslot()
     * }
     */
    public static FunctionDescriptor ttyslot$descriptor() {
        return ttyslot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ttyslot()
     * }
     */
    public static MethodHandle ttyslot$handle() {
        return ttyslot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ttyslot()
     * }
     */
    public static MemorySegment ttyslot$address() {
        return ttyslot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ttyslot()
     * }
     */
    public static int ttyslot() {
        var mh$ = ttyslot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ttyslot");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class undelete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("undelete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int undelete(const char *)
     * }
     */
    public static FunctionDescriptor undelete$descriptor() {
        return undelete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int undelete(const char *)
     * }
     */
    public static MethodHandle undelete$handle() {
        return undelete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int undelete(const char *)
     * }
     */
    public static MemorySegment undelete$address() {
        return undelete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int undelete(const char *)
     * }
     */
    public static int undelete(MemorySegment x0) {
        var mh$ = undelete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("undelete", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unwhiteout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("unwhiteout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int unwhiteout(const char *)
     * }
     */
    public static FunctionDescriptor unwhiteout$descriptor() {
        return unwhiteout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int unwhiteout(const char *)
     * }
     */
    public static MethodHandle unwhiteout$handle() {
        return unwhiteout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int unwhiteout(const char *)
     * }
     */
    public static MemorySegment unwhiteout$address() {
        return unwhiteout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int unwhiteout(const char *)
     * }
     */
    public static int unwhiteout(MemorySegment x0) {
        var mh$ = unwhiteout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unwhiteout", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int syscall(int, ...)
     * }
     */
    public static class syscall {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_INT
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("syscall");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private syscall(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int syscall(int, ...)
         * }
         */
        public static syscall makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new syscall(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(int x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("syscall", x0, x1);
                }
                return (int)spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class fgetattrlist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fgetattrlist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fgetattrlist(int, void *, void *, size_t, unsigned int)
     * }
     */
    public static FunctionDescriptor fgetattrlist$descriptor() {
        return fgetattrlist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fgetattrlist(int, void *, void *, size_t, unsigned int)
     * }
     */
    public static MethodHandle fgetattrlist$handle() {
        return fgetattrlist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fgetattrlist(int, void *, void *, size_t, unsigned int)
     * }
     */
    public static MemorySegment fgetattrlist$address() {
        return fgetattrlist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fgetattrlist(int, void *, void *, size_t, unsigned int)
     * }
     */
    public static int fgetattrlist(int x0, MemorySegment x1, MemorySegment x2, long x3, int x4) {
        var mh$ = fgetattrlist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetattrlist", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsetattrlist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fsetattrlist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fsetattrlist(int, void *, void *, size_t, unsigned int)
     * }
     */
    public static FunctionDescriptor fsetattrlist$descriptor() {
        return fsetattrlist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fsetattrlist(int, void *, void *, size_t, unsigned int)
     * }
     */
    public static MethodHandle fsetattrlist$handle() {
        return fsetattrlist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fsetattrlist(int, void *, void *, size_t, unsigned int)
     * }
     */
    public static MemorySegment fsetattrlist$address() {
        return fsetattrlist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fsetattrlist(int, void *, void *, size_t, unsigned int)
     * }
     */
    public static int fsetattrlist(int x0, MemorySegment x1, MemorySegment x2, long x3, int x4) {
        var mh$ = fsetattrlist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsetattrlist", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getattrlist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getattrlist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getattrlist(const char *, void *, void *, size_t, unsigned int)
     * }
     */
    public static FunctionDescriptor getattrlist$descriptor() {
        return getattrlist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getattrlist(const char *, void *, void *, size_t, unsigned int)
     * }
     */
    public static MethodHandle getattrlist$handle() {
        return getattrlist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getattrlist(const char *, void *, void *, size_t, unsigned int)
     * }
     */
    public static MemorySegment getattrlist$address() {
        return getattrlist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getattrlist(const char *, void *, void *, size_t, unsigned int)
     * }
     */
    public static int getattrlist(MemorySegment x0, MemorySegment x1, MemorySegment x2, long x3, int x4) {
        var mh$ = getattrlist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getattrlist", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setattrlist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setattrlist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setattrlist(const char *, void *, void *, size_t, unsigned int)
     * }
     */
    public static FunctionDescriptor setattrlist$descriptor() {
        return setattrlist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setattrlist(const char *, void *, void *, size_t, unsigned int)
     * }
     */
    public static MethodHandle setattrlist$handle() {
        return setattrlist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setattrlist(const char *, void *, void *, size_t, unsigned int)
     * }
     */
    public static MemorySegment setattrlist$address() {
        return setattrlist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setattrlist(const char *, void *, void *, size_t, unsigned int)
     * }
     */
    public static int setattrlist(MemorySegment x0, MemorySegment x1, MemorySegment x2, long x3, int x4) {
        var mh$ = setattrlist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setattrlist", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exchangedata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("exchangedata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int exchangedata(const char *, const char *, unsigned int)
     * }
     */
    public static FunctionDescriptor exchangedata$descriptor() {
        return exchangedata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int exchangedata(const char *, const char *, unsigned int)
     * }
     */
    public static MethodHandle exchangedata$handle() {
        return exchangedata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int exchangedata(const char *, const char *, unsigned int)
     * }
     */
    public static MemorySegment exchangedata$address() {
        return exchangedata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int exchangedata(const char *, const char *, unsigned int)
     * }
     */
    public static int exchangedata(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = exchangedata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exchangedata", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getdirentriesattr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getdirentriesattr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getdirentriesattr(int, void *, void *, size_t, unsigned int *, unsigned int *, unsigned int *, unsigned int)
     * }
     */
    public static FunctionDescriptor getdirentriesattr$descriptor() {
        return getdirentriesattr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getdirentriesattr(int, void *, void *, size_t, unsigned int *, unsigned int *, unsigned int *, unsigned int)
     * }
     */
    public static MethodHandle getdirentriesattr$handle() {
        return getdirentriesattr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getdirentriesattr(int, void *, void *, size_t, unsigned int *, unsigned int *, unsigned int *, unsigned int)
     * }
     */
    public static MemorySegment getdirentriesattr$address() {
        return getdirentriesattr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getdirentriesattr(int, void *, void *, size_t, unsigned int *, unsigned int *, unsigned int *, unsigned int)
     * }
     */
    public static int getdirentriesattr(int x0, MemorySegment x1, MemorySegment x2, long x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, int x7) {
        var mh$ = getdirentriesattr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getdirentriesattr", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class searchfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("searchfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int searchfs(const char *, struct fssearchblock *, unsigned long *, unsigned int, unsigned int, struct searchstate *)
     * }
     */
    public static FunctionDescriptor searchfs$descriptor() {
        return searchfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int searchfs(const char *, struct fssearchblock *, unsigned long *, unsigned int, unsigned int, struct searchstate *)
     * }
     */
    public static MethodHandle searchfs$handle() {
        return searchfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int searchfs(const char *, struct fssearchblock *, unsigned long *, unsigned int, unsigned int, struct searchstate *)
     * }
     */
    public static MemorySegment searchfs$address() {
        return searchfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int searchfs(const char *, struct fssearchblock *, unsigned long *, unsigned int, unsigned int, struct searchstate *)
     * }
     */
    public static int searchfs(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5) {
        var mh$ = searchfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("searchfs", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsctl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fsctl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fsctl(const char *, unsigned long, void *, unsigned int)
     * }
     */
    public static FunctionDescriptor fsctl$descriptor() {
        return fsctl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fsctl(const char *, unsigned long, void *, unsigned int)
     * }
     */
    public static MethodHandle fsctl$handle() {
        return fsctl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fsctl(const char *, unsigned long, void *, unsigned int)
     * }
     */
    public static MemorySegment fsctl$address() {
        return fsctl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fsctl(const char *, unsigned long, void *, unsigned int)
     * }
     */
    public static int fsctl(MemorySegment x0, long x1, MemorySegment x2, int x3) {
        var mh$ = fsctl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsctl", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffsctl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ffsctl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ffsctl(int, unsigned long, void *, unsigned int)
     * }
     */
    public static FunctionDescriptor ffsctl$descriptor() {
        return ffsctl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ffsctl(int, unsigned long, void *, unsigned int)
     * }
     */
    public static MethodHandle ffsctl$handle() {
        return ffsctl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ffsctl(int, unsigned long, void *, unsigned int)
     * }
     */
    public static MemorySegment ffsctl$address() {
        return ffsctl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ffsctl(int, unsigned long, void *, unsigned int)
     * }
     */
    public static int ffsctl(int x0, long x1, MemorySegment x2, int x3) {
        var mh$ = ffsctl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffsctl", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsync_volume_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fsync_volume_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fsync_volume_np(int, int)
     * }
     */
    public static FunctionDescriptor fsync_volume_np$descriptor() {
        return fsync_volume_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fsync_volume_np(int, int)
     * }
     */
    public static MethodHandle fsync_volume_np$handle() {
        return fsync_volume_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fsync_volume_np(int, int)
     * }
     */
    public static MemorySegment fsync_volume_np$address() {
        return fsync_volume_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fsync_volume_np(int, int)
     * }
     */
    public static int fsync_volume_np(int x0, int x1) {
        var mh$ = fsync_volume_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsync_volume_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sync_volume_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sync_volume_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sync_volume_np(const char *, int)
     * }
     */
    public static FunctionDescriptor sync_volume_np$descriptor() {
        return sync_volume_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sync_volume_np(const char *, int)
     * }
     */
    public static MethodHandle sync_volume_np$handle() {
        return sync_volume_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sync_volume_np(const char *, int)
     * }
     */
    public static MemorySegment sync_volume_np$address() {
        return sync_volume_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sync_volume_np(const char *, int)
     * }
     */
    public static int sync_volume_np(MemorySegment x0, int x1) {
        var mh$ = sync_volume_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sync_volume_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class optreset$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("optreset").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int optreset
     * }
     */
    public static OfInt optreset$layout() {
        return optreset$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int optreset
     * }
     */
    public static MemorySegment optreset$segment() {
        return optreset$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int optreset
     * }
     */
    public static int optreset() {
        return optreset$constants.SEGMENT.get(optreset$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int optreset
     * }
     */
    public static void optreset(int varValue) {
        optreset$constants.SEGMENT.set(optreset$constants.LAYOUT, 0L, varValue);
    }

    private static class __assert_rtn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__assert_rtn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __assert_rtn(const char *, const char *, int, const char *)
     * }
     */
    public static FunctionDescriptor __assert_rtn$descriptor() {
        return __assert_rtn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __assert_rtn(const char *, const char *, int, const char *)
     * }
     */
    public static MethodHandle __assert_rtn$handle() {
        return __assert_rtn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __assert_rtn(const char *, const char *, int, const char *)
     * }
     */
    public static MemorySegment __assert_rtn$address() {
        return __assert_rtn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __assert_rtn(const char *, const char *, int, const char *)
     * }
     */
    public static void __assert_rtn(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3) {
        var mh$ = __assert_rtn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__assert_rtn", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __builtin_va_list __gnuc_va_list
     * }
     */
    public static final AddressLayout __gnuc_va_list = Python_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __darwin_clock_t clock_t
     * }
     */
    public static final OfLong clock_t = Python_h.C_LONG;

    private static class tzname$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(0, Python_h.C_POINTER);
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("tzname").reinterpret(LAYOUT.byteSize());
        public static final VarHandle HANDLE = LAYOUT.varHandle();

        public static final long[] DIMS = {  };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *tzname[]
     * }
     */
    public static SequenceLayout tzname$layout() {
        return tzname$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern char *tzname[]
     * }
     */
    public static long[] tzname$dimensions() {
        return tzname$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *tzname[]
     * }
     */
    public static MemorySegment tzname() {
        return tzname$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *tzname[]
     * }
     */
    public static void tzname(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, tzname$constants.SEGMENT, 0L, tzname$constants.LAYOUT.byteSize());
    }

    private static class getdate_err$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("getdate_err").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int getdate_err
     * }
     */
    public static OfInt getdate_err$layout() {
        return getdate_err$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int getdate_err
     * }
     */
    public static MemorySegment getdate_err$segment() {
        return getdate_err$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int getdate_err
     * }
     */
    public static int getdate_err() {
        return getdate_err$constants.SEGMENT.get(getdate_err$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int getdate_err
     * }
     */
    public static void getdate_err(int varValue) {
        getdate_err$constants.SEGMENT.set(getdate_err$constants.LAYOUT, 0L, varValue);
    }

    private static class timezone$constants {
        public static final OfLong LAYOUT = Python_h.C_LONG;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("timezone").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static OfLong timezone$layout() {
        return timezone$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static MemorySegment timezone$segment() {
        return timezone$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static long timezone() {
        return timezone$constants.SEGMENT.get(timezone$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static void timezone(long varValue) {
        timezone$constants.SEGMENT.set(timezone$constants.LAYOUT, 0L, varValue);
    }

    private static class daylight$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("daylight").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static OfInt daylight$layout() {
        return daylight$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static MemorySegment daylight$segment() {
        return daylight$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static int daylight() {
        return daylight$constants.SEGMENT.get(daylight$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static void daylight(int varValue) {
        daylight$constants.SEGMENT.set(daylight$constants.LAYOUT, 0L, varValue);
    }

    private static class asctime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("asctime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *asctime(const struct tm *)
     * }
     */
    public static FunctionDescriptor asctime$descriptor() {
        return asctime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *asctime(const struct tm *)
     * }
     */
    public static MethodHandle asctime$handle() {
        return asctime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *asctime(const struct tm *)
     * }
     */
    public static MemorySegment asctime$address() {
        return asctime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *asctime(const struct tm *)
     * }
     */
    public static MemorySegment asctime(MemorySegment x0) {
        var mh$ = asctime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asctime", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("clock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * clock_t clock()
     * }
     */
    public static FunctionDescriptor clock$descriptor() {
        return clock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * clock_t clock()
     * }
     */
    public static MethodHandle clock$handle() {
        return clock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * clock_t clock()
     * }
     */
    public static MemorySegment clock$address() {
        return clock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * clock_t clock()
     * }
     */
    public static long clock() {
        var mh$ = clock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ctime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ctime(const time_t *)
     * }
     */
    public static FunctionDescriptor ctime$descriptor() {
        return ctime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ctime(const time_t *)
     * }
     */
    public static MethodHandle ctime$handle() {
        return ctime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ctime(const time_t *)
     * }
     */
    public static MemorySegment ctime$address() {
        return ctime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ctime(const time_t *)
     * }
     */
    public static MemorySegment ctime(MemorySegment x0) {
        var mh$ = ctime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctime", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class difftime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("difftime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double difftime(time_t, time_t)
     * }
     */
    public static FunctionDescriptor difftime$descriptor() {
        return difftime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double difftime(time_t, time_t)
     * }
     */
    public static MethodHandle difftime$handle() {
        return difftime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double difftime(time_t, time_t)
     * }
     */
    public static MemorySegment difftime$address() {
        return difftime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double difftime(time_t, time_t)
     * }
     */
    public static double difftime(long x0, long x1) {
        var mh$ = difftime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("difftime", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getdate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getdate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct tm *getdate(const char *)
     * }
     */
    public static FunctionDescriptor getdate$descriptor() {
        return getdate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct tm *getdate(const char *)
     * }
     */
    public static MethodHandle getdate$handle() {
        return getdate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct tm *getdate(const char *)
     * }
     */
    public static MemorySegment getdate$address() {
        return getdate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct tm *getdate(const char *)
     * }
     */
    public static MemorySegment getdate(MemorySegment x0) {
        var mh$ = getdate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getdate", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gmtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("gmtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct tm *gmtime(const time_t *)
     * }
     */
    public static FunctionDescriptor gmtime$descriptor() {
        return gmtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct tm *gmtime(const time_t *)
     * }
     */
    public static MethodHandle gmtime$handle() {
        return gmtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct tm *gmtime(const time_t *)
     * }
     */
    public static MemorySegment gmtime$address() {
        return gmtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct tm *gmtime(const time_t *)
     * }
     */
    public static MemorySegment gmtime(MemorySegment x0) {
        var mh$ = gmtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gmtime", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class localtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("localtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct tm *localtime(const time_t *)
     * }
     */
    public static FunctionDescriptor localtime$descriptor() {
        return localtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct tm *localtime(const time_t *)
     * }
     */
    public static MethodHandle localtime$handle() {
        return localtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct tm *localtime(const time_t *)
     * }
     */
    public static MemorySegment localtime$address() {
        return localtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct tm *localtime(const time_t *)
     * }
     */
    public static MemorySegment localtime(MemorySegment x0) {
        var mh$ = localtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("localtime", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mktime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mktime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * time_t mktime(struct tm *)
     * }
     */
    public static FunctionDescriptor mktime$descriptor() {
        return mktime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * time_t mktime(struct tm *)
     * }
     */
    public static MethodHandle mktime$handle() {
        return mktime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * time_t mktime(struct tm *)
     * }
     */
    public static MemorySegment mktime$address() {
        return mktime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * time_t mktime(struct tm *)
     * }
     */
    public static long mktime(MemorySegment x0) {
        var mh$ = mktime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mktime", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strftime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strftime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t strftime(char *restrict, size_t, const char *restrict, const struct tm *restrict)
     * }
     */
    public static FunctionDescriptor strftime$descriptor() {
        return strftime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t strftime(char *restrict, size_t, const char *restrict, const struct tm *restrict)
     * }
     */
    public static MethodHandle strftime$handle() {
        return strftime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t strftime(char *restrict, size_t, const char *restrict, const struct tm *restrict)
     * }
     */
    public static MemorySegment strftime$address() {
        return strftime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t strftime(char *restrict, size_t, const char *restrict, const struct tm *restrict)
     * }
     */
    public static long strftime(MemorySegment x0, long x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = strftime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strftime", x0, x1, x2, x3);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strptime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strptime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strptime(const char *restrict, const char *restrict, struct tm *restrict)
     * }
     */
    public static FunctionDescriptor strptime$descriptor() {
        return strptime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strptime(const char *restrict, const char *restrict, struct tm *restrict)
     * }
     */
    public static MethodHandle strptime$handle() {
        return strptime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strptime(const char *restrict, const char *restrict, struct tm *restrict)
     * }
     */
    public static MemorySegment strptime$address() {
        return strptime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strptime(const char *restrict, const char *restrict, struct tm *restrict)
     * }
     */
    public static MemorySegment strptime(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = strptime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strptime", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * time_t time(time_t *)
     * }
     */
    public static FunctionDescriptor time$descriptor() {
        return time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * time_t time(time_t *)
     * }
     */
    public static MethodHandle time$handle() {
        return time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * time_t time(time_t *)
     * }
     */
    public static MemorySegment time$address() {
        return time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * time_t time(time_t *)
     * }
     */
    public static long time(MemorySegment x0) {
        var mh$ = time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("time", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tzset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tzset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void tzset()
     * }
     */
    public static FunctionDescriptor tzset$descriptor() {
        return tzset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void tzset()
     * }
     */
    public static MethodHandle tzset$handle() {
        return tzset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void tzset()
     * }
     */
    public static MemorySegment tzset$address() {
        return tzset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void tzset()
     * }
     */
    public static void tzset() {
        var mh$ = tzset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tzset");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asctime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("asctime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *asctime_r(const struct tm *restrict, char *restrict)
     * }
     */
    public static FunctionDescriptor asctime_r$descriptor() {
        return asctime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *asctime_r(const struct tm *restrict, char *restrict)
     * }
     */
    public static MethodHandle asctime_r$handle() {
        return asctime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *asctime_r(const struct tm *restrict, char *restrict)
     * }
     */
    public static MemorySegment asctime_r$address() {
        return asctime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *asctime_r(const struct tm *restrict, char *restrict)
     * }
     */
    public static MemorySegment asctime_r(MemorySegment x0, MemorySegment x1) {
        var mh$ = asctime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asctime_r", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ctime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ctime_r(const time_t *, char *)
     * }
     */
    public static FunctionDescriptor ctime_r$descriptor() {
        return ctime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ctime_r(const time_t *, char *)
     * }
     */
    public static MethodHandle ctime_r$handle() {
        return ctime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ctime_r(const time_t *, char *)
     * }
     */
    public static MemorySegment ctime_r$address() {
        return ctime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ctime_r(const time_t *, char *)
     * }
     */
    public static MemorySegment ctime_r(MemorySegment x0, MemorySegment x1) {
        var mh$ = ctime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctime_r", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gmtime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("gmtime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct tm *gmtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static FunctionDescriptor gmtime_r$descriptor() {
        return gmtime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct tm *gmtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static MethodHandle gmtime_r$handle() {
        return gmtime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct tm *gmtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static MemorySegment gmtime_r$address() {
        return gmtime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct tm *gmtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static MemorySegment gmtime_r(MemorySegment x0, MemorySegment x1) {
        var mh$ = gmtime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gmtime_r", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class localtime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("localtime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct tm *localtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static FunctionDescriptor localtime_r$descriptor() {
        return localtime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct tm *localtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static MethodHandle localtime_r$handle() {
        return localtime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct tm *localtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static MemorySegment localtime_r$address() {
        return localtime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct tm *localtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static MemorySegment localtime_r(MemorySegment x0, MemorySegment x1) {
        var mh$ = localtime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("localtime_r", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class posix2time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("posix2time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * time_t posix2time(time_t)
     * }
     */
    public static FunctionDescriptor posix2time$descriptor() {
        return posix2time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * time_t posix2time(time_t)
     * }
     */
    public static MethodHandle posix2time$handle() {
        return posix2time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * time_t posix2time(time_t)
     * }
     */
    public static MemorySegment posix2time$address() {
        return posix2time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * time_t posix2time(time_t)
     * }
     */
    public static long posix2time(long x0) {
        var mh$ = posix2time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("posix2time", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tzsetwall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tzsetwall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void tzsetwall()
     * }
     */
    public static FunctionDescriptor tzsetwall$descriptor() {
        return tzsetwall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void tzsetwall()
     * }
     */
    public static MethodHandle tzsetwall$handle() {
        return tzsetwall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void tzsetwall()
     * }
     */
    public static MemorySegment tzsetwall$address() {
        return tzsetwall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void tzsetwall()
     * }
     */
    public static void tzsetwall() {
        var mh$ = tzsetwall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tzsetwall");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class time2posix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("time2posix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * time_t time2posix(time_t)
     * }
     */
    public static FunctionDescriptor time2posix$descriptor() {
        return time2posix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * time_t time2posix(time_t)
     * }
     */
    public static MethodHandle time2posix$handle() {
        return time2posix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * time_t time2posix(time_t)
     * }
     */
    public static MemorySegment time2posix$address() {
        return time2posix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * time_t time2posix(time_t)
     * }
     */
    public static long time2posix(long x0) {
        var mh$ = time2posix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("time2posix", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timelocal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("timelocal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * time_t timelocal(struct tm *const)
     * }
     */
    public static FunctionDescriptor timelocal$descriptor() {
        return timelocal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * time_t timelocal(struct tm *const)
     * }
     */
    public static MethodHandle timelocal$handle() {
        return timelocal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * time_t timelocal(struct tm *const)
     * }
     */
    public static MemorySegment timelocal$address() {
        return timelocal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * time_t timelocal(struct tm *const)
     * }
     */
    public static long timelocal(MemorySegment x0) {
        var mh$ = timelocal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timelocal", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timegm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("timegm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * time_t timegm(struct tm *const)
     * }
     */
    public static FunctionDescriptor timegm$descriptor() {
        return timegm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * time_t timegm(struct tm *const)
     * }
     */
    public static MethodHandle timegm$handle() {
        return timegm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * time_t timegm(struct tm *const)
     * }
     */
    public static MemorySegment timegm$address() {
        return timegm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * time_t timegm(struct tm *const)
     * }
     */
    public static long timegm(MemorySegment x0) {
        var mh$ = timegm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timegm", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nanosleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("nanosleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int nanosleep(const struct timespec *__rqtp, struct timespec *__rmtp)
     * }
     */
    public static FunctionDescriptor nanosleep$descriptor() {
        return nanosleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int nanosleep(const struct timespec *__rqtp, struct timespec *__rmtp)
     * }
     */
    public static MethodHandle nanosleep$handle() {
        return nanosleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int nanosleep(const struct timespec *__rqtp, struct timespec *__rmtp)
     * }
     */
    public static MemorySegment nanosleep$address() {
        return nanosleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int nanosleep(const struct timespec *__rqtp, struct timespec *__rmtp)
     * }
     */
    public static int nanosleep(MemorySegment __rqtp, MemorySegment __rmtp) {
        var mh$ = nanosleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nanosleep", __rqtp, __rmtp);
            }
            return (int)mh$.invokeExact(__rqtp, __rmtp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int _CLOCK_REALTIME = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_REALTIME = 0
     * }
     */
    public static int _CLOCK_REALTIME() {
        return _CLOCK_REALTIME;
    }
    private static final int _CLOCK_MONOTONIC = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_MONOTONIC = 6
     * }
     */
    public static int _CLOCK_MONOTONIC() {
        return _CLOCK_MONOTONIC;
    }
    private static final int _CLOCK_MONOTONIC_RAW = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_MONOTONIC_RAW = 4
     * }
     */
    public static int _CLOCK_MONOTONIC_RAW() {
        return _CLOCK_MONOTONIC_RAW;
    }
    private static final int _CLOCK_MONOTONIC_RAW_APPROX = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_MONOTONIC_RAW_APPROX = 5
     * }
     */
    public static int _CLOCK_MONOTONIC_RAW_APPROX() {
        return _CLOCK_MONOTONIC_RAW_APPROX;
    }
    private static final int _CLOCK_UPTIME_RAW = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_UPTIME_RAW = 8
     * }
     */
    public static int _CLOCK_UPTIME_RAW() {
        return _CLOCK_UPTIME_RAW;
    }
    private static final int _CLOCK_UPTIME_RAW_APPROX = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_UPTIME_RAW_APPROX = 9
     * }
     */
    public static int _CLOCK_UPTIME_RAW_APPROX() {
        return _CLOCK_UPTIME_RAW_APPROX;
    }
    private static final int _CLOCK_PROCESS_CPUTIME_ID = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_PROCESS_CPUTIME_ID = 12
     * }
     */
    public static int _CLOCK_PROCESS_CPUTIME_ID() {
        return _CLOCK_PROCESS_CPUTIME_ID;
    }
    private static final int _CLOCK_THREAD_CPUTIME_ID = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_THREAD_CPUTIME_ID = 16
     * }
     */
    public static int _CLOCK_THREAD_CPUTIME_ID() {
        return _CLOCK_THREAD_CPUTIME_ID;
    }

    private static class clock_getres {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("clock_getres");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static FunctionDescriptor clock_getres$descriptor() {
        return clock_getres.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static MethodHandle clock_getres$handle() {
        return clock_getres.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static MemorySegment clock_getres$address() {
        return clock_getres.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static int clock_getres(int __clock_id, MemorySegment __res) {
        var mh$ = clock_getres.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_getres", __clock_id, __res);
            }
            return (int)mh$.invokeExact(__clock_id, __res);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_gettime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("clock_gettime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static FunctionDescriptor clock_gettime$descriptor() {
        return clock_gettime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static MethodHandle clock_gettime$handle() {
        return clock_gettime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static MemorySegment clock_gettime$address() {
        return clock_gettime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static int clock_gettime(int __clock_id, MemorySegment __tp) {
        var mh$ = clock_gettime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_gettime", __clock_id, __tp);
            }
            return (int)mh$.invokeExact(__clock_id, __tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_gettime_nsec_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("clock_gettime_nsec_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __uint64_t clock_gettime_nsec_np(clockid_t __clock_id)
     * }
     */
    public static FunctionDescriptor clock_gettime_nsec_np$descriptor() {
        return clock_gettime_nsec_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __uint64_t clock_gettime_nsec_np(clockid_t __clock_id)
     * }
     */
    public static MethodHandle clock_gettime_nsec_np$handle() {
        return clock_gettime_nsec_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __uint64_t clock_gettime_nsec_np(clockid_t __clock_id)
     * }
     */
    public static MemorySegment clock_gettime_nsec_np$address() {
        return clock_gettime_nsec_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __uint64_t clock_gettime_nsec_np(clockid_t __clock_id)
     * }
     */
    public static long clock_gettime_nsec_np(int __clock_id) {
        var mh$ = clock_gettime_nsec_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_gettime_nsec_np", __clock_id);
            }
            return (long)mh$.invokeExact(__clock_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_settime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("clock_settime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static FunctionDescriptor clock_settime$descriptor() {
        return clock_settime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static MethodHandle clock_settime$handle() {
        return clock_settime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static MemorySegment clock_settime$address() {
        return clock_settime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static int clock_settime(int __clock_id, MemorySegment __tp) {
        var mh$ = clock_settime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_settime", __clock_id, __tp);
            }
            return (int)mh$.invokeExact(__clock_id, __tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timespec_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("timespec_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int timespec_get(struct timespec *ts, int base)
     * }
     */
    public static FunctionDescriptor timespec_get$descriptor() {
        return timespec_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int timespec_get(struct timespec *ts, int base)
     * }
     */
    public static MethodHandle timespec_get$handle() {
        return timespec_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int timespec_get(struct timespec *ts, int base)
     * }
     */
    public static MemorySegment timespec_get$address() {
        return timespec_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int timespec_get(struct timespec *ts, int base)
     * }
     */
    public static int timespec_get(MemorySegment ts, int base) {
        var mh$ = timespec_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timespec_get", ts, base);
            }
            return (int)mh$.invokeExact(ts, base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_wint_t wint_t
     * }
     */
    public static final OfInt wint_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_wctype_t wctype_t
     * }
     */
    public static final OfInt wctype_t = Python_h.C_INT;

    private static class _DefaultRuneLocale$constants {
        public static final GroupLayout LAYOUT = _RuneLocale.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_DefaultRuneLocale").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern _RuneLocale _DefaultRuneLocale
     * }
     */
    public static GroupLayout _DefaultRuneLocale$layout() {
        return _DefaultRuneLocale$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern _RuneLocale _DefaultRuneLocale
     * }
     */
    public static MemorySegment _DefaultRuneLocale() {
        return _DefaultRuneLocale$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern _RuneLocale _DefaultRuneLocale
     * }
     */
    public static void _DefaultRuneLocale(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _DefaultRuneLocale$constants.SEGMENT, 0L, _DefaultRuneLocale$constants.LAYOUT.byteSize());
    }

    private static class _CurrentRuneLocale$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_CurrentRuneLocale").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern _RuneLocale *_CurrentRuneLocale
     * }
     */
    public static AddressLayout _CurrentRuneLocale$layout() {
        return _CurrentRuneLocale$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern _RuneLocale *_CurrentRuneLocale
     * }
     */
    public static MemorySegment _CurrentRuneLocale$segment() {
        return _CurrentRuneLocale$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern _RuneLocale *_CurrentRuneLocale
     * }
     */
    public static MemorySegment _CurrentRuneLocale() {
        return _CurrentRuneLocale$constants.SEGMENT.get(_CurrentRuneLocale$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern _RuneLocale *_CurrentRuneLocale
     * }
     */
    public static void _CurrentRuneLocale(MemorySegment varValue) {
        _CurrentRuneLocale$constants.SEGMENT.set(_CurrentRuneLocale$constants.LAYOUT, 0L, varValue);
    }

    private static class ___runetype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("___runetype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long ___runetype(__darwin_ct_rune_t)
     * }
     */
    public static FunctionDescriptor ___runetype$descriptor() {
        return ___runetype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long ___runetype(__darwin_ct_rune_t)
     * }
     */
    public static MethodHandle ___runetype$handle() {
        return ___runetype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long ___runetype(__darwin_ct_rune_t)
     * }
     */
    public static MemorySegment ___runetype$address() {
        return ___runetype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long ___runetype(__darwin_ct_rune_t)
     * }
     */
    public static long ___runetype(int x0) {
        var mh$ = ___runetype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("___runetype", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ___tolower {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("___tolower");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __darwin_ct_rune_t ___tolower(__darwin_ct_rune_t)
     * }
     */
    public static FunctionDescriptor ___tolower$descriptor() {
        return ___tolower.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __darwin_ct_rune_t ___tolower(__darwin_ct_rune_t)
     * }
     */
    public static MethodHandle ___tolower$handle() {
        return ___tolower.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __darwin_ct_rune_t ___tolower(__darwin_ct_rune_t)
     * }
     */
    public static MemorySegment ___tolower$address() {
        return ___tolower.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __darwin_ct_rune_t ___tolower(__darwin_ct_rune_t)
     * }
     */
    public static int ___tolower(int x0) {
        var mh$ = ___tolower.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("___tolower", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ___toupper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("___toupper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __darwin_ct_rune_t ___toupper(__darwin_ct_rune_t)
     * }
     */
    public static FunctionDescriptor ___toupper$descriptor() {
        return ___toupper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __darwin_ct_rune_t ___toupper(__darwin_ct_rune_t)
     * }
     */
    public static MethodHandle ___toupper$handle() {
        return ___toupper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __darwin_ct_rune_t ___toupper(__darwin_ct_rune_t)
     * }
     */
    public static MemorySegment ___toupper$address() {
        return ___toupper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __darwin_ct_rune_t ___toupper(__darwin_ct_rune_t)
     * }
     */
    public static int ___toupper(int x0) {
        var mh$ = ___toupper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("___toupper", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __maskrune {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__maskrune");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __maskrune(__darwin_ct_rune_t, unsigned long)
     * }
     */
    public static FunctionDescriptor __maskrune$descriptor() {
        return __maskrune.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __maskrune(__darwin_ct_rune_t, unsigned long)
     * }
     */
    public static MethodHandle __maskrune$handle() {
        return __maskrune.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __maskrune(__darwin_ct_rune_t, unsigned long)
     * }
     */
    public static MemorySegment __maskrune$address() {
        return __maskrune.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __maskrune(__darwin_ct_rune_t, unsigned long)
     * }
     */
    public static int __maskrune(int x0, long x1) {
        var mh$ = __maskrune.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__maskrune", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __toupper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__toupper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __darwin_ct_rune_t __toupper(__darwin_ct_rune_t)
     * }
     */
    public static FunctionDescriptor __toupper$descriptor() {
        return __toupper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __darwin_ct_rune_t __toupper(__darwin_ct_rune_t)
     * }
     */
    public static MethodHandle __toupper$handle() {
        return __toupper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __darwin_ct_rune_t __toupper(__darwin_ct_rune_t)
     * }
     */
    public static MemorySegment __toupper$address() {
        return __toupper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __darwin_ct_rune_t __toupper(__darwin_ct_rune_t)
     * }
     */
    public static int __toupper(int x0) {
        var mh$ = __toupper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__toupper", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __tolower {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__tolower");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __darwin_ct_rune_t __tolower(__darwin_ct_rune_t)
     * }
     */
    public static FunctionDescriptor __tolower$descriptor() {
        return __tolower.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __darwin_ct_rune_t __tolower(__darwin_ct_rune_t)
     * }
     */
    public static MethodHandle __tolower$handle() {
        return __tolower.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __darwin_ct_rune_t __tolower(__darwin_ct_rune_t)
     * }
     */
    public static MemorySegment __tolower$address() {
        return __tolower.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __darwin_ct_rune_t __tolower(__darwin_ct_rune_t)
     * }
     */
    public static int __tolower(int x0) {
        var mh$ = __tolower.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__tolower", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wctype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wctype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wctype_t wctype(const char *)
     * }
     */
    public static FunctionDescriptor wctype$descriptor() {
        return wctype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wctype_t wctype(const char *)
     * }
     */
    public static MethodHandle wctype$handle() {
        return wctype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wctype_t wctype(const char *)
     * }
     */
    public static MemorySegment wctype$address() {
        return wctype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wctype_t wctype(const char *)
     * }
     */
    public static int wctype(MemorySegment x0) {
        var mh$ = wctype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wctype", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btowc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("btowc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t btowc(int)
     * }
     */
    public static FunctionDescriptor btowc$descriptor() {
        return btowc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t btowc(int)
     * }
     */
    public static MethodHandle btowc$handle() {
        return btowc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t btowc(int)
     * }
     */
    public static MemorySegment btowc$address() {
        return btowc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t btowc(int)
     * }
     */
    public static int btowc(int x0) {
        var mh$ = btowc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btowc", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetwc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fgetwc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t fgetwc(FILE *)
     * }
     */
    public static FunctionDescriptor fgetwc$descriptor() {
        return fgetwc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t fgetwc(FILE *)
     * }
     */
    public static MethodHandle fgetwc$handle() {
        return fgetwc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t fgetwc(FILE *)
     * }
     */
    public static MemorySegment fgetwc$address() {
        return fgetwc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t fgetwc(FILE *)
     * }
     */
    public static int fgetwc(MemorySegment x0) {
        var mh$ = fgetwc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetwc", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetws {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fgetws");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *fgetws(wchar_t *restrict, int, FILE *restrict)
     * }
     */
    public static FunctionDescriptor fgetws$descriptor() {
        return fgetws.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *fgetws(wchar_t *restrict, int, FILE *restrict)
     * }
     */
    public static MethodHandle fgetws$handle() {
        return fgetws.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *fgetws(wchar_t *restrict, int, FILE *restrict)
     * }
     */
    public static MemorySegment fgetws$address() {
        return fgetws.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *fgetws(wchar_t *restrict, int, FILE *restrict)
     * }
     */
    public static MemorySegment fgetws(MemorySegment x0, int x1, MemorySegment x2) {
        var mh$ = fgetws.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetws", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputwc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fputwc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t fputwc(wchar_t, FILE *)
     * }
     */
    public static FunctionDescriptor fputwc$descriptor() {
        return fputwc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t fputwc(wchar_t, FILE *)
     * }
     */
    public static MethodHandle fputwc$handle() {
        return fputwc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t fputwc(wchar_t, FILE *)
     * }
     */
    public static MemorySegment fputwc$address() {
        return fputwc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t fputwc(wchar_t, FILE *)
     * }
     */
    public static int fputwc(int x0, MemorySegment x1) {
        var mh$ = fputwc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputwc", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputws {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fputws");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fputws(const wchar_t *restrict, FILE *restrict)
     * }
     */
    public static FunctionDescriptor fputws$descriptor() {
        return fputws.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fputws(const wchar_t *restrict, FILE *restrict)
     * }
     */
    public static MethodHandle fputws$handle() {
        return fputws.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fputws(const wchar_t *restrict, FILE *restrict)
     * }
     */
    public static MemorySegment fputws$address() {
        return fputws.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fputws(const wchar_t *restrict, FILE *restrict)
     * }
     */
    public static int fputws(MemorySegment x0, MemorySegment x1) {
        var mh$ = fputws.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputws", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fwide {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fwide");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fwide(FILE *, int)
     * }
     */
    public static FunctionDescriptor fwide$descriptor() {
        return fwide.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fwide(FILE *, int)
     * }
     */
    public static MethodHandle fwide$handle() {
        return fwide.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fwide(FILE *, int)
     * }
     */
    public static MemorySegment fwide$address() {
        return fwide.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fwide(FILE *, int)
     * }
     */
    public static int fwide(MemorySegment x0, int x1) {
        var mh$ = fwide.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fwide", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int fwprintf(FILE *restrict, const wchar_t *restrict, ...)
     * }
     */
    public static class fwprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("fwprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fwprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int fwprintf(FILE *restrict, const wchar_t *restrict, ...)
         * }
         */
        public static fwprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fwprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fwprintf", x0, x1, x2);
                }
                return (int)spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int fwscanf(FILE *restrict, const wchar_t *restrict, ...)
     * }
     */
    public static class fwscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("fwscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fwscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int fwscanf(FILE *restrict, const wchar_t *restrict, ...)
         * }
         */
        public static fwscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fwscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fwscanf", x0, x1, x2);
                }
                return (int)spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class getwc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getwc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t getwc(FILE *)
     * }
     */
    public static FunctionDescriptor getwc$descriptor() {
        return getwc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t getwc(FILE *)
     * }
     */
    public static MethodHandle getwc$handle() {
        return getwc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t getwc(FILE *)
     * }
     */
    public static MemorySegment getwc$address() {
        return getwc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t getwc(FILE *)
     * }
     */
    public static int getwc(MemorySegment x0) {
        var mh$ = getwc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getwc", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getwchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getwchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t getwchar()
     * }
     */
    public static FunctionDescriptor getwchar$descriptor() {
        return getwchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t getwchar()
     * }
     */
    public static MethodHandle getwchar$handle() {
        return getwchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t getwchar()
     * }
     */
    public static MemorySegment getwchar$address() {
        return getwchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t getwchar()
     * }
     */
    public static int getwchar() {
        var mh$ = getwchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getwchar");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbrlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mbrlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t mbrlen(const char *restrict, size_t, mbstate_t *restrict)
     * }
     */
    public static FunctionDescriptor mbrlen$descriptor() {
        return mbrlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t mbrlen(const char *restrict, size_t, mbstate_t *restrict)
     * }
     */
    public static MethodHandle mbrlen$handle() {
        return mbrlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t mbrlen(const char *restrict, size_t, mbstate_t *restrict)
     * }
     */
    public static MemorySegment mbrlen$address() {
        return mbrlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t mbrlen(const char *restrict, size_t, mbstate_t *restrict)
     * }
     */
    public static long mbrlen(MemorySegment x0, long x1, MemorySegment x2) {
        var mh$ = mbrlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbrlen", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbrtowc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mbrtowc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t mbrtowc(wchar_t *restrict, const char *restrict, size_t, mbstate_t *restrict)
     * }
     */
    public static FunctionDescriptor mbrtowc$descriptor() {
        return mbrtowc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t mbrtowc(wchar_t *restrict, const char *restrict, size_t, mbstate_t *restrict)
     * }
     */
    public static MethodHandle mbrtowc$handle() {
        return mbrtowc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t mbrtowc(wchar_t *restrict, const char *restrict, size_t, mbstate_t *restrict)
     * }
     */
    public static MemorySegment mbrtowc$address() {
        return mbrtowc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t mbrtowc(wchar_t *restrict, const char *restrict, size_t, mbstate_t *restrict)
     * }
     */
    public static long mbrtowc(MemorySegment x0, MemorySegment x1, long x2, MemorySegment x3) {
        var mh$ = mbrtowc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbrtowc", x0, x1, x2, x3);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbsinit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mbsinit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mbsinit(const mbstate_t *)
     * }
     */
    public static FunctionDescriptor mbsinit$descriptor() {
        return mbsinit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mbsinit(const mbstate_t *)
     * }
     */
    public static MethodHandle mbsinit$handle() {
        return mbsinit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mbsinit(const mbstate_t *)
     * }
     */
    public static MemorySegment mbsinit$address() {
        return mbsinit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mbsinit(const mbstate_t *)
     * }
     */
    public static int mbsinit(MemorySegment x0) {
        var mh$ = mbsinit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbsinit", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbsrtowcs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mbsrtowcs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t mbsrtowcs(wchar_t *restrict, const char **restrict, size_t, mbstate_t *restrict)
     * }
     */
    public static FunctionDescriptor mbsrtowcs$descriptor() {
        return mbsrtowcs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t mbsrtowcs(wchar_t *restrict, const char **restrict, size_t, mbstate_t *restrict)
     * }
     */
    public static MethodHandle mbsrtowcs$handle() {
        return mbsrtowcs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t mbsrtowcs(wchar_t *restrict, const char **restrict, size_t, mbstate_t *restrict)
     * }
     */
    public static MemorySegment mbsrtowcs$address() {
        return mbsrtowcs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t mbsrtowcs(wchar_t *restrict, const char **restrict, size_t, mbstate_t *restrict)
     * }
     */
    public static long mbsrtowcs(MemorySegment x0, MemorySegment x1, long x2, MemorySegment x3) {
        var mh$ = mbsrtowcs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbsrtowcs", x0, x1, x2, x3);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putwc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("putwc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t putwc(wchar_t, FILE *)
     * }
     */
    public static FunctionDescriptor putwc$descriptor() {
        return putwc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t putwc(wchar_t, FILE *)
     * }
     */
    public static MethodHandle putwc$handle() {
        return putwc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t putwc(wchar_t, FILE *)
     * }
     */
    public static MemorySegment putwc$address() {
        return putwc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t putwc(wchar_t, FILE *)
     * }
     */
    public static int putwc(int x0, MemorySegment x1) {
        var mh$ = putwc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putwc", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putwchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("putwchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t putwchar(wchar_t)
     * }
     */
    public static FunctionDescriptor putwchar$descriptor() {
        return putwchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t putwchar(wchar_t)
     * }
     */
    public static MethodHandle putwchar$handle() {
        return putwchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t putwchar(wchar_t)
     * }
     */
    public static MemorySegment putwchar$address() {
        return putwchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t putwchar(wchar_t)
     * }
     */
    public static int putwchar(int x0) {
        var mh$ = putwchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putwchar", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int swprintf(wchar_t *restrict, size_t, const wchar_t *restrict, ...)
     * }
     */
    public static class swprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_LONG,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("swprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private swprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int swprintf(wchar_t *restrict, size_t, const wchar_t *restrict, ...)
         * }
         */
        public static swprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new swprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, long x1, MemorySegment x2, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("swprintf", x0, x1, x2, x3);
                }
                return (int)spreader.invokeExact(x0, x1, x2, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int swscanf(const wchar_t *restrict, const wchar_t *restrict, ...)
     * }
     */
    public static class swscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("swscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private swscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int swscanf(const wchar_t *restrict, const wchar_t *restrict, ...)
         * }
         */
        public static swscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new swscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("swscanf", x0, x1, x2);
                }
                return (int)spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class ungetwc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ungetwc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t ungetwc(wint_t, FILE *)
     * }
     */
    public static FunctionDescriptor ungetwc$descriptor() {
        return ungetwc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t ungetwc(wint_t, FILE *)
     * }
     */
    public static MethodHandle ungetwc$handle() {
        return ungetwc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t ungetwc(wint_t, FILE *)
     * }
     */
    public static MemorySegment ungetwc$address() {
        return ungetwc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t ungetwc(wint_t, FILE *)
     * }
     */
    public static int ungetwc(int x0, MemorySegment x1) {
        var mh$ = ungetwc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ungetwc", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vfwprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("vfwprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vfwprintf(FILE *restrict, const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static FunctionDescriptor vfwprintf$descriptor() {
        return vfwprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vfwprintf(FILE *restrict, const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static MethodHandle vfwprintf$handle() {
        return vfwprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vfwprintf(FILE *restrict, const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static MemorySegment vfwprintf$address() {
        return vfwprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vfwprintf(FILE *restrict, const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static int vfwprintf(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = vfwprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfwprintf", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vswprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("vswprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vswprintf(wchar_t *restrict, size_t, const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static FunctionDescriptor vswprintf$descriptor() {
        return vswprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vswprintf(wchar_t *restrict, size_t, const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static MethodHandle vswprintf$handle() {
        return vswprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vswprintf(wchar_t *restrict, size_t, const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static MemorySegment vswprintf$address() {
        return vswprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vswprintf(wchar_t *restrict, size_t, const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static int vswprintf(MemorySegment x0, long x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = vswprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vswprintf", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vwprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("vwprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vwprintf(const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static FunctionDescriptor vwprintf$descriptor() {
        return vwprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vwprintf(const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static MethodHandle vwprintf$handle() {
        return vwprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vwprintf(const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static MemorySegment vwprintf$address() {
        return vwprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vwprintf(const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static int vwprintf(MemorySegment x0, MemorySegment x1) {
        var mh$ = vwprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vwprintf", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcrtomb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcrtomb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcrtomb(char *restrict, wchar_t, mbstate_t *restrict)
     * }
     */
    public static FunctionDescriptor wcrtomb$descriptor() {
        return wcrtomb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcrtomb(char *restrict, wchar_t, mbstate_t *restrict)
     * }
     */
    public static MethodHandle wcrtomb$handle() {
        return wcrtomb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcrtomb(char *restrict, wchar_t, mbstate_t *restrict)
     * }
     */
    public static MemorySegment wcrtomb$address() {
        return wcrtomb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcrtomb(char *restrict, wchar_t, mbstate_t *restrict)
     * }
     */
    public static long wcrtomb(MemorySegment x0, int x1, MemorySegment x2) {
        var mh$ = wcrtomb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcrtomb", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcscat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcscat(wchar_t *restrict, const wchar_t *restrict)
     * }
     */
    public static FunctionDescriptor wcscat$descriptor() {
        return wcscat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcscat(wchar_t *restrict, const wchar_t *restrict)
     * }
     */
    public static MethodHandle wcscat$handle() {
        return wcscat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcscat(wchar_t *restrict, const wchar_t *restrict)
     * }
     */
    public static MemorySegment wcscat$address() {
        return wcscat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcscat(wchar_t *restrict, const wchar_t *restrict)
     * }
     */
    public static MemorySegment wcscat(MemorySegment x0, MemorySegment x1) {
        var mh$ = wcscat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscat", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcschr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcschr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *wcschr(const wchar_t *, wchar_t)
     * }
     */
    public static FunctionDescriptor wcschr$descriptor() {
        return wcschr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *wcschr(const wchar_t *, wchar_t)
     * }
     */
    public static MethodHandle wcschr$handle() {
        return wcschr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *wcschr(const wchar_t *, wchar_t)
     * }
     */
    public static MemorySegment wcschr$address() {
        return wcschr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *wcschr(const wchar_t *, wchar_t)
     * }
     */
    public static MemorySegment wcschr(MemorySegment x0, int x1) {
        var mh$ = wcschr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcschr", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcscmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcscmp(const wchar_t *, const wchar_t *)
     * }
     */
    public static FunctionDescriptor wcscmp$descriptor() {
        return wcscmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcscmp(const wchar_t *, const wchar_t *)
     * }
     */
    public static MethodHandle wcscmp$handle() {
        return wcscmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcscmp(const wchar_t *, const wchar_t *)
     * }
     */
    public static MemorySegment wcscmp$address() {
        return wcscmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcscmp(const wchar_t *, const wchar_t *)
     * }
     */
    public static int wcscmp(MemorySegment x0, MemorySegment x1) {
        var mh$ = wcscmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscmp", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcscoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcscoll(const wchar_t *, const wchar_t *)
     * }
     */
    public static FunctionDescriptor wcscoll$descriptor() {
        return wcscoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcscoll(const wchar_t *, const wchar_t *)
     * }
     */
    public static MethodHandle wcscoll$handle() {
        return wcscoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcscoll(const wchar_t *, const wchar_t *)
     * }
     */
    public static MemorySegment wcscoll$address() {
        return wcscoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcscoll(const wchar_t *, const wchar_t *)
     * }
     */
    public static int wcscoll(MemorySegment x0, MemorySegment x1) {
        var mh$ = wcscoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscoll", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcscpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcscpy(wchar_t *restrict, const wchar_t *restrict)
     * }
     */
    public static FunctionDescriptor wcscpy$descriptor() {
        return wcscpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcscpy(wchar_t *restrict, const wchar_t *restrict)
     * }
     */
    public static MethodHandle wcscpy$handle() {
        return wcscpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcscpy(wchar_t *restrict, const wchar_t *restrict)
     * }
     */
    public static MemorySegment wcscpy$address() {
        return wcscpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcscpy(wchar_t *restrict, const wchar_t *restrict)
     * }
     */
    public static MemorySegment wcscpy(MemorySegment x0, MemorySegment x1) {
        var mh$ = wcscpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscpy", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcscspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcscspn(const wchar_t *, const wchar_t *)
     * }
     */
    public static FunctionDescriptor wcscspn$descriptor() {
        return wcscspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcscspn(const wchar_t *, const wchar_t *)
     * }
     */
    public static MethodHandle wcscspn$handle() {
        return wcscspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcscspn(const wchar_t *, const wchar_t *)
     * }
     */
    public static MemorySegment wcscspn$address() {
        return wcscspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcscspn(const wchar_t *, const wchar_t *)
     * }
     */
    public static long wcscspn(MemorySegment x0, MemorySegment x1) {
        var mh$ = wcscspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscspn", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsftime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsftime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcsftime(wchar_t *restrict, size_t, const wchar_t *restrict, const struct tm *restrict)
     * }
     */
    public static FunctionDescriptor wcsftime$descriptor() {
        return wcsftime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcsftime(wchar_t *restrict, size_t, const wchar_t *restrict, const struct tm *restrict)
     * }
     */
    public static MethodHandle wcsftime$handle() {
        return wcsftime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcsftime(wchar_t *restrict, size_t, const wchar_t *restrict, const struct tm *restrict)
     * }
     */
    public static MemorySegment wcsftime$address() {
        return wcsftime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcsftime(wchar_t *restrict, size_t, const wchar_t *restrict, const struct tm *restrict)
     * }
     */
    public static long wcsftime(MemorySegment x0, long x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = wcsftime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsftime", x0, x1, x2, x3);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcslen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcslen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long wcslen(const wchar_t *)
     * }
     */
    public static FunctionDescriptor wcslen$descriptor() {
        return wcslen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long wcslen(const wchar_t *)
     * }
     */
    public static MethodHandle wcslen$handle() {
        return wcslen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long wcslen(const wchar_t *)
     * }
     */
    public static MemorySegment wcslen$address() {
        return wcslen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long wcslen(const wchar_t *)
     * }
     */
    public static long wcslen(MemorySegment x0) {
        var mh$ = wcslen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcslen", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsncat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsncat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsncat(wchar_t *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static FunctionDescriptor wcsncat$descriptor() {
        return wcsncat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsncat(wchar_t *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static MethodHandle wcsncat$handle() {
        return wcsncat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsncat(wchar_t *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static MemorySegment wcsncat$address() {
        return wcsncat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsncat(wchar_t *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static MemorySegment wcsncat(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = wcsncat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsncat", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsncmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsncmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcsncmp(const wchar_t *, const wchar_t *, size_t)
     * }
     */
    public static FunctionDescriptor wcsncmp$descriptor() {
        return wcsncmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcsncmp(const wchar_t *, const wchar_t *, size_t)
     * }
     */
    public static MethodHandle wcsncmp$handle() {
        return wcsncmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcsncmp(const wchar_t *, const wchar_t *, size_t)
     * }
     */
    public static MemorySegment wcsncmp$address() {
        return wcsncmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcsncmp(const wchar_t *, const wchar_t *, size_t)
     * }
     */
    public static int wcsncmp(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = wcsncmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsncmp", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsncpy(wchar_t *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static FunctionDescriptor wcsncpy$descriptor() {
        return wcsncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsncpy(wchar_t *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static MethodHandle wcsncpy$handle() {
        return wcsncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsncpy(wchar_t *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static MemorySegment wcsncpy$address() {
        return wcsncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsncpy(wchar_t *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static MemorySegment wcsncpy(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = wcsncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsncpy", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcspbrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcspbrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcspbrk(const wchar_t *, const wchar_t *)
     * }
     */
    public static FunctionDescriptor wcspbrk$descriptor() {
        return wcspbrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcspbrk(const wchar_t *, const wchar_t *)
     * }
     */
    public static MethodHandle wcspbrk$handle() {
        return wcspbrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcspbrk(const wchar_t *, const wchar_t *)
     * }
     */
    public static MemorySegment wcspbrk$address() {
        return wcspbrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcspbrk(const wchar_t *, const wchar_t *)
     * }
     */
    public static MemorySegment wcspbrk(MemorySegment x0, MemorySegment x1) {
        var mh$ = wcspbrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcspbrk", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsrchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsrchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsrchr(const wchar_t *, wchar_t)
     * }
     */
    public static FunctionDescriptor wcsrchr$descriptor() {
        return wcsrchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsrchr(const wchar_t *, wchar_t)
     * }
     */
    public static MethodHandle wcsrchr$handle() {
        return wcsrchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsrchr(const wchar_t *, wchar_t)
     * }
     */
    public static MemorySegment wcsrchr$address() {
        return wcsrchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsrchr(const wchar_t *, wchar_t)
     * }
     */
    public static MemorySegment wcsrchr(MemorySegment x0, int x1) {
        var mh$ = wcsrchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsrchr", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsrtombs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsrtombs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcsrtombs(char *restrict, const wchar_t **restrict, size_t, mbstate_t *restrict)
     * }
     */
    public static FunctionDescriptor wcsrtombs$descriptor() {
        return wcsrtombs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcsrtombs(char *restrict, const wchar_t **restrict, size_t, mbstate_t *restrict)
     * }
     */
    public static MethodHandle wcsrtombs$handle() {
        return wcsrtombs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcsrtombs(char *restrict, const wchar_t **restrict, size_t, mbstate_t *restrict)
     * }
     */
    public static MemorySegment wcsrtombs$address() {
        return wcsrtombs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcsrtombs(char *restrict, const wchar_t **restrict, size_t, mbstate_t *restrict)
     * }
     */
    public static long wcsrtombs(MemorySegment x0, MemorySegment x1, long x2, MemorySegment x3) {
        var mh$ = wcsrtombs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsrtombs", x0, x1, x2, x3);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcsspn(const wchar_t *, const wchar_t *)
     * }
     */
    public static FunctionDescriptor wcsspn$descriptor() {
        return wcsspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcsspn(const wchar_t *, const wchar_t *)
     * }
     */
    public static MethodHandle wcsspn$handle() {
        return wcsspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcsspn(const wchar_t *, const wchar_t *)
     * }
     */
    public static MemorySegment wcsspn$address() {
        return wcsspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcsspn(const wchar_t *, const wchar_t *)
     * }
     */
    public static long wcsspn(MemorySegment x0, MemorySegment x1) {
        var mh$ = wcsspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsspn", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsstr(const wchar_t *restrict, const wchar_t *restrict)
     * }
     */
    public static FunctionDescriptor wcsstr$descriptor() {
        return wcsstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsstr(const wchar_t *restrict, const wchar_t *restrict)
     * }
     */
    public static MethodHandle wcsstr$handle() {
        return wcsstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsstr(const wchar_t *restrict, const wchar_t *restrict)
     * }
     */
    public static MemorySegment wcsstr$address() {
        return wcsstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsstr(const wchar_t *restrict, const wchar_t *restrict)
     * }
     */
    public static MemorySegment wcsstr(MemorySegment x0, MemorySegment x1) {
        var mh$ = wcsstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsstr", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsxfrm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsxfrm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcsxfrm(wchar_t *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static FunctionDescriptor wcsxfrm$descriptor() {
        return wcsxfrm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcsxfrm(wchar_t *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static MethodHandle wcsxfrm$handle() {
        return wcsxfrm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcsxfrm(wchar_t *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static MemorySegment wcsxfrm$address() {
        return wcsxfrm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcsxfrm(wchar_t *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static long wcsxfrm(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = wcsxfrm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsxfrm", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wctob {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wctob");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wctob(wint_t)
     * }
     */
    public static FunctionDescriptor wctob$descriptor() {
        return wctob.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wctob(wint_t)
     * }
     */
    public static MethodHandle wctob$handle() {
        return wctob.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wctob(wint_t)
     * }
     */
    public static MemorySegment wctob$address() {
        return wctob.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wctob(wint_t)
     * }
     */
    public static int wctob(int x0) {
        var mh$ = wctob.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wctob", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcstod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double wcstod(const wchar_t *restrict, wchar_t **restrict)
     * }
     */
    public static FunctionDescriptor wcstod$descriptor() {
        return wcstod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double wcstod(const wchar_t *restrict, wchar_t **restrict)
     * }
     */
    public static MethodHandle wcstod$handle() {
        return wcstod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double wcstod(const wchar_t *restrict, wchar_t **restrict)
     * }
     */
    public static MemorySegment wcstod$address() {
        return wcstod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double wcstod(const wchar_t *restrict, wchar_t **restrict)
     * }
     */
    public static double wcstod(MemorySegment x0, MemorySegment x1) {
        var mh$ = wcstod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstod", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstok {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcstok");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcstok(wchar_t *restrict, const wchar_t *restrict, wchar_t **restrict)
     * }
     */
    public static FunctionDescriptor wcstok$descriptor() {
        return wcstok.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcstok(wchar_t *restrict, const wchar_t *restrict, wchar_t **restrict)
     * }
     */
    public static MethodHandle wcstok$handle() {
        return wcstok.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcstok(wchar_t *restrict, const wchar_t *restrict, wchar_t **restrict)
     * }
     */
    public static MemorySegment wcstok$address() {
        return wcstok.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcstok(wchar_t *restrict, const wchar_t *restrict, wchar_t **restrict)
     * }
     */
    public static MemorySegment wcstok(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = wcstok.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstok", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcstol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long wcstol(const wchar_t *restrict, wchar_t **restrict, int)
     * }
     */
    public static FunctionDescriptor wcstol$descriptor() {
        return wcstol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long wcstol(const wchar_t *restrict, wchar_t **restrict, int)
     * }
     */
    public static MethodHandle wcstol$handle() {
        return wcstol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long wcstol(const wchar_t *restrict, wchar_t **restrict, int)
     * }
     */
    public static MemorySegment wcstol$address() {
        return wcstol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long wcstol(const wchar_t *restrict, wchar_t **restrict, int)
     * }
     */
    public static long wcstol(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = wcstol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstol", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcstoul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long wcstoul(const wchar_t *restrict, wchar_t **restrict, int)
     * }
     */
    public static FunctionDescriptor wcstoul$descriptor() {
        return wcstoul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long wcstoul(const wchar_t *restrict, wchar_t **restrict, int)
     * }
     */
    public static MethodHandle wcstoul$handle() {
        return wcstoul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long wcstoul(const wchar_t *restrict, wchar_t **restrict, int)
     * }
     */
    public static MemorySegment wcstoul$address() {
        return wcstoul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long wcstoul(const wchar_t *restrict, wchar_t **restrict, int)
     * }
     */
    public static long wcstoul(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = wcstoul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoul", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wmemchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wmemchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *wmemchr(const wchar_t *, wchar_t, size_t)
     * }
     */
    public static FunctionDescriptor wmemchr$descriptor() {
        return wmemchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *wmemchr(const wchar_t *, wchar_t, size_t)
     * }
     */
    public static MethodHandle wmemchr$handle() {
        return wmemchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *wmemchr(const wchar_t *, wchar_t, size_t)
     * }
     */
    public static MemorySegment wmemchr$address() {
        return wmemchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *wmemchr(const wchar_t *, wchar_t, size_t)
     * }
     */
    public static MemorySegment wmemchr(MemorySegment x0, int x1, long x2) {
        var mh$ = wmemchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wmemchr", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wmemcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wmemcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wmemcmp(const wchar_t *, const wchar_t *, size_t)
     * }
     */
    public static FunctionDescriptor wmemcmp$descriptor() {
        return wmemcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wmemcmp(const wchar_t *, const wchar_t *, size_t)
     * }
     */
    public static MethodHandle wmemcmp$handle() {
        return wmemcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wmemcmp(const wchar_t *, const wchar_t *, size_t)
     * }
     */
    public static MemorySegment wmemcmp$address() {
        return wmemcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wmemcmp(const wchar_t *, const wchar_t *, size_t)
     * }
     */
    public static int wmemcmp(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = wmemcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wmemcmp", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wmemcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wmemcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *wmemcpy(wchar_t *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static FunctionDescriptor wmemcpy$descriptor() {
        return wmemcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *wmemcpy(wchar_t *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static MethodHandle wmemcpy$handle() {
        return wmemcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *wmemcpy(wchar_t *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static MemorySegment wmemcpy$address() {
        return wmemcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *wmemcpy(wchar_t *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static MemorySegment wmemcpy(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = wmemcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wmemcpy", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wmemmove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wmemmove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *wmemmove(wchar_t *, const wchar_t *, size_t)
     * }
     */
    public static FunctionDescriptor wmemmove$descriptor() {
        return wmemmove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *wmemmove(wchar_t *, const wchar_t *, size_t)
     * }
     */
    public static MethodHandle wmemmove$handle() {
        return wmemmove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *wmemmove(wchar_t *, const wchar_t *, size_t)
     * }
     */
    public static MemorySegment wmemmove$address() {
        return wmemmove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *wmemmove(wchar_t *, const wchar_t *, size_t)
     * }
     */
    public static MemorySegment wmemmove(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = wmemmove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wmemmove", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wmemset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wmemset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wmemset(wchar_t *, wchar_t, size_t)
     * }
     */
    public static FunctionDescriptor wmemset$descriptor() {
        return wmemset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wmemset(wchar_t *, wchar_t, size_t)
     * }
     */
    public static MethodHandle wmemset$handle() {
        return wmemset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wmemset(wchar_t *, wchar_t, size_t)
     * }
     */
    public static MemorySegment wmemset$address() {
        return wmemset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wmemset(wchar_t *, wchar_t, size_t)
     * }
     */
    public static MemorySegment wmemset(MemorySegment x0, int x1, long x2) {
        var mh$ = wmemset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wmemset", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int wprintf(const wchar_t *restrict, ...)
     * }
     */
    public static class wprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("wprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private wprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int wprintf(const wchar_t *restrict, ...)
         * }
         */
        public static wprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new wprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("wprintf", x0, x1);
                }
                return (int)spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int wscanf(const wchar_t *restrict, ...)
     * }
     */
    public static class wscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("wscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private wscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int wscanf(const wchar_t *restrict, ...)
         * }
         */
        public static wscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new wscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("wscanf", x0, x1);
                }
                return (int)spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class wcswidth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcswidth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcswidth(const wchar_t *, size_t)
     * }
     */
    public static FunctionDescriptor wcswidth$descriptor() {
        return wcswidth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcswidth(const wchar_t *, size_t)
     * }
     */
    public static MethodHandle wcswidth$handle() {
        return wcswidth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcswidth(const wchar_t *, size_t)
     * }
     */
    public static MemorySegment wcswidth$address() {
        return wcswidth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcswidth(const wchar_t *, size_t)
     * }
     */
    public static int wcswidth(MemorySegment x0, long x1) {
        var mh$ = wcswidth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcswidth", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcwidth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcwidth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcwidth(wchar_t)
     * }
     */
    public static FunctionDescriptor wcwidth$descriptor() {
        return wcwidth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcwidth(wchar_t)
     * }
     */
    public static MethodHandle wcwidth$handle() {
        return wcwidth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcwidth(wchar_t)
     * }
     */
    public static MemorySegment wcwidth$address() {
        return wcwidth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcwidth(wchar_t)
     * }
     */
    public static int wcwidth(int x0) {
        var mh$ = wcwidth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcwidth", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vfwscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("vfwscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vfwscanf(FILE *restrict, const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static FunctionDescriptor vfwscanf$descriptor() {
        return vfwscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vfwscanf(FILE *restrict, const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static MethodHandle vfwscanf$handle() {
        return vfwscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vfwscanf(FILE *restrict, const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static MemorySegment vfwscanf$address() {
        return vfwscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vfwscanf(FILE *restrict, const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static int vfwscanf(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = vfwscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfwscanf", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vswscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("vswscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vswscanf(const wchar_t *restrict, const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static FunctionDescriptor vswscanf$descriptor() {
        return vswscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vswscanf(const wchar_t *restrict, const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static MethodHandle vswscanf$handle() {
        return vswscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vswscanf(const wchar_t *restrict, const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static MemorySegment vswscanf$address() {
        return vswscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vswscanf(const wchar_t *restrict, const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static int vswscanf(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = vswscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vswscanf", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vwscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("vwscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vwscanf(const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static FunctionDescriptor vwscanf$descriptor() {
        return vwscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vwscanf(const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static MethodHandle vwscanf$handle() {
        return vwscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vwscanf(const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static MemorySegment vwscanf$address() {
        return vwscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vwscanf(const wchar_t *restrict, __darwin_va_list)
     * }
     */
    public static int vwscanf(MemorySegment x0, MemorySegment x1) {
        var mh$ = vwscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vwscanf", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcstof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float wcstof(const wchar_t *restrict, wchar_t **restrict)
     * }
     */
    public static FunctionDescriptor wcstof$descriptor() {
        return wcstof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float wcstof(const wchar_t *restrict, wchar_t **restrict)
     * }
     */
    public static MethodHandle wcstof$handle() {
        return wcstof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float wcstof(const wchar_t *restrict, wchar_t **restrict)
     * }
     */
    public static MemorySegment wcstof$address() {
        return wcstof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float wcstof(const wchar_t *restrict, wchar_t **restrict)
     * }
     */
    public static float wcstof(MemorySegment x0, MemorySegment x1) {
        var mh$ = wcstof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstof", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcstoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long wcstoll(const wchar_t *restrict, wchar_t **restrict, int)
     * }
     */
    public static FunctionDescriptor wcstoll$descriptor() {
        return wcstoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long wcstoll(const wchar_t *restrict, wchar_t **restrict, int)
     * }
     */
    public static MethodHandle wcstoll$handle() {
        return wcstoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long wcstoll(const wchar_t *restrict, wchar_t **restrict, int)
     * }
     */
    public static MemorySegment wcstoll$address() {
        return wcstoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long wcstoll(const wchar_t *restrict, wchar_t **restrict, int)
     * }
     */
    public static long wcstoll(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = wcstoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoll", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcstoull");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long wcstoull(const wchar_t *restrict, wchar_t **restrict, int)
     * }
     */
    public static FunctionDescriptor wcstoull$descriptor() {
        return wcstoull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long wcstoull(const wchar_t *restrict, wchar_t **restrict, int)
     * }
     */
    public static MethodHandle wcstoull$handle() {
        return wcstoull.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long wcstoull(const wchar_t *restrict, wchar_t **restrict, int)
     * }
     */
    public static MemorySegment wcstoull$address() {
        return wcstoull.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long wcstoull(const wchar_t *restrict, wchar_t **restrict, int)
     * }
     */
    public static long wcstoull(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = wcstoull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoull", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbsnrtowcs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mbsnrtowcs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t mbsnrtowcs(wchar_t *restrict, const char **restrict, size_t, size_t, mbstate_t *restrict)
     * }
     */
    public static FunctionDescriptor mbsnrtowcs$descriptor() {
        return mbsnrtowcs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t mbsnrtowcs(wchar_t *restrict, const char **restrict, size_t, size_t, mbstate_t *restrict)
     * }
     */
    public static MethodHandle mbsnrtowcs$handle() {
        return mbsnrtowcs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t mbsnrtowcs(wchar_t *restrict, const char **restrict, size_t, size_t, mbstate_t *restrict)
     * }
     */
    public static MemorySegment mbsnrtowcs$address() {
        return mbsnrtowcs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t mbsnrtowcs(wchar_t *restrict, const char **restrict, size_t, size_t, mbstate_t *restrict)
     * }
     */
    public static long mbsnrtowcs(MemorySegment x0, MemorySegment x1, long x2, long x3, MemorySegment x4) {
        var mh$ = mbsnrtowcs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbsnrtowcs", x0, x1, x2, x3, x4);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcpcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcpcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcpcpy(wchar_t *restrict, const wchar_t *restrict)
     * }
     */
    public static FunctionDescriptor wcpcpy$descriptor() {
        return wcpcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcpcpy(wchar_t *restrict, const wchar_t *restrict)
     * }
     */
    public static MethodHandle wcpcpy$handle() {
        return wcpcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcpcpy(wchar_t *restrict, const wchar_t *restrict)
     * }
     */
    public static MemorySegment wcpcpy$address() {
        return wcpcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcpcpy(wchar_t *restrict, const wchar_t *restrict)
     * }
     */
    public static MemorySegment wcpcpy(MemorySegment x0, MemorySegment x1) {
        var mh$ = wcpcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcpcpy", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcpncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcpncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcpncpy(wchar_t *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static FunctionDescriptor wcpncpy$descriptor() {
        return wcpncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcpncpy(wchar_t *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static MethodHandle wcpncpy$handle() {
        return wcpncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcpncpy(wchar_t *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static MemorySegment wcpncpy$address() {
        return wcpncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcpncpy(wchar_t *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static MemorySegment wcpncpy(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = wcpncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcpncpy", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *wcsdup(const wchar_t *)
     * }
     */
    public static FunctionDescriptor wcsdup$descriptor() {
        return wcsdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *wcsdup(const wchar_t *)
     * }
     */
    public static MethodHandle wcsdup$handle() {
        return wcsdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *wcsdup(const wchar_t *)
     * }
     */
    public static MemorySegment wcsdup$address() {
        return wcsdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *wcsdup(const wchar_t *)
     * }
     */
    public static MemorySegment wcsdup(MemorySegment x0) {
        var mh$ = wcsdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsdup", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcscasecmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcscasecmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcscasecmp(const wchar_t *, const wchar_t *)
     * }
     */
    public static FunctionDescriptor wcscasecmp$descriptor() {
        return wcscasecmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcscasecmp(const wchar_t *, const wchar_t *)
     * }
     */
    public static MethodHandle wcscasecmp$handle() {
        return wcscasecmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcscasecmp(const wchar_t *, const wchar_t *)
     * }
     */
    public static MemorySegment wcscasecmp$address() {
        return wcscasecmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcscasecmp(const wchar_t *, const wchar_t *)
     * }
     */
    public static int wcscasecmp(MemorySegment x0, MemorySegment x1) {
        var mh$ = wcscasecmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcscasecmp", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsncasecmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsncasecmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wcsncasecmp(const wchar_t *, const wchar_t *, size_t n)
     * }
     */
    public static FunctionDescriptor wcsncasecmp$descriptor() {
        return wcsncasecmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wcsncasecmp(const wchar_t *, const wchar_t *, size_t n)
     * }
     */
    public static MethodHandle wcsncasecmp$handle() {
        return wcsncasecmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wcsncasecmp(const wchar_t *, const wchar_t *, size_t n)
     * }
     */
    public static MemorySegment wcsncasecmp$address() {
        return wcsncasecmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wcsncasecmp(const wchar_t *, const wchar_t *, size_t n)
     * }
     */
    public static int wcsncasecmp(MemorySegment x0, MemorySegment x1, long n) {
        var mh$ = wcsncasecmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsncasecmp", x0, x1, n);
            }
            return (int)mh$.invokeExact(x0, x1, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsnlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsnlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcsnlen(const wchar_t *, size_t)
     * }
     */
    public static FunctionDescriptor wcsnlen$descriptor() {
        return wcsnlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcsnlen(const wchar_t *, size_t)
     * }
     */
    public static MethodHandle wcsnlen$handle() {
        return wcsnlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcsnlen(const wchar_t *, size_t)
     * }
     */
    public static MemorySegment wcsnlen$address() {
        return wcsnlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcsnlen(const wchar_t *, size_t)
     * }
     */
    public static long wcsnlen(MemorySegment x0, long x1) {
        var mh$ = wcsnlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsnlen", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcsnrtombs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcsnrtombs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcsnrtombs(char *restrict, const wchar_t **restrict, size_t, size_t, mbstate_t *restrict)
     * }
     */
    public static FunctionDescriptor wcsnrtombs$descriptor() {
        return wcsnrtombs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcsnrtombs(char *restrict, const wchar_t **restrict, size_t, size_t, mbstate_t *restrict)
     * }
     */
    public static MethodHandle wcsnrtombs$handle() {
        return wcsnrtombs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcsnrtombs(char *restrict, const wchar_t **restrict, size_t, size_t, mbstate_t *restrict)
     * }
     */
    public static MemorySegment wcsnrtombs$address() {
        return wcsnrtombs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcsnrtombs(char *restrict, const wchar_t **restrict, size_t, size_t, mbstate_t *restrict)
     * }
     */
    public static long wcsnrtombs(MemorySegment x0, MemorySegment x1, long x2, long x3, MemorySegment x4) {
        var mh$ = wcsnrtombs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcsnrtombs", x0, x1, x2, x3, x4);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class open_wmemstream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("open_wmemstream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *open_wmemstream(wchar_t **__bufp, size_t *__sizep)
     * }
     */
    public static FunctionDescriptor open_wmemstream$descriptor() {
        return open_wmemstream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *open_wmemstream(wchar_t **__bufp, size_t *__sizep)
     * }
     */
    public static MethodHandle open_wmemstream$handle() {
        return open_wmemstream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *open_wmemstream(wchar_t **__bufp, size_t *__sizep)
     * }
     */
    public static MemorySegment open_wmemstream$address() {
        return open_wmemstream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *open_wmemstream(wchar_t **__bufp, size_t *__sizep)
     * }
     */
    public static MemorySegment open_wmemstream(MemorySegment __bufp, MemorySegment __sizep) {
        var mh$ = open_wmemstream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("open_wmemstream", __bufp, __sizep);
            }
            return (MemorySegment)mh$.invokeExact(__bufp, __sizep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetwln {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fgetwln");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *fgetwln(FILE *restrict, size_t *)
     * }
     */
    public static FunctionDescriptor fgetwln$descriptor() {
        return fgetwln.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *fgetwln(FILE *restrict, size_t *)
     * }
     */
    public static MethodHandle fgetwln$handle() {
        return fgetwln.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *fgetwln(FILE *restrict, size_t *)
     * }
     */
    public static MemorySegment fgetwln$address() {
        return fgetwln.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *fgetwln(FILE *restrict, size_t *)
     * }
     */
    public static MemorySegment fgetwln(MemorySegment x0, MemorySegment x1) {
        var mh$ = fgetwln.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetwln", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcslcat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcslcat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcslcat(wchar_t *, const wchar_t *, size_t)
     * }
     */
    public static FunctionDescriptor wcslcat$descriptor() {
        return wcslcat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcslcat(wchar_t *, const wchar_t *, size_t)
     * }
     */
    public static MethodHandle wcslcat$handle() {
        return wcslcat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcslcat(wchar_t *, const wchar_t *, size_t)
     * }
     */
    public static MemorySegment wcslcat$address() {
        return wcslcat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcslcat(wchar_t *, const wchar_t *, size_t)
     * }
     */
    public static long wcslcat(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = wcslcat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcslcat", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcslcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcslcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcslcpy(wchar_t *, const wchar_t *, size_t)
     * }
     */
    public static FunctionDescriptor wcslcpy$descriptor() {
        return wcslcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcslcpy(wchar_t *, const wchar_t *, size_t)
     * }
     */
    public static MethodHandle wcslcpy$handle() {
        return wcslcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcslcpy(wchar_t *, const wchar_t *, size_t)
     * }
     */
    public static MemorySegment wcslcpy$address() {
        return wcslcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcslcpy(wchar_t *, const wchar_t *, size_t)
     * }
     */
    public static long wcslcpy(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = wcslcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcslcpy", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class imaxabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("imaxabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t j)
     * }
     */
    public static FunctionDescriptor imaxabs$descriptor() {
        return imaxabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t j)
     * }
     */
    public static MethodHandle imaxabs$handle() {
        return imaxabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t j)
     * }
     */
    public static MemorySegment imaxabs$address() {
        return imaxabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t j)
     * }
     */
    public static long imaxabs(long j) {
        var mh$ = imaxabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("imaxabs", j);
            }
            return (long)mh$.invokeExact(j);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class imaxdiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            imaxdiv_t.layout(),
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("imaxdiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static FunctionDescriptor imaxdiv$descriptor() {
        return imaxdiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static MethodHandle imaxdiv$handle() {
        return imaxdiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static MemorySegment imaxdiv$address() {
        return imaxdiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static MemorySegment imaxdiv(SegmentAllocator allocator, long __numer, long __denom) {
        var mh$ = imaxdiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("imaxdiv", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoimax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strtoimax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoimax$descriptor() {
        return strtoimax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoimax$handle() {
        return strtoimax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoimax$address() {
        return strtoimax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoimax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoimax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoimax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoumax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strtoumax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoumax$descriptor() {
        return strtoumax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoumax$handle() {
        return strtoumax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoumax$address() {
        return strtoumax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoumax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoumax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoumax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoimax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcstoimax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const wchar_t *restrict __nptr, wchar_t **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor wcstoimax$descriptor() {
        return wcstoimax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const wchar_t *restrict __nptr, wchar_t **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle wcstoimax$handle() {
        return wcstoimax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const wchar_t *restrict __nptr, wchar_t **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment wcstoimax$address() {
        return wcstoimax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const wchar_t *restrict __nptr, wchar_t **restrict __endptr, int __base)
     * }
     */
    public static long wcstoimax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = wcstoimax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoimax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoumax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcstoumax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const wchar_t *restrict __nptr, wchar_t **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor wcstoumax$descriptor() {
        return wcstoumax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const wchar_t *restrict __nptr, wchar_t **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle wcstoumax$handle() {
        return wcstoumax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const wchar_t *restrict __nptr, wchar_t **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment wcstoumax$address() {
        return wcstoumax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const wchar_t *restrict __nptr, wchar_t **restrict __endptr, int __base)
     * }
     */
    public static long wcstoumax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = wcstoumax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoumax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef uintptr_t Py_uintptr_t
     * }
     */
    public static final OfLong Py_uintptr_t = Python_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef intptr_t Py_intptr_t
     * }
     */
    public static final OfLong Py_intptr_t = Python_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef ssize_t Py_ssize_t
     * }
     */
    public static final OfLong Py_ssize_t = Python_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef Py_ssize_t Py_hash_t
     * }
     */
    public static final OfLong Py_hash_t = Python_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef size_t Py_uhash_t
     * }
     */
    public static final OfLong Py_uhash_t = Python_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef Py_ssize_t Py_ssize_clean_t
     * }
     */
    public static final OfLong Py_ssize_clean_t = Python_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef float float_t
     * }
     */
    public static final OfFloat float_t = Python_h.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef double double_t
     * }
     */
    public static final OfDouble double_t = Python_h.C_DOUBLE;

    private static class __math_errhandling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__math_errhandling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __math_errhandling()
     * }
     */
    public static FunctionDescriptor __math_errhandling$descriptor() {
        return __math_errhandling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __math_errhandling()
     * }
     */
    public static MethodHandle __math_errhandling$handle() {
        return __math_errhandling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __math_errhandling()
     * }
     */
    public static MemorySegment __math_errhandling$address() {
        return __math_errhandling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __math_errhandling()
     * }
     */
    public static int __math_errhandling() {
        var mh$ = __math_errhandling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__math_errhandling");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fpclassifyf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__fpclassifyf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __fpclassifyf(float)
     * }
     */
    public static FunctionDescriptor __fpclassifyf$descriptor() {
        return __fpclassifyf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __fpclassifyf(float)
     * }
     */
    public static MethodHandle __fpclassifyf$handle() {
        return __fpclassifyf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __fpclassifyf(float)
     * }
     */
    public static MemorySegment __fpclassifyf$address() {
        return __fpclassifyf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __fpclassifyf(float)
     * }
     */
    public static int __fpclassifyf(float x0) {
        var mh$ = __fpclassifyf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fpclassifyf", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fpclassifyd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__fpclassifyd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __fpclassifyd(double)
     * }
     */
    public static FunctionDescriptor __fpclassifyd$descriptor() {
        return __fpclassifyd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __fpclassifyd(double)
     * }
     */
    public static MethodHandle __fpclassifyd$handle() {
        return __fpclassifyd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __fpclassifyd(double)
     * }
     */
    public static MemorySegment __fpclassifyd$address() {
        return __fpclassifyd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __fpclassifyd(double)
     * }
     */
    public static int __fpclassifyd(double x0) {
        var mh$ = __fpclassifyd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fpclassifyd", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acosf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("acosf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float acosf(float)
     * }
     */
    public static FunctionDescriptor acosf$descriptor() {
        return acosf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float acosf(float)
     * }
     */
    public static MethodHandle acosf$handle() {
        return acosf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float acosf(float)
     * }
     */
    public static MemorySegment acosf$address() {
        return acosf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float acosf(float)
     * }
     */
    public static float acosf(float x0) {
        var mh$ = acosf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acosf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("acos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double acos(double)
     * }
     */
    public static FunctionDescriptor acos$descriptor() {
        return acos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double acos(double)
     * }
     */
    public static MethodHandle acos$handle() {
        return acos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double acos(double)
     * }
     */
    public static MemorySegment acos$address() {
        return acos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double acos(double)
     * }
     */
    public static double acos(double x0) {
        var mh$ = acos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acos", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("asinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float asinf(float)
     * }
     */
    public static FunctionDescriptor asinf$descriptor() {
        return asinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float asinf(float)
     * }
     */
    public static MethodHandle asinf$handle() {
        return asinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float asinf(float)
     * }
     */
    public static MemorySegment asinf$address() {
        return asinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float asinf(float)
     * }
     */
    public static float asinf(float x0) {
        var mh$ = asinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asinf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("asin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double asin(double)
     * }
     */
    public static FunctionDescriptor asin$descriptor() {
        return asin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double asin(double)
     * }
     */
    public static MethodHandle asin$handle() {
        return asin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double asin(double)
     * }
     */
    public static MemorySegment asin$address() {
        return asin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double asin(double)
     * }
     */
    public static double asin(double x0) {
        var mh$ = asin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asin", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("atanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float atanf(float)
     * }
     */
    public static FunctionDescriptor atanf$descriptor() {
        return atanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float atanf(float)
     * }
     */
    public static MethodHandle atanf$handle() {
        return atanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float atanf(float)
     * }
     */
    public static MemorySegment atanf$address() {
        return atanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float atanf(float)
     * }
     */
    public static float atanf(float x0) {
        var mh$ = atanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atanf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("atan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double atan(double)
     * }
     */
    public static FunctionDescriptor atan$descriptor() {
        return atan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double atan(double)
     * }
     */
    public static MethodHandle atan$handle() {
        return atan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double atan(double)
     * }
     */
    public static MemorySegment atan$address() {
        return atan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double atan(double)
     * }
     */
    public static double atan(double x0) {
        var mh$ = atan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atan", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atan2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("atan2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float atan2f(float, float)
     * }
     */
    public static FunctionDescriptor atan2f$descriptor() {
        return atan2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float atan2f(float, float)
     * }
     */
    public static MethodHandle atan2f$handle() {
        return atan2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float atan2f(float, float)
     * }
     */
    public static MemorySegment atan2f$address() {
        return atan2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float atan2f(float, float)
     * }
     */
    public static float atan2f(float x0, float x1) {
        var mh$ = atan2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atan2f", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atan2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("atan2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double atan2(double, double)
     * }
     */
    public static FunctionDescriptor atan2$descriptor() {
        return atan2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double atan2(double, double)
     * }
     */
    public static MethodHandle atan2$handle() {
        return atan2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double atan2(double, double)
     * }
     */
    public static MemorySegment atan2$address() {
        return atan2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double atan2(double, double)
     * }
     */
    public static double atan2(double x0, double x1) {
        var mh$ = atan2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atan2", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cosf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("cosf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float cosf(float)
     * }
     */
    public static FunctionDescriptor cosf$descriptor() {
        return cosf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float cosf(float)
     * }
     */
    public static MethodHandle cosf$handle() {
        return cosf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float cosf(float)
     * }
     */
    public static MemorySegment cosf$address() {
        return cosf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float cosf(float)
     * }
     */
    public static float cosf(float x0) {
        var mh$ = cosf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cosf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("cos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double cos(double)
     * }
     */
    public static FunctionDescriptor cos$descriptor() {
        return cos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double cos(double)
     * }
     */
    public static MethodHandle cos$handle() {
        return cos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double cos(double)
     * }
     */
    public static MemorySegment cos$address() {
        return cos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double cos(double)
     * }
     */
    public static double cos(double x0) {
        var mh$ = cos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cos", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float sinf(float)
     * }
     */
    public static FunctionDescriptor sinf$descriptor() {
        return sinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float sinf(float)
     * }
     */
    public static MethodHandle sinf$handle() {
        return sinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float sinf(float)
     * }
     */
    public static MemorySegment sinf$address() {
        return sinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float sinf(float)
     * }
     */
    public static float sinf(float x0) {
        var mh$ = sinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sinf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double sin(double)
     * }
     */
    public static FunctionDescriptor sin$descriptor() {
        return sin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double sin(double)
     * }
     */
    public static MethodHandle sin$handle() {
        return sin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double sin(double)
     * }
     */
    public static MemorySegment sin$address() {
        return sin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double sin(double)
     * }
     */
    public static double sin(double x0) {
        var mh$ = sin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sin", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float tanf(float)
     * }
     */
    public static FunctionDescriptor tanf$descriptor() {
        return tanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float tanf(float)
     * }
     */
    public static MethodHandle tanf$handle() {
        return tanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float tanf(float)
     * }
     */
    public static MemorySegment tanf$address() {
        return tanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float tanf(float)
     * }
     */
    public static float tanf(float x0) {
        var mh$ = tanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tanf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double tan(double)
     * }
     */
    public static FunctionDescriptor tan$descriptor() {
        return tan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double tan(double)
     * }
     */
    public static MethodHandle tan$handle() {
        return tan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double tan(double)
     * }
     */
    public static MemorySegment tan$address() {
        return tan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double tan(double)
     * }
     */
    public static double tan(double x0) {
        var mh$ = tan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tan", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acoshf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("acoshf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float acoshf(float)
     * }
     */
    public static FunctionDescriptor acoshf$descriptor() {
        return acoshf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float acoshf(float)
     * }
     */
    public static MethodHandle acoshf$handle() {
        return acoshf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float acoshf(float)
     * }
     */
    public static MemorySegment acoshf$address() {
        return acoshf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float acoshf(float)
     * }
     */
    public static float acoshf(float x0) {
        var mh$ = acoshf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acoshf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acosh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("acosh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double acosh(double)
     * }
     */
    public static FunctionDescriptor acosh$descriptor() {
        return acosh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double acosh(double)
     * }
     */
    public static MethodHandle acosh$handle() {
        return acosh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double acosh(double)
     * }
     */
    public static MemorySegment acosh$address() {
        return acosh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double acosh(double)
     * }
     */
    public static double acosh(double x0) {
        var mh$ = acosh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acosh", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asinhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("asinhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float asinhf(float)
     * }
     */
    public static FunctionDescriptor asinhf$descriptor() {
        return asinhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float asinhf(float)
     * }
     */
    public static MethodHandle asinhf$handle() {
        return asinhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float asinhf(float)
     * }
     */
    public static MemorySegment asinhf$address() {
        return asinhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float asinhf(float)
     * }
     */
    public static float asinhf(float x0) {
        var mh$ = asinhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asinhf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asinh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("asinh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double asinh(double)
     * }
     */
    public static FunctionDescriptor asinh$descriptor() {
        return asinh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double asinh(double)
     * }
     */
    public static MethodHandle asinh$handle() {
        return asinh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double asinh(double)
     * }
     */
    public static MemorySegment asinh$address() {
        return asinh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double asinh(double)
     * }
     */
    public static double asinh(double x0) {
        var mh$ = asinh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asinh", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atanhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("atanhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float atanhf(float)
     * }
     */
    public static FunctionDescriptor atanhf$descriptor() {
        return atanhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float atanhf(float)
     * }
     */
    public static MethodHandle atanhf$handle() {
        return atanhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float atanhf(float)
     * }
     */
    public static MemorySegment atanhf$address() {
        return atanhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float atanhf(float)
     * }
     */
    public static float atanhf(float x0) {
        var mh$ = atanhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atanhf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atanh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("atanh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double atanh(double)
     * }
     */
    public static FunctionDescriptor atanh$descriptor() {
        return atanh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double atanh(double)
     * }
     */
    public static MethodHandle atanh$handle() {
        return atanh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double atanh(double)
     * }
     */
    public static MemorySegment atanh$address() {
        return atanh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double atanh(double)
     * }
     */
    public static double atanh(double x0) {
        var mh$ = atanh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atanh", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class coshf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("coshf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float coshf(float)
     * }
     */
    public static FunctionDescriptor coshf$descriptor() {
        return coshf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float coshf(float)
     * }
     */
    public static MethodHandle coshf$handle() {
        return coshf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float coshf(float)
     * }
     */
    public static MemorySegment coshf$address() {
        return coshf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float coshf(float)
     * }
     */
    public static float coshf(float x0) {
        var mh$ = coshf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("coshf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cosh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("cosh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double cosh(double)
     * }
     */
    public static FunctionDescriptor cosh$descriptor() {
        return cosh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double cosh(double)
     * }
     */
    public static MethodHandle cosh$handle() {
        return cosh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double cosh(double)
     * }
     */
    public static MemorySegment cosh$address() {
        return cosh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double cosh(double)
     * }
     */
    public static double cosh(double x0) {
        var mh$ = cosh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cosh", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sinhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sinhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float sinhf(float)
     * }
     */
    public static FunctionDescriptor sinhf$descriptor() {
        return sinhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float sinhf(float)
     * }
     */
    public static MethodHandle sinhf$handle() {
        return sinhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float sinhf(float)
     * }
     */
    public static MemorySegment sinhf$address() {
        return sinhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float sinhf(float)
     * }
     */
    public static float sinhf(float x0) {
        var mh$ = sinhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sinhf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sinh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sinh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double sinh(double)
     * }
     */
    public static FunctionDescriptor sinh$descriptor() {
        return sinh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double sinh(double)
     * }
     */
    public static MethodHandle sinh$handle() {
        return sinh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double sinh(double)
     * }
     */
    public static MemorySegment sinh$address() {
        return sinh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double sinh(double)
     * }
     */
    public static double sinh(double x0) {
        var mh$ = sinh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sinh", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tanhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tanhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float tanhf(float)
     * }
     */
    public static FunctionDescriptor tanhf$descriptor() {
        return tanhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float tanhf(float)
     * }
     */
    public static MethodHandle tanhf$handle() {
        return tanhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float tanhf(float)
     * }
     */
    public static MemorySegment tanhf$address() {
        return tanhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float tanhf(float)
     * }
     */
    public static float tanhf(float x0) {
        var mh$ = tanhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tanhf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tanh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tanh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double tanh(double)
     * }
     */
    public static FunctionDescriptor tanh$descriptor() {
        return tanh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double tanh(double)
     * }
     */
    public static MethodHandle tanh$handle() {
        return tanh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double tanh(double)
     * }
     */
    public static MemorySegment tanh$address() {
        return tanh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double tanh(double)
     * }
     */
    public static double tanh(double x0) {
        var mh$ = tanh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tanh", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class expf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("expf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float expf(float)
     * }
     */
    public static FunctionDescriptor expf$descriptor() {
        return expf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float expf(float)
     * }
     */
    public static MethodHandle expf$handle() {
        return expf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float expf(float)
     * }
     */
    public static MemorySegment expf$address() {
        return expf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float expf(float)
     * }
     */
    public static float expf(float x0) {
        var mh$ = expf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("expf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("exp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double exp(double)
     * }
     */
    public static FunctionDescriptor exp$descriptor() {
        return exp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double exp(double)
     * }
     */
    public static MethodHandle exp$handle() {
        return exp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double exp(double)
     * }
     */
    public static MemorySegment exp$address() {
        return exp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double exp(double)
     * }
     */
    public static double exp(double x0) {
        var mh$ = exp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exp", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exp2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("exp2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float exp2f(float)
     * }
     */
    public static FunctionDescriptor exp2f$descriptor() {
        return exp2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float exp2f(float)
     * }
     */
    public static MethodHandle exp2f$handle() {
        return exp2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float exp2f(float)
     * }
     */
    public static MemorySegment exp2f$address() {
        return exp2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float exp2f(float)
     * }
     */
    public static float exp2f(float x0) {
        var mh$ = exp2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exp2f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exp2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("exp2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double exp2(double)
     * }
     */
    public static FunctionDescriptor exp2$descriptor() {
        return exp2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double exp2(double)
     * }
     */
    public static MethodHandle exp2$handle() {
        return exp2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double exp2(double)
     * }
     */
    public static MemorySegment exp2$address() {
        return exp2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double exp2(double)
     * }
     */
    public static double exp2(double x0) {
        var mh$ = exp2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exp2", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class expm1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("expm1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float expm1f(float)
     * }
     */
    public static FunctionDescriptor expm1f$descriptor() {
        return expm1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float expm1f(float)
     * }
     */
    public static MethodHandle expm1f$handle() {
        return expm1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float expm1f(float)
     * }
     */
    public static MemorySegment expm1f$address() {
        return expm1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float expm1f(float)
     * }
     */
    public static float expm1f(float x0) {
        var mh$ = expm1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("expm1f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class expm1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("expm1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double expm1(double)
     * }
     */
    public static FunctionDescriptor expm1$descriptor() {
        return expm1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double expm1(double)
     * }
     */
    public static MethodHandle expm1$handle() {
        return expm1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double expm1(double)
     * }
     */
    public static MemorySegment expm1$address() {
        return expm1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double expm1(double)
     * }
     */
    public static double expm1(double x0) {
        var mh$ = expm1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("expm1", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class logf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("logf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float logf(float)
     * }
     */
    public static FunctionDescriptor logf$descriptor() {
        return logf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float logf(float)
     * }
     */
    public static MethodHandle logf$handle() {
        return logf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float logf(float)
     * }
     */
    public static MemorySegment logf$address() {
        return logf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float logf(float)
     * }
     */
    public static float logf(float x0) {
        var mh$ = logf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("logf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("log");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double log(double)
     * }
     */
    public static FunctionDescriptor log$descriptor() {
        return log.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double log(double)
     * }
     */
    public static MethodHandle log$handle() {
        return log.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double log(double)
     * }
     */
    public static MemorySegment log$address() {
        return log.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double log(double)
     * }
     */
    public static double log(double x0) {
        var mh$ = log.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log10f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("log10f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float log10f(float)
     * }
     */
    public static FunctionDescriptor log10f$descriptor() {
        return log10f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float log10f(float)
     * }
     */
    public static MethodHandle log10f$handle() {
        return log10f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float log10f(float)
     * }
     */
    public static MemorySegment log10f$address() {
        return log10f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float log10f(float)
     * }
     */
    public static float log10f(float x0) {
        var mh$ = log10f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log10f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log10 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("log10");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double log10(double)
     * }
     */
    public static FunctionDescriptor log10$descriptor() {
        return log10.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double log10(double)
     * }
     */
    public static MethodHandle log10$handle() {
        return log10.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double log10(double)
     * }
     */
    public static MemorySegment log10$address() {
        return log10.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double log10(double)
     * }
     */
    public static double log10(double x0) {
        var mh$ = log10.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log10", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("log2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float log2f(float)
     * }
     */
    public static FunctionDescriptor log2f$descriptor() {
        return log2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float log2f(float)
     * }
     */
    public static MethodHandle log2f$handle() {
        return log2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float log2f(float)
     * }
     */
    public static MemorySegment log2f$address() {
        return log2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float log2f(float)
     * }
     */
    public static float log2f(float x0) {
        var mh$ = log2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log2f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("log2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double log2(double)
     * }
     */
    public static FunctionDescriptor log2$descriptor() {
        return log2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double log2(double)
     * }
     */
    public static MethodHandle log2$handle() {
        return log2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double log2(double)
     * }
     */
    public static MemorySegment log2$address() {
        return log2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double log2(double)
     * }
     */
    public static double log2(double x0) {
        var mh$ = log2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log2", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log1pf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("log1pf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float log1pf(float)
     * }
     */
    public static FunctionDescriptor log1pf$descriptor() {
        return log1pf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float log1pf(float)
     * }
     */
    public static MethodHandle log1pf$handle() {
        return log1pf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float log1pf(float)
     * }
     */
    public static MemorySegment log1pf$address() {
        return log1pf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float log1pf(float)
     * }
     */
    public static float log1pf(float x0) {
        var mh$ = log1pf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log1pf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log1p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("log1p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double log1p(double)
     * }
     */
    public static FunctionDescriptor log1p$descriptor() {
        return log1p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double log1p(double)
     * }
     */
    public static MethodHandle log1p$handle() {
        return log1p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double log1p(double)
     * }
     */
    public static MemorySegment log1p$address() {
        return log1p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double log1p(double)
     * }
     */
    public static double log1p(double x0) {
        var mh$ = log1p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log1p", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class logbf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("logbf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float logbf(float)
     * }
     */
    public static FunctionDescriptor logbf$descriptor() {
        return logbf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float logbf(float)
     * }
     */
    public static MethodHandle logbf$handle() {
        return logbf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float logbf(float)
     * }
     */
    public static MemorySegment logbf$address() {
        return logbf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float logbf(float)
     * }
     */
    public static float logbf(float x0) {
        var mh$ = logbf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("logbf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class logb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("logb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double logb(double)
     * }
     */
    public static FunctionDescriptor logb$descriptor() {
        return logb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double logb(double)
     * }
     */
    public static MethodHandle logb$handle() {
        return logb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double logb(double)
     * }
     */
    public static MemorySegment logb$address() {
        return logb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double logb(double)
     * }
     */
    public static double logb(double x0) {
        var mh$ = logb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("logb", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class modff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("modff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float modff(float, float *)
     * }
     */
    public static FunctionDescriptor modff$descriptor() {
        return modff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float modff(float, float *)
     * }
     */
    public static MethodHandle modff$handle() {
        return modff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float modff(float, float *)
     * }
     */
    public static MemorySegment modff$address() {
        return modff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float modff(float, float *)
     * }
     */
    public static float modff(float x0, MemorySegment x1) {
        var mh$ = modff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("modff", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class modf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("modf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double modf(double, double *)
     * }
     */
    public static FunctionDescriptor modf$descriptor() {
        return modf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double modf(double, double *)
     * }
     */
    public static MethodHandle modf$handle() {
        return modf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double modf(double, double *)
     * }
     */
    public static MemorySegment modf$address() {
        return modf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double modf(double, double *)
     * }
     */
    public static double modf(double x0, MemorySegment x1) {
        var mh$ = modf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("modf", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldexpf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ldexpf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float ldexpf(float, int)
     * }
     */
    public static FunctionDescriptor ldexpf$descriptor() {
        return ldexpf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float ldexpf(float, int)
     * }
     */
    public static MethodHandle ldexpf$handle() {
        return ldexpf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float ldexpf(float, int)
     * }
     */
    public static MemorySegment ldexpf$address() {
        return ldexpf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float ldexpf(float, int)
     * }
     */
    public static float ldexpf(float x0, int x1) {
        var mh$ = ldexpf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldexpf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ldexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double ldexp(double, int)
     * }
     */
    public static FunctionDescriptor ldexp$descriptor() {
        return ldexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double ldexp(double, int)
     * }
     */
    public static MethodHandle ldexp$handle() {
        return ldexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double ldexp(double, int)
     * }
     */
    public static MemorySegment ldexp$address() {
        return ldexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double ldexp(double, int)
     * }
     */
    public static double ldexp(double x0, int x1) {
        var mh$ = ldexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldexp", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class frexpf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("frexpf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float frexpf(float, int *)
     * }
     */
    public static FunctionDescriptor frexpf$descriptor() {
        return frexpf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float frexpf(float, int *)
     * }
     */
    public static MethodHandle frexpf$handle() {
        return frexpf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float frexpf(float, int *)
     * }
     */
    public static MemorySegment frexpf$address() {
        return frexpf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float frexpf(float, int *)
     * }
     */
    public static float frexpf(float x0, MemorySegment x1) {
        var mh$ = frexpf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("frexpf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class frexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("frexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double frexp(double, int *)
     * }
     */
    public static FunctionDescriptor frexp$descriptor() {
        return frexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double frexp(double, int *)
     * }
     */
    public static MethodHandle frexp$handle() {
        return frexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double frexp(double, int *)
     * }
     */
    public static MemorySegment frexp$address() {
        return frexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double frexp(double, int *)
     * }
     */
    public static double frexp(double x0, MemorySegment x1) {
        var mh$ = frexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("frexp", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ilogbf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ilogbf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ilogbf(float)
     * }
     */
    public static FunctionDescriptor ilogbf$descriptor() {
        return ilogbf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ilogbf(float)
     * }
     */
    public static MethodHandle ilogbf$handle() {
        return ilogbf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ilogbf(float)
     * }
     */
    public static MemorySegment ilogbf$address() {
        return ilogbf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ilogbf(float)
     * }
     */
    public static int ilogbf(float x0) {
        var mh$ = ilogbf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ilogbf", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ilogb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ilogb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ilogb(double)
     * }
     */
    public static FunctionDescriptor ilogb$descriptor() {
        return ilogb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ilogb(double)
     * }
     */
    public static MethodHandle ilogb$handle() {
        return ilogb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ilogb(double)
     * }
     */
    public static MemorySegment ilogb$address() {
        return ilogb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ilogb(double)
     * }
     */
    public static int ilogb(double x0) {
        var mh$ = ilogb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ilogb", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalbnf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("scalbnf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float scalbnf(float, int)
     * }
     */
    public static FunctionDescriptor scalbnf$descriptor() {
        return scalbnf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float scalbnf(float, int)
     * }
     */
    public static MethodHandle scalbnf$handle() {
        return scalbnf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float scalbnf(float, int)
     * }
     */
    public static MemorySegment scalbnf$address() {
        return scalbnf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float scalbnf(float, int)
     * }
     */
    public static float scalbnf(float x0, int x1) {
        var mh$ = scalbnf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalbnf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalbn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("scalbn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double scalbn(double, int)
     * }
     */
    public static FunctionDescriptor scalbn$descriptor() {
        return scalbn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double scalbn(double, int)
     * }
     */
    public static MethodHandle scalbn$handle() {
        return scalbn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double scalbn(double, int)
     * }
     */
    public static MemorySegment scalbn$address() {
        return scalbn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double scalbn(double, int)
     * }
     */
    public static double scalbn(double x0, int x1) {
        var mh$ = scalbn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalbn", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalblnf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("scalblnf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float scalblnf(float, long)
     * }
     */
    public static FunctionDescriptor scalblnf$descriptor() {
        return scalblnf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float scalblnf(float, long)
     * }
     */
    public static MethodHandle scalblnf$handle() {
        return scalblnf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float scalblnf(float, long)
     * }
     */
    public static MemorySegment scalblnf$address() {
        return scalblnf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float scalblnf(float, long)
     * }
     */
    public static float scalblnf(float x0, long x1) {
        var mh$ = scalblnf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalblnf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalbln {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("scalbln");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double scalbln(double, long)
     * }
     */
    public static FunctionDescriptor scalbln$descriptor() {
        return scalbln.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double scalbln(double, long)
     * }
     */
    public static MethodHandle scalbln$handle() {
        return scalbln.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double scalbln(double, long)
     * }
     */
    public static MemorySegment scalbln$address() {
        return scalbln.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double scalbln(double, long)
     * }
     */
    public static double scalbln(double x0, long x1) {
        var mh$ = scalbln.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalbln", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fabsf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fabsf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fabsf(float)
     * }
     */
    public static FunctionDescriptor fabsf$descriptor() {
        return fabsf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fabsf(float)
     * }
     */
    public static MethodHandle fabsf$handle() {
        return fabsf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float fabsf(float)
     * }
     */
    public static MemorySegment fabsf$address() {
        return fabsf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float fabsf(float)
     * }
     */
    public static float fabsf(float x0) {
        var mh$ = fabsf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fabsf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fabs(double)
     * }
     */
    public static FunctionDescriptor fabs$descriptor() {
        return fabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fabs(double)
     * }
     */
    public static MethodHandle fabs$handle() {
        return fabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fabs(double)
     * }
     */
    public static MemorySegment fabs$address() {
        return fabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fabs(double)
     * }
     */
    public static double fabs(double x0) {
        var mh$ = fabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fabs", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cbrtf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("cbrtf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float cbrtf(float)
     * }
     */
    public static FunctionDescriptor cbrtf$descriptor() {
        return cbrtf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float cbrtf(float)
     * }
     */
    public static MethodHandle cbrtf$handle() {
        return cbrtf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float cbrtf(float)
     * }
     */
    public static MemorySegment cbrtf$address() {
        return cbrtf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float cbrtf(float)
     * }
     */
    public static float cbrtf(float x0) {
        var mh$ = cbrtf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cbrtf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cbrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("cbrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double cbrt(double)
     * }
     */
    public static FunctionDescriptor cbrt$descriptor() {
        return cbrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double cbrt(double)
     * }
     */
    public static MethodHandle cbrt$handle() {
        return cbrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double cbrt(double)
     * }
     */
    public static MemorySegment cbrt$address() {
        return cbrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double cbrt(double)
     * }
     */
    public static double cbrt(double x0) {
        var mh$ = cbrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cbrt", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class hypotf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("hypotf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float hypotf(float, float)
     * }
     */
    public static FunctionDescriptor hypotf$descriptor() {
        return hypotf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float hypotf(float, float)
     * }
     */
    public static MethodHandle hypotf$handle() {
        return hypotf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float hypotf(float, float)
     * }
     */
    public static MemorySegment hypotf$address() {
        return hypotf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float hypotf(float, float)
     * }
     */
    public static float hypotf(float x0, float x1) {
        var mh$ = hypotf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("hypotf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class hypot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("hypot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double hypot(double, double)
     * }
     */
    public static FunctionDescriptor hypot$descriptor() {
        return hypot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double hypot(double, double)
     * }
     */
    public static MethodHandle hypot$handle() {
        return hypot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double hypot(double, double)
     * }
     */
    public static MemorySegment hypot$address() {
        return hypot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double hypot(double, double)
     * }
     */
    public static double hypot(double x0, double x1) {
        var mh$ = hypot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("hypot", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class powf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("powf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float powf(float, float)
     * }
     */
    public static FunctionDescriptor powf$descriptor() {
        return powf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float powf(float, float)
     * }
     */
    public static MethodHandle powf$handle() {
        return powf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float powf(float, float)
     * }
     */
    public static MemorySegment powf$address() {
        return powf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float powf(float, float)
     * }
     */
    public static float powf(float x0, float x1) {
        var mh$ = powf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("powf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double pow(double, double)
     * }
     */
    public static FunctionDescriptor pow$descriptor() {
        return pow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double pow(double, double)
     * }
     */
    public static MethodHandle pow$handle() {
        return pow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double pow(double, double)
     * }
     */
    public static MemorySegment pow$address() {
        return pow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double pow(double, double)
     * }
     */
    public static double pow(double x0, double x1) {
        var mh$ = pow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pow", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sqrtf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sqrtf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float sqrtf(float)
     * }
     */
    public static FunctionDescriptor sqrtf$descriptor() {
        return sqrtf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float sqrtf(float)
     * }
     */
    public static MethodHandle sqrtf$handle() {
        return sqrtf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float sqrtf(float)
     * }
     */
    public static MemorySegment sqrtf$address() {
        return sqrtf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float sqrtf(float)
     * }
     */
    public static float sqrtf(float x0) {
        var mh$ = sqrtf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sqrtf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double sqrt(double)
     * }
     */
    public static FunctionDescriptor sqrt$descriptor() {
        return sqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double sqrt(double)
     * }
     */
    public static MethodHandle sqrt$handle() {
        return sqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double sqrt(double)
     * }
     */
    public static MemorySegment sqrt$address() {
        return sqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double sqrt(double)
     * }
     */
    public static double sqrt(double x0) {
        var mh$ = sqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sqrt", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("erff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float erff(float)
     * }
     */
    public static FunctionDescriptor erff$descriptor() {
        return erff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float erff(float)
     * }
     */
    public static MethodHandle erff$handle() {
        return erff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float erff(float)
     * }
     */
    public static MemorySegment erff$address() {
        return erff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float erff(float)
     * }
     */
    public static float erff(float x0) {
        var mh$ = erff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erff", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("erf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double erf(double)
     * }
     */
    public static FunctionDescriptor erf$descriptor() {
        return erf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double erf(double)
     * }
     */
    public static MethodHandle erf$handle() {
        return erf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double erf(double)
     * }
     */
    public static MemorySegment erf$address() {
        return erf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double erf(double)
     * }
     */
    public static double erf(double x0) {
        var mh$ = erf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erf", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erfcf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("erfcf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float erfcf(float)
     * }
     */
    public static FunctionDescriptor erfcf$descriptor() {
        return erfcf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float erfcf(float)
     * }
     */
    public static MethodHandle erfcf$handle() {
        return erfcf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float erfcf(float)
     * }
     */
    public static MemorySegment erfcf$address() {
        return erfcf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float erfcf(float)
     * }
     */
    public static float erfcf(float x0) {
        var mh$ = erfcf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erfcf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erfc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("erfc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double erfc(double)
     * }
     */
    public static FunctionDescriptor erfc$descriptor() {
        return erfc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double erfc(double)
     * }
     */
    public static MethodHandle erfc$handle() {
        return erfc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double erfc(double)
     * }
     */
    public static MemorySegment erfc$address() {
        return erfc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double erfc(double)
     * }
     */
    public static double erfc(double x0) {
        var mh$ = erfc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erfc", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lgammaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lgammaf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float lgammaf(float)
     * }
     */
    public static FunctionDescriptor lgammaf$descriptor() {
        return lgammaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float lgammaf(float)
     * }
     */
    public static MethodHandle lgammaf$handle() {
        return lgammaf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float lgammaf(float)
     * }
     */
    public static MemorySegment lgammaf$address() {
        return lgammaf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float lgammaf(float)
     * }
     */
    public static float lgammaf(float x0) {
        var mh$ = lgammaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lgammaf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lgamma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lgamma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double lgamma(double)
     * }
     */
    public static FunctionDescriptor lgamma$descriptor() {
        return lgamma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double lgamma(double)
     * }
     */
    public static MethodHandle lgamma$handle() {
        return lgamma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double lgamma(double)
     * }
     */
    public static MemorySegment lgamma$address() {
        return lgamma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double lgamma(double)
     * }
     */
    public static double lgamma(double x0) {
        var mh$ = lgamma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lgamma", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tgammaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tgammaf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float tgammaf(float)
     * }
     */
    public static FunctionDescriptor tgammaf$descriptor() {
        return tgammaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float tgammaf(float)
     * }
     */
    public static MethodHandle tgammaf$handle() {
        return tgammaf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float tgammaf(float)
     * }
     */
    public static MemorySegment tgammaf$address() {
        return tgammaf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float tgammaf(float)
     * }
     */
    public static float tgammaf(float x0) {
        var mh$ = tgammaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tgammaf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tgamma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tgamma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double tgamma(double)
     * }
     */
    public static FunctionDescriptor tgamma$descriptor() {
        return tgamma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double tgamma(double)
     * }
     */
    public static MethodHandle tgamma$handle() {
        return tgamma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double tgamma(double)
     * }
     */
    public static MemorySegment tgamma$address() {
        return tgamma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double tgamma(double)
     * }
     */
    public static double tgamma(double x0) {
        var mh$ = tgamma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tgamma", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ceilf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ceilf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float ceilf(float)
     * }
     */
    public static FunctionDescriptor ceilf$descriptor() {
        return ceilf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float ceilf(float)
     * }
     */
    public static MethodHandle ceilf$handle() {
        return ceilf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float ceilf(float)
     * }
     */
    public static MemorySegment ceilf$address() {
        return ceilf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float ceilf(float)
     * }
     */
    public static float ceilf(float x0) {
        var mh$ = ceilf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ceilf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ceil {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ceil");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double ceil(double)
     * }
     */
    public static FunctionDescriptor ceil$descriptor() {
        return ceil.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double ceil(double)
     * }
     */
    public static MethodHandle ceil$handle() {
        return ceil.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double ceil(double)
     * }
     */
    public static MemorySegment ceil$address() {
        return ceil.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double ceil(double)
     * }
     */
    public static double ceil(double x0) {
        var mh$ = ceil.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ceil", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class floorf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("floorf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float floorf(float)
     * }
     */
    public static FunctionDescriptor floorf$descriptor() {
        return floorf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float floorf(float)
     * }
     */
    public static MethodHandle floorf$handle() {
        return floorf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float floorf(float)
     * }
     */
    public static MemorySegment floorf$address() {
        return floorf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float floorf(float)
     * }
     */
    public static float floorf(float x0) {
        var mh$ = floorf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("floorf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class floor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("floor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double floor(double)
     * }
     */
    public static FunctionDescriptor floor$descriptor() {
        return floor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double floor(double)
     * }
     */
    public static MethodHandle floor$handle() {
        return floor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double floor(double)
     * }
     */
    public static MemorySegment floor$address() {
        return floor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double floor(double)
     * }
     */
    public static double floor(double x0) {
        var mh$ = floor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("floor", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nearbyintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("nearbyintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float nearbyintf(float)
     * }
     */
    public static FunctionDescriptor nearbyintf$descriptor() {
        return nearbyintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float nearbyintf(float)
     * }
     */
    public static MethodHandle nearbyintf$handle() {
        return nearbyintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float nearbyintf(float)
     * }
     */
    public static MemorySegment nearbyintf$address() {
        return nearbyintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float nearbyintf(float)
     * }
     */
    public static float nearbyintf(float x0) {
        var mh$ = nearbyintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nearbyintf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nearbyint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("nearbyint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double nearbyint(double)
     * }
     */
    public static FunctionDescriptor nearbyint$descriptor() {
        return nearbyint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double nearbyint(double)
     * }
     */
    public static MethodHandle nearbyint$handle() {
        return nearbyint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double nearbyint(double)
     * }
     */
    public static MemorySegment nearbyint$address() {
        return nearbyint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double nearbyint(double)
     * }
     */
    public static double nearbyint(double x0) {
        var mh$ = nearbyint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nearbyint", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("rintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float rintf(float)
     * }
     */
    public static FunctionDescriptor rintf$descriptor() {
        return rintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float rintf(float)
     * }
     */
    public static MethodHandle rintf$handle() {
        return rintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float rintf(float)
     * }
     */
    public static MemorySegment rintf$address() {
        return rintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float rintf(float)
     * }
     */
    public static float rintf(float x0) {
        var mh$ = rintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rintf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("rint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double rint(double)
     * }
     */
    public static FunctionDescriptor rint$descriptor() {
        return rint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double rint(double)
     * }
     */
    public static MethodHandle rint$handle() {
        return rint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double rint(double)
     * }
     */
    public static MemorySegment rint$address() {
        return rint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double rint(double)
     * }
     */
    public static double rint(double x0) {
        var mh$ = rint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rint", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lrintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long lrintf(float)
     * }
     */
    public static FunctionDescriptor lrintf$descriptor() {
        return lrintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long lrintf(float)
     * }
     */
    public static MethodHandle lrintf$handle() {
        return lrintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long lrintf(float)
     * }
     */
    public static MemorySegment lrintf$address() {
        return lrintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long lrintf(float)
     * }
     */
    public static long lrintf(float x0) {
        var mh$ = lrintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrintf", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lrint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long lrint(double)
     * }
     */
    public static FunctionDescriptor lrint$descriptor() {
        return lrint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long lrint(double)
     * }
     */
    public static MethodHandle lrint$handle() {
        return lrint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long lrint(double)
     * }
     */
    public static MemorySegment lrint$address() {
        return lrint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long lrint(double)
     * }
     */
    public static long lrint(double x0) {
        var mh$ = lrint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrint", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class roundf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("roundf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float roundf(float)
     * }
     */
    public static FunctionDescriptor roundf$descriptor() {
        return roundf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float roundf(float)
     * }
     */
    public static MethodHandle roundf$handle() {
        return roundf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float roundf(float)
     * }
     */
    public static MemorySegment roundf$address() {
        return roundf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float roundf(float)
     * }
     */
    public static float roundf(float x0) {
        var mh$ = roundf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("roundf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class round {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("round");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double round(double)
     * }
     */
    public static FunctionDescriptor round$descriptor() {
        return round.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double round(double)
     * }
     */
    public static MethodHandle round$handle() {
        return round.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double round(double)
     * }
     */
    public static MemorySegment round$address() {
        return round.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double round(double)
     * }
     */
    public static double round(double x0) {
        var mh$ = round.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("round", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lroundf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lroundf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long lroundf(float)
     * }
     */
    public static FunctionDescriptor lroundf$descriptor() {
        return lroundf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long lroundf(float)
     * }
     */
    public static MethodHandle lroundf$handle() {
        return lroundf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long lroundf(float)
     * }
     */
    public static MemorySegment lroundf$address() {
        return lroundf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long lroundf(float)
     * }
     */
    public static long lroundf(float x0) {
        var mh$ = lroundf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lroundf", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lround {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lround");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long lround(double)
     * }
     */
    public static FunctionDescriptor lround$descriptor() {
        return lround.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long lround(double)
     * }
     */
    public static MethodHandle lround$handle() {
        return lround.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long lround(double)
     * }
     */
    public static MemorySegment lround$address() {
        return lround.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long lround(double)
     * }
     */
    public static long lround(double x0) {
        var mh$ = lround.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lround", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llrintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("llrintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long llrintf(float)
     * }
     */
    public static FunctionDescriptor llrintf$descriptor() {
        return llrintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long llrintf(float)
     * }
     */
    public static MethodHandle llrintf$handle() {
        return llrintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long llrintf(float)
     * }
     */
    public static MemorySegment llrintf$address() {
        return llrintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long llrintf(float)
     * }
     */
    public static long llrintf(float x0) {
        var mh$ = llrintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llrintf", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llrint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("llrint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long llrint(double)
     * }
     */
    public static FunctionDescriptor llrint$descriptor() {
        return llrint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long llrint(double)
     * }
     */
    public static MethodHandle llrint$handle() {
        return llrint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long llrint(double)
     * }
     */
    public static MemorySegment llrint$address() {
        return llrint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long llrint(double)
     * }
     */
    public static long llrint(double x0) {
        var mh$ = llrint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llrint", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llroundf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("llroundf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long llroundf(float)
     * }
     */
    public static FunctionDescriptor llroundf$descriptor() {
        return llroundf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long llroundf(float)
     * }
     */
    public static MethodHandle llroundf$handle() {
        return llroundf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long llroundf(float)
     * }
     */
    public static MemorySegment llroundf$address() {
        return llroundf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long llroundf(float)
     * }
     */
    public static long llroundf(float x0) {
        var mh$ = llroundf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llroundf", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llround {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("llround");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long llround(double)
     * }
     */
    public static FunctionDescriptor llround$descriptor() {
        return llround.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long llround(double)
     * }
     */
    public static MethodHandle llround$handle() {
        return llround.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long llround(double)
     * }
     */
    public static MemorySegment llround$address() {
        return llround.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long llround(double)
     * }
     */
    public static long llround(double x0) {
        var mh$ = llround.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llround", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class truncf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("truncf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float truncf(float)
     * }
     */
    public static FunctionDescriptor truncf$descriptor() {
        return truncf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float truncf(float)
     * }
     */
    public static MethodHandle truncf$handle() {
        return truncf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float truncf(float)
     * }
     */
    public static MemorySegment truncf$address() {
        return truncf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float truncf(float)
     * }
     */
    public static float truncf(float x0) {
        var mh$ = truncf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("truncf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class trunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("trunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double trunc(double)
     * }
     */
    public static FunctionDescriptor trunc$descriptor() {
        return trunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double trunc(double)
     * }
     */
    public static MethodHandle trunc$handle() {
        return trunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double trunc(double)
     * }
     */
    public static MemorySegment trunc$address() {
        return trunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double trunc(double)
     * }
     */
    public static double trunc(double x0) {
        var mh$ = trunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("trunc", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmodf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fmodf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fmodf(float, float)
     * }
     */
    public static FunctionDescriptor fmodf$descriptor() {
        return fmodf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fmodf(float, float)
     * }
     */
    public static MethodHandle fmodf$handle() {
        return fmodf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float fmodf(float, float)
     * }
     */
    public static MemorySegment fmodf$address() {
        return fmodf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float fmodf(float, float)
     * }
     */
    public static float fmodf(float x0, float x1) {
        var mh$ = fmodf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmodf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fmod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fmod(double, double)
     * }
     */
    public static FunctionDescriptor fmod$descriptor() {
        return fmod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fmod(double, double)
     * }
     */
    public static MethodHandle fmod$handle() {
        return fmod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fmod(double, double)
     * }
     */
    public static MemorySegment fmod$address() {
        return fmod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fmod(double, double)
     * }
     */
    public static double fmod(double x0, double x1) {
        var mh$ = fmod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmod", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remainderf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("remainderf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float remainderf(float, float)
     * }
     */
    public static FunctionDescriptor remainderf$descriptor() {
        return remainderf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float remainderf(float, float)
     * }
     */
    public static MethodHandle remainderf$handle() {
        return remainderf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float remainderf(float, float)
     * }
     */
    public static MemorySegment remainderf$address() {
        return remainderf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float remainderf(float, float)
     * }
     */
    public static float remainderf(float x0, float x1) {
        var mh$ = remainderf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remainderf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remainder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("remainder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double remainder(double, double)
     * }
     */
    public static FunctionDescriptor remainder$descriptor() {
        return remainder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double remainder(double, double)
     * }
     */
    public static MethodHandle remainder$handle() {
        return remainder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double remainder(double, double)
     * }
     */
    public static MemorySegment remainder$address() {
        return remainder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double remainder(double, double)
     * }
     */
    public static double remainder(double x0, double x1) {
        var mh$ = remainder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remainder", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remquof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("remquof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float remquof(float, float, int *)
     * }
     */
    public static FunctionDescriptor remquof$descriptor() {
        return remquof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float remquof(float, float, int *)
     * }
     */
    public static MethodHandle remquof$handle() {
        return remquof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float remquof(float, float, int *)
     * }
     */
    public static MemorySegment remquof$address() {
        return remquof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float remquof(float, float, int *)
     * }
     */
    public static float remquof(float x0, float x1, MemorySegment x2) {
        var mh$ = remquof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remquof", x0, x1, x2);
            }
            return (float)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remquo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("remquo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double remquo(double, double, int *)
     * }
     */
    public static FunctionDescriptor remquo$descriptor() {
        return remquo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double remquo(double, double, int *)
     * }
     */
    public static MethodHandle remquo$handle() {
        return remquo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double remquo(double, double, int *)
     * }
     */
    public static MemorySegment remquo$address() {
        return remquo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double remquo(double, double, int *)
     * }
     */
    public static double remquo(double x0, double x1, MemorySegment x2) {
        var mh$ = remquo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remquo", x0, x1, x2);
            }
            return (double)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class copysignf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("copysignf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float copysignf(float, float)
     * }
     */
    public static FunctionDescriptor copysignf$descriptor() {
        return copysignf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float copysignf(float, float)
     * }
     */
    public static MethodHandle copysignf$handle() {
        return copysignf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float copysignf(float, float)
     * }
     */
    public static MemorySegment copysignf$address() {
        return copysignf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float copysignf(float, float)
     * }
     */
    public static float copysignf(float x0, float x1) {
        var mh$ = copysignf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("copysignf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class copysign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("copysign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double copysign(double, double)
     * }
     */
    public static FunctionDescriptor copysign$descriptor() {
        return copysign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double copysign(double, double)
     * }
     */
    public static MethodHandle copysign$handle() {
        return copysign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double copysign(double, double)
     * }
     */
    public static MemorySegment copysign$address() {
        return copysign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double copysign(double, double)
     * }
     */
    public static double copysign(double x0, double x1) {
        var mh$ = copysign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("copysign", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("nanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float nanf(const char *)
     * }
     */
    public static FunctionDescriptor nanf$descriptor() {
        return nanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float nanf(const char *)
     * }
     */
    public static MethodHandle nanf$handle() {
        return nanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float nanf(const char *)
     * }
     */
    public static MemorySegment nanf$address() {
        return nanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float nanf(const char *)
     * }
     */
    public static float nanf(MemorySegment x0) {
        var mh$ = nanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nanf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("nan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double nan(const char *)
     * }
     */
    public static FunctionDescriptor nan$descriptor() {
        return nan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double nan(const char *)
     * }
     */
    public static MethodHandle nan$handle() {
        return nan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double nan(const char *)
     * }
     */
    public static MemorySegment nan$address() {
        return nan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double nan(const char *)
     * }
     */
    public static double nan(MemorySegment x0) {
        var mh$ = nan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nan", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nextafterf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("nextafterf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float nextafterf(float, float)
     * }
     */
    public static FunctionDescriptor nextafterf$descriptor() {
        return nextafterf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float nextafterf(float, float)
     * }
     */
    public static MethodHandle nextafterf$handle() {
        return nextafterf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float nextafterf(float, float)
     * }
     */
    public static MemorySegment nextafterf$address() {
        return nextafterf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float nextafterf(float, float)
     * }
     */
    public static float nextafterf(float x0, float x1) {
        var mh$ = nextafterf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nextafterf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nextafter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("nextafter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double nextafter(double, double)
     * }
     */
    public static FunctionDescriptor nextafter$descriptor() {
        return nextafter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double nextafter(double, double)
     * }
     */
    public static MethodHandle nextafter$handle() {
        return nextafter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double nextafter(double, double)
     * }
     */
    public static MemorySegment nextafter$address() {
        return nextafter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double nextafter(double, double)
     * }
     */
    public static double nextafter(double x0, double x1) {
        var mh$ = nextafter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nextafter", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdimf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fdimf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fdimf(float, float)
     * }
     */
    public static FunctionDescriptor fdimf$descriptor() {
        return fdimf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fdimf(float, float)
     * }
     */
    public static MethodHandle fdimf$handle() {
        return fdimf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float fdimf(float, float)
     * }
     */
    public static MemorySegment fdimf$address() {
        return fdimf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float fdimf(float, float)
     * }
     */
    public static float fdimf(float x0, float x1) {
        var mh$ = fdimf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdimf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fdim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fdim(double, double)
     * }
     */
    public static FunctionDescriptor fdim$descriptor() {
        return fdim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fdim(double, double)
     * }
     */
    public static MethodHandle fdim$handle() {
        return fdim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fdim(double, double)
     * }
     */
    public static MemorySegment fdim$address() {
        return fdim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fdim(double, double)
     * }
     */
    public static double fdim(double x0, double x1) {
        var mh$ = fdim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdim", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmaxf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fmaxf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fmaxf(float, float)
     * }
     */
    public static FunctionDescriptor fmaxf$descriptor() {
        return fmaxf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fmaxf(float, float)
     * }
     */
    public static MethodHandle fmaxf$handle() {
        return fmaxf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float fmaxf(float, float)
     * }
     */
    public static MemorySegment fmaxf$address() {
        return fmaxf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float fmaxf(float, float)
     * }
     */
    public static float fmaxf(float x0, float x1) {
        var mh$ = fmaxf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmaxf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fmax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fmax(double, double)
     * }
     */
    public static FunctionDescriptor fmax$descriptor() {
        return fmax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fmax(double, double)
     * }
     */
    public static MethodHandle fmax$handle() {
        return fmax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fmax(double, double)
     * }
     */
    public static MemorySegment fmax$address() {
        return fmax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fmax(double, double)
     * }
     */
    public static double fmax(double x0, double x1) {
        var mh$ = fmax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmax", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fminf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fminf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fminf(float, float)
     * }
     */
    public static FunctionDescriptor fminf$descriptor() {
        return fminf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fminf(float, float)
     * }
     */
    public static MethodHandle fminf$handle() {
        return fminf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float fminf(float, float)
     * }
     */
    public static MemorySegment fminf$address() {
        return fminf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float fminf(float, float)
     * }
     */
    public static float fminf(float x0, float x1) {
        var mh$ = fminf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fminf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fmin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fmin(double, double)
     * }
     */
    public static FunctionDescriptor fmin$descriptor() {
        return fmin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fmin(double, double)
     * }
     */
    public static MethodHandle fmin$handle() {
        return fmin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fmin(double, double)
     * }
     */
    public static MemorySegment fmin$address() {
        return fmin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fmin(double, double)
     * }
     */
    public static double fmin(double x0, double x1) {
        var mh$ = fmin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmin", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fmaf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fmaf(float, float, float)
     * }
     */
    public static FunctionDescriptor fmaf$descriptor() {
        return fmaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fmaf(float, float, float)
     * }
     */
    public static MethodHandle fmaf$handle() {
        return fmaf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float fmaf(float, float, float)
     * }
     */
    public static MemorySegment fmaf$address() {
        return fmaf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float fmaf(float, float, float)
     * }
     */
    public static float fmaf(float x0, float x1, float x2) {
        var mh$ = fmaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmaf", x0, x1, x2);
            }
            return (float)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fma(double, double, double)
     * }
     */
    public static FunctionDescriptor fma$descriptor() {
        return fma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fma(double, double, double)
     * }
     */
    public static MethodHandle fma$handle() {
        return fma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fma(double, double, double)
     * }
     */
    public static MemorySegment fma$address() {
        return fma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fma(double, double, double)
     * }
     */
    public static double fma(double x0, double x1, double x2) {
        var mh$ = fma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fma", x0, x1, x2);
            }
            return (double)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lgammaf_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lgammaf_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float lgammaf_r(float, int *)
     * }
     */
    public static FunctionDescriptor lgammaf_r$descriptor() {
        return lgammaf_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float lgammaf_r(float, int *)
     * }
     */
    public static MethodHandle lgammaf_r$handle() {
        return lgammaf_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float lgammaf_r(float, int *)
     * }
     */
    public static MemorySegment lgammaf_r$address() {
        return lgammaf_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float lgammaf_r(float, int *)
     * }
     */
    public static float lgammaf_r(float x0, MemorySegment x1) {
        var mh$ = lgammaf_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lgammaf_r", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lgamma_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lgamma_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double lgamma_r(double, int *)
     * }
     */
    public static FunctionDescriptor lgamma_r$descriptor() {
        return lgamma_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double lgamma_r(double, int *)
     * }
     */
    public static MethodHandle lgamma_r$handle() {
        return lgamma_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double lgamma_r(double, int *)
     * }
     */
    public static MemorySegment lgamma_r$address() {
        return lgamma_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double lgamma_r(double, int *)
     * }
     */
    public static double lgamma_r(double x0, MemorySegment x1) {
        var mh$ = lgamma_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lgamma_r", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __exp10f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__exp10f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __exp10f(float)
     * }
     */
    public static FunctionDescriptor __exp10f$descriptor() {
        return __exp10f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __exp10f(float)
     * }
     */
    public static MethodHandle __exp10f$handle() {
        return __exp10f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __exp10f(float)
     * }
     */
    public static MemorySegment __exp10f$address() {
        return __exp10f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __exp10f(float)
     * }
     */
    public static float __exp10f(float x0) {
        var mh$ = __exp10f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__exp10f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __exp10 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__exp10");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __exp10(double)
     * }
     */
    public static FunctionDescriptor __exp10$descriptor() {
        return __exp10.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __exp10(double)
     * }
     */
    public static MethodHandle __exp10$handle() {
        return __exp10.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __exp10(double)
     * }
     */
    public static MemorySegment __exp10$address() {
        return __exp10.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __exp10(double)
     * }
     */
    public static double __exp10(double x0) {
        var mh$ = __exp10.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__exp10", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cospif {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__cospif");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __cospif(float)
     * }
     */
    public static FunctionDescriptor __cospif$descriptor() {
        return __cospif.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __cospif(float)
     * }
     */
    public static MethodHandle __cospif$handle() {
        return __cospif.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __cospif(float)
     * }
     */
    public static MemorySegment __cospif$address() {
        return __cospif.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __cospif(float)
     * }
     */
    public static float __cospif(float x0) {
        var mh$ = __cospif.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cospif", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cospi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__cospi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __cospi(double)
     * }
     */
    public static FunctionDescriptor __cospi$descriptor() {
        return __cospi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __cospi(double)
     * }
     */
    public static MethodHandle __cospi$handle() {
        return __cospi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __cospi(double)
     * }
     */
    public static MemorySegment __cospi$address() {
        return __cospi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __cospi(double)
     * }
     */
    public static double __cospi(double x0) {
        var mh$ = __cospi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cospi", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sinpif {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__sinpif");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __sinpif(float)
     * }
     */
    public static FunctionDescriptor __sinpif$descriptor() {
        return __sinpif.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __sinpif(float)
     * }
     */
    public static MethodHandle __sinpif$handle() {
        return __sinpif.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __sinpif(float)
     * }
     */
    public static MemorySegment __sinpif$address() {
        return __sinpif.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __sinpif(float)
     * }
     */
    public static float __sinpif(float x0) {
        var mh$ = __sinpif.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sinpif", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sinpi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__sinpi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __sinpi(double)
     * }
     */
    public static FunctionDescriptor __sinpi$descriptor() {
        return __sinpi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __sinpi(double)
     * }
     */
    public static MethodHandle __sinpi$handle() {
        return __sinpi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __sinpi(double)
     * }
     */
    public static MemorySegment __sinpi$address() {
        return __sinpi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __sinpi(double)
     * }
     */
    public static double __sinpi(double x0) {
        var mh$ = __sinpi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sinpi", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __tanpif {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_FLOAT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__tanpif");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __tanpif(float)
     * }
     */
    public static FunctionDescriptor __tanpif$descriptor() {
        return __tanpif.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __tanpif(float)
     * }
     */
    public static MethodHandle __tanpif$handle() {
        return __tanpif.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __tanpif(float)
     * }
     */
    public static MemorySegment __tanpif$address() {
        return __tanpif.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __tanpif(float)
     * }
     */
    public static float __tanpif(float x0) {
        var mh$ = __tanpif.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__tanpif", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __tanpi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__tanpi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __tanpi(double)
     * }
     */
    public static FunctionDescriptor __tanpi$descriptor() {
        return __tanpi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __tanpi(double)
     * }
     */
    public static MethodHandle __tanpi$handle() {
        return __tanpi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __tanpi(double)
     * }
     */
    public static MemorySegment __tanpi$address() {
        return __tanpi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __tanpi(double)
     * }
     */
    public static double __tanpi(double x0) {
        var mh$ = __tanpi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__tanpi", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class j0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("j0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double j0(double)
     * }
     */
    public static FunctionDescriptor j0$descriptor() {
        return j0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double j0(double)
     * }
     */
    public static MethodHandle j0$handle() {
        return j0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double j0(double)
     * }
     */
    public static MemorySegment j0$address() {
        return j0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double j0(double)
     * }
     */
    public static double j0(double x0) {
        var mh$ = j0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("j0", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class j1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("j1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double j1(double)
     * }
     */
    public static FunctionDescriptor j1$descriptor() {
        return j1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double j1(double)
     * }
     */
    public static MethodHandle j1$handle() {
        return j1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double j1(double)
     * }
     */
    public static MemorySegment j1$address() {
        return j1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double j1(double)
     * }
     */
    public static double j1(double x0) {
        var mh$ = j1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("j1", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_INT,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("jn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double jn(int, double)
     * }
     */
    public static FunctionDescriptor jn$descriptor() {
        return jn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double jn(int, double)
     * }
     */
    public static MethodHandle jn$handle() {
        return jn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double jn(int, double)
     * }
     */
    public static MemorySegment jn$address() {
        return jn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double jn(int, double)
     * }
     */
    public static double jn(int x0, double x1) {
        var mh$ = jn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jn", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class y0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("y0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double y0(double)
     * }
     */
    public static FunctionDescriptor y0$descriptor() {
        return y0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double y0(double)
     * }
     */
    public static MethodHandle y0$handle() {
        return y0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double y0(double)
     * }
     */
    public static MemorySegment y0$address() {
        return y0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double y0(double)
     * }
     */
    public static double y0(double x0) {
        var mh$ = y0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("y0", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class y1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("y1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double y1(double)
     * }
     */
    public static FunctionDescriptor y1$descriptor() {
        return y1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double y1(double)
     * }
     */
    public static MethodHandle y1$handle() {
        return y1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double y1(double)
     * }
     */
    public static MemorySegment y1$address() {
        return y1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double y1(double)
     * }
     */
    public static double y1(double x0) {
        var mh$ = y1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("y1", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class yn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_INT,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("yn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double yn(int, double)
     * }
     */
    public static FunctionDescriptor yn$descriptor() {
        return yn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double yn(int, double)
     * }
     */
    public static MethodHandle yn$handle() {
        return yn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double yn(int, double)
     * }
     */
    public static MemorySegment yn$address() {
        return yn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double yn(int, double)
     * }
     */
    public static double yn(int x0, double x1) {
        var mh$ = yn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("yn", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("scalb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double scalb(double, double)
     * }
     */
    public static FunctionDescriptor scalb$descriptor() {
        return scalb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double scalb(double, double)
     * }
     */
    public static MethodHandle scalb$handle() {
        return scalb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double scalb(double, double)
     * }
     */
    public static MemorySegment scalb$address() {
        return scalb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double scalb(double, double)
     * }
     */
    public static double scalb(double x0, double x1) {
        var mh$ = scalb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalb", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class signgam$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("signgam").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int signgam
     * }
     */
    public static OfInt signgam$layout() {
        return signgam$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int signgam
     * }
     */
    public static MemorySegment signgam$segment() {
        return signgam$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int signgam
     * }
     */
    public static int signgam() {
        return signgam$constants.SEGMENT.get(signgam$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int signgam
     * }
     */
    public static void signgam(int varValue) {
        signgam$constants.SEGMENT.set(signgam$constants.LAYOUT, 0L, varValue);
    }

    private static class adjtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("adjtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int adjtime(const struct timeval *, struct timeval *)
     * }
     */
    public static FunctionDescriptor adjtime$descriptor() {
        return adjtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int adjtime(const struct timeval *, struct timeval *)
     * }
     */
    public static MethodHandle adjtime$handle() {
        return adjtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int adjtime(const struct timeval *, struct timeval *)
     * }
     */
    public static MemorySegment adjtime$address() {
        return adjtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int adjtime(const struct timeval *, struct timeval *)
     * }
     */
    public static int adjtime(MemorySegment x0, MemorySegment x1) {
        var mh$ = adjtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("adjtime", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class futimes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("futimes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int futimes(int, const struct timeval *)
     * }
     */
    public static FunctionDescriptor futimes$descriptor() {
        return futimes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int futimes(int, const struct timeval *)
     * }
     */
    public static MethodHandle futimes$handle() {
        return futimes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int futimes(int, const struct timeval *)
     * }
     */
    public static MemorySegment futimes$address() {
        return futimes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int futimes(int, const struct timeval *)
     * }
     */
    public static int futimes(int x0, MemorySegment x1) {
        var mh$ = futimes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("futimes", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lutimes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lutimes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lutimes(const char *, const struct timeval *)
     * }
     */
    public static FunctionDescriptor lutimes$descriptor() {
        return lutimes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lutimes(const char *, const struct timeval *)
     * }
     */
    public static MethodHandle lutimes$handle() {
        return lutimes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int lutimes(const char *, const struct timeval *)
     * }
     */
    public static MemorySegment lutimes$address() {
        return lutimes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int lutimes(const char *, const struct timeval *)
     * }
     */
    public static int lutimes(MemorySegment x0, MemorySegment x1) {
        var mh$ = lutimes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lutimes", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class settimeofday {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("settimeofday");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int settimeofday(const struct timeval *, const struct timezone *)
     * }
     */
    public static FunctionDescriptor settimeofday$descriptor() {
        return settimeofday.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int settimeofday(const struct timeval *, const struct timezone *)
     * }
     */
    public static MethodHandle settimeofday$handle() {
        return settimeofday.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int settimeofday(const struct timeval *, const struct timezone *)
     * }
     */
    public static MemorySegment settimeofday$address() {
        return settimeofday.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int settimeofday(const struct timeval *, const struct timezone *)
     * }
     */
    public static int settimeofday(MemorySegment x0, MemorySegment x1) {
        var mh$ = settimeofday.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("settimeofday", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getitimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getitimer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getitimer(int, struct itimerval *)
     * }
     */
    public static FunctionDescriptor getitimer$descriptor() {
        return getitimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getitimer(int, struct itimerval *)
     * }
     */
    public static MethodHandle getitimer$handle() {
        return getitimer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getitimer(int, struct itimerval *)
     * }
     */
    public static MemorySegment getitimer$address() {
        return getitimer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getitimer(int, struct itimerval *)
     * }
     */
    public static int getitimer(int x0, MemorySegment x1) {
        var mh$ = getitimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getitimer", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gettimeofday {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("gettimeofday");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int gettimeofday(struct timeval *restrict, void *restrict)
     * }
     */
    public static FunctionDescriptor gettimeofday$descriptor() {
        return gettimeofday.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int gettimeofday(struct timeval *restrict, void *restrict)
     * }
     */
    public static MethodHandle gettimeofday$handle() {
        return gettimeofday.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int gettimeofday(struct timeval *restrict, void *restrict)
     * }
     */
    public static MemorySegment gettimeofday$address() {
        return gettimeofday.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int gettimeofday(struct timeval *restrict, void *restrict)
     * }
     */
    public static int gettimeofday(MemorySegment x0, MemorySegment x1) {
        var mh$ = gettimeofday.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gettimeofday", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setitimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setitimer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setitimer(int, const struct itimerval *restrict, struct itimerval *restrict)
     * }
     */
    public static FunctionDescriptor setitimer$descriptor() {
        return setitimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setitimer(int, const struct itimerval *restrict, struct itimerval *restrict)
     * }
     */
    public static MethodHandle setitimer$handle() {
        return setitimer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setitimer(int, const struct itimerval *restrict, struct itimerval *restrict)
     * }
     */
    public static MemorySegment setitimer$address() {
        return setitimer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setitimer(int, const struct itimerval *restrict, struct itimerval *restrict)
     * }
     */
    public static int setitimer(int x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = setitimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setitimer", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class utimes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("utimes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int utimes(const char *, const struct timeval *)
     * }
     */
    public static FunctionDescriptor utimes$descriptor() {
        return utimes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int utimes(const char *, const struct timeval *)
     * }
     */
    public static MethodHandle utimes$handle() {
        return utimes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int utimes(const char *, const struct timeval *)
     * }
     */
    public static MemorySegment utimes$address() {
        return utimes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int utimes(const char *, const struct timeval *)
     * }
     */
    public static int utimes(MemorySegment x0, MemorySegment x1) {
        var mh$ = utimes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("utimes", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_blkcnt_t blkcnt_t
     * }
     */
    public static final OfLong blkcnt_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_blksize_t blksize_t
     * }
     */
    public static final OfInt blksize_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_ino_t ino_t
     * }
     */
    public static final OfLong ino_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_ino64_t ino64_t
     * }
     */
    public static final OfLong ino64_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t nlink_t
     * }
     */
    public static final OfShort nlink_t = Python_h.C_SHORT;

    private static class chmod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("chmod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chmod(const char *, mode_t)
     * }
     */
    public static FunctionDescriptor chmod$descriptor() {
        return chmod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chmod(const char *, mode_t)
     * }
     */
    public static MethodHandle chmod$handle() {
        return chmod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chmod(const char *, mode_t)
     * }
     */
    public static MemorySegment chmod$address() {
        return chmod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chmod(const char *, mode_t)
     * }
     */
    public static int chmod(MemorySegment x0, short x1) {
        var mh$ = chmod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chmod", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fchmod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fchmod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fchmod(int, mode_t)
     * }
     */
    public static FunctionDescriptor fchmod$descriptor() {
        return fchmod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fchmod(int, mode_t)
     * }
     */
    public static MethodHandle fchmod$handle() {
        return fchmod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fchmod(int, mode_t)
     * }
     */
    public static MemorySegment fchmod$address() {
        return fchmod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fchmod(int, mode_t)
     * }
     */
    public static int fchmod(int x0, short x1) {
        var mh$ = fchmod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fchmod", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fstat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fstat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fstat(int, struct stat *)
     * }
     */
    public static FunctionDescriptor fstat$descriptor() {
        return fstat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fstat(int, struct stat *)
     * }
     */
    public static MethodHandle fstat$handle() {
        return fstat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fstat(int, struct stat *)
     * }
     */
    public static MemorySegment fstat$address() {
        return fstat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fstat(int, struct stat *)
     * }
     */
    public static int fstat(int x0, MemorySegment x1) {
        var mh$ = fstat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fstat", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lstat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lstat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lstat(const char *, struct stat *)
     * }
     */
    public static FunctionDescriptor lstat$descriptor() {
        return lstat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lstat(const char *, struct stat *)
     * }
     */
    public static MethodHandle lstat$handle() {
        return lstat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int lstat(const char *, struct stat *)
     * }
     */
    public static MemorySegment lstat$address() {
        return lstat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int lstat(const char *, struct stat *)
     * }
     */
    public static int lstat(MemorySegment x0, MemorySegment x1) {
        var mh$ = lstat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lstat", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkdir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mkdir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkdir(const char *, mode_t)
     * }
     */
    public static FunctionDescriptor mkdir$descriptor() {
        return mkdir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkdir(const char *, mode_t)
     * }
     */
    public static MethodHandle mkdir$handle() {
        return mkdir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkdir(const char *, mode_t)
     * }
     */
    public static MemorySegment mkdir$address() {
        return mkdir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkdir(const char *, mode_t)
     * }
     */
    public static int mkdir(MemorySegment x0, short x1) {
        var mh$ = mkdir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkdir", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkfifo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mkfifo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkfifo(const char *, mode_t)
     * }
     */
    public static FunctionDescriptor mkfifo$descriptor() {
        return mkfifo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkfifo(const char *, mode_t)
     * }
     */
    public static MethodHandle mkfifo$handle() {
        return mkfifo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkfifo(const char *, mode_t)
     * }
     */
    public static MemorySegment mkfifo$address() {
        return mkfifo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkfifo(const char *, mode_t)
     * }
     */
    public static int mkfifo(MemorySegment x0, short x1) {
        var mh$ = mkfifo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkfifo", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("stat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int stat(const char *, struct stat *)
     * }
     */
    public static FunctionDescriptor stat$descriptor() {
        return stat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int stat(const char *, struct stat *)
     * }
     */
    public static MethodHandle stat$handle() {
        return stat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int stat(const char *, struct stat *)
     * }
     */
    public static MemorySegment stat$address() {
        return stat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int stat(const char *, struct stat *)
     * }
     */
    public static int stat(MemorySegment x0, MemorySegment x1) {
        var mh$ = stat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stat", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_SHORT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("umask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mode_t umask(mode_t)
     * }
     */
    public static FunctionDescriptor umask$descriptor() {
        return umask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mode_t umask(mode_t)
     * }
     */
    public static MethodHandle umask$handle() {
        return umask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mode_t umask(mode_t)
     * }
     */
    public static MemorySegment umask$address() {
        return umask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mode_t umask(mode_t)
     * }
     */
    public static short umask(short x0) {
        var mh$ = umask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umask", x0);
            }
            return (short)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fchmodat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_SHORT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fchmodat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fchmodat(int, const char *, mode_t, int)
     * }
     */
    public static FunctionDescriptor fchmodat$descriptor() {
        return fchmodat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fchmodat(int, const char *, mode_t, int)
     * }
     */
    public static MethodHandle fchmodat$handle() {
        return fchmodat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fchmodat(int, const char *, mode_t, int)
     * }
     */
    public static MemorySegment fchmodat$address() {
        return fchmodat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fchmodat(int, const char *, mode_t, int)
     * }
     */
    public static int fchmodat(int x0, MemorySegment x1, short x2, int x3) {
        var mh$ = fchmodat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fchmodat", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fstatat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fstatat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fstatat(int, const char *, struct stat *, int)
     * }
     */
    public static FunctionDescriptor fstatat$descriptor() {
        return fstatat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fstatat(int, const char *, struct stat *, int)
     * }
     */
    public static MethodHandle fstatat$handle() {
        return fstatat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fstatat(int, const char *, struct stat *, int)
     * }
     */
    public static MemorySegment fstatat$address() {
        return fstatat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fstatat(int, const char *, struct stat *, int)
     * }
     */
    public static int fstatat(int x0, MemorySegment x1, MemorySegment x2, int x3) {
        var mh$ = fstatat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fstatat", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkdirat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mkdirat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkdirat(int, const char *, mode_t)
     * }
     */
    public static FunctionDescriptor mkdirat$descriptor() {
        return mkdirat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkdirat(int, const char *, mode_t)
     * }
     */
    public static MethodHandle mkdirat$handle() {
        return mkdirat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkdirat(int, const char *, mode_t)
     * }
     */
    public static MemorySegment mkdirat$address() {
        return mkdirat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkdirat(int, const char *, mode_t)
     * }
     */
    public static int mkdirat(int x0, MemorySegment x1, short x2) {
        var mh$ = mkdirat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkdirat", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkfifoat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mkfifoat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkfifoat(int, const char *, mode_t)
     * }
     */
    public static FunctionDescriptor mkfifoat$descriptor() {
        return mkfifoat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkfifoat(int, const char *, mode_t)
     * }
     */
    public static MethodHandle mkfifoat$handle() {
        return mkfifoat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkfifoat(int, const char *, mode_t)
     * }
     */
    public static MemorySegment mkfifoat$address() {
        return mkfifoat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkfifoat(int, const char *, mode_t)
     * }
     */
    public static int mkfifoat(int x0, MemorySegment x1, short x2) {
        var mh$ = mkfifoat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkfifoat", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mknodat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_SHORT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mknodat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mknodat(int, const char *, mode_t, dev_t)
     * }
     */
    public static FunctionDescriptor mknodat$descriptor() {
        return mknodat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mknodat(int, const char *, mode_t, dev_t)
     * }
     */
    public static MethodHandle mknodat$handle() {
        return mknodat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mknodat(int, const char *, mode_t, dev_t)
     * }
     */
    public static MemorySegment mknodat$address() {
        return mknodat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mknodat(int, const char *, mode_t, dev_t)
     * }
     */
    public static int mknodat(int x0, MemorySegment x1, short x2, int x3) {
        var mh$ = mknodat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mknodat", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class futimens {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("futimens");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int futimens(int __fd, const struct timespec __times[2])
     * }
     */
    public static FunctionDescriptor futimens$descriptor() {
        return futimens.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int futimens(int __fd, const struct timespec __times[2])
     * }
     */
    public static MethodHandle futimens$handle() {
        return futimens.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int futimens(int __fd, const struct timespec __times[2])
     * }
     */
    public static MemorySegment futimens$address() {
        return futimens.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int futimens(int __fd, const struct timespec __times[2])
     * }
     */
    public static int futimens(int __fd, MemorySegment __times) {
        var mh$ = futimens.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("futimens", __fd, __times);
            }
            return (int)mh$.invokeExact(__fd, __times);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class utimensat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("utimensat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int utimensat(int __fd, const char *__path, const struct timespec __times[2], int __flag)
     * }
     */
    public static FunctionDescriptor utimensat$descriptor() {
        return utimensat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int utimensat(int __fd, const char *__path, const struct timespec __times[2], int __flag)
     * }
     */
    public static MethodHandle utimensat$handle() {
        return utimensat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int utimensat(int __fd, const char *__path, const struct timespec __times[2], int __flag)
     * }
     */
    public static MemorySegment utimensat$address() {
        return utimensat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int utimensat(int __fd, const char *__path, const struct timespec __times[2], int __flag)
     * }
     */
    public static int utimensat(int __fd, MemorySegment __path, MemorySegment __times, int __flag) {
        var mh$ = utimensat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("utimensat", __fd, __path, __times, __flag);
            }
            return (int)mh$.invokeExact(__fd, __path, __times, __flag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _filesec *filesec_t
     * }
     */
    public static final AddressLayout filesec_t = Python_h.C_POINTER;

    private static class chflags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("chflags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chflags(const char *, __uint32_t)
     * }
     */
    public static FunctionDescriptor chflags$descriptor() {
        return chflags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chflags(const char *, __uint32_t)
     * }
     */
    public static MethodHandle chflags$handle() {
        return chflags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chflags(const char *, __uint32_t)
     * }
     */
    public static MemorySegment chflags$address() {
        return chflags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chflags(const char *, __uint32_t)
     * }
     */
    public static int chflags(MemorySegment x0, int x1) {
        var mh$ = chflags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chflags", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chmodx_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("chmodx_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chmodx_np(const char *, filesec_t)
     * }
     */
    public static FunctionDescriptor chmodx_np$descriptor() {
        return chmodx_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chmodx_np(const char *, filesec_t)
     * }
     */
    public static MethodHandle chmodx_np$handle() {
        return chmodx_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chmodx_np(const char *, filesec_t)
     * }
     */
    public static MemorySegment chmodx_np$address() {
        return chmodx_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chmodx_np(const char *, filesec_t)
     * }
     */
    public static int chmodx_np(MemorySegment x0, MemorySegment x1) {
        var mh$ = chmodx_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chmodx_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fchflags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fchflags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fchflags(int, __uint32_t)
     * }
     */
    public static FunctionDescriptor fchflags$descriptor() {
        return fchflags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fchflags(int, __uint32_t)
     * }
     */
    public static MethodHandle fchflags$handle() {
        return fchflags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fchflags(int, __uint32_t)
     * }
     */
    public static MemorySegment fchflags$address() {
        return fchflags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fchflags(int, __uint32_t)
     * }
     */
    public static int fchflags(int x0, int x1) {
        var mh$ = fchflags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fchflags", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fchmodx_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fchmodx_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fchmodx_np(int, filesec_t)
     * }
     */
    public static FunctionDescriptor fchmodx_np$descriptor() {
        return fchmodx_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fchmodx_np(int, filesec_t)
     * }
     */
    public static MethodHandle fchmodx_np$handle() {
        return fchmodx_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fchmodx_np(int, filesec_t)
     * }
     */
    public static MemorySegment fchmodx_np$address() {
        return fchmodx_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fchmodx_np(int, filesec_t)
     * }
     */
    public static int fchmodx_np(int x0, MemorySegment x1) {
        var mh$ = fchmodx_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fchmodx_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fstatx_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fstatx_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fstatx_np(int, struct stat *, filesec_t)
     * }
     */
    public static FunctionDescriptor fstatx_np$descriptor() {
        return fstatx_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fstatx_np(int, struct stat *, filesec_t)
     * }
     */
    public static MethodHandle fstatx_np$handle() {
        return fstatx_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fstatx_np(int, struct stat *, filesec_t)
     * }
     */
    public static MemorySegment fstatx_np$address() {
        return fstatx_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fstatx_np(int, struct stat *, filesec_t)
     * }
     */
    public static int fstatx_np(int x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = fstatx_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fstatx_np", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lchflags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lchflags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lchflags(const char *, __uint32_t)
     * }
     */
    public static FunctionDescriptor lchflags$descriptor() {
        return lchflags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lchflags(const char *, __uint32_t)
     * }
     */
    public static MethodHandle lchflags$handle() {
        return lchflags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int lchflags(const char *, __uint32_t)
     * }
     */
    public static MemorySegment lchflags$address() {
        return lchflags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int lchflags(const char *, __uint32_t)
     * }
     */
    public static int lchflags(MemorySegment x0, int x1) {
        var mh$ = lchflags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lchflags", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lchmod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lchmod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lchmod(const char *, mode_t)
     * }
     */
    public static FunctionDescriptor lchmod$descriptor() {
        return lchmod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lchmod(const char *, mode_t)
     * }
     */
    public static MethodHandle lchmod$handle() {
        return lchmod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int lchmod(const char *, mode_t)
     * }
     */
    public static MemorySegment lchmod$address() {
        return lchmod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int lchmod(const char *, mode_t)
     * }
     */
    public static int lchmod(MemorySegment x0, short x1) {
        var mh$ = lchmod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lchmod", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lstatx_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lstatx_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lstatx_np(const char *, struct stat *, filesec_t)
     * }
     */
    public static FunctionDescriptor lstatx_np$descriptor() {
        return lstatx_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lstatx_np(const char *, struct stat *, filesec_t)
     * }
     */
    public static MethodHandle lstatx_np$handle() {
        return lstatx_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int lstatx_np(const char *, struct stat *, filesec_t)
     * }
     */
    public static MemorySegment lstatx_np$address() {
        return lstatx_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int lstatx_np(const char *, struct stat *, filesec_t)
     * }
     */
    public static int lstatx_np(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = lstatx_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lstatx_np", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkdirx_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mkdirx_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkdirx_np(const char *, filesec_t)
     * }
     */
    public static FunctionDescriptor mkdirx_np$descriptor() {
        return mkdirx_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkdirx_np(const char *, filesec_t)
     * }
     */
    public static MethodHandle mkdirx_np$handle() {
        return mkdirx_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkdirx_np(const char *, filesec_t)
     * }
     */
    public static MemorySegment mkdirx_np$address() {
        return mkdirx_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkdirx_np(const char *, filesec_t)
     * }
     */
    public static int mkdirx_np(MemorySegment x0, MemorySegment x1) {
        var mh$ = mkdirx_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkdirx_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkfifox_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mkfifox_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkfifox_np(const char *, filesec_t)
     * }
     */
    public static FunctionDescriptor mkfifox_np$descriptor() {
        return mkfifox_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkfifox_np(const char *, filesec_t)
     * }
     */
    public static MethodHandle mkfifox_np$handle() {
        return mkfifox_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkfifox_np(const char *, filesec_t)
     * }
     */
    public static MemorySegment mkfifox_np$address() {
        return mkfifox_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkfifox_np(const char *, filesec_t)
     * }
     */
    public static int mkfifox_np(MemorySegment x0, MemorySegment x1) {
        var mh$ = mkfifox_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkfifox_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class statx_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("statx_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int statx_np(const char *, struct stat *, filesec_t)
     * }
     */
    public static FunctionDescriptor statx_np$descriptor() {
        return statx_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int statx_np(const char *, struct stat *, filesec_t)
     * }
     */
    public static MethodHandle statx_np$handle() {
        return statx_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int statx_np(const char *, struct stat *, filesec_t)
     * }
     */
    public static MemorySegment statx_np$address() {
        return statx_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int statx_np(const char *, struct stat *, filesec_t)
     * }
     */
    public static int statx_np(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = statx_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("statx_np", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umaskx_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("umaskx_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int umaskx_np(filesec_t)
     * }
     */
    public static FunctionDescriptor umaskx_np$descriptor() {
        return umaskx_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int umaskx_np(filesec_t)
     * }
     */
    public static MethodHandle umaskx_np$handle() {
        return umaskx_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int umaskx_np(filesec_t)
     * }
     */
    public static MemorySegment umaskx_np$address() {
        return umaskx_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int umaskx_np(filesec_t)
     * }
     */
    public static int umaskx_np(MemorySegment x0) {
        var mh$ = umaskx_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umaskx_np", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_wctrans_t wctrans_t
     * }
     */
    public static final OfInt wctrans_t = Python_h.C_INT;

    private static class nextwctype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("nextwctype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t nextwctype(wint_t, wctype_t)
     * }
     */
    public static FunctionDescriptor nextwctype$descriptor() {
        return nextwctype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t nextwctype(wint_t, wctype_t)
     * }
     */
    public static MethodHandle nextwctype$handle() {
        return nextwctype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t nextwctype(wint_t, wctype_t)
     * }
     */
    public static MemorySegment nextwctype$address() {
        return nextwctype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t nextwctype(wint_t, wctype_t)
     * }
     */
    public static int nextwctype(int x0, int x1) {
        var mh$ = nextwctype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nextwctype", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class towctrans {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("towctrans");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t towctrans(wint_t, wctrans_t)
     * }
     */
    public static FunctionDescriptor towctrans$descriptor() {
        return towctrans.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t towctrans(wint_t, wctrans_t)
     * }
     */
    public static MethodHandle towctrans$handle() {
        return towctrans.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t towctrans(wint_t, wctrans_t)
     * }
     */
    public static MemorySegment towctrans$address() {
        return towctrans.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t towctrans(wint_t, wctrans_t)
     * }
     */
    public static int towctrans(int x0, int x1) {
        var mh$ = towctrans.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("towctrans", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wctrans {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wctrans");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wctrans_t wctrans(const char *)
     * }
     */
    public static FunctionDescriptor wctrans$descriptor() {
        return wctrans.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wctrans_t wctrans(const char *)
     * }
     */
    public static MethodHandle wctrans$handle() {
        return wctrans.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wctrans_t wctrans(const char *)
     * }
     */
    public static MemorySegment wctrans$address() {
        return wctrans.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wctrans_t wctrans(const char *)
     * }
     */
    public static int wctrans(MemorySegment x0) {
        var mh$ = wctrans.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wctrans", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMem_Malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMem_Malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyMem_Malloc(size_t size)
     * }
     */
    public static FunctionDescriptor PyMem_Malloc$descriptor() {
        return PyMem_Malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyMem_Malloc(size_t size)
     * }
     */
    public static MethodHandle PyMem_Malloc$handle() {
        return PyMem_Malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyMem_Malloc(size_t size)
     * }
     */
    public static MemorySegment PyMem_Malloc$address() {
        return PyMem_Malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyMem_Malloc(size_t size)
     * }
     */
    public static MemorySegment PyMem_Malloc(long size) {
        var mh$ = PyMem_Malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMem_Malloc", size);
            }
            return (MemorySegment)mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMem_Calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMem_Calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyMem_Calloc(size_t nelem, size_t elsize)
     * }
     */
    public static FunctionDescriptor PyMem_Calloc$descriptor() {
        return PyMem_Calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyMem_Calloc(size_t nelem, size_t elsize)
     * }
     */
    public static MethodHandle PyMem_Calloc$handle() {
        return PyMem_Calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyMem_Calloc(size_t nelem, size_t elsize)
     * }
     */
    public static MemorySegment PyMem_Calloc$address() {
        return PyMem_Calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyMem_Calloc(size_t nelem, size_t elsize)
     * }
     */
    public static MemorySegment PyMem_Calloc(long nelem, long elsize) {
        var mh$ = PyMem_Calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMem_Calloc", nelem, elsize);
            }
            return (MemorySegment)mh$.invokeExact(nelem, elsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMem_Realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMem_Realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyMem_Realloc(void *ptr, size_t new_size)
     * }
     */
    public static FunctionDescriptor PyMem_Realloc$descriptor() {
        return PyMem_Realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyMem_Realloc(void *ptr, size_t new_size)
     * }
     */
    public static MethodHandle PyMem_Realloc$handle() {
        return PyMem_Realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyMem_Realloc(void *ptr, size_t new_size)
     * }
     */
    public static MemorySegment PyMem_Realloc$address() {
        return PyMem_Realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyMem_Realloc(void *ptr, size_t new_size)
     * }
     */
    public static MemorySegment PyMem_Realloc(MemorySegment ptr, long new_size) {
        var mh$ = PyMem_Realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMem_Realloc", ptr, new_size);
            }
            return (MemorySegment)mh$.invokeExact(ptr, new_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMem_Free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMem_Free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyMem_Free(void *ptr)
     * }
     */
    public static FunctionDescriptor PyMem_Free$descriptor() {
        return PyMem_Free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyMem_Free(void *ptr)
     * }
     */
    public static MethodHandle PyMem_Free$handle() {
        return PyMem_Free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyMem_Free(void *ptr)
     * }
     */
    public static MemorySegment PyMem_Free$address() {
        return PyMem_Free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyMem_Free(void *ptr)
     * }
     */
    public static void PyMem_Free(MemorySegment ptr) {
        var mh$ = PyMem_Free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMem_Free", ptr);
            }
            mh$.invokeExact(ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMem_RawMalloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMem_RawMalloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyMem_RawMalloc(size_t size)
     * }
     */
    public static FunctionDescriptor PyMem_RawMalloc$descriptor() {
        return PyMem_RawMalloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyMem_RawMalloc(size_t size)
     * }
     */
    public static MethodHandle PyMem_RawMalloc$handle() {
        return PyMem_RawMalloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyMem_RawMalloc(size_t size)
     * }
     */
    public static MemorySegment PyMem_RawMalloc$address() {
        return PyMem_RawMalloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyMem_RawMalloc(size_t size)
     * }
     */
    public static MemorySegment PyMem_RawMalloc(long size) {
        var mh$ = PyMem_RawMalloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMem_RawMalloc", size);
            }
            return (MemorySegment)mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMem_RawCalloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMem_RawCalloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyMem_RawCalloc(size_t nelem, size_t elsize)
     * }
     */
    public static FunctionDescriptor PyMem_RawCalloc$descriptor() {
        return PyMem_RawCalloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyMem_RawCalloc(size_t nelem, size_t elsize)
     * }
     */
    public static MethodHandle PyMem_RawCalloc$handle() {
        return PyMem_RawCalloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyMem_RawCalloc(size_t nelem, size_t elsize)
     * }
     */
    public static MemorySegment PyMem_RawCalloc$address() {
        return PyMem_RawCalloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyMem_RawCalloc(size_t nelem, size_t elsize)
     * }
     */
    public static MemorySegment PyMem_RawCalloc(long nelem, long elsize) {
        var mh$ = PyMem_RawCalloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMem_RawCalloc", nelem, elsize);
            }
            return (MemorySegment)mh$.invokeExact(nelem, elsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMem_RawRealloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMem_RawRealloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyMem_RawRealloc(void *ptr, size_t new_size)
     * }
     */
    public static FunctionDescriptor PyMem_RawRealloc$descriptor() {
        return PyMem_RawRealloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyMem_RawRealloc(void *ptr, size_t new_size)
     * }
     */
    public static MethodHandle PyMem_RawRealloc$handle() {
        return PyMem_RawRealloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyMem_RawRealloc(void *ptr, size_t new_size)
     * }
     */
    public static MemorySegment PyMem_RawRealloc$address() {
        return PyMem_RawRealloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyMem_RawRealloc(void *ptr, size_t new_size)
     * }
     */
    public static MemorySegment PyMem_RawRealloc(MemorySegment ptr, long new_size) {
        var mh$ = PyMem_RawRealloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMem_RawRealloc", ptr, new_size);
            }
            return (MemorySegment)mh$.invokeExact(ptr, new_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMem_RawFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMem_RawFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyMem_RawFree(void *ptr)
     * }
     */
    public static FunctionDescriptor PyMem_RawFree$descriptor() {
        return PyMem_RawFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyMem_RawFree(void *ptr)
     * }
     */
    public static MethodHandle PyMem_RawFree$handle() {
        return PyMem_RawFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyMem_RawFree(void *ptr)
     * }
     */
    public static MemorySegment PyMem_RawFree$address() {
        return PyMem_RawFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyMem_RawFree(void *ptr)
     * }
     */
    public static void PyMem_RawFree(MemorySegment ptr) {
        var mh$ = PyMem_RawFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMem_RawFree", ptr);
            }
            mh$.invokeExact(ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyMem_GetCurrentAllocatorName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyMem_GetCurrentAllocatorName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *_PyMem_GetCurrentAllocatorName()
     * }
     */
    public static FunctionDescriptor _PyMem_GetCurrentAllocatorName$descriptor() {
        return _PyMem_GetCurrentAllocatorName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *_PyMem_GetCurrentAllocatorName()
     * }
     */
    public static MethodHandle _PyMem_GetCurrentAllocatorName$handle() {
        return _PyMem_GetCurrentAllocatorName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *_PyMem_GetCurrentAllocatorName()
     * }
     */
    public static MemorySegment _PyMem_GetCurrentAllocatorName$address() {
        return _PyMem_GetCurrentAllocatorName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *_PyMem_GetCurrentAllocatorName()
     * }
     */
    public static MemorySegment _PyMem_GetCurrentAllocatorName() {
        var mh$ = _PyMem_GetCurrentAllocatorName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyMem_GetCurrentAllocatorName");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyMem_RawStrdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyMem_RawStrdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_PyMem_RawStrdup(const char *str)
     * }
     */
    public static FunctionDescriptor _PyMem_RawStrdup$descriptor() {
        return _PyMem_RawStrdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_PyMem_RawStrdup(const char *str)
     * }
     */
    public static MethodHandle _PyMem_RawStrdup$handle() {
        return _PyMem_RawStrdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_PyMem_RawStrdup(const char *str)
     * }
     */
    public static MemorySegment _PyMem_RawStrdup$address() {
        return _PyMem_RawStrdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_PyMem_RawStrdup(const char *str)
     * }
     */
    public static MemorySegment _PyMem_RawStrdup(MemorySegment str) {
        var mh$ = _PyMem_RawStrdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyMem_RawStrdup", str);
            }
            return (MemorySegment)mh$.invokeExact(str);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyMem_Strdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyMem_Strdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_PyMem_Strdup(const char *str)
     * }
     */
    public static FunctionDescriptor _PyMem_Strdup$descriptor() {
        return _PyMem_Strdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_PyMem_Strdup(const char *str)
     * }
     */
    public static MethodHandle _PyMem_Strdup$handle() {
        return _PyMem_Strdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_PyMem_Strdup(const char *str)
     * }
     */
    public static MemorySegment _PyMem_Strdup$address() {
        return _PyMem_Strdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_PyMem_Strdup(const char *str)
     * }
     */
    public static MemorySegment _PyMem_Strdup(MemorySegment str) {
        var mh$ = _PyMem_Strdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyMem_Strdup", str);
            }
            return (MemorySegment)mh$.invokeExact(str);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyMem_RawWcsdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyMem_RawWcsdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_PyMem_RawWcsdup(const wchar_t *str)
     * }
     */
    public static FunctionDescriptor _PyMem_RawWcsdup$descriptor() {
        return _PyMem_RawWcsdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_PyMem_RawWcsdup(const wchar_t *str)
     * }
     */
    public static MethodHandle _PyMem_RawWcsdup$handle() {
        return _PyMem_RawWcsdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_PyMem_RawWcsdup(const wchar_t *str)
     * }
     */
    public static MemorySegment _PyMem_RawWcsdup$address() {
        return _PyMem_RawWcsdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_PyMem_RawWcsdup(const wchar_t *str)
     * }
     */
    public static MemorySegment _PyMem_RawWcsdup(MemorySegment str) {
        var mh$ = _PyMem_RawWcsdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyMem_RawWcsdup", str);
            }
            return (MemorySegment)mh$.invokeExact(str);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int PYMEM_DOMAIN_RAW = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PYMEM_DOMAIN_RAW = 0
     * }
     */
    public static int PYMEM_DOMAIN_RAW() {
        return PYMEM_DOMAIN_RAW;
    }
    private static final int PYMEM_DOMAIN_MEM = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PYMEM_DOMAIN_MEM = 1
     * }
     */
    public static int PYMEM_DOMAIN_MEM() {
        return PYMEM_DOMAIN_MEM;
    }
    private static final int PYMEM_DOMAIN_OBJ = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PYMEM_DOMAIN_OBJ = 2
     * }
     */
    public static int PYMEM_DOMAIN_OBJ() {
        return PYMEM_DOMAIN_OBJ;
    }
    private static final int PYMEM_ALLOCATOR_NOT_SET = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PYMEM_ALLOCATOR_NOT_SET = 0
     * }
     */
    public static int PYMEM_ALLOCATOR_NOT_SET() {
        return PYMEM_ALLOCATOR_NOT_SET;
    }
    private static final int PYMEM_ALLOCATOR_DEFAULT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PYMEM_ALLOCATOR_DEFAULT = 1
     * }
     */
    public static int PYMEM_ALLOCATOR_DEFAULT() {
        return PYMEM_ALLOCATOR_DEFAULT;
    }
    private static final int PYMEM_ALLOCATOR_DEBUG = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PYMEM_ALLOCATOR_DEBUG = 2
     * }
     */
    public static int PYMEM_ALLOCATOR_DEBUG() {
        return PYMEM_ALLOCATOR_DEBUG;
    }
    private static final int PYMEM_ALLOCATOR_MALLOC = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PYMEM_ALLOCATOR_MALLOC = 3
     * }
     */
    public static int PYMEM_ALLOCATOR_MALLOC() {
        return PYMEM_ALLOCATOR_MALLOC;
    }
    private static final int PYMEM_ALLOCATOR_MALLOC_DEBUG = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PYMEM_ALLOCATOR_MALLOC_DEBUG = 4
     * }
     */
    public static int PYMEM_ALLOCATOR_MALLOC_DEBUG() {
        return PYMEM_ALLOCATOR_MALLOC_DEBUG;
    }
    private static final int PYMEM_ALLOCATOR_PYMALLOC = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PYMEM_ALLOCATOR_PYMALLOC = 5
     * }
     */
    public static int PYMEM_ALLOCATOR_PYMALLOC() {
        return PYMEM_ALLOCATOR_PYMALLOC;
    }
    private static final int PYMEM_ALLOCATOR_PYMALLOC_DEBUG = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PYMEM_ALLOCATOR_PYMALLOC_DEBUG = 6
     * }
     */
    public static int PYMEM_ALLOCATOR_PYMALLOC_DEBUG() {
        return PYMEM_ALLOCATOR_PYMALLOC_DEBUG;
    }

    private static class PyMem_GetAllocator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMem_GetAllocator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyMem_GetAllocator(PyMemAllocatorDomain domain, PyMemAllocatorEx *allocator)
     * }
     */
    public static FunctionDescriptor PyMem_GetAllocator$descriptor() {
        return PyMem_GetAllocator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyMem_GetAllocator(PyMemAllocatorDomain domain, PyMemAllocatorEx *allocator)
     * }
     */
    public static MethodHandle PyMem_GetAllocator$handle() {
        return PyMem_GetAllocator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyMem_GetAllocator(PyMemAllocatorDomain domain, PyMemAllocatorEx *allocator)
     * }
     */
    public static MemorySegment PyMem_GetAllocator$address() {
        return PyMem_GetAllocator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyMem_GetAllocator(PyMemAllocatorDomain domain, PyMemAllocatorEx *allocator)
     * }
     */
    public static void PyMem_GetAllocator(int domain, MemorySegment allocator) {
        var mh$ = PyMem_GetAllocator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMem_GetAllocator", domain, allocator);
            }
            mh$.invokeExact(domain, allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMem_SetAllocator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMem_SetAllocator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyMem_SetAllocator(PyMemAllocatorDomain domain, PyMemAllocatorEx *allocator)
     * }
     */
    public static FunctionDescriptor PyMem_SetAllocator$descriptor() {
        return PyMem_SetAllocator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyMem_SetAllocator(PyMemAllocatorDomain domain, PyMemAllocatorEx *allocator)
     * }
     */
    public static MethodHandle PyMem_SetAllocator$handle() {
        return PyMem_SetAllocator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyMem_SetAllocator(PyMemAllocatorDomain domain, PyMemAllocatorEx *allocator)
     * }
     */
    public static MemorySegment PyMem_SetAllocator$address() {
        return PyMem_SetAllocator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyMem_SetAllocator(PyMemAllocatorDomain domain, PyMemAllocatorEx *allocator)
     * }
     */
    public static void PyMem_SetAllocator(int domain, MemorySegment allocator) {
        var mh$ = PyMem_SetAllocator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMem_SetAllocator", domain, allocator);
            }
            mh$.invokeExact(domain, allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyMem_SetupDebugHooks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyMem_SetupDebugHooks");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyMem_SetupDebugHooks()
     * }
     */
    public static FunctionDescriptor PyMem_SetupDebugHooks$descriptor() {
        return PyMem_SetupDebugHooks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyMem_SetupDebugHooks()
     * }
     */
    public static MethodHandle PyMem_SetupDebugHooks$handle() {
        return PyMem_SetupDebugHooks.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyMem_SetupDebugHooks()
     * }
     */
    public static MemorySegment PyMem_SetupDebugHooks$address() {
        return PyMem_SetupDebugHooks.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyMem_SetupDebugHooks()
     * }
     */
    public static void PyMem_SetupDebugHooks() {
        var mh$ = PyMem_SetupDebugHooks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyMem_SetupDebugHooks");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_CheckBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_CheckBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_CheckBuffer(PyObject *obj)
     * }
     */
    public static FunctionDescriptor PyObject_CheckBuffer$descriptor() {
        return PyObject_CheckBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_CheckBuffer(PyObject *obj)
     * }
     */
    public static MethodHandle PyObject_CheckBuffer$handle() {
        return PyObject_CheckBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_CheckBuffer(PyObject *obj)
     * }
     */
    public static MemorySegment PyObject_CheckBuffer$address() {
        return PyObject_CheckBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_CheckBuffer(PyObject *obj)
     * }
     */
    public static int PyObject_CheckBuffer(MemorySegment obj) {
        var mh$ = PyObject_CheckBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_CheckBuffer", obj);
            }
            return (int)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GetBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GetBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_GetBuffer(PyObject *obj, Py_buffer *view, int flags)
     * }
     */
    public static FunctionDescriptor PyObject_GetBuffer$descriptor() {
        return PyObject_GetBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_GetBuffer(PyObject *obj, Py_buffer *view, int flags)
     * }
     */
    public static MethodHandle PyObject_GetBuffer$handle() {
        return PyObject_GetBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_GetBuffer(PyObject *obj, Py_buffer *view, int flags)
     * }
     */
    public static MemorySegment PyObject_GetBuffer$address() {
        return PyObject_GetBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_GetBuffer(PyObject *obj, Py_buffer *view, int flags)
     * }
     */
    public static int PyObject_GetBuffer(MemorySegment obj, MemorySegment view, int flags) {
        var mh$ = PyObject_GetBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GetBuffer", obj, view, flags);
            }
            return (int)mh$.invokeExact(obj, view, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBuffer_GetPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBuffer_GetPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyBuffer_GetPointer(const Py_buffer *view, const Py_ssize_t *indices)
     * }
     */
    public static FunctionDescriptor PyBuffer_GetPointer$descriptor() {
        return PyBuffer_GetPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyBuffer_GetPointer(const Py_buffer *view, const Py_ssize_t *indices)
     * }
     */
    public static MethodHandle PyBuffer_GetPointer$handle() {
        return PyBuffer_GetPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyBuffer_GetPointer(const Py_buffer *view, const Py_ssize_t *indices)
     * }
     */
    public static MemorySegment PyBuffer_GetPointer$address() {
        return PyBuffer_GetPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyBuffer_GetPointer(const Py_buffer *view, const Py_ssize_t *indices)
     * }
     */
    public static MemorySegment PyBuffer_GetPointer(MemorySegment view, MemorySegment indices) {
        var mh$ = PyBuffer_GetPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBuffer_GetPointer", view, indices);
            }
            return (MemorySegment)mh$.invokeExact(view, indices);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBuffer_SizeFromFormat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBuffer_SizeFromFormat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyBuffer_SizeFromFormat(const char *format)
     * }
     */
    public static FunctionDescriptor PyBuffer_SizeFromFormat$descriptor() {
        return PyBuffer_SizeFromFormat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyBuffer_SizeFromFormat(const char *format)
     * }
     */
    public static MethodHandle PyBuffer_SizeFromFormat$handle() {
        return PyBuffer_SizeFromFormat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyBuffer_SizeFromFormat(const char *format)
     * }
     */
    public static MemorySegment PyBuffer_SizeFromFormat$address() {
        return PyBuffer_SizeFromFormat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyBuffer_SizeFromFormat(const char *format)
     * }
     */
    public static long PyBuffer_SizeFromFormat(MemorySegment format) {
        var mh$ = PyBuffer_SizeFromFormat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBuffer_SizeFromFormat", format);
            }
            return (long)mh$.invokeExact(format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBuffer_ToContiguous {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_CHAR
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBuffer_ToContiguous");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyBuffer_ToContiguous(void *buf, const Py_buffer *view, Py_ssize_t len, char order)
     * }
     */
    public static FunctionDescriptor PyBuffer_ToContiguous$descriptor() {
        return PyBuffer_ToContiguous.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyBuffer_ToContiguous(void *buf, const Py_buffer *view, Py_ssize_t len, char order)
     * }
     */
    public static MethodHandle PyBuffer_ToContiguous$handle() {
        return PyBuffer_ToContiguous.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyBuffer_ToContiguous(void *buf, const Py_buffer *view, Py_ssize_t len, char order)
     * }
     */
    public static MemorySegment PyBuffer_ToContiguous$address() {
        return PyBuffer_ToContiguous.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyBuffer_ToContiguous(void *buf, const Py_buffer *view, Py_ssize_t len, char order)
     * }
     */
    public static int PyBuffer_ToContiguous(MemorySegment buf, MemorySegment view, long len, byte order) {
        var mh$ = PyBuffer_ToContiguous.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBuffer_ToContiguous", buf, view, len, order);
            }
            return (int)mh$.invokeExact(buf, view, len, order);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBuffer_FromContiguous {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_CHAR
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBuffer_FromContiguous");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyBuffer_FromContiguous(const Py_buffer *view, const void *buf, Py_ssize_t len, char order)
     * }
     */
    public static FunctionDescriptor PyBuffer_FromContiguous$descriptor() {
        return PyBuffer_FromContiguous.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyBuffer_FromContiguous(const Py_buffer *view, const void *buf, Py_ssize_t len, char order)
     * }
     */
    public static MethodHandle PyBuffer_FromContiguous$handle() {
        return PyBuffer_FromContiguous.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyBuffer_FromContiguous(const Py_buffer *view, const void *buf, Py_ssize_t len, char order)
     * }
     */
    public static MemorySegment PyBuffer_FromContiguous$address() {
        return PyBuffer_FromContiguous.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyBuffer_FromContiguous(const Py_buffer *view, const void *buf, Py_ssize_t len, char order)
     * }
     */
    public static int PyBuffer_FromContiguous(MemorySegment view, MemorySegment buf, long len, byte order) {
        var mh$ = PyBuffer_FromContiguous.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBuffer_FromContiguous", view, buf, len, order);
            }
            return (int)mh$.invokeExact(view, buf, len, order);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_CopyData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_CopyData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_CopyData(PyObject *dest, PyObject *src)
     * }
     */
    public static FunctionDescriptor PyObject_CopyData$descriptor() {
        return PyObject_CopyData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_CopyData(PyObject *dest, PyObject *src)
     * }
     */
    public static MethodHandle PyObject_CopyData$handle() {
        return PyObject_CopyData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_CopyData(PyObject *dest, PyObject *src)
     * }
     */
    public static MemorySegment PyObject_CopyData$address() {
        return PyObject_CopyData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_CopyData(PyObject *dest, PyObject *src)
     * }
     */
    public static int PyObject_CopyData(MemorySegment dest, MemorySegment src) {
        var mh$ = PyObject_CopyData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_CopyData", dest, src);
            }
            return (int)mh$.invokeExact(dest, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBuffer_IsContiguous {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_CHAR
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBuffer_IsContiguous");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyBuffer_IsContiguous(const Py_buffer *view, char fort)
     * }
     */
    public static FunctionDescriptor PyBuffer_IsContiguous$descriptor() {
        return PyBuffer_IsContiguous.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyBuffer_IsContiguous(const Py_buffer *view, char fort)
     * }
     */
    public static MethodHandle PyBuffer_IsContiguous$handle() {
        return PyBuffer_IsContiguous.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyBuffer_IsContiguous(const Py_buffer *view, char fort)
     * }
     */
    public static MemorySegment PyBuffer_IsContiguous$address() {
        return PyBuffer_IsContiguous.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyBuffer_IsContiguous(const Py_buffer *view, char fort)
     * }
     */
    public static int PyBuffer_IsContiguous(MemorySegment view, byte fort) {
        var mh$ = PyBuffer_IsContiguous.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBuffer_IsContiguous", view, fort);
            }
            return (int)mh$.invokeExact(view, fort);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBuffer_FillContiguousStrides {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_CHAR
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBuffer_FillContiguousStrides");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyBuffer_FillContiguousStrides(int ndims, Py_ssize_t *shape, Py_ssize_t *strides, int itemsize, char fort)
     * }
     */
    public static FunctionDescriptor PyBuffer_FillContiguousStrides$descriptor() {
        return PyBuffer_FillContiguousStrides.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyBuffer_FillContiguousStrides(int ndims, Py_ssize_t *shape, Py_ssize_t *strides, int itemsize, char fort)
     * }
     */
    public static MethodHandle PyBuffer_FillContiguousStrides$handle() {
        return PyBuffer_FillContiguousStrides.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyBuffer_FillContiguousStrides(int ndims, Py_ssize_t *shape, Py_ssize_t *strides, int itemsize, char fort)
     * }
     */
    public static MemorySegment PyBuffer_FillContiguousStrides$address() {
        return PyBuffer_FillContiguousStrides.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyBuffer_FillContiguousStrides(int ndims, Py_ssize_t *shape, Py_ssize_t *strides, int itemsize, char fort)
     * }
     */
    public static void PyBuffer_FillContiguousStrides(int ndims, MemorySegment shape, MemorySegment strides, int itemsize, byte fort) {
        var mh$ = PyBuffer_FillContiguousStrides.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBuffer_FillContiguousStrides", ndims, shape, strides, itemsize, fort);
            }
            mh$.invokeExact(ndims, shape, strides, itemsize, fort);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBuffer_FillInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBuffer_FillInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyBuffer_FillInfo(Py_buffer *view, PyObject *o, void *buf, Py_ssize_t len, int readonly, int flags)
     * }
     */
    public static FunctionDescriptor PyBuffer_FillInfo$descriptor() {
        return PyBuffer_FillInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyBuffer_FillInfo(Py_buffer *view, PyObject *o, void *buf, Py_ssize_t len, int readonly, int flags)
     * }
     */
    public static MethodHandle PyBuffer_FillInfo$handle() {
        return PyBuffer_FillInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyBuffer_FillInfo(Py_buffer *view, PyObject *o, void *buf, Py_ssize_t len, int readonly, int flags)
     * }
     */
    public static MemorySegment PyBuffer_FillInfo$address() {
        return PyBuffer_FillInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyBuffer_FillInfo(Py_buffer *view, PyObject *o, void *buf, Py_ssize_t len, int readonly, int flags)
     * }
     */
    public static int PyBuffer_FillInfo(MemorySegment view, MemorySegment o, MemorySegment buf, long len, int readonly, int flags) {
        var mh$ = PyBuffer_FillInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBuffer_FillInfo", view, o, buf, len, readonly, flags);
            }
            return (int)mh$.invokeExact(view, o, buf, len, readonly, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBuffer_Release {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBuffer_Release");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyBuffer_Release(Py_buffer *view)
     * }
     */
    public static FunctionDescriptor PyBuffer_Release$descriptor() {
        return PyBuffer_Release.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyBuffer_Release(Py_buffer *view)
     * }
     */
    public static MethodHandle PyBuffer_Release$handle() {
        return PyBuffer_Release.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyBuffer_Release(Py_buffer *view)
     * }
     */
    public static MemorySegment PyBuffer_Release$address() {
        return PyBuffer_Release.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyBuffer_Release(Py_buffer *view)
     * }
     */
    public static void PyBuffer_Release(MemorySegment view) {
        var mh$ = PyBuffer_Release.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBuffer_Release", view);
            }
            mh$.invokeExact(view);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_Is {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_Is");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_Is(PyObject *x, PyObject *y)
     * }
     */
    public static FunctionDescriptor Py_Is$descriptor() {
        return Py_Is.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_Is(PyObject *x, PyObject *y)
     * }
     */
    public static MethodHandle Py_Is$handle() {
        return Py_Is.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_Is(PyObject *x, PyObject *y)
     * }
     */
    public static MemorySegment Py_Is$address() {
        return Py_Is.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_Is(PyObject *x, PyObject *y)
     * }
     */
    public static int Py_Is(MemorySegment x, MemorySegment y) {
        var mh$ = Py_Is.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_Is", x, y);
            }
            return (int)mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_FromSpec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_FromSpec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyType_FromSpec(PyType_Spec *)
     * }
     */
    public static FunctionDescriptor PyType_FromSpec$descriptor() {
        return PyType_FromSpec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyType_FromSpec(PyType_Spec *)
     * }
     */
    public static MethodHandle PyType_FromSpec$handle() {
        return PyType_FromSpec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyType_FromSpec(PyType_Spec *)
     * }
     */
    public static MemorySegment PyType_FromSpec$address() {
        return PyType_FromSpec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyType_FromSpec(PyType_Spec *)
     * }
     */
    public static MemorySegment PyType_FromSpec(MemorySegment x0) {
        var mh$ = PyType_FromSpec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_FromSpec", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_FromSpecWithBases {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_FromSpecWithBases");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyType_FromSpecWithBases(PyType_Spec *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyType_FromSpecWithBases$descriptor() {
        return PyType_FromSpecWithBases.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyType_FromSpecWithBases(PyType_Spec *, PyObject *)
     * }
     */
    public static MethodHandle PyType_FromSpecWithBases$handle() {
        return PyType_FromSpecWithBases.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyType_FromSpecWithBases(PyType_Spec *, PyObject *)
     * }
     */
    public static MemorySegment PyType_FromSpecWithBases$address() {
        return PyType_FromSpecWithBases.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyType_FromSpecWithBases(PyType_Spec *, PyObject *)
     * }
     */
    public static MemorySegment PyType_FromSpecWithBases(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyType_FromSpecWithBases.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_FromSpecWithBases", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_GetSlot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_GetSlot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyType_GetSlot(PyTypeObject *, int)
     * }
     */
    public static FunctionDescriptor PyType_GetSlot$descriptor() {
        return PyType_GetSlot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyType_GetSlot(PyTypeObject *, int)
     * }
     */
    public static MethodHandle PyType_GetSlot$handle() {
        return PyType_GetSlot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyType_GetSlot(PyTypeObject *, int)
     * }
     */
    public static MemorySegment PyType_GetSlot$address() {
        return PyType_GetSlot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyType_GetSlot(PyTypeObject *, int)
     * }
     */
    public static MemorySegment PyType_GetSlot(MemorySegment x0, int x1) {
        var mh$ = PyType_GetSlot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_GetSlot", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_FromModuleAndSpec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_FromModuleAndSpec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyType_FromModuleAndSpec(PyObject *, PyType_Spec *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyType_FromModuleAndSpec$descriptor() {
        return PyType_FromModuleAndSpec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyType_FromModuleAndSpec(PyObject *, PyType_Spec *, PyObject *)
     * }
     */
    public static MethodHandle PyType_FromModuleAndSpec$handle() {
        return PyType_FromModuleAndSpec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyType_FromModuleAndSpec(PyObject *, PyType_Spec *, PyObject *)
     * }
     */
    public static MemorySegment PyType_FromModuleAndSpec$address() {
        return PyType_FromModuleAndSpec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyType_FromModuleAndSpec(PyObject *, PyType_Spec *, PyObject *)
     * }
     */
    public static MemorySegment PyType_FromModuleAndSpec(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyType_FromModuleAndSpec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_FromModuleAndSpec", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_GetModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_GetModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyType_GetModule(PyTypeObject *)
     * }
     */
    public static FunctionDescriptor PyType_GetModule$descriptor() {
        return PyType_GetModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyType_GetModule(PyTypeObject *)
     * }
     */
    public static MethodHandle PyType_GetModule$handle() {
        return PyType_GetModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyType_GetModule(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_GetModule$address() {
        return PyType_GetModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyType_GetModule(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_GetModule(MemorySegment x0) {
        var mh$ = PyType_GetModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_GetModule", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_GetModuleState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_GetModuleState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyType_GetModuleState(PyTypeObject *)
     * }
     */
    public static FunctionDescriptor PyType_GetModuleState$descriptor() {
        return PyType_GetModuleState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyType_GetModuleState(PyTypeObject *)
     * }
     */
    public static MethodHandle PyType_GetModuleState$handle() {
        return PyType_GetModuleState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyType_GetModuleState(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_GetModuleState$address() {
        return PyType_GetModuleState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyType_GetModuleState(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_GetModuleState(MemorySegment x0) {
        var mh$ = PyType_GetModuleState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_GetModuleState", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_GetName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_GetName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyType_GetName(PyTypeObject *)
     * }
     */
    public static FunctionDescriptor PyType_GetName$descriptor() {
        return PyType_GetName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyType_GetName(PyTypeObject *)
     * }
     */
    public static MethodHandle PyType_GetName$handle() {
        return PyType_GetName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyType_GetName(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_GetName$address() {
        return PyType_GetName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyType_GetName(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_GetName(MemorySegment x0) {
        var mh$ = PyType_GetName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_GetName", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_GetQualName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_GetQualName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyType_GetQualName(PyTypeObject *)
     * }
     */
    public static FunctionDescriptor PyType_GetQualName$descriptor() {
        return PyType_GetQualName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyType_GetQualName(PyTypeObject *)
     * }
     */
    public static MethodHandle PyType_GetQualName$handle() {
        return PyType_GetQualName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyType_GetQualName(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_GetQualName$address() {
        return PyType_GetQualName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyType_GetQualName(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_GetQualName(MemorySegment x0) {
        var mh$ = PyType_GetQualName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_GetQualName", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_IsSubtype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_IsSubtype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyType_IsSubtype(PyTypeObject *, PyTypeObject *)
     * }
     */
    public static FunctionDescriptor PyType_IsSubtype$descriptor() {
        return PyType_IsSubtype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyType_IsSubtype(PyTypeObject *, PyTypeObject *)
     * }
     */
    public static MethodHandle PyType_IsSubtype$handle() {
        return PyType_IsSubtype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyType_IsSubtype(PyTypeObject *, PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_IsSubtype$address() {
        return PyType_IsSubtype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyType_IsSubtype(PyTypeObject *, PyTypeObject *)
     * }
     */
    public static int PyType_IsSubtype(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyType_IsSubtype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_IsSubtype", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyType_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyType_Type
     * }
     */
    public static GroupLayout PyType_Type$layout() {
        return PyType_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyType_Type
     * }
     */
    public static MemorySegment PyType_Type() {
        return PyType_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyType_Type
     * }
     */
    public static void PyType_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyType_Type$constants.SEGMENT, 0L, PyType_Type$constants.LAYOUT.byteSize());
    }

    private static class PyBaseObject_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyBaseObject_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBaseObject_Type
     * }
     */
    public static GroupLayout PyBaseObject_Type$layout() {
        return PyBaseObject_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBaseObject_Type
     * }
     */
    public static MemorySegment PyBaseObject_Type() {
        return PyBaseObject_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBaseObject_Type
     * }
     */
    public static void PyBaseObject_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyBaseObject_Type$constants.SEGMENT, 0L, PyBaseObject_Type$constants.LAYOUT.byteSize());
    }

    private static class PySuper_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PySuper_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySuper_Type
     * }
     */
    public static GroupLayout PySuper_Type$layout() {
        return PySuper_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySuper_Type
     * }
     */
    public static MemorySegment PySuper_Type() {
        return PySuper_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PySuper_Type
     * }
     */
    public static void PySuper_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PySuper_Type$constants.SEGMENT, 0L, PySuper_Type$constants.LAYOUT.byteSize());
    }

    private static class PyType_GetFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_GetFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long PyType_GetFlags(PyTypeObject *)
     * }
     */
    public static FunctionDescriptor PyType_GetFlags$descriptor() {
        return PyType_GetFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long PyType_GetFlags(PyTypeObject *)
     * }
     */
    public static MethodHandle PyType_GetFlags$handle() {
        return PyType_GetFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long PyType_GetFlags(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_GetFlags$address() {
        return PyType_GetFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long PyType_GetFlags(PyTypeObject *)
     * }
     */
    public static long PyType_GetFlags(MemorySegment x0) {
        var mh$ = PyType_GetFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_GetFlags", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_Ready {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_Ready");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyType_Ready(PyTypeObject *)
     * }
     */
    public static FunctionDescriptor PyType_Ready$descriptor() {
        return PyType_Ready.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyType_Ready(PyTypeObject *)
     * }
     */
    public static MethodHandle PyType_Ready$handle() {
        return PyType_Ready.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyType_Ready(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_Ready$address() {
        return PyType_Ready.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyType_Ready(PyTypeObject *)
     * }
     */
    public static int PyType_Ready(MemorySegment x0) {
        var mh$ = PyType_Ready.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_Ready", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_GenericAlloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_GenericAlloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyType_GenericAlloc(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyType_GenericAlloc$descriptor() {
        return PyType_GenericAlloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyType_GenericAlloc(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyType_GenericAlloc$handle() {
        return PyType_GenericAlloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyType_GenericAlloc(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyType_GenericAlloc$address() {
        return PyType_GenericAlloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyType_GenericAlloc(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyType_GenericAlloc(MemorySegment x0, long x1) {
        var mh$ = PyType_GenericAlloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_GenericAlloc", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_GenericNew {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_GenericNew");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyType_GenericNew(PyTypeObject *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyType_GenericNew$descriptor() {
        return PyType_GenericNew.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyType_GenericNew(PyTypeObject *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyType_GenericNew$handle() {
        return PyType_GenericNew.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyType_GenericNew(PyTypeObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyType_GenericNew$address() {
        return PyType_GenericNew.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyType_GenericNew(PyTypeObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyType_GenericNew(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyType_GenericNew.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_GenericNew", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_ClearCache {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_ClearCache");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int PyType_ClearCache()
     * }
     */
    public static FunctionDescriptor PyType_ClearCache$descriptor() {
        return PyType_ClearCache.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int PyType_ClearCache()
     * }
     */
    public static MethodHandle PyType_ClearCache$handle() {
        return PyType_ClearCache.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int PyType_ClearCache()
     * }
     */
    public static MemorySegment PyType_ClearCache$address() {
        return PyType_ClearCache.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int PyType_ClearCache()
     * }
     */
    public static int PyType_ClearCache() {
        var mh$ = PyType_ClearCache.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_ClearCache");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_Modified {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_Modified");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyType_Modified(PyTypeObject *)
     * }
     */
    public static FunctionDescriptor PyType_Modified$descriptor() {
        return PyType_Modified.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyType_Modified(PyTypeObject *)
     * }
     */
    public static MethodHandle PyType_Modified$handle() {
        return PyType_Modified.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyType_Modified(PyTypeObject *)
     * }
     */
    public static MemorySegment PyType_Modified$address() {
        return PyType_Modified.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyType_Modified(PyTypeObject *)
     * }
     */
    public static void PyType_Modified(MemorySegment x0) {
        var mh$ = PyType_Modified.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_Modified", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Repr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Repr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_Repr(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_Repr$descriptor() {
        return PyObject_Repr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_Repr(PyObject *)
     * }
     */
    public static MethodHandle PyObject_Repr$handle() {
        return PyObject_Repr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_Repr(PyObject *)
     * }
     */
    public static MemorySegment PyObject_Repr$address() {
        return PyObject_Repr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_Repr(PyObject *)
     * }
     */
    public static MemorySegment PyObject_Repr(MemorySegment x0) {
        var mh$ = PyObject_Repr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Repr", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Str {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Str");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_Str(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_Str$descriptor() {
        return PyObject_Str.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_Str(PyObject *)
     * }
     */
    public static MethodHandle PyObject_Str$handle() {
        return PyObject_Str.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_Str(PyObject *)
     * }
     */
    public static MemorySegment PyObject_Str$address() {
        return PyObject_Str.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_Str(PyObject *)
     * }
     */
    public static MemorySegment PyObject_Str(MemorySegment x0) {
        var mh$ = PyObject_Str.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Str", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_ASCII {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_ASCII");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_ASCII(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_ASCII$descriptor() {
        return PyObject_ASCII.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_ASCII(PyObject *)
     * }
     */
    public static MethodHandle PyObject_ASCII$handle() {
        return PyObject_ASCII.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_ASCII(PyObject *)
     * }
     */
    public static MemorySegment PyObject_ASCII$address() {
        return PyObject_ASCII.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_ASCII(PyObject *)
     * }
     */
    public static MemorySegment PyObject_ASCII(MemorySegment x0) {
        var mh$ = PyObject_ASCII.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_ASCII", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Bytes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Bytes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_Bytes(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_Bytes$descriptor() {
        return PyObject_Bytes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_Bytes(PyObject *)
     * }
     */
    public static MethodHandle PyObject_Bytes$handle() {
        return PyObject_Bytes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_Bytes(PyObject *)
     * }
     */
    public static MemorySegment PyObject_Bytes$address() {
        return PyObject_Bytes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_Bytes(PyObject *)
     * }
     */
    public static MemorySegment PyObject_Bytes(MemorySegment x0) {
        var mh$ = PyObject_Bytes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Bytes", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_RichCompare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_RichCompare");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_RichCompare(PyObject *, PyObject *, int)
     * }
     */
    public static FunctionDescriptor PyObject_RichCompare$descriptor() {
        return PyObject_RichCompare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_RichCompare(PyObject *, PyObject *, int)
     * }
     */
    public static MethodHandle PyObject_RichCompare$handle() {
        return PyObject_RichCompare.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_RichCompare(PyObject *, PyObject *, int)
     * }
     */
    public static MemorySegment PyObject_RichCompare$address() {
        return PyObject_RichCompare.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_RichCompare(PyObject *, PyObject *, int)
     * }
     */
    public static MemorySegment PyObject_RichCompare(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = PyObject_RichCompare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_RichCompare", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_RichCompareBool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_RichCompareBool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_RichCompareBool(PyObject *, PyObject *, int)
     * }
     */
    public static FunctionDescriptor PyObject_RichCompareBool$descriptor() {
        return PyObject_RichCompareBool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_RichCompareBool(PyObject *, PyObject *, int)
     * }
     */
    public static MethodHandle PyObject_RichCompareBool$handle() {
        return PyObject_RichCompareBool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_RichCompareBool(PyObject *, PyObject *, int)
     * }
     */
    public static MemorySegment PyObject_RichCompareBool$address() {
        return PyObject_RichCompareBool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_RichCompareBool(PyObject *, PyObject *, int)
     * }
     */
    public static int PyObject_RichCompareBool(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = PyObject_RichCompareBool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_RichCompareBool", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GetAttrString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GetAttrString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetAttrString(PyObject *, const char *)
     * }
     */
    public static FunctionDescriptor PyObject_GetAttrString$descriptor() {
        return PyObject_GetAttrString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetAttrString(PyObject *, const char *)
     * }
     */
    public static MethodHandle PyObject_GetAttrString$handle() {
        return PyObject_GetAttrString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetAttrString(PyObject *, const char *)
     * }
     */
    public static MemorySegment PyObject_GetAttrString$address() {
        return PyObject_GetAttrString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_GetAttrString(PyObject *, const char *)
     * }
     */
    public static MemorySegment PyObject_GetAttrString(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyObject_GetAttrString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GetAttrString", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_SetAttrString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_SetAttrString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_SetAttrString(PyObject *, const char *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_SetAttrString$descriptor() {
        return PyObject_SetAttrString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_SetAttrString(PyObject *, const char *, PyObject *)
     * }
     */
    public static MethodHandle PyObject_SetAttrString$handle() {
        return PyObject_SetAttrString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_SetAttrString(PyObject *, const char *, PyObject *)
     * }
     */
    public static MemorySegment PyObject_SetAttrString$address() {
        return PyObject_SetAttrString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_SetAttrString(PyObject *, const char *, PyObject *)
     * }
     */
    public static int PyObject_SetAttrString(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyObject_SetAttrString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_SetAttrString", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_HasAttrString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_HasAttrString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_HasAttrString(PyObject *, const char *)
     * }
     */
    public static FunctionDescriptor PyObject_HasAttrString$descriptor() {
        return PyObject_HasAttrString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_HasAttrString(PyObject *, const char *)
     * }
     */
    public static MethodHandle PyObject_HasAttrString$handle() {
        return PyObject_HasAttrString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_HasAttrString(PyObject *, const char *)
     * }
     */
    public static MemorySegment PyObject_HasAttrString$address() {
        return PyObject_HasAttrString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_HasAttrString(PyObject *, const char *)
     * }
     */
    public static int PyObject_HasAttrString(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyObject_HasAttrString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_HasAttrString", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GetAttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GetAttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetAttr(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_GetAttr$descriptor() {
        return PyObject_GetAttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetAttr(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyObject_GetAttr$handle() {
        return PyObject_GetAttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_GetAttr(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyObject_GetAttr$address() {
        return PyObject_GetAttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_GetAttr(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyObject_GetAttr(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyObject_GetAttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GetAttr", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_SetAttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_SetAttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_SetAttr(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_SetAttr$descriptor() {
        return PyObject_SetAttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_SetAttr(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyObject_SetAttr$handle() {
        return PyObject_SetAttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_SetAttr(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyObject_SetAttr$address() {
        return PyObject_SetAttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_SetAttr(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static int PyObject_SetAttr(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyObject_SetAttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_SetAttr", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_HasAttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_HasAttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_HasAttr(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_HasAttr$descriptor() {
        return PyObject_HasAttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_HasAttr(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyObject_HasAttr$handle() {
        return PyObject_HasAttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_HasAttr(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyObject_HasAttr$address() {
        return PyObject_HasAttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_HasAttr(PyObject *, PyObject *)
     * }
     */
    public static int PyObject_HasAttr(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyObject_HasAttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_HasAttr", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_SelfIter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_SelfIter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_SelfIter(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_SelfIter$descriptor() {
        return PyObject_SelfIter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_SelfIter(PyObject *)
     * }
     */
    public static MethodHandle PyObject_SelfIter$handle() {
        return PyObject_SelfIter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_SelfIter(PyObject *)
     * }
     */
    public static MemorySegment PyObject_SelfIter$address() {
        return PyObject_SelfIter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_SelfIter(PyObject *)
     * }
     */
    public static MemorySegment PyObject_SelfIter(MemorySegment x0) {
        var mh$ = PyObject_SelfIter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_SelfIter", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GenericGetAttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GenericGetAttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_GenericGetAttr(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_GenericGetAttr$descriptor() {
        return PyObject_GenericGetAttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_GenericGetAttr(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyObject_GenericGetAttr$handle() {
        return PyObject_GenericGetAttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_GenericGetAttr(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyObject_GenericGetAttr$address() {
        return PyObject_GenericGetAttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_GenericGetAttr(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyObject_GenericGetAttr(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyObject_GenericGetAttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GenericGetAttr", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GenericSetAttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GenericSetAttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_GenericSetAttr(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_GenericSetAttr$descriptor() {
        return PyObject_GenericSetAttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_GenericSetAttr(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyObject_GenericSetAttr$handle() {
        return PyObject_GenericSetAttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_GenericSetAttr(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyObject_GenericSetAttr$address() {
        return PyObject_GenericSetAttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_GenericSetAttr(PyObject *, PyObject *, PyObject *)
     * }
     */
    public static int PyObject_GenericSetAttr(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyObject_GenericSetAttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GenericSetAttr", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GenericSetDict {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GenericSetDict");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_GenericSetDict(PyObject *, PyObject *, void *)
     * }
     */
    public static FunctionDescriptor PyObject_GenericSetDict$descriptor() {
        return PyObject_GenericSetDict.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_GenericSetDict(PyObject *, PyObject *, void *)
     * }
     */
    public static MethodHandle PyObject_GenericSetDict$handle() {
        return PyObject_GenericSetDict.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_GenericSetDict(PyObject *, PyObject *, void *)
     * }
     */
    public static MemorySegment PyObject_GenericSetDict$address() {
        return PyObject_GenericSetDict.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_GenericSetDict(PyObject *, PyObject *, void *)
     * }
     */
    public static int PyObject_GenericSetDict(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = PyObject_GenericSetDict.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GenericSetDict", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Hash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Hash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_hash_t PyObject_Hash(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_Hash$descriptor() {
        return PyObject_Hash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_hash_t PyObject_Hash(PyObject *)
     * }
     */
    public static MethodHandle PyObject_Hash$handle() {
        return PyObject_Hash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_hash_t PyObject_Hash(PyObject *)
     * }
     */
    public static MemorySegment PyObject_Hash$address() {
        return PyObject_Hash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_hash_t PyObject_Hash(PyObject *)
     * }
     */
    public static long PyObject_Hash(MemorySegment x0) {
        var mh$ = PyObject_Hash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Hash", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_HashNotImplemented {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_HashNotImplemented");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_hash_t PyObject_HashNotImplemented(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_HashNotImplemented$descriptor() {
        return PyObject_HashNotImplemented.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_hash_t PyObject_HashNotImplemented(PyObject *)
     * }
     */
    public static MethodHandle PyObject_HashNotImplemented$handle() {
        return PyObject_HashNotImplemented.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_hash_t PyObject_HashNotImplemented(PyObject *)
     * }
     */
    public static MemorySegment PyObject_HashNotImplemented$address() {
        return PyObject_HashNotImplemented.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_hash_t PyObject_HashNotImplemented(PyObject *)
     * }
     */
    public static long PyObject_HashNotImplemented(MemorySegment x0) {
        var mh$ = PyObject_HashNotImplemented.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_HashNotImplemented", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_IsTrue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_IsTrue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_IsTrue(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_IsTrue$descriptor() {
        return PyObject_IsTrue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_IsTrue(PyObject *)
     * }
     */
    public static MethodHandle PyObject_IsTrue$handle() {
        return PyObject_IsTrue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_IsTrue(PyObject *)
     * }
     */
    public static MemorySegment PyObject_IsTrue$address() {
        return PyObject_IsTrue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_IsTrue(PyObject *)
     * }
     */
    public static int PyObject_IsTrue(MemorySegment x0) {
        var mh$ = PyObject_IsTrue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_IsTrue", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Not {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Not");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_Not(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_Not$descriptor() {
        return PyObject_Not.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_Not(PyObject *)
     * }
     */
    public static MethodHandle PyObject_Not$handle() {
        return PyObject_Not.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_Not(PyObject *)
     * }
     */
    public static MemorySegment PyObject_Not$address() {
        return PyObject_Not.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_Not(PyObject *)
     * }
     */
    public static int PyObject_Not(MemorySegment x0) {
        var mh$ = PyObject_Not.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Not", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyCallable_Check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyCallable_Check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyCallable_Check(PyObject *)
     * }
     */
    public static FunctionDescriptor PyCallable_Check$descriptor() {
        return PyCallable_Check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyCallable_Check(PyObject *)
     * }
     */
    public static MethodHandle PyCallable_Check$handle() {
        return PyCallable_Check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyCallable_Check(PyObject *)
     * }
     */
    public static MemorySegment PyCallable_Check$address() {
        return PyCallable_Check.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyCallable_Check(PyObject *)
     * }
     */
    public static int PyCallable_Check(MemorySegment x0) {
        var mh$ = PyCallable_Check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyCallable_Check", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_ClearWeakRefs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_ClearWeakRefs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyObject_ClearWeakRefs(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_ClearWeakRefs$descriptor() {
        return PyObject_ClearWeakRefs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyObject_ClearWeakRefs(PyObject *)
     * }
     */
    public static MethodHandle PyObject_ClearWeakRefs$handle() {
        return PyObject_ClearWeakRefs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyObject_ClearWeakRefs(PyObject *)
     * }
     */
    public static MemorySegment PyObject_ClearWeakRefs$address() {
        return PyObject_ClearWeakRefs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyObject_ClearWeakRefs(PyObject *)
     * }
     */
    public static void PyObject_ClearWeakRefs(MemorySegment x0) {
        var mh$ = PyObject_ClearWeakRefs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_ClearWeakRefs", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Dir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Dir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_Dir(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_Dir$descriptor() {
        return PyObject_Dir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_Dir(PyObject *)
     * }
     */
    public static MethodHandle PyObject_Dir$handle() {
        return PyObject_Dir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_Dir(PyObject *)
     * }
     */
    public static MemorySegment PyObject_Dir$address() {
        return PyObject_Dir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_Dir(PyObject *)
     * }
     */
    public static MemorySegment PyObject_Dir(MemorySegment x0) {
        var mh$ = PyObject_Dir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Dir", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_GetState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_GetState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyObject_GetState(PyObject *)
     * }
     */
    public static FunctionDescriptor _PyObject_GetState$descriptor() {
        return _PyObject_GetState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyObject_GetState(PyObject *)
     * }
     */
    public static MethodHandle _PyObject_GetState$handle() {
        return _PyObject_GetState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyObject_GetState(PyObject *)
     * }
     */
    public static MemorySegment _PyObject_GetState$address() {
        return _PyObject_GetState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyObject_GetState(PyObject *)
     * }
     */
    public static MemorySegment _PyObject_GetState(MemorySegment x0) {
        var mh$ = _PyObject_GetState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_GetState", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_ReprEnter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_ReprEnter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_ReprEnter(PyObject *)
     * }
     */
    public static FunctionDescriptor Py_ReprEnter$descriptor() {
        return Py_ReprEnter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_ReprEnter(PyObject *)
     * }
     */
    public static MethodHandle Py_ReprEnter$handle() {
        return Py_ReprEnter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_ReprEnter(PyObject *)
     * }
     */
    public static MemorySegment Py_ReprEnter$address() {
        return Py_ReprEnter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_ReprEnter(PyObject *)
     * }
     */
    public static int Py_ReprEnter(MemorySegment x0) {
        var mh$ = Py_ReprEnter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_ReprEnter", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_ReprLeave {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_ReprLeave");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_ReprLeave(PyObject *)
     * }
     */
    public static FunctionDescriptor Py_ReprLeave$descriptor() {
        return Py_ReprLeave.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_ReprLeave(PyObject *)
     * }
     */
    public static MethodHandle Py_ReprLeave$handle() {
        return Py_ReprLeave.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_ReprLeave(PyObject *)
     * }
     */
    public static MemorySegment Py_ReprLeave$address() {
        return Py_ReprLeave.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_ReprLeave(PyObject *)
     * }
     */
    public static void Py_ReprLeave(MemorySegment x0) {
        var mh$ = Py_ReprLeave.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_ReprLeave", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_Dealloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_Dealloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _Py_Dealloc(PyObject *)
     * }
     */
    public static FunctionDescriptor _Py_Dealloc$descriptor() {
        return _Py_Dealloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _Py_Dealloc(PyObject *)
     * }
     */
    public static MethodHandle _Py_Dealloc$handle() {
        return _Py_Dealloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _Py_Dealloc(PyObject *)
     * }
     */
    public static MemorySegment _Py_Dealloc$address() {
        return _Py_Dealloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _Py_Dealloc(PyObject *)
     * }
     */
    public static void _Py_Dealloc(MemorySegment x0) {
        var mh$ = _Py_Dealloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_Dealloc", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_IncRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_IncRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_IncRef(PyObject *)
     * }
     */
    public static FunctionDescriptor Py_IncRef$descriptor() {
        return Py_IncRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_IncRef(PyObject *)
     * }
     */
    public static MethodHandle Py_IncRef$handle() {
        return Py_IncRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_IncRef(PyObject *)
     * }
     */
    public static MemorySegment Py_IncRef$address() {
        return Py_IncRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_IncRef(PyObject *)
     * }
     */
    public static void Py_IncRef(MemorySegment x0) {
        var mh$ = Py_IncRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_IncRef", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_DecRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_DecRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Py_DecRef(PyObject *)
     * }
     */
    public static FunctionDescriptor Py_DecRef$descriptor() {
        return Py_DecRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Py_DecRef(PyObject *)
     * }
     */
    public static MethodHandle Py_DecRef$handle() {
        return Py_DecRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Py_DecRef(PyObject *)
     * }
     */
    public static MemorySegment Py_DecRef$address() {
        return Py_DecRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Py_DecRef(PyObject *)
     * }
     */
    public static void Py_DecRef(MemorySegment x0) {
        var mh$ = Py_DecRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_DecRef", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_IncRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_IncRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _Py_IncRef(PyObject *)
     * }
     */
    public static FunctionDescriptor _Py_IncRef$descriptor() {
        return _Py_IncRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _Py_IncRef(PyObject *)
     * }
     */
    public static MethodHandle _Py_IncRef$handle() {
        return _Py_IncRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _Py_IncRef(PyObject *)
     * }
     */
    public static MemorySegment _Py_IncRef$address() {
        return _Py_IncRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _Py_IncRef(PyObject *)
     * }
     */
    public static void _Py_IncRef(MemorySegment x0) {
        var mh$ = _Py_IncRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_IncRef", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_DecRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_DecRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _Py_DecRef(PyObject *)
     * }
     */
    public static FunctionDescriptor _Py_DecRef$descriptor() {
        return _Py_DecRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _Py_DecRef(PyObject *)
     * }
     */
    public static MethodHandle _Py_DecRef$handle() {
        return _Py_DecRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _Py_DecRef(PyObject *)
     * }
     */
    public static MemorySegment _Py_DecRef$address() {
        return _Py_DecRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _Py_DecRef(PyObject *)
     * }
     */
    public static void _Py_DecRef(MemorySegment x0) {
        var mh$ = _Py_DecRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_DecRef", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_NewRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_NewRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *Py_NewRef(PyObject *obj)
     * }
     */
    public static FunctionDescriptor Py_NewRef$descriptor() {
        return Py_NewRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *Py_NewRef(PyObject *obj)
     * }
     */
    public static MethodHandle Py_NewRef$handle() {
        return Py_NewRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *Py_NewRef(PyObject *obj)
     * }
     */
    public static MemorySegment Py_NewRef$address() {
        return Py_NewRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *Py_NewRef(PyObject *obj)
     * }
     */
    public static MemorySegment Py_NewRef(MemorySegment obj) {
        var mh$ = Py_NewRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_NewRef", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_XNewRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_XNewRef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *Py_XNewRef(PyObject *obj)
     * }
     */
    public static FunctionDescriptor Py_XNewRef$descriptor() {
        return Py_XNewRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *Py_XNewRef(PyObject *obj)
     * }
     */
    public static MethodHandle Py_XNewRef$handle() {
        return Py_XNewRef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *Py_XNewRef(PyObject *obj)
     * }
     */
    public static MemorySegment Py_XNewRef$address() {
        return Py_XNewRef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *Py_XNewRef(PyObject *obj)
     * }
     */
    public static MemorySegment Py_XNewRef(MemorySegment obj) {
        var mh$ = Py_XNewRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_XNewRef", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_NoneStruct$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_Py_NoneStruct").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject _Py_NoneStruct
     * }
     */
    public static GroupLayout _Py_NoneStruct$layout() {
        return _Py_NoneStruct$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject _Py_NoneStruct
     * }
     */
    public static MemorySegment _Py_NoneStruct() {
        return _Py_NoneStruct$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject _Py_NoneStruct
     * }
     */
    public static void _Py_NoneStruct(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Py_NoneStruct$constants.SEGMENT, 0L, _Py_NoneStruct$constants.LAYOUT.byteSize());
    }

    private static class Py_IsNone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_IsNone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_IsNone(PyObject *x)
     * }
     */
    public static FunctionDescriptor Py_IsNone$descriptor() {
        return Py_IsNone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_IsNone(PyObject *x)
     * }
     */
    public static MethodHandle Py_IsNone$handle() {
        return Py_IsNone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_IsNone(PyObject *x)
     * }
     */
    public static MemorySegment Py_IsNone$address() {
        return Py_IsNone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_IsNone(PyObject *x)
     * }
     */
    public static int Py_IsNone(MemorySegment x) {
        var mh$ = Py_IsNone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_IsNone", x);
            }
            return (int)mh$.invokeExact(x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_NotImplementedStruct$constants {
        public static final GroupLayout LAYOUT = _object.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_Py_NotImplementedStruct").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyObject _Py_NotImplementedStruct
     * }
     */
    public static GroupLayout _Py_NotImplementedStruct$layout() {
        return _Py_NotImplementedStruct$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyObject _Py_NotImplementedStruct
     * }
     */
    public static MemorySegment _Py_NotImplementedStruct() {
        return _Py_NotImplementedStruct$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyObject _Py_NotImplementedStruct
     * }
     */
    public static void _Py_NotImplementedStruct(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Py_NotImplementedStruct$constants.SEGMENT, 0L, _Py_NotImplementedStruct$constants.LAYOUT.byteSize());
    }
    private static final int PYGEN_RETURN = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PYGEN_RETURN = 0
     * }
     */
    public static int PYGEN_RETURN() {
        return PYGEN_RETURN;
    }
    private static final int PYGEN_ERROR = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PYGEN_ERROR = -1
     * }
     */
    public static int PYGEN_ERROR() {
        return PYGEN_ERROR;
    }
    private static final int PYGEN_NEXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PYGEN_NEXT = 1
     * }
     */
    public static int PYGEN_NEXT() {
        return PYGEN_NEXT;
    }

    private static class _Py_NewReference {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_NewReference");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _Py_NewReference(PyObject *op)
     * }
     */
    public static FunctionDescriptor _Py_NewReference$descriptor() {
        return _Py_NewReference.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _Py_NewReference(PyObject *op)
     * }
     */
    public static MethodHandle _Py_NewReference$handle() {
        return _Py_NewReference.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _Py_NewReference(PyObject *op)
     * }
     */
    public static MemorySegment _Py_NewReference$address() {
        return _Py_NewReference.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _Py_NewReference(PyObject *op)
     * }
     */
    public static void _Py_NewReference(MemorySegment op) {
        var mh$ = _Py_NewReference.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_NewReference", op);
            }
            mh$.invokeExact(op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef Py_ssize_t printfunc
     * }
     */
    public static final OfLong printfunc = Python_h.C_LONG;

    private static class _PyType_Name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyType_Name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *_PyType_Name(PyTypeObject *)
     * }
     */
    public static FunctionDescriptor _PyType_Name$descriptor() {
        return _PyType_Name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *_PyType_Name(PyTypeObject *)
     * }
     */
    public static MethodHandle _PyType_Name$handle() {
        return _PyType_Name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *_PyType_Name(PyTypeObject *)
     * }
     */
    public static MemorySegment _PyType_Name$address() {
        return _PyType_Name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *_PyType_Name(PyTypeObject *)
     * }
     */
    public static MemorySegment _PyType_Name(MemorySegment x0) {
        var mh$ = _PyType_Name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyType_Name", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyType_Lookup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyType_Lookup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyType_Lookup(PyTypeObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor _PyType_Lookup$descriptor() {
        return _PyType_Lookup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyType_Lookup(PyTypeObject *, PyObject *)
     * }
     */
    public static MethodHandle _PyType_Lookup$handle() {
        return _PyType_Lookup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyType_Lookup(PyTypeObject *, PyObject *)
     * }
     */
    public static MemorySegment _PyType_Lookup$address() {
        return _PyType_Lookup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyType_Lookup(PyTypeObject *, PyObject *)
     * }
     */
    public static MemorySegment _PyType_Lookup(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyType_Lookup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyType_Lookup", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyType_LookupId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyType_LookupId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyType_LookupId(PyTypeObject *, _Py_Identifier *)
     * }
     */
    public static FunctionDescriptor _PyType_LookupId$descriptor() {
        return _PyType_LookupId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyType_LookupId(PyTypeObject *, _Py_Identifier *)
     * }
     */
    public static MethodHandle _PyType_LookupId$handle() {
        return _PyType_LookupId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyType_LookupId(PyTypeObject *, _Py_Identifier *)
     * }
     */
    public static MemorySegment _PyType_LookupId$address() {
        return _PyType_LookupId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyType_LookupId(PyTypeObject *, _Py_Identifier *)
     * }
     */
    public static MemorySegment _PyType_LookupId(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyType_LookupId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyType_LookupId", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_LookupSpecialId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_LookupSpecialId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyObject_LookupSpecialId(PyObject *, _Py_Identifier *)
     * }
     */
    public static FunctionDescriptor _PyObject_LookupSpecialId$descriptor() {
        return _PyObject_LookupSpecialId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyObject_LookupSpecialId(PyObject *, _Py_Identifier *)
     * }
     */
    public static MethodHandle _PyObject_LookupSpecialId$handle() {
        return _PyObject_LookupSpecialId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyObject_LookupSpecialId(PyObject *, _Py_Identifier *)
     * }
     */
    public static MemorySegment _PyObject_LookupSpecialId$address() {
        return _PyObject_LookupSpecialId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyObject_LookupSpecialId(PyObject *, _Py_Identifier *)
     * }
     */
    public static MemorySegment _PyObject_LookupSpecialId(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyObject_LookupSpecialId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_LookupSpecialId", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyType_CalculateMetaclass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyType_CalculateMetaclass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyTypeObject *_PyType_CalculateMetaclass(PyTypeObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor _PyType_CalculateMetaclass$descriptor() {
        return _PyType_CalculateMetaclass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyTypeObject *_PyType_CalculateMetaclass(PyTypeObject *, PyObject *)
     * }
     */
    public static MethodHandle _PyType_CalculateMetaclass$handle() {
        return _PyType_CalculateMetaclass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyTypeObject *_PyType_CalculateMetaclass(PyTypeObject *, PyObject *)
     * }
     */
    public static MemorySegment _PyType_CalculateMetaclass$address() {
        return _PyType_CalculateMetaclass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyTypeObject *_PyType_CalculateMetaclass(PyTypeObject *, PyObject *)
     * }
     */
    public static MemorySegment _PyType_CalculateMetaclass(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyType_CalculateMetaclass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyType_CalculateMetaclass", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyType_GetDocFromInternalDoc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyType_GetDocFromInternalDoc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyType_GetDocFromInternalDoc(const char *, const char *)
     * }
     */
    public static FunctionDescriptor _PyType_GetDocFromInternalDoc$descriptor() {
        return _PyType_GetDocFromInternalDoc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyType_GetDocFromInternalDoc(const char *, const char *)
     * }
     */
    public static MethodHandle _PyType_GetDocFromInternalDoc$handle() {
        return _PyType_GetDocFromInternalDoc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyType_GetDocFromInternalDoc(const char *, const char *)
     * }
     */
    public static MemorySegment _PyType_GetDocFromInternalDoc$address() {
        return _PyType_GetDocFromInternalDoc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyType_GetDocFromInternalDoc(const char *, const char *)
     * }
     */
    public static MemorySegment _PyType_GetDocFromInternalDoc(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyType_GetDocFromInternalDoc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyType_GetDocFromInternalDoc", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyType_GetTextSignatureFromInternalDoc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyType_GetTextSignatureFromInternalDoc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyType_GetTextSignatureFromInternalDoc(const char *, const char *)
     * }
     */
    public static FunctionDescriptor _PyType_GetTextSignatureFromInternalDoc$descriptor() {
        return _PyType_GetTextSignatureFromInternalDoc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyType_GetTextSignatureFromInternalDoc(const char *, const char *)
     * }
     */
    public static MethodHandle _PyType_GetTextSignatureFromInternalDoc$handle() {
        return _PyType_GetTextSignatureFromInternalDoc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyType_GetTextSignatureFromInternalDoc(const char *, const char *)
     * }
     */
    public static MemorySegment _PyType_GetTextSignatureFromInternalDoc$address() {
        return _PyType_GetTextSignatureFromInternalDoc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyType_GetTextSignatureFromInternalDoc(const char *, const char *)
     * }
     */
    public static MemorySegment _PyType_GetTextSignatureFromInternalDoc(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyType_GetTextSignatureFromInternalDoc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyType_GetTextSignatureFromInternalDoc", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_GetModuleByDef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_GetModuleByDef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyType_GetModuleByDef(PyTypeObject *, PyModuleDef *)
     * }
     */
    public static FunctionDescriptor PyType_GetModuleByDef$descriptor() {
        return PyType_GetModuleByDef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyType_GetModuleByDef(PyTypeObject *, PyModuleDef *)
     * }
     */
    public static MethodHandle PyType_GetModuleByDef$handle() {
        return PyType_GetModuleByDef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyType_GetModuleByDef(PyTypeObject *, PyModuleDef *)
     * }
     */
    public static MemorySegment PyType_GetModuleByDef$address() {
        return PyType_GetModuleByDef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyType_GetModuleByDef(PyTypeObject *, PyModuleDef *)
     * }
     */
    public static MemorySegment PyType_GetModuleByDef(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyType_GetModuleByDef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_GetModuleByDef", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_Print(PyObject *, FILE *, int)
     * }
     */
    public static FunctionDescriptor PyObject_Print$descriptor() {
        return PyObject_Print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_Print(PyObject *, FILE *, int)
     * }
     */
    public static MethodHandle PyObject_Print$handle() {
        return PyObject_Print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_Print(PyObject *, FILE *, int)
     * }
     */
    public static MemorySegment PyObject_Print$address() {
        return PyObject_Print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_Print(PyObject *, FILE *, int)
     * }
     */
    public static int PyObject_Print(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = PyObject_Print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Print", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_BreakPoint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_BreakPoint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _Py_BreakPoint()
     * }
     */
    public static FunctionDescriptor _Py_BreakPoint$descriptor() {
        return _Py_BreakPoint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _Py_BreakPoint()
     * }
     */
    public static MethodHandle _Py_BreakPoint$handle() {
        return _Py_BreakPoint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _Py_BreakPoint()
     * }
     */
    public static MemorySegment _Py_BreakPoint$address() {
        return _Py_BreakPoint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _Py_BreakPoint()
     * }
     */
    public static void _Py_BreakPoint() {
        var mh$ = _Py_BreakPoint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_BreakPoint");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_Dump {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_Dump");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyObject_Dump(PyObject *)
     * }
     */
    public static FunctionDescriptor _PyObject_Dump$descriptor() {
        return _PyObject_Dump.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyObject_Dump(PyObject *)
     * }
     */
    public static MethodHandle _PyObject_Dump$handle() {
        return _PyObject_Dump.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyObject_Dump(PyObject *)
     * }
     */
    public static MemorySegment _PyObject_Dump$address() {
        return _PyObject_Dump.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyObject_Dump(PyObject *)
     * }
     */
    public static void _PyObject_Dump(MemorySegment x0) {
        var mh$ = _PyObject_Dump.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_Dump", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_IsFreed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_IsFreed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyObject_IsFreed(PyObject *)
     * }
     */
    public static FunctionDescriptor _PyObject_IsFreed$descriptor() {
        return _PyObject_IsFreed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyObject_IsFreed(PyObject *)
     * }
     */
    public static MethodHandle _PyObject_IsFreed$handle() {
        return _PyObject_IsFreed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyObject_IsFreed(PyObject *)
     * }
     */
    public static MemorySegment _PyObject_IsFreed$address() {
        return _PyObject_IsFreed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyObject_IsFreed(PyObject *)
     * }
     */
    public static int _PyObject_IsFreed(MemorySegment x0) {
        var mh$ = _PyObject_IsFreed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_IsFreed", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_IsAbstract {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_IsAbstract");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyObject_IsAbstract(PyObject *)
     * }
     */
    public static FunctionDescriptor _PyObject_IsAbstract$descriptor() {
        return _PyObject_IsAbstract.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyObject_IsAbstract(PyObject *)
     * }
     */
    public static MethodHandle _PyObject_IsAbstract$handle() {
        return _PyObject_IsAbstract.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyObject_IsAbstract(PyObject *)
     * }
     */
    public static MemorySegment _PyObject_IsAbstract$address() {
        return _PyObject_IsAbstract.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyObject_IsAbstract(PyObject *)
     * }
     */
    public static int _PyObject_IsAbstract(MemorySegment x0) {
        var mh$ = _PyObject_IsAbstract.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_IsAbstract", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_GetAttrId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_GetAttrId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyObject_GetAttrId(PyObject *, _Py_Identifier *)
     * }
     */
    public static FunctionDescriptor _PyObject_GetAttrId$descriptor() {
        return _PyObject_GetAttrId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyObject_GetAttrId(PyObject *, _Py_Identifier *)
     * }
     */
    public static MethodHandle _PyObject_GetAttrId$handle() {
        return _PyObject_GetAttrId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyObject_GetAttrId(PyObject *, _Py_Identifier *)
     * }
     */
    public static MemorySegment _PyObject_GetAttrId$address() {
        return _PyObject_GetAttrId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyObject_GetAttrId(PyObject *, _Py_Identifier *)
     * }
     */
    public static MemorySegment _PyObject_GetAttrId(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyObject_GetAttrId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_GetAttrId", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_SetAttrId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_SetAttrId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyObject_SetAttrId(PyObject *, _Py_Identifier *, PyObject *)
     * }
     */
    public static FunctionDescriptor _PyObject_SetAttrId$descriptor() {
        return _PyObject_SetAttrId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyObject_SetAttrId(PyObject *, _Py_Identifier *, PyObject *)
     * }
     */
    public static MethodHandle _PyObject_SetAttrId$handle() {
        return _PyObject_SetAttrId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyObject_SetAttrId(PyObject *, _Py_Identifier *, PyObject *)
     * }
     */
    public static MemorySegment _PyObject_SetAttrId$address() {
        return _PyObject_SetAttrId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyObject_SetAttrId(PyObject *, _Py_Identifier *, PyObject *)
     * }
     */
    public static int _PyObject_SetAttrId(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = _PyObject_SetAttrId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_SetAttrId", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_LookupAttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_LookupAttr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyObject_LookupAttr(PyObject *, PyObject *, PyObject **)
     * }
     */
    public static FunctionDescriptor _PyObject_LookupAttr$descriptor() {
        return _PyObject_LookupAttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyObject_LookupAttr(PyObject *, PyObject *, PyObject **)
     * }
     */
    public static MethodHandle _PyObject_LookupAttr$handle() {
        return _PyObject_LookupAttr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyObject_LookupAttr(PyObject *, PyObject *, PyObject **)
     * }
     */
    public static MemorySegment _PyObject_LookupAttr$address() {
        return _PyObject_LookupAttr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyObject_LookupAttr(PyObject *, PyObject *, PyObject **)
     * }
     */
    public static int _PyObject_LookupAttr(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = _PyObject_LookupAttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_LookupAttr", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_LookupAttrId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_LookupAttrId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyObject_LookupAttrId(PyObject *, _Py_Identifier *, PyObject **)
     * }
     */
    public static FunctionDescriptor _PyObject_LookupAttrId$descriptor() {
        return _PyObject_LookupAttrId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyObject_LookupAttrId(PyObject *, _Py_Identifier *, PyObject **)
     * }
     */
    public static MethodHandle _PyObject_LookupAttrId$handle() {
        return _PyObject_LookupAttrId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyObject_LookupAttrId(PyObject *, _Py_Identifier *, PyObject **)
     * }
     */
    public static MemorySegment _PyObject_LookupAttrId$address() {
        return _PyObject_LookupAttrId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyObject_LookupAttrId(PyObject *, _Py_Identifier *, PyObject **)
     * }
     */
    public static int _PyObject_LookupAttrId(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = _PyObject_LookupAttrId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_LookupAttrId", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_GetMethod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_GetMethod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyObject_GetMethod(PyObject *obj, PyObject *name, PyObject **method)
     * }
     */
    public static FunctionDescriptor _PyObject_GetMethod$descriptor() {
        return _PyObject_GetMethod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyObject_GetMethod(PyObject *obj, PyObject *name, PyObject **method)
     * }
     */
    public static MethodHandle _PyObject_GetMethod$handle() {
        return _PyObject_GetMethod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyObject_GetMethod(PyObject *obj, PyObject *name, PyObject **method)
     * }
     */
    public static MemorySegment _PyObject_GetMethod$address() {
        return _PyObject_GetMethod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyObject_GetMethod(PyObject *obj, PyObject *name, PyObject **method)
     * }
     */
    public static int _PyObject_GetMethod(MemorySegment obj, MemorySegment name, MemorySegment method) {
        var mh$ = _PyObject_GetMethod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_GetMethod", obj, name, method);
            }
            return (int)mh$.invokeExact(obj, name, method);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_GetDictPtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_GetDictPtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject **_PyObject_GetDictPtr(PyObject *)
     * }
     */
    public static FunctionDescriptor _PyObject_GetDictPtr$descriptor() {
        return _PyObject_GetDictPtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject **_PyObject_GetDictPtr(PyObject *)
     * }
     */
    public static MethodHandle _PyObject_GetDictPtr$handle() {
        return _PyObject_GetDictPtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject **_PyObject_GetDictPtr(PyObject *)
     * }
     */
    public static MemorySegment _PyObject_GetDictPtr$address() {
        return _PyObject_GetDictPtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject **_PyObject_GetDictPtr(PyObject *)
     * }
     */
    public static MemorySegment _PyObject_GetDictPtr(MemorySegment x0) {
        var mh$ = _PyObject_GetDictPtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_GetDictPtr", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_NextNotImplemented {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_NextNotImplemented");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyObject_NextNotImplemented(PyObject *)
     * }
     */
    public static FunctionDescriptor _PyObject_NextNotImplemented$descriptor() {
        return _PyObject_NextNotImplemented.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyObject_NextNotImplemented(PyObject *)
     * }
     */
    public static MethodHandle _PyObject_NextNotImplemented$handle() {
        return _PyObject_NextNotImplemented.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyObject_NextNotImplemented(PyObject *)
     * }
     */
    public static MemorySegment _PyObject_NextNotImplemented$address() {
        return _PyObject_NextNotImplemented.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyObject_NextNotImplemented(PyObject *)
     * }
     */
    public static MemorySegment _PyObject_NextNotImplemented(MemorySegment x0) {
        var mh$ = _PyObject_NextNotImplemented.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_NextNotImplemented", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_CallFinalizer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_CallFinalizer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyObject_CallFinalizer(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_CallFinalizer$descriptor() {
        return PyObject_CallFinalizer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyObject_CallFinalizer(PyObject *)
     * }
     */
    public static MethodHandle PyObject_CallFinalizer$handle() {
        return PyObject_CallFinalizer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyObject_CallFinalizer(PyObject *)
     * }
     */
    public static MemorySegment PyObject_CallFinalizer$address() {
        return PyObject_CallFinalizer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyObject_CallFinalizer(PyObject *)
     * }
     */
    public static void PyObject_CallFinalizer(MemorySegment x0) {
        var mh$ = PyObject_CallFinalizer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_CallFinalizer", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_CallFinalizerFromDealloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_CallFinalizerFromDealloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_CallFinalizerFromDealloc(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_CallFinalizerFromDealloc$descriptor() {
        return PyObject_CallFinalizerFromDealloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_CallFinalizerFromDealloc(PyObject *)
     * }
     */
    public static MethodHandle PyObject_CallFinalizerFromDealloc$handle() {
        return PyObject_CallFinalizerFromDealloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_CallFinalizerFromDealloc(PyObject *)
     * }
     */
    public static MemorySegment PyObject_CallFinalizerFromDealloc$address() {
        return PyObject_CallFinalizerFromDealloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_CallFinalizerFromDealloc(PyObject *)
     * }
     */
    public static int PyObject_CallFinalizerFromDealloc(MemorySegment x0) {
        var mh$ = PyObject_CallFinalizerFromDealloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_CallFinalizerFromDealloc", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_GenericGetAttrWithDict {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_GenericGetAttrWithDict");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyObject_GenericGetAttrWithDict(PyObject *, PyObject *, PyObject *, int)
     * }
     */
    public static FunctionDescriptor _PyObject_GenericGetAttrWithDict$descriptor() {
        return _PyObject_GenericGetAttrWithDict.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyObject_GenericGetAttrWithDict(PyObject *, PyObject *, PyObject *, int)
     * }
     */
    public static MethodHandle _PyObject_GenericGetAttrWithDict$handle() {
        return _PyObject_GenericGetAttrWithDict.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyObject_GenericGetAttrWithDict(PyObject *, PyObject *, PyObject *, int)
     * }
     */
    public static MemorySegment _PyObject_GenericGetAttrWithDict$address() {
        return _PyObject_GenericGetAttrWithDict.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyObject_GenericGetAttrWithDict(PyObject *, PyObject *, PyObject *, int)
     * }
     */
    public static MemorySegment _PyObject_GenericGetAttrWithDict(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3) {
        var mh$ = _PyObject_GenericGetAttrWithDict.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_GenericGetAttrWithDict", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_GenericSetAttrWithDict {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_GenericSetAttrWithDict");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyObject_GenericSetAttrWithDict(PyObject *, PyObject *, PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor _PyObject_GenericSetAttrWithDict$descriptor() {
        return _PyObject_GenericSetAttrWithDict.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyObject_GenericSetAttrWithDict(PyObject *, PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MethodHandle _PyObject_GenericSetAttrWithDict$handle() {
        return _PyObject_GenericSetAttrWithDict.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyObject_GenericSetAttrWithDict(PyObject *, PyObject *, PyObject *, PyObject *)
     * }
     */
    public static MemorySegment _PyObject_GenericSetAttrWithDict$address() {
        return _PyObject_GenericSetAttrWithDict.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyObject_GenericSetAttrWithDict(PyObject *, PyObject *, PyObject *, PyObject *)
     * }
     */
    public static int _PyObject_GenericSetAttrWithDict(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = _PyObject_GenericSetAttrWithDict.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_GenericSetAttrWithDict", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_FunctionStr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_FunctionStr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyObject_FunctionStr(PyObject *)
     * }
     */
    public static FunctionDescriptor _PyObject_FunctionStr$descriptor() {
        return _PyObject_FunctionStr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyObject_FunctionStr(PyObject *)
     * }
     */
    public static MethodHandle _PyObject_FunctionStr$handle() {
        return _PyObject_FunctionStr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyObject_FunctionStr(PyObject *)
     * }
     */
    public static MemorySegment _PyObject_FunctionStr$address() {
        return _PyObject_FunctionStr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyObject_FunctionStr(PyObject *)
     * }
     */
    public static MemorySegment _PyObject_FunctionStr(MemorySegment x0) {
        var mh$ = _PyObject_FunctionStr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_FunctionStr", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyNone_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_PyNone_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyNone_Type
     * }
     */
    public static GroupLayout _PyNone_Type$layout() {
        return _PyNone_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyNone_Type
     * }
     */
    public static MemorySegment _PyNone_Type() {
        return _PyNone_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyNone_Type
     * }
     */
    public static void _PyNone_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _PyNone_Type$constants.SEGMENT, 0L, _PyNone_Type$constants.LAYOUT.byteSize());
    }

    private static class _PyNotImplemented_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_PyNotImplemented_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyNotImplemented_Type
     * }
     */
    public static GroupLayout _PyNotImplemented_Type$layout() {
        return _PyNotImplemented_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyNotImplemented_Type
     * }
     */
    public static MemorySegment _PyNotImplemented_Type() {
        return _PyNotImplemented_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyNotImplemented_Type
     * }
     */
    public static void _PyNotImplemented_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _PyNotImplemented_Type$constants.SEGMENT, 0L, _PyNotImplemented_Type$constants.LAYOUT.byteSize());
    }

    private static class _Py_SwappedOp$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(0, Python_h.C_INT);
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_Py_SwappedOp").reinterpret(LAYOUT.byteSize());
        public static final VarHandle HANDLE = LAYOUT.varHandle();

        public static final long[] DIMS = {  };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int _Py_SwappedOp[]
     * }
     */
    public static SequenceLayout _Py_SwappedOp$layout() {
        return _Py_SwappedOp$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern int _Py_SwappedOp[]
     * }
     */
    public static long[] _Py_SwappedOp$dimensions() {
        return _Py_SwappedOp$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int _Py_SwappedOp[]
     * }
     */
    public static MemorySegment _Py_SwappedOp() {
        return _Py_SwappedOp$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int _Py_SwappedOp[]
     * }
     */
    public static void _Py_SwappedOp(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Py_SwappedOp$constants.SEGMENT, 0L, _Py_SwappedOp$constants.LAYOUT.byteSize());
    }

    private static class _PyDebugAllocatorStats {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyDebugAllocatorStats");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyDebugAllocatorStats(FILE *out, const char *block_name, int num_blocks, size_t sizeof_block)
     * }
     */
    public static FunctionDescriptor _PyDebugAllocatorStats$descriptor() {
        return _PyDebugAllocatorStats.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyDebugAllocatorStats(FILE *out, const char *block_name, int num_blocks, size_t sizeof_block)
     * }
     */
    public static MethodHandle _PyDebugAllocatorStats$handle() {
        return _PyDebugAllocatorStats.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyDebugAllocatorStats(FILE *out, const char *block_name, int num_blocks, size_t sizeof_block)
     * }
     */
    public static MemorySegment _PyDebugAllocatorStats$address() {
        return _PyDebugAllocatorStats.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyDebugAllocatorStats(FILE *out, const char *block_name, int num_blocks, size_t sizeof_block)
     * }
     */
    public static void _PyDebugAllocatorStats(MemorySegment out, MemorySegment block_name, int num_blocks, long sizeof_block) {
        var mh$ = _PyDebugAllocatorStats.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyDebugAllocatorStats", out, block_name, num_blocks, sizeof_block);
            }
            mh$.invokeExact(out, block_name, num_blocks, sizeof_block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_DebugTypeStats {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_DebugTypeStats");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyObject_DebugTypeStats(FILE *out)
     * }
     */
    public static FunctionDescriptor _PyObject_DebugTypeStats$descriptor() {
        return _PyObject_DebugTypeStats.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyObject_DebugTypeStats(FILE *out)
     * }
     */
    public static MethodHandle _PyObject_DebugTypeStats$handle() {
        return _PyObject_DebugTypeStats.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyObject_DebugTypeStats(FILE *out)
     * }
     */
    public static MemorySegment _PyObject_DebugTypeStats$address() {
        return _PyObject_DebugTypeStats.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyObject_DebugTypeStats(FILE *out)
     * }
     */
    public static void _PyObject_DebugTypeStats(MemorySegment out) {
        var mh$ = _PyObject_DebugTypeStats.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_DebugTypeStats", out);
            }
            mh$.invokeExact(out);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_AssertFailed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_AssertFailed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyObject_AssertFailed(PyObject *obj, const char *expr, const char *msg, const char *file, int line, const char *function)
     * }
     */
    public static FunctionDescriptor _PyObject_AssertFailed$descriptor() {
        return _PyObject_AssertFailed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyObject_AssertFailed(PyObject *obj, const char *expr, const char *msg, const char *file, int line, const char *function)
     * }
     */
    public static MethodHandle _PyObject_AssertFailed$handle() {
        return _PyObject_AssertFailed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyObject_AssertFailed(PyObject *obj, const char *expr, const char *msg, const char *file, int line, const char *function)
     * }
     */
    public static MemorySegment _PyObject_AssertFailed$address() {
        return _PyObject_AssertFailed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyObject_AssertFailed(PyObject *obj, const char *expr, const char *msg, const char *file, int line, const char *function)
     * }
     */
    public static void _PyObject_AssertFailed(MemorySegment obj, MemorySegment expr, MemorySegment msg, MemorySegment file, int line, MemorySegment function) {
        var mh$ = _PyObject_AssertFailed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_AssertFailed", obj, expr, msg, file, line, function);
            }
            mh$.invokeExact(obj, expr, msg, file, line, function);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_CheckConsistency {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_CheckConsistency");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyObject_CheckConsistency(PyObject *op, int check_content)
     * }
     */
    public static FunctionDescriptor _PyObject_CheckConsistency$descriptor() {
        return _PyObject_CheckConsistency.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyObject_CheckConsistency(PyObject *op, int check_content)
     * }
     */
    public static MethodHandle _PyObject_CheckConsistency$handle() {
        return _PyObject_CheckConsistency.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyObject_CheckConsistency(PyObject *op, int check_content)
     * }
     */
    public static MemorySegment _PyObject_CheckConsistency$address() {
        return _PyObject_CheckConsistency.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyObject_CheckConsistency(PyObject *op, int check_content)
     * }
     */
    public static int _PyObject_CheckConsistency(MemorySegment op, int check_content) {
        var mh$ = _PyObject_CheckConsistency.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_CheckConsistency", op, check_content);
            }
            return (int)mh$.invokeExact(op, check_content);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTrash_begin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTrash_begin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyTrash_begin(PyThreadState *tstate, PyObject *op)
     * }
     */
    public static FunctionDescriptor _PyTrash_begin$descriptor() {
        return _PyTrash_begin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyTrash_begin(PyThreadState *tstate, PyObject *op)
     * }
     */
    public static MethodHandle _PyTrash_begin$handle() {
        return _PyTrash_begin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyTrash_begin(PyThreadState *tstate, PyObject *op)
     * }
     */
    public static MemorySegment _PyTrash_begin$address() {
        return _PyTrash_begin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyTrash_begin(PyThreadState *tstate, PyObject *op)
     * }
     */
    public static int _PyTrash_begin(MemorySegment tstate, MemorySegment op) {
        var mh$ = _PyTrash_begin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTrash_begin", tstate, op);
            }
            return (int)mh$.invokeExact(tstate, op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTrash_end {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTrash_end");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyTrash_end(PyThreadState *tstate)
     * }
     */
    public static FunctionDescriptor _PyTrash_end$descriptor() {
        return _PyTrash_end.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyTrash_end(PyThreadState *tstate)
     * }
     */
    public static MethodHandle _PyTrash_end$handle() {
        return _PyTrash_end.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyTrash_end(PyThreadState *tstate)
     * }
     */
    public static MemorySegment _PyTrash_end$address() {
        return _PyTrash_end.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyTrash_end(PyThreadState *tstate)
     * }
     */
    public static void _PyTrash_end(MemorySegment tstate) {
        var mh$ = _PyTrash_end.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTrash_end", tstate);
            }
            mh$.invokeExact(tstate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyTrash_cond {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyTrash_cond");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyTrash_cond(PyObject *op, destructor dealloc)
     * }
     */
    public static FunctionDescriptor _PyTrash_cond$descriptor() {
        return _PyTrash_cond.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyTrash_cond(PyObject *op, destructor dealloc)
     * }
     */
    public static MethodHandle _PyTrash_cond$handle() {
        return _PyTrash_cond.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyTrash_cond(PyObject *op, destructor dealloc)
     * }
     */
    public static MemorySegment _PyTrash_cond$address() {
        return _PyTrash_cond.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyTrash_cond(PyObject *op, destructor dealloc)
     * }
     */
    public static int _PyTrash_cond(MemorySegment op, MemorySegment dealloc) {
        var mh$ = _PyTrash_cond.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyTrash_cond", op, dealloc);
            }
            return (int)mh$.invokeExact(op, dealloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int UsingDeprecatedTrashcanMacro
     * }
     */
    public static final OfInt UsingDeprecatedTrashcanMacro = Python_h.C_INT;

    private static class PyObject_Malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyObject_Malloc(size_t size)
     * }
     */
    public static FunctionDescriptor PyObject_Malloc$descriptor() {
        return PyObject_Malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyObject_Malloc(size_t size)
     * }
     */
    public static MethodHandle PyObject_Malloc$handle() {
        return PyObject_Malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyObject_Malloc(size_t size)
     * }
     */
    public static MemorySegment PyObject_Malloc$address() {
        return PyObject_Malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyObject_Malloc(size_t size)
     * }
     */
    public static MemorySegment PyObject_Malloc(long size) {
        var mh$ = PyObject_Malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Malloc", size);
            }
            return (MemorySegment)mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyObject_Calloc(size_t nelem, size_t elsize)
     * }
     */
    public static FunctionDescriptor PyObject_Calloc$descriptor() {
        return PyObject_Calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyObject_Calloc(size_t nelem, size_t elsize)
     * }
     */
    public static MethodHandle PyObject_Calloc$handle() {
        return PyObject_Calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyObject_Calloc(size_t nelem, size_t elsize)
     * }
     */
    public static MemorySegment PyObject_Calloc$address() {
        return PyObject_Calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyObject_Calloc(size_t nelem, size_t elsize)
     * }
     */
    public static MemorySegment PyObject_Calloc(long nelem, long elsize) {
        var mh$ = PyObject_Calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Calloc", nelem, elsize);
            }
            return (MemorySegment)mh$.invokeExact(nelem, elsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyObject_Realloc(void *ptr, size_t new_size)
     * }
     */
    public static FunctionDescriptor PyObject_Realloc$descriptor() {
        return PyObject_Realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyObject_Realloc(void *ptr, size_t new_size)
     * }
     */
    public static MethodHandle PyObject_Realloc$handle() {
        return PyObject_Realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyObject_Realloc(void *ptr, size_t new_size)
     * }
     */
    public static MemorySegment PyObject_Realloc$address() {
        return PyObject_Realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyObject_Realloc(void *ptr, size_t new_size)
     * }
     */
    public static MemorySegment PyObject_Realloc(MemorySegment ptr, long new_size) {
        var mh$ = PyObject_Realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Realloc", ptr, new_size);
            }
            return (MemorySegment)mh$.invokeExact(ptr, new_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyObject_Free(void *ptr)
     * }
     */
    public static FunctionDescriptor PyObject_Free$descriptor() {
        return PyObject_Free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyObject_Free(void *ptr)
     * }
     */
    public static MethodHandle PyObject_Free$handle() {
        return PyObject_Free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyObject_Free(void *ptr)
     * }
     */
    public static MemorySegment PyObject_Free$address() {
        return PyObject_Free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyObject_Free(void *ptr)
     * }
     */
    public static void PyObject_Free(MemorySegment ptr) {
        var mh$ = PyObject_Free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Free", ptr);
            }
            mh$.invokeExact(ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_Init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_Init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyObject_Init(PyObject *, PyTypeObject *)
     * }
     */
    public static FunctionDescriptor PyObject_Init$descriptor() {
        return PyObject_Init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyObject_Init(PyObject *, PyTypeObject *)
     * }
     */
    public static MethodHandle PyObject_Init$handle() {
        return PyObject_Init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyObject_Init(PyObject *, PyTypeObject *)
     * }
     */
    public static MemorySegment PyObject_Init$address() {
        return PyObject_Init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyObject_Init(PyObject *, PyTypeObject *)
     * }
     */
    public static MemorySegment PyObject_Init(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyObject_Init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_Init", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_InitVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_InitVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyVarObject *PyObject_InitVar(PyVarObject *, PyTypeObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyObject_InitVar$descriptor() {
        return PyObject_InitVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyVarObject *PyObject_InitVar(PyVarObject *, PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyObject_InitVar$handle() {
        return PyObject_InitVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyVarObject *PyObject_InitVar(PyVarObject *, PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyObject_InitVar$address() {
        return PyObject_InitVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyVarObject *PyObject_InitVar(PyVarObject *, PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyObject_InitVar(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = PyObject_InitVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_InitVar", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyObject_New(PyTypeObject *)
     * }
     */
    public static FunctionDescriptor _PyObject_New$descriptor() {
        return _PyObject_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyObject_New(PyTypeObject *)
     * }
     */
    public static MethodHandle _PyObject_New$handle() {
        return _PyObject_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyObject_New(PyTypeObject *)
     * }
     */
    public static MemorySegment _PyObject_New$address() {
        return _PyObject_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyObject_New(PyTypeObject *)
     * }
     */
    public static MemorySegment _PyObject_New(MemorySegment x0) {
        var mh$ = _PyObject_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_New", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_NewVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_NewVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyVarObject *_PyObject_NewVar(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor _PyObject_NewVar$descriptor() {
        return _PyObject_NewVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyVarObject *_PyObject_NewVar(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle _PyObject_NewVar$handle() {
        return _PyObject_NewVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyVarObject *_PyObject_NewVar(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment _PyObject_NewVar$address() {
        return _PyObject_NewVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyVarObject *_PyObject_NewVar(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment _PyObject_NewVar(MemorySegment x0, long x1) {
        var mh$ = _PyObject_NewVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_NewVar", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyGC_Collect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyGC_Collect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyGC_Collect()
     * }
     */
    public static FunctionDescriptor PyGC_Collect$descriptor() {
        return PyGC_Collect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyGC_Collect()
     * }
     */
    public static MethodHandle PyGC_Collect$handle() {
        return PyGC_Collect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyGC_Collect()
     * }
     */
    public static MemorySegment PyGC_Collect$address() {
        return PyGC_Collect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyGC_Collect()
     * }
     */
    public static long PyGC_Collect() {
        var mh$ = PyGC_Collect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyGC_Collect");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyGC_Enable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyGC_Enable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyGC_Enable()
     * }
     */
    public static FunctionDescriptor PyGC_Enable$descriptor() {
        return PyGC_Enable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyGC_Enable()
     * }
     */
    public static MethodHandle PyGC_Enable$handle() {
        return PyGC_Enable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyGC_Enable()
     * }
     */
    public static MemorySegment PyGC_Enable$address() {
        return PyGC_Enable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyGC_Enable()
     * }
     */
    public static int PyGC_Enable() {
        var mh$ = PyGC_Enable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyGC_Enable");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyGC_Disable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyGC_Disable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyGC_Disable()
     * }
     */
    public static FunctionDescriptor PyGC_Disable$descriptor() {
        return PyGC_Disable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyGC_Disable()
     * }
     */
    public static MethodHandle PyGC_Disable$handle() {
        return PyGC_Disable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyGC_Disable()
     * }
     */
    public static MemorySegment PyGC_Disable$address() {
        return PyGC_Disable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyGC_Disable()
     * }
     */
    public static int PyGC_Disable() {
        var mh$ = PyGC_Disable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyGC_Disable");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyGC_IsEnabled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyGC_IsEnabled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyGC_IsEnabled()
     * }
     */
    public static FunctionDescriptor PyGC_IsEnabled$descriptor() {
        return PyGC_IsEnabled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyGC_IsEnabled()
     * }
     */
    public static MethodHandle PyGC_IsEnabled$handle() {
        return PyGC_IsEnabled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyGC_IsEnabled()
     * }
     */
    public static MemorySegment PyGC_IsEnabled$address() {
        return PyGC_IsEnabled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyGC_IsEnabled()
     * }
     */
    public static int PyGC_IsEnabled() {
        var mh$ = PyGC_IsEnabled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyGC_IsEnabled");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_GC_Resize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_GC_Resize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyVarObject *_PyObject_GC_Resize(PyVarObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor _PyObject_GC_Resize$descriptor() {
        return _PyObject_GC_Resize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyVarObject *_PyObject_GC_Resize(PyVarObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle _PyObject_GC_Resize$handle() {
        return _PyObject_GC_Resize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyVarObject *_PyObject_GC_Resize(PyVarObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment _PyObject_GC_Resize$address() {
        return _PyObject_GC_Resize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyVarObject *_PyObject_GC_Resize(PyVarObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment _PyObject_GC_Resize(MemorySegment x0, long x1) {
        var mh$ = _PyObject_GC_Resize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_GC_Resize", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_GC_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_GC_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyObject_GC_New(PyTypeObject *)
     * }
     */
    public static FunctionDescriptor _PyObject_GC_New$descriptor() {
        return _PyObject_GC_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyObject_GC_New(PyTypeObject *)
     * }
     */
    public static MethodHandle _PyObject_GC_New$handle() {
        return _PyObject_GC_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyObject_GC_New(PyTypeObject *)
     * }
     */
    public static MemorySegment _PyObject_GC_New$address() {
        return _PyObject_GC_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyObject_GC_New(PyTypeObject *)
     * }
     */
    public static MemorySegment _PyObject_GC_New(MemorySegment x0) {
        var mh$ = _PyObject_GC_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_GC_New", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyObject_GC_NewVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyObject_GC_NewVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyVarObject *_PyObject_GC_NewVar(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor _PyObject_GC_NewVar$descriptor() {
        return _PyObject_GC_NewVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyVarObject *_PyObject_GC_NewVar(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle _PyObject_GC_NewVar$handle() {
        return _PyObject_GC_NewVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyVarObject *_PyObject_GC_NewVar(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment _PyObject_GC_NewVar$address() {
        return _PyObject_GC_NewVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyVarObject *_PyObject_GC_NewVar(PyTypeObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment _PyObject_GC_NewVar(MemorySegment x0, long x1) {
        var mh$ = _PyObject_GC_NewVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyObject_GC_NewVar", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GC_Track {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GC_Track");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyObject_GC_Track(void *)
     * }
     */
    public static FunctionDescriptor PyObject_GC_Track$descriptor() {
        return PyObject_GC_Track.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyObject_GC_Track(void *)
     * }
     */
    public static MethodHandle PyObject_GC_Track$handle() {
        return PyObject_GC_Track.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyObject_GC_Track(void *)
     * }
     */
    public static MemorySegment PyObject_GC_Track$address() {
        return PyObject_GC_Track.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyObject_GC_Track(void *)
     * }
     */
    public static void PyObject_GC_Track(MemorySegment x0) {
        var mh$ = PyObject_GC_Track.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GC_Track", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GC_UnTrack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GC_UnTrack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyObject_GC_UnTrack(void *)
     * }
     */
    public static FunctionDescriptor PyObject_GC_UnTrack$descriptor() {
        return PyObject_GC_UnTrack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyObject_GC_UnTrack(void *)
     * }
     */
    public static MethodHandle PyObject_GC_UnTrack$handle() {
        return PyObject_GC_UnTrack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyObject_GC_UnTrack(void *)
     * }
     */
    public static MemorySegment PyObject_GC_UnTrack$address() {
        return PyObject_GC_UnTrack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyObject_GC_UnTrack(void *)
     * }
     */
    public static void PyObject_GC_UnTrack(MemorySegment x0) {
        var mh$ = PyObject_GC_UnTrack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GC_UnTrack", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GC_Del {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GC_Del");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyObject_GC_Del(void *)
     * }
     */
    public static FunctionDescriptor PyObject_GC_Del$descriptor() {
        return PyObject_GC_Del.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyObject_GC_Del(void *)
     * }
     */
    public static MethodHandle PyObject_GC_Del$handle() {
        return PyObject_GC_Del.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyObject_GC_Del(void *)
     * }
     */
    public static MemorySegment PyObject_GC_Del$address() {
        return PyObject_GC_Del.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyObject_GC_Del(void *)
     * }
     */
    public static void PyObject_GC_Del(MemorySegment x0) {
        var mh$ = PyObject_GC_Del.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GC_Del", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GC_IsTracked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GC_IsTracked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_GC_IsTracked(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_GC_IsTracked$descriptor() {
        return PyObject_GC_IsTracked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_GC_IsTracked(PyObject *)
     * }
     */
    public static MethodHandle PyObject_GC_IsTracked$handle() {
        return PyObject_GC_IsTracked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_GC_IsTracked(PyObject *)
     * }
     */
    public static MemorySegment PyObject_GC_IsTracked$address() {
        return PyObject_GC_IsTracked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_GC_IsTracked(PyObject *)
     * }
     */
    public static int PyObject_GC_IsTracked(MemorySegment x0) {
        var mh$ = PyObject_GC_IsTracked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GC_IsTracked", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GC_IsFinalized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GC_IsFinalized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_GC_IsFinalized(PyObject *)
     * }
     */
    public static FunctionDescriptor PyObject_GC_IsFinalized$descriptor() {
        return PyObject_GC_IsFinalized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_GC_IsFinalized(PyObject *)
     * }
     */
    public static MethodHandle PyObject_GC_IsFinalized$handle() {
        return PyObject_GC_IsFinalized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_GC_IsFinalized(PyObject *)
     * }
     */
    public static MemorySegment PyObject_GC_IsFinalized$address() {
        return PyObject_GC_IsFinalized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_GC_IsFinalized(PyObject *)
     * }
     */
    public static int PyObject_GC_IsFinalized(MemorySegment x0) {
        var mh$ = PyObject_GC_IsFinalized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GC_IsFinalized", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GetArenaAllocator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GetArenaAllocator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyObject_GetArenaAllocator(PyObjectArenaAllocator *allocator)
     * }
     */
    public static FunctionDescriptor PyObject_GetArenaAllocator$descriptor() {
        return PyObject_GetArenaAllocator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyObject_GetArenaAllocator(PyObjectArenaAllocator *allocator)
     * }
     */
    public static MethodHandle PyObject_GetArenaAllocator$handle() {
        return PyObject_GetArenaAllocator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyObject_GetArenaAllocator(PyObjectArenaAllocator *allocator)
     * }
     */
    public static MemorySegment PyObject_GetArenaAllocator$address() {
        return PyObject_GetArenaAllocator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyObject_GetArenaAllocator(PyObjectArenaAllocator *allocator)
     * }
     */
    public static void PyObject_GetArenaAllocator(MemorySegment allocator) {
        var mh$ = PyObject_GetArenaAllocator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GetArenaAllocator", allocator);
            }
            mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_SetArenaAllocator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_SetArenaAllocator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyObject_SetArenaAllocator(PyObjectArenaAllocator *allocator)
     * }
     */
    public static FunctionDescriptor PyObject_SetArenaAllocator$descriptor() {
        return PyObject_SetArenaAllocator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyObject_SetArenaAllocator(PyObjectArenaAllocator *allocator)
     * }
     */
    public static MethodHandle PyObject_SetArenaAllocator$handle() {
        return PyObject_SetArenaAllocator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyObject_SetArenaAllocator(PyObjectArenaAllocator *allocator)
     * }
     */
    public static MemorySegment PyObject_SetArenaAllocator$address() {
        return PyObject_SetArenaAllocator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyObject_SetArenaAllocator(PyObjectArenaAllocator *allocator)
     * }
     */
    public static void PyObject_SetArenaAllocator(MemorySegment allocator) {
        var mh$ = PyObject_SetArenaAllocator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_SetArenaAllocator", allocator);
            }
            mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_IS_GC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_IS_GC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyObject_IS_GC(PyObject *obj)
     * }
     */
    public static FunctionDescriptor PyObject_IS_GC$descriptor() {
        return PyObject_IS_GC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyObject_IS_GC(PyObject *obj)
     * }
     */
    public static MethodHandle PyObject_IS_GC$handle() {
        return PyObject_IS_GC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyObject_IS_GC(PyObject *obj)
     * }
     */
    public static MemorySegment PyObject_IS_GC$address() {
        return PyObject_IS_GC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyObject_IS_GC(PyObject *obj)
     * }
     */
    public static int PyObject_IS_GC(MemorySegment obj) {
        var mh$ = PyObject_IS_GC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_IS_GC", obj);
            }
            return (int)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyType_SUPPORTS_WEAKREFS {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyType_SUPPORTS_WEAKREFS");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyType_SUPPORTS_WEAKREFS(PyTypeObject *type)
     * }
     */
    public static FunctionDescriptor PyType_SUPPORTS_WEAKREFS$descriptor() {
        return PyType_SUPPORTS_WEAKREFS.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyType_SUPPORTS_WEAKREFS(PyTypeObject *type)
     * }
     */
    public static MethodHandle PyType_SUPPORTS_WEAKREFS$handle() {
        return PyType_SUPPORTS_WEAKREFS.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyType_SUPPORTS_WEAKREFS(PyTypeObject *type)
     * }
     */
    public static MemorySegment PyType_SUPPORTS_WEAKREFS$address() {
        return PyType_SUPPORTS_WEAKREFS.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyType_SUPPORTS_WEAKREFS(PyTypeObject *type)
     * }
     */
    public static int PyType_SUPPORTS_WEAKREFS(MemorySegment type) {
        var mh$ = PyType_SUPPORTS_WEAKREFS.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyType_SUPPORTS_WEAKREFS", type);
            }
            return (int)mh$.invokeExact(type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyObject_GET_WEAKREFS_LISTPTR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyObject_GET_WEAKREFS_LISTPTR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject **PyObject_GET_WEAKREFS_LISTPTR(PyObject *op)
     * }
     */
    public static FunctionDescriptor PyObject_GET_WEAKREFS_LISTPTR$descriptor() {
        return PyObject_GET_WEAKREFS_LISTPTR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject **PyObject_GET_WEAKREFS_LISTPTR(PyObject *op)
     * }
     */
    public static MethodHandle PyObject_GET_WEAKREFS_LISTPTR$handle() {
        return PyObject_GET_WEAKREFS_LISTPTR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject **PyObject_GET_WEAKREFS_LISTPTR(PyObject *op)
     * }
     */
    public static MemorySegment PyObject_GET_WEAKREFS_LISTPTR$address() {
        return PyObject_GET_WEAKREFS_LISTPTR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject **PyObject_GET_WEAKREFS_LISTPTR(PyObject *op)
     * }
     */
    public static MemorySegment PyObject_GET_WEAKREFS_LISTPTR(MemorySegment op) {
        var mh$ = PyObject_GET_WEAKREFS_LISTPTR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyObject_GET_WEAKREFS_LISTPTR", op);
            }
            return (MemorySegment)mh$.invokeExact(op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_HashDouble {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_HashDouble");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_hash_t _Py_HashDouble(PyObject *, double)
     * }
     */
    public static FunctionDescriptor _Py_HashDouble$descriptor() {
        return _Py_HashDouble.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_hash_t _Py_HashDouble(PyObject *, double)
     * }
     */
    public static MethodHandle _Py_HashDouble$handle() {
        return _Py_HashDouble.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_hash_t _Py_HashDouble(PyObject *, double)
     * }
     */
    public static MemorySegment _Py_HashDouble$address() {
        return _Py_HashDouble.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_hash_t _Py_HashDouble(PyObject *, double)
     * }
     */
    public static long _Py_HashDouble(MemorySegment x0, double x1) {
        var mh$ = _Py_HashDouble.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_HashDouble", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_HashPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_HashPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_hash_t _Py_HashPointer(const void *)
     * }
     */
    public static FunctionDescriptor _Py_HashPointer$descriptor() {
        return _Py_HashPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_hash_t _Py_HashPointer(const void *)
     * }
     */
    public static MethodHandle _Py_HashPointer$handle() {
        return _Py_HashPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_hash_t _Py_HashPointer(const void *)
     * }
     */
    public static MemorySegment _Py_HashPointer$address() {
        return _Py_HashPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_hash_t _Py_HashPointer(const void *)
     * }
     */
    public static long _Py_HashPointer(MemorySegment x0) {
        var mh$ = _Py_HashPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_HashPointer", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_HashPointerRaw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_HashPointerRaw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_hash_t _Py_HashPointerRaw(const void *)
     * }
     */
    public static FunctionDescriptor _Py_HashPointerRaw$descriptor() {
        return _Py_HashPointerRaw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_hash_t _Py_HashPointerRaw(const void *)
     * }
     */
    public static MethodHandle _Py_HashPointerRaw$handle() {
        return _Py_HashPointerRaw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_hash_t _Py_HashPointerRaw(const void *)
     * }
     */
    public static MemorySegment _Py_HashPointerRaw$address() {
        return _Py_HashPointerRaw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_hash_t _Py_HashPointerRaw(const void *)
     * }
     */
    public static long _Py_HashPointerRaw(MemorySegment x0) {
        var mh$ = _Py_HashPointerRaw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_HashPointerRaw", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_HashBytes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_HashBytes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_hash_t _Py_HashBytes(const void *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor _Py_HashBytes$descriptor() {
        return _Py_HashBytes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_hash_t _Py_HashBytes(const void *, Py_ssize_t)
     * }
     */
    public static MethodHandle _Py_HashBytes$handle() {
        return _Py_HashBytes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_hash_t _Py_HashBytes(const void *, Py_ssize_t)
     * }
     */
    public static MemorySegment _Py_HashBytes$address() {
        return _Py_HashBytes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_hash_t _Py_HashBytes(const void *, Py_ssize_t)
     * }
     */
    public static long _Py_HashBytes(MemorySegment x0, long x1) {
        var mh$ = _Py_HashBytes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_HashBytes", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_HashSecret$constants {
        public static final GroupLayout LAYOUT = _Py_HashSecret_t.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_Py_HashSecret").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern _Py_HashSecret_t _Py_HashSecret
     * }
     */
    public static GroupLayout _Py_HashSecret$layout() {
        return _Py_HashSecret$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern _Py_HashSecret_t _Py_HashSecret
     * }
     */
    public static MemorySegment _Py_HashSecret() {
        return _Py_HashSecret$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern _Py_HashSecret_t _Py_HashSecret
     * }
     */
    public static void _Py_HashSecret(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Py_HashSecret$constants.SEGMENT, 0L, _Py_HashSecret$constants.LAYOUT.byteSize());
    }

    private static class PyHash_GetFuncDef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyHash_GetFuncDef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyHash_FuncDef *PyHash_GetFuncDef()
     * }
     */
    public static FunctionDescriptor PyHash_GetFuncDef$descriptor() {
        return PyHash_GetFuncDef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyHash_FuncDef *PyHash_GetFuncDef()
     * }
     */
    public static MethodHandle PyHash_GetFuncDef$handle() {
        return PyHash_GetFuncDef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyHash_FuncDef *PyHash_GetFuncDef()
     * }
     */
    public static MemorySegment PyHash_GetFuncDef$address() {
        return PyHash_GetFuncDef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyHash_FuncDef *PyHash_GetFuncDef()
     * }
     */
    public static MemorySegment PyHash_GetFuncDef() {
        var mh$ = PyHash_GetFuncDef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyHash_GetFuncDef");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_DebugFlag$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_DebugFlag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_DebugFlag
     * }
     */
    public static OfInt Py_DebugFlag$layout() {
        return Py_DebugFlag$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_DebugFlag
     * }
     */
    public static MemorySegment Py_DebugFlag$segment() {
        return Py_DebugFlag$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_DebugFlag
     * }
     */
    public static int Py_DebugFlag() {
        return Py_DebugFlag$constants.SEGMENT.get(Py_DebugFlag$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_DebugFlag
     * }
     */
    public static void Py_DebugFlag(int varValue) {
        Py_DebugFlag$constants.SEGMENT.set(Py_DebugFlag$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_VerboseFlag$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_VerboseFlag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_VerboseFlag
     * }
     */
    public static OfInt Py_VerboseFlag$layout() {
        return Py_VerboseFlag$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_VerboseFlag
     * }
     */
    public static MemorySegment Py_VerboseFlag$segment() {
        return Py_VerboseFlag$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_VerboseFlag
     * }
     */
    public static int Py_VerboseFlag() {
        return Py_VerboseFlag$constants.SEGMENT.get(Py_VerboseFlag$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_VerboseFlag
     * }
     */
    public static void Py_VerboseFlag(int varValue) {
        Py_VerboseFlag$constants.SEGMENT.set(Py_VerboseFlag$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_QuietFlag$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_QuietFlag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_QuietFlag
     * }
     */
    public static OfInt Py_QuietFlag$layout() {
        return Py_QuietFlag$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_QuietFlag
     * }
     */
    public static MemorySegment Py_QuietFlag$segment() {
        return Py_QuietFlag$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_QuietFlag
     * }
     */
    public static int Py_QuietFlag() {
        return Py_QuietFlag$constants.SEGMENT.get(Py_QuietFlag$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_QuietFlag
     * }
     */
    public static void Py_QuietFlag(int varValue) {
        Py_QuietFlag$constants.SEGMENT.set(Py_QuietFlag$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_InteractiveFlag$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_InteractiveFlag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_InteractiveFlag
     * }
     */
    public static OfInt Py_InteractiveFlag$layout() {
        return Py_InteractiveFlag$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_InteractiveFlag
     * }
     */
    public static MemorySegment Py_InteractiveFlag$segment() {
        return Py_InteractiveFlag$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_InteractiveFlag
     * }
     */
    public static int Py_InteractiveFlag() {
        return Py_InteractiveFlag$constants.SEGMENT.get(Py_InteractiveFlag$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_InteractiveFlag
     * }
     */
    public static void Py_InteractiveFlag(int varValue) {
        Py_InteractiveFlag$constants.SEGMENT.set(Py_InteractiveFlag$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_InspectFlag$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_InspectFlag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_InspectFlag
     * }
     */
    public static OfInt Py_InspectFlag$layout() {
        return Py_InspectFlag$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_InspectFlag
     * }
     */
    public static MemorySegment Py_InspectFlag$segment() {
        return Py_InspectFlag$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_InspectFlag
     * }
     */
    public static int Py_InspectFlag() {
        return Py_InspectFlag$constants.SEGMENT.get(Py_InspectFlag$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_InspectFlag
     * }
     */
    public static void Py_InspectFlag(int varValue) {
        Py_InspectFlag$constants.SEGMENT.set(Py_InspectFlag$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_OptimizeFlag$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_OptimizeFlag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_OptimizeFlag
     * }
     */
    public static OfInt Py_OptimizeFlag$layout() {
        return Py_OptimizeFlag$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_OptimizeFlag
     * }
     */
    public static MemorySegment Py_OptimizeFlag$segment() {
        return Py_OptimizeFlag$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_OptimizeFlag
     * }
     */
    public static int Py_OptimizeFlag() {
        return Py_OptimizeFlag$constants.SEGMENT.get(Py_OptimizeFlag$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_OptimizeFlag
     * }
     */
    public static void Py_OptimizeFlag(int varValue) {
        Py_OptimizeFlag$constants.SEGMENT.set(Py_OptimizeFlag$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_NoSiteFlag$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_NoSiteFlag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_NoSiteFlag
     * }
     */
    public static OfInt Py_NoSiteFlag$layout() {
        return Py_NoSiteFlag$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_NoSiteFlag
     * }
     */
    public static MemorySegment Py_NoSiteFlag$segment() {
        return Py_NoSiteFlag$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_NoSiteFlag
     * }
     */
    public static int Py_NoSiteFlag() {
        return Py_NoSiteFlag$constants.SEGMENT.get(Py_NoSiteFlag$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_NoSiteFlag
     * }
     */
    public static void Py_NoSiteFlag(int varValue) {
        Py_NoSiteFlag$constants.SEGMENT.set(Py_NoSiteFlag$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_BytesWarningFlag$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_BytesWarningFlag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_BytesWarningFlag
     * }
     */
    public static OfInt Py_BytesWarningFlag$layout() {
        return Py_BytesWarningFlag$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_BytesWarningFlag
     * }
     */
    public static MemorySegment Py_BytesWarningFlag$segment() {
        return Py_BytesWarningFlag$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_BytesWarningFlag
     * }
     */
    public static int Py_BytesWarningFlag() {
        return Py_BytesWarningFlag$constants.SEGMENT.get(Py_BytesWarningFlag$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_BytesWarningFlag
     * }
     */
    public static void Py_BytesWarningFlag(int varValue) {
        Py_BytesWarningFlag$constants.SEGMENT.set(Py_BytesWarningFlag$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_FrozenFlag$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_FrozenFlag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_FrozenFlag
     * }
     */
    public static OfInt Py_FrozenFlag$layout() {
        return Py_FrozenFlag$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_FrozenFlag
     * }
     */
    public static MemorySegment Py_FrozenFlag$segment() {
        return Py_FrozenFlag$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_FrozenFlag
     * }
     */
    public static int Py_FrozenFlag() {
        return Py_FrozenFlag$constants.SEGMENT.get(Py_FrozenFlag$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_FrozenFlag
     * }
     */
    public static void Py_FrozenFlag(int varValue) {
        Py_FrozenFlag$constants.SEGMENT.set(Py_FrozenFlag$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_IgnoreEnvironmentFlag$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_IgnoreEnvironmentFlag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_IgnoreEnvironmentFlag
     * }
     */
    public static OfInt Py_IgnoreEnvironmentFlag$layout() {
        return Py_IgnoreEnvironmentFlag$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_IgnoreEnvironmentFlag
     * }
     */
    public static MemorySegment Py_IgnoreEnvironmentFlag$segment() {
        return Py_IgnoreEnvironmentFlag$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_IgnoreEnvironmentFlag
     * }
     */
    public static int Py_IgnoreEnvironmentFlag() {
        return Py_IgnoreEnvironmentFlag$constants.SEGMENT.get(Py_IgnoreEnvironmentFlag$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_IgnoreEnvironmentFlag
     * }
     */
    public static void Py_IgnoreEnvironmentFlag(int varValue) {
        Py_IgnoreEnvironmentFlag$constants.SEGMENT.set(Py_IgnoreEnvironmentFlag$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_DontWriteBytecodeFlag$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_DontWriteBytecodeFlag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_DontWriteBytecodeFlag
     * }
     */
    public static OfInt Py_DontWriteBytecodeFlag$layout() {
        return Py_DontWriteBytecodeFlag$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_DontWriteBytecodeFlag
     * }
     */
    public static MemorySegment Py_DontWriteBytecodeFlag$segment() {
        return Py_DontWriteBytecodeFlag$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_DontWriteBytecodeFlag
     * }
     */
    public static int Py_DontWriteBytecodeFlag() {
        return Py_DontWriteBytecodeFlag$constants.SEGMENT.get(Py_DontWriteBytecodeFlag$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_DontWriteBytecodeFlag
     * }
     */
    public static void Py_DontWriteBytecodeFlag(int varValue) {
        Py_DontWriteBytecodeFlag$constants.SEGMENT.set(Py_DontWriteBytecodeFlag$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_NoUserSiteDirectory$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_NoUserSiteDirectory").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_NoUserSiteDirectory
     * }
     */
    public static OfInt Py_NoUserSiteDirectory$layout() {
        return Py_NoUserSiteDirectory$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_NoUserSiteDirectory
     * }
     */
    public static MemorySegment Py_NoUserSiteDirectory$segment() {
        return Py_NoUserSiteDirectory$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_NoUserSiteDirectory
     * }
     */
    public static int Py_NoUserSiteDirectory() {
        return Py_NoUserSiteDirectory$constants.SEGMENT.get(Py_NoUserSiteDirectory$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_NoUserSiteDirectory
     * }
     */
    public static void Py_NoUserSiteDirectory(int varValue) {
        Py_NoUserSiteDirectory$constants.SEGMENT.set(Py_NoUserSiteDirectory$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_UnbufferedStdioFlag$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_UnbufferedStdioFlag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_UnbufferedStdioFlag
     * }
     */
    public static OfInt Py_UnbufferedStdioFlag$layout() {
        return Py_UnbufferedStdioFlag$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_UnbufferedStdioFlag
     * }
     */
    public static MemorySegment Py_UnbufferedStdioFlag$segment() {
        return Py_UnbufferedStdioFlag$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_UnbufferedStdioFlag
     * }
     */
    public static int Py_UnbufferedStdioFlag() {
        return Py_UnbufferedStdioFlag$constants.SEGMENT.get(Py_UnbufferedStdioFlag$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_UnbufferedStdioFlag
     * }
     */
    public static void Py_UnbufferedStdioFlag(int varValue) {
        Py_UnbufferedStdioFlag$constants.SEGMENT.set(Py_UnbufferedStdioFlag$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_HashRandomizationFlag$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_HashRandomizationFlag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_HashRandomizationFlag
     * }
     */
    public static OfInt Py_HashRandomizationFlag$layout() {
        return Py_HashRandomizationFlag$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_HashRandomizationFlag
     * }
     */
    public static MemorySegment Py_HashRandomizationFlag$segment() {
        return Py_HashRandomizationFlag$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_HashRandomizationFlag
     * }
     */
    public static int Py_HashRandomizationFlag() {
        return Py_HashRandomizationFlag$constants.SEGMENT.get(Py_HashRandomizationFlag$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_HashRandomizationFlag
     * }
     */
    public static void Py_HashRandomizationFlag(int varValue) {
        Py_HashRandomizationFlag$constants.SEGMENT.set(Py_HashRandomizationFlag$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_IsolatedFlag$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("Py_IsolatedFlag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int Py_IsolatedFlag
     * }
     */
    public static OfInt Py_IsolatedFlag$layout() {
        return Py_IsolatedFlag$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int Py_IsolatedFlag
     * }
     */
    public static MemorySegment Py_IsolatedFlag$segment() {
        return Py_IsolatedFlag$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int Py_IsolatedFlag
     * }
     */
    public static int Py_IsolatedFlag() {
        return Py_IsolatedFlag$constants.SEGMENT.get(Py_IsolatedFlag$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int Py_IsolatedFlag
     * }
     */
    public static void Py_IsolatedFlag(int varValue) {
        Py_IsolatedFlag$constants.SEGMENT.set(Py_IsolatedFlag$constants.LAYOUT, 0L, varValue);
    }

    private static class Py_GETENV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_GETENV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *Py_GETENV(const char *name)
     * }
     */
    public static FunctionDescriptor Py_GETENV$descriptor() {
        return Py_GETENV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *Py_GETENV(const char *name)
     * }
     */
    public static MethodHandle Py_GETENV$handle() {
        return Py_GETENV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *Py_GETENV(const char *name)
     * }
     */
    public static MemorySegment Py_GETENV$address() {
        return Py_GETENV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *Py_GETENV(const char *name)
     * }
     */
    public static MemorySegment Py_GETENV(MemorySegment name) {
        var mh$ = Py_GETENV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_GETENV", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyByteArray_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyByteArray_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyByteArray_Type
     * }
     */
    public static GroupLayout PyByteArray_Type$layout() {
        return PyByteArray_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyByteArray_Type
     * }
     */
    public static MemorySegment PyByteArray_Type() {
        return PyByteArray_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyByteArray_Type
     * }
     */
    public static void PyByteArray_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyByteArray_Type$constants.SEGMENT, 0L, PyByteArray_Type$constants.LAYOUT.byteSize());
    }

    private static class PyByteArrayIter_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyByteArrayIter_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyByteArrayIter_Type
     * }
     */
    public static GroupLayout PyByteArrayIter_Type$layout() {
        return PyByteArrayIter_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyByteArrayIter_Type
     * }
     */
    public static MemorySegment PyByteArrayIter_Type() {
        return PyByteArrayIter_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyByteArrayIter_Type
     * }
     */
    public static void PyByteArrayIter_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyByteArrayIter_Type$constants.SEGMENT, 0L, PyByteArrayIter_Type$constants.LAYOUT.byteSize());
    }

    private static class PyByteArray_FromObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyByteArray_FromObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyByteArray_FromObject(PyObject *)
     * }
     */
    public static FunctionDescriptor PyByteArray_FromObject$descriptor() {
        return PyByteArray_FromObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyByteArray_FromObject(PyObject *)
     * }
     */
    public static MethodHandle PyByteArray_FromObject$handle() {
        return PyByteArray_FromObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyByteArray_FromObject(PyObject *)
     * }
     */
    public static MemorySegment PyByteArray_FromObject$address() {
        return PyByteArray_FromObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyByteArray_FromObject(PyObject *)
     * }
     */
    public static MemorySegment PyByteArray_FromObject(MemorySegment x0) {
        var mh$ = PyByteArray_FromObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyByteArray_FromObject", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyByteArray_Concat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyByteArray_Concat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyByteArray_Concat(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor PyByteArray_Concat$descriptor() {
        return PyByteArray_Concat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyByteArray_Concat(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle PyByteArray_Concat$handle() {
        return PyByteArray_Concat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyByteArray_Concat(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyByteArray_Concat$address() {
        return PyByteArray_Concat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyByteArray_Concat(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment PyByteArray_Concat(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyByteArray_Concat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyByteArray_Concat", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyByteArray_FromStringAndSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyByteArray_FromStringAndSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyByteArray_FromStringAndSize(const char *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyByteArray_FromStringAndSize$descriptor() {
        return PyByteArray_FromStringAndSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyByteArray_FromStringAndSize(const char *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyByteArray_FromStringAndSize$handle() {
        return PyByteArray_FromStringAndSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyByteArray_FromStringAndSize(const char *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyByteArray_FromStringAndSize$address() {
        return PyByteArray_FromStringAndSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyByteArray_FromStringAndSize(const char *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyByteArray_FromStringAndSize(MemorySegment x0, long x1) {
        var mh$ = PyByteArray_FromStringAndSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyByteArray_FromStringAndSize", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyByteArray_Size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyByteArray_Size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyByteArray_Size(PyObject *)
     * }
     */
    public static FunctionDescriptor PyByteArray_Size$descriptor() {
        return PyByteArray_Size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyByteArray_Size(PyObject *)
     * }
     */
    public static MethodHandle PyByteArray_Size$handle() {
        return PyByteArray_Size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyByteArray_Size(PyObject *)
     * }
     */
    public static MemorySegment PyByteArray_Size$address() {
        return PyByteArray_Size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyByteArray_Size(PyObject *)
     * }
     */
    public static long PyByteArray_Size(MemorySegment x0) {
        var mh$ = PyByteArray_Size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyByteArray_Size", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyByteArray_AsString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyByteArray_AsString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *PyByteArray_AsString(PyObject *)
     * }
     */
    public static FunctionDescriptor PyByteArray_AsString$descriptor() {
        return PyByteArray_AsString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *PyByteArray_AsString(PyObject *)
     * }
     */
    public static MethodHandle PyByteArray_AsString$handle() {
        return PyByteArray_AsString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *PyByteArray_AsString(PyObject *)
     * }
     */
    public static MemorySegment PyByteArray_AsString$address() {
        return PyByteArray_AsString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *PyByteArray_AsString(PyObject *)
     * }
     */
    public static MemorySegment PyByteArray_AsString(MemorySegment x0) {
        var mh$ = PyByteArray_AsString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyByteArray_AsString", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyByteArray_Resize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyByteArray_Resize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyByteArray_Resize(PyObject *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyByteArray_Resize$descriptor() {
        return PyByteArray_Resize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyByteArray_Resize(PyObject *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyByteArray_Resize$handle() {
        return PyByteArray_Resize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyByteArray_Resize(PyObject *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyByteArray_Resize$address() {
        return PyByteArray_Resize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyByteArray_Resize(PyObject *, Py_ssize_t)
     * }
     */
    public static int PyByteArray_Resize(MemorySegment x0, long x1) {
        var mh$ = PyByteArray_Resize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyByteArray_Resize", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyByteArray_empty_string$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(0, Python_h.C_CHAR);
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_PyByteArray_empty_string").reinterpret(LAYOUT.byteSize());
        public static final VarHandle HANDLE = LAYOUT.varHandle();

        public static final long[] DIMS = {  };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char _PyByteArray_empty_string[]
     * }
     */
    public static SequenceLayout _PyByteArray_empty_string$layout() {
        return _PyByteArray_empty_string$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern char _PyByteArray_empty_string[]
     * }
     */
    public static long[] _PyByteArray_empty_string$dimensions() {
        return _PyByteArray_empty_string$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char _PyByteArray_empty_string[]
     * }
     */
    public static MemorySegment _PyByteArray_empty_string() {
        return _PyByteArray_empty_string$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char _PyByteArray_empty_string[]
     * }
     */
    public static void _PyByteArray_empty_string(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _PyByteArray_empty_string$constants.SEGMENT, 0L, _PyByteArray_empty_string$constants.LAYOUT.byteSize());
    }

    private static class PyBytes_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyBytes_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBytes_Type
     * }
     */
    public static GroupLayout PyBytes_Type$layout() {
        return PyBytes_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBytes_Type
     * }
     */
    public static MemorySegment PyBytes_Type() {
        return PyBytes_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBytes_Type
     * }
     */
    public static void PyBytes_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyBytes_Type$constants.SEGMENT, 0L, PyBytes_Type$constants.LAYOUT.byteSize());
    }

    private static class PyBytesIter_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyBytesIter_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBytesIter_Type
     * }
     */
    public static GroupLayout PyBytesIter_Type$layout() {
        return PyBytesIter_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBytesIter_Type
     * }
     */
    public static MemorySegment PyBytesIter_Type() {
        return PyBytesIter_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBytesIter_Type
     * }
     */
    public static void PyBytesIter_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyBytesIter_Type$constants.SEGMENT, 0L, PyBytesIter_Type$constants.LAYOUT.byteSize());
    }

    private static class PyBytes_FromStringAndSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_FromStringAndSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromStringAndSize(const char *, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyBytes_FromStringAndSize$descriptor() {
        return PyBytes_FromStringAndSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromStringAndSize(const char *, Py_ssize_t)
     * }
     */
    public static MethodHandle PyBytes_FromStringAndSize$handle() {
        return PyBytes_FromStringAndSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromStringAndSize(const char *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyBytes_FromStringAndSize$address() {
        return PyBytes_FromStringAndSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyBytes_FromStringAndSize(const char *, Py_ssize_t)
     * }
     */
    public static MemorySegment PyBytes_FromStringAndSize(MemorySegment x0, long x1) {
        var mh$ = PyBytes_FromStringAndSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBytes_FromStringAndSize", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBytes_FromString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_FromString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromString(const char *)
     * }
     */
    public static FunctionDescriptor PyBytes_FromString$descriptor() {
        return PyBytes_FromString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromString(const char *)
     * }
     */
    public static MethodHandle PyBytes_FromString$handle() {
        return PyBytes_FromString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromString(const char *)
     * }
     */
    public static MemorySegment PyBytes_FromString$address() {
        return PyBytes_FromString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyBytes_FromString(const char *)
     * }
     */
    public static MemorySegment PyBytes_FromString(MemorySegment x0) {
        var mh$ = PyBytes_FromString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBytes_FromString", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBytes_FromObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_FromObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromObject(PyObject *)
     * }
     */
    public static FunctionDescriptor PyBytes_FromObject$descriptor() {
        return PyBytes_FromObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromObject(PyObject *)
     * }
     */
    public static MethodHandle PyBytes_FromObject$handle() {
        return PyBytes_FromObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromObject(PyObject *)
     * }
     */
    public static MemorySegment PyBytes_FromObject$address() {
        return PyBytes_FromObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyBytes_FromObject(PyObject *)
     * }
     */
    public static MemorySegment PyBytes_FromObject(MemorySegment x0) {
        var mh$ = PyBytes_FromObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBytes_FromObject", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBytes_FromFormatV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_FromFormatV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromFormatV(const char *, va_list)
     * }
     */
    public static FunctionDescriptor PyBytes_FromFormatV$descriptor() {
        return PyBytes_FromFormatV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromFormatV(const char *, va_list)
     * }
     */
    public static MethodHandle PyBytes_FromFormatV$handle() {
        return PyBytes_FromFormatV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromFormatV(const char *, va_list)
     * }
     */
    public static MemorySegment PyBytes_FromFormatV$address() {
        return PyBytes_FromFormatV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyBytes_FromFormatV(const char *, va_list)
     * }
     */
    public static MemorySegment PyBytes_FromFormatV(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyBytes_FromFormatV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBytes_FromFormatV", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *PyBytes_FromFormat(const char *, ...)
     * }
     */
    public static class PyBytes_FromFormat {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_FromFormat");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyBytes_FromFormat(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *PyBytes_FromFormat(const char *, ...)
         * }
         */
        public static PyBytes_FromFormat makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyBytes_FromFormat(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyBytes_FromFormat", x0, x1);
                }
                return (MemorySegment)spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class PyBytes_Size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_Size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyBytes_Size(PyObject *)
     * }
     */
    public static FunctionDescriptor PyBytes_Size$descriptor() {
        return PyBytes_Size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyBytes_Size(PyObject *)
     * }
     */
    public static MethodHandle PyBytes_Size$handle() {
        return PyBytes_Size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyBytes_Size(PyObject *)
     * }
     */
    public static MemorySegment PyBytes_Size$address() {
        return PyBytes_Size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyBytes_Size(PyObject *)
     * }
     */
    public static long PyBytes_Size(MemorySegment x0) {
        var mh$ = PyBytes_Size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBytes_Size", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBytes_AsString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_AsString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *PyBytes_AsString(PyObject *)
     * }
     */
    public static FunctionDescriptor PyBytes_AsString$descriptor() {
        return PyBytes_AsString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *PyBytes_AsString(PyObject *)
     * }
     */
    public static MethodHandle PyBytes_AsString$handle() {
        return PyBytes_AsString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *PyBytes_AsString(PyObject *)
     * }
     */
    public static MemorySegment PyBytes_AsString$address() {
        return PyBytes_AsString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *PyBytes_AsString(PyObject *)
     * }
     */
    public static MemorySegment PyBytes_AsString(MemorySegment x0) {
        var mh$ = PyBytes_AsString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBytes_AsString", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBytes_Repr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_Repr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyBytes_Repr(PyObject *, int)
     * }
     */
    public static FunctionDescriptor PyBytes_Repr$descriptor() {
        return PyBytes_Repr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyBytes_Repr(PyObject *, int)
     * }
     */
    public static MethodHandle PyBytes_Repr$handle() {
        return PyBytes_Repr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyBytes_Repr(PyObject *, int)
     * }
     */
    public static MemorySegment PyBytes_Repr$address() {
        return PyBytes_Repr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyBytes_Repr(PyObject *, int)
     * }
     */
    public static MemorySegment PyBytes_Repr(MemorySegment x0, int x1) {
        var mh$ = PyBytes_Repr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBytes_Repr", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBytes_Concat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_Concat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyBytes_Concat(PyObject **, PyObject *)
     * }
     */
    public static FunctionDescriptor PyBytes_Concat$descriptor() {
        return PyBytes_Concat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyBytes_Concat(PyObject **, PyObject *)
     * }
     */
    public static MethodHandle PyBytes_Concat$handle() {
        return PyBytes_Concat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyBytes_Concat(PyObject **, PyObject *)
     * }
     */
    public static MemorySegment PyBytes_Concat$address() {
        return PyBytes_Concat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyBytes_Concat(PyObject **, PyObject *)
     * }
     */
    public static void PyBytes_Concat(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyBytes_Concat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBytes_Concat", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBytes_ConcatAndDel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_ConcatAndDel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyBytes_ConcatAndDel(PyObject **, PyObject *)
     * }
     */
    public static FunctionDescriptor PyBytes_ConcatAndDel$descriptor() {
        return PyBytes_ConcatAndDel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyBytes_ConcatAndDel(PyObject **, PyObject *)
     * }
     */
    public static MethodHandle PyBytes_ConcatAndDel$handle() {
        return PyBytes_ConcatAndDel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyBytes_ConcatAndDel(PyObject **, PyObject *)
     * }
     */
    public static MemorySegment PyBytes_ConcatAndDel$address() {
        return PyBytes_ConcatAndDel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyBytes_ConcatAndDel(PyObject **, PyObject *)
     * }
     */
    public static void PyBytes_ConcatAndDel(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyBytes_ConcatAndDel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBytes_ConcatAndDel", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBytes_DecodeEscape {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_DecodeEscape");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyBytes_DecodeEscape(const char *, Py_ssize_t, const char *, Py_ssize_t, const char *)
     * }
     */
    public static FunctionDescriptor PyBytes_DecodeEscape$descriptor() {
        return PyBytes_DecodeEscape.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyBytes_DecodeEscape(const char *, Py_ssize_t, const char *, Py_ssize_t, const char *)
     * }
     */
    public static MethodHandle PyBytes_DecodeEscape$handle() {
        return PyBytes_DecodeEscape.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyBytes_DecodeEscape(const char *, Py_ssize_t, const char *, Py_ssize_t, const char *)
     * }
     */
    public static MemorySegment PyBytes_DecodeEscape$address() {
        return PyBytes_DecodeEscape.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyBytes_DecodeEscape(const char *, Py_ssize_t, const char *, Py_ssize_t, const char *)
     * }
     */
    public static MemorySegment PyBytes_DecodeEscape(MemorySegment x0, long x1, MemorySegment x2, long x3, MemorySegment x4) {
        var mh$ = PyBytes_DecodeEscape.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBytes_DecodeEscape", x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBytes_AsStringAndSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBytes_AsStringAndSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyBytes_AsStringAndSize(PyObject *obj, char **s, Py_ssize_t *len)
     * }
     */
    public static FunctionDescriptor PyBytes_AsStringAndSize$descriptor() {
        return PyBytes_AsStringAndSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyBytes_AsStringAndSize(PyObject *obj, char **s, Py_ssize_t *len)
     * }
     */
    public static MethodHandle PyBytes_AsStringAndSize$handle() {
        return PyBytes_AsStringAndSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyBytes_AsStringAndSize(PyObject *obj, char **s, Py_ssize_t *len)
     * }
     */
    public static MemorySegment PyBytes_AsStringAndSize$address() {
        return PyBytes_AsStringAndSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyBytes_AsStringAndSize(PyObject *obj, char **s, Py_ssize_t *len)
     * }
     */
    public static int PyBytes_AsStringAndSize(MemorySegment obj, MemorySegment s, MemorySegment len) {
        var mh$ = PyBytes_AsStringAndSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBytes_AsStringAndSize", obj, s, len);
            }
            return (int)mh$.invokeExact(obj, s, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyBytes_Resize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyBytes_Resize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyBytes_Resize(PyObject **, Py_ssize_t)
     * }
     */
    public static FunctionDescriptor _PyBytes_Resize$descriptor() {
        return _PyBytes_Resize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyBytes_Resize(PyObject **, Py_ssize_t)
     * }
     */
    public static MethodHandle _PyBytes_Resize$handle() {
        return _PyBytes_Resize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyBytes_Resize(PyObject **, Py_ssize_t)
     * }
     */
    public static MemorySegment _PyBytes_Resize$address() {
        return _PyBytes_Resize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyBytes_Resize(PyObject **, Py_ssize_t)
     * }
     */
    public static int _PyBytes_Resize(MemorySegment x0, long x1) {
        var mh$ = _PyBytes_Resize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyBytes_Resize", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyBytes_FormatEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyBytes_FormatEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyBytes_FormatEx(const char *format, Py_ssize_t format_len, PyObject *args, int use_bytearray)
     * }
     */
    public static FunctionDescriptor _PyBytes_FormatEx$descriptor() {
        return _PyBytes_FormatEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyBytes_FormatEx(const char *format, Py_ssize_t format_len, PyObject *args, int use_bytearray)
     * }
     */
    public static MethodHandle _PyBytes_FormatEx$handle() {
        return _PyBytes_FormatEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyBytes_FormatEx(const char *format, Py_ssize_t format_len, PyObject *args, int use_bytearray)
     * }
     */
    public static MemorySegment _PyBytes_FormatEx$address() {
        return _PyBytes_FormatEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyBytes_FormatEx(const char *format, Py_ssize_t format_len, PyObject *args, int use_bytearray)
     * }
     */
    public static MemorySegment _PyBytes_FormatEx(MemorySegment format, long format_len, MemorySegment args, int use_bytearray) {
        var mh$ = _PyBytes_FormatEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyBytes_FormatEx", format, format_len, args, use_bytearray);
            }
            return (MemorySegment)mh$.invokeExact(format, format_len, args, use_bytearray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyBytes_FromHex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyBytes_FromHex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyBytes_FromHex(PyObject *string, int use_bytearray)
     * }
     */
    public static FunctionDescriptor _PyBytes_FromHex$descriptor() {
        return _PyBytes_FromHex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyBytes_FromHex(PyObject *string, int use_bytearray)
     * }
     */
    public static MethodHandle _PyBytes_FromHex$handle() {
        return _PyBytes_FromHex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyBytes_FromHex(PyObject *string, int use_bytearray)
     * }
     */
    public static MemorySegment _PyBytes_FromHex$address() {
        return _PyBytes_FromHex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyBytes_FromHex(PyObject *string, int use_bytearray)
     * }
     */
    public static MemorySegment _PyBytes_FromHex(MemorySegment string, int use_bytearray) {
        var mh$ = _PyBytes_FromHex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyBytes_FromHex", string, use_bytearray);
            }
            return (MemorySegment)mh$.invokeExact(string, use_bytearray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyBytes_DecodeEscape {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyBytes_DecodeEscape");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyBytes_DecodeEscape(const char *, Py_ssize_t, const char *, const char **)
     * }
     */
    public static FunctionDescriptor _PyBytes_DecodeEscape$descriptor() {
        return _PyBytes_DecodeEscape.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyBytes_DecodeEscape(const char *, Py_ssize_t, const char *, const char **)
     * }
     */
    public static MethodHandle _PyBytes_DecodeEscape$handle() {
        return _PyBytes_DecodeEscape.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyBytes_DecodeEscape(const char *, Py_ssize_t, const char *, const char **)
     * }
     */
    public static MemorySegment _PyBytes_DecodeEscape$address() {
        return _PyBytes_DecodeEscape.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyBytes_DecodeEscape(const char *, Py_ssize_t, const char *, const char **)
     * }
     */
    public static MemorySegment _PyBytes_DecodeEscape(MemorySegment x0, long x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = _PyBytes_DecodeEscape.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyBytes_DecodeEscape", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyBytes_Join {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyBytes_Join");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyBytes_Join(PyObject *sep, PyObject *x)
     * }
     */
    public static FunctionDescriptor _PyBytes_Join$descriptor() {
        return _PyBytes_Join.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyBytes_Join(PyObject *sep, PyObject *x)
     * }
     */
    public static MethodHandle _PyBytes_Join$handle() {
        return _PyBytes_Join.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyBytes_Join(PyObject *sep, PyObject *x)
     * }
     */
    public static MemorySegment _PyBytes_Join$address() {
        return _PyBytes_Join.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyBytes_Join(PyObject *sep, PyObject *x)
     * }
     */
    public static MemorySegment _PyBytes_Join(MemorySegment sep, MemorySegment x) {
        var mh$ = _PyBytes_Join.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyBytes_Join", sep, x);
            }
            return (MemorySegment)mh$.invokeExact(sep, x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyBytesWriter_Init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyBytesWriter_Init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyBytesWriter_Init(_PyBytesWriter *writer)
     * }
     */
    public static FunctionDescriptor _PyBytesWriter_Init$descriptor() {
        return _PyBytesWriter_Init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyBytesWriter_Init(_PyBytesWriter *writer)
     * }
     */
    public static MethodHandle _PyBytesWriter_Init$handle() {
        return _PyBytesWriter_Init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyBytesWriter_Init(_PyBytesWriter *writer)
     * }
     */
    public static MemorySegment _PyBytesWriter_Init$address() {
        return _PyBytesWriter_Init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyBytesWriter_Init(_PyBytesWriter *writer)
     * }
     */
    public static void _PyBytesWriter_Init(MemorySegment writer) {
        var mh$ = _PyBytesWriter_Init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyBytesWriter_Init", writer);
            }
            mh$.invokeExact(writer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyBytesWriter_Finish {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyBytesWriter_Finish");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyBytesWriter_Finish(_PyBytesWriter *writer, void *str)
     * }
     */
    public static FunctionDescriptor _PyBytesWriter_Finish$descriptor() {
        return _PyBytesWriter_Finish.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyBytesWriter_Finish(_PyBytesWriter *writer, void *str)
     * }
     */
    public static MethodHandle _PyBytesWriter_Finish$handle() {
        return _PyBytesWriter_Finish.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyBytesWriter_Finish(_PyBytesWriter *writer, void *str)
     * }
     */
    public static MemorySegment _PyBytesWriter_Finish$address() {
        return _PyBytesWriter_Finish.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyBytesWriter_Finish(_PyBytesWriter *writer, void *str)
     * }
     */
    public static MemorySegment _PyBytesWriter_Finish(MemorySegment writer, MemorySegment str) {
        var mh$ = _PyBytesWriter_Finish.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyBytesWriter_Finish", writer, str);
            }
            return (MemorySegment)mh$.invokeExact(writer, str);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyBytesWriter_Dealloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyBytesWriter_Dealloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyBytesWriter_Dealloc(_PyBytesWriter *writer)
     * }
     */
    public static FunctionDescriptor _PyBytesWriter_Dealloc$descriptor() {
        return _PyBytesWriter_Dealloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyBytesWriter_Dealloc(_PyBytesWriter *writer)
     * }
     */
    public static MethodHandle _PyBytesWriter_Dealloc$handle() {
        return _PyBytesWriter_Dealloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyBytesWriter_Dealloc(_PyBytesWriter *writer)
     * }
     */
    public static MemorySegment _PyBytesWriter_Dealloc$address() {
        return _PyBytesWriter_Dealloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyBytesWriter_Dealloc(_PyBytesWriter *writer)
     * }
     */
    public static void _PyBytesWriter_Dealloc(MemorySegment writer) {
        var mh$ = _PyBytesWriter_Dealloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyBytesWriter_Dealloc", writer);
            }
            mh$.invokeExact(writer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyBytesWriter_Alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyBytesWriter_Alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_PyBytesWriter_Alloc(_PyBytesWriter *writer, Py_ssize_t size)
     * }
     */
    public static FunctionDescriptor _PyBytesWriter_Alloc$descriptor() {
        return _PyBytesWriter_Alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_PyBytesWriter_Alloc(_PyBytesWriter *writer, Py_ssize_t size)
     * }
     */
    public static MethodHandle _PyBytesWriter_Alloc$handle() {
        return _PyBytesWriter_Alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_PyBytesWriter_Alloc(_PyBytesWriter *writer, Py_ssize_t size)
     * }
     */
    public static MemorySegment _PyBytesWriter_Alloc$address() {
        return _PyBytesWriter_Alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_PyBytesWriter_Alloc(_PyBytesWriter *writer, Py_ssize_t size)
     * }
     */
    public static MemorySegment _PyBytesWriter_Alloc(MemorySegment writer, long size) {
        var mh$ = _PyBytesWriter_Alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyBytesWriter_Alloc", writer, size);
            }
            return (MemorySegment)mh$.invokeExact(writer, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyBytesWriter_Prepare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyBytesWriter_Prepare");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_PyBytesWriter_Prepare(_PyBytesWriter *writer, void *str, Py_ssize_t size)
     * }
     */
    public static FunctionDescriptor _PyBytesWriter_Prepare$descriptor() {
        return _PyBytesWriter_Prepare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_PyBytesWriter_Prepare(_PyBytesWriter *writer, void *str, Py_ssize_t size)
     * }
     */
    public static MethodHandle _PyBytesWriter_Prepare$handle() {
        return _PyBytesWriter_Prepare.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_PyBytesWriter_Prepare(_PyBytesWriter *writer, void *str, Py_ssize_t size)
     * }
     */
    public static MemorySegment _PyBytesWriter_Prepare$address() {
        return _PyBytesWriter_Prepare.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_PyBytesWriter_Prepare(_PyBytesWriter *writer, void *str, Py_ssize_t size)
     * }
     */
    public static MemorySegment _PyBytesWriter_Prepare(MemorySegment writer, MemorySegment str, long size) {
        var mh$ = _PyBytesWriter_Prepare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyBytesWriter_Prepare", writer, str, size);
            }
            return (MemorySegment)mh$.invokeExact(writer, str, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyBytesWriter_Resize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyBytesWriter_Resize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_PyBytesWriter_Resize(_PyBytesWriter *writer, void *str, Py_ssize_t size)
     * }
     */
    public static FunctionDescriptor _PyBytesWriter_Resize$descriptor() {
        return _PyBytesWriter_Resize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_PyBytesWriter_Resize(_PyBytesWriter *writer, void *str, Py_ssize_t size)
     * }
     */
    public static MethodHandle _PyBytesWriter_Resize$handle() {
        return _PyBytesWriter_Resize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_PyBytesWriter_Resize(_PyBytesWriter *writer, void *str, Py_ssize_t size)
     * }
     */
    public static MemorySegment _PyBytesWriter_Resize$address() {
        return _PyBytesWriter_Resize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_PyBytesWriter_Resize(_PyBytesWriter *writer, void *str, Py_ssize_t size)
     * }
     */
    public static MemorySegment _PyBytesWriter_Resize(MemorySegment writer, MemorySegment str, long size) {
        var mh$ = _PyBytesWriter_Resize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyBytesWriter_Resize", writer, str, size);
            }
            return (MemorySegment)mh$.invokeExact(writer, str, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyBytesWriter_WriteBytes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyBytesWriter_WriteBytes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_PyBytesWriter_WriteBytes(_PyBytesWriter *writer, void *str, const void *bytes, Py_ssize_t size)
     * }
     */
    public static FunctionDescriptor _PyBytesWriter_WriteBytes$descriptor() {
        return _PyBytesWriter_WriteBytes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_PyBytesWriter_WriteBytes(_PyBytesWriter *writer, void *str, const void *bytes, Py_ssize_t size)
     * }
     */
    public static MethodHandle _PyBytesWriter_WriteBytes$handle() {
        return _PyBytesWriter_WriteBytes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_PyBytesWriter_WriteBytes(_PyBytesWriter *writer, void *str, const void *bytes, Py_ssize_t size)
     * }
     */
    public static MemorySegment _PyBytesWriter_WriteBytes$address() {
        return _PyBytesWriter_WriteBytes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_PyBytesWriter_WriteBytes(_PyBytesWriter *writer, void *str, const void *bytes, Py_ssize_t size)
     * }
     */
    public static MemorySegment _PyBytesWriter_WriteBytes(MemorySegment writer, MemorySegment str, MemorySegment bytes, long size) {
        var mh$ = _PyBytesWriter_WriteBytes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyBytesWriter_WriteBytes", writer, str, bytes, size);
            }
            return (MemorySegment)mh$.invokeExact(writer, str, bytes, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef uint32_t Py_UCS4
     * }
     */
    public static final OfInt Py_UCS4 = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint16_t Py_UCS2
     * }
     */
    public static final OfShort Py_UCS2 = Python_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint8_t Py_UCS1
     * }
     */
    public static final OfByte Py_UCS1 = Python_h.C_CHAR;

    private static class PyUnicode_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyUnicode_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyUnicode_Type
     * }
     */
    public static GroupLayout PyUnicode_Type$layout() {
        return PyUnicode_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyUnicode_Type
     * }
     */
    public static MemorySegment PyUnicode_Type() {
        return PyUnicode_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyUnicode_Type
     * }
     */
    public static void PyUnicode_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyUnicode_Type$constants.SEGMENT, 0L, PyUnicode_Type$constants.LAYOUT.byteSize());
    }

    private static class PyUnicodeIter_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyUnicodeIter_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyUnicodeIter_Type
     * }
     */
    public static GroupLayout PyUnicodeIter_Type$layout() {
        return PyUnicodeIter_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyUnicodeIter_Type
     * }
     */
    public static MemorySegment PyUnicodeIter_Type() {
        return PyUnicodeIter_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyUnicodeIter_Type
     * }
     */
    public static void PyUnicodeIter_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyUnicodeIter_Type$constants.SEGMENT, 0L, PyUnicodeIter_Type$constants.LAYOUT.byteSize());
    }

    private static class PyUnicode_FromStringAndSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FromStringAndSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromStringAndSize(const char *u, Py_ssize_t size)
     * }
     */
    public static FunctionDescriptor PyUnicode_FromStringAndSize$descriptor() {
        return PyUnicode_FromStringAndSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromStringAndSize(const char *u, Py_ssize_t size)
     * }
     */
    public static MethodHandle PyUnicode_FromStringAndSize$handle() {
        return PyUnicode_FromStringAndSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromStringAndSize(const char *u, Py_ssize_t size)
     * }
     */
    public static MemorySegment PyUnicode_FromStringAndSize$address() {
        return PyUnicode_FromStringAndSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromStringAndSize(const char *u, Py_ssize_t size)
     * }
     */
    public static MemorySegment PyUnicode_FromStringAndSize(MemorySegment u, long size) {
        var mh$ = PyUnicode_FromStringAndSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_FromStringAndSize", u, size);
            }
            return (MemorySegment)mh$.invokeExact(u, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_FromString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FromString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromString(const char *u)
     * }
     */
    public static FunctionDescriptor PyUnicode_FromString$descriptor() {
        return PyUnicode_FromString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromString(const char *u)
     * }
     */
    public static MethodHandle PyUnicode_FromString$handle() {
        return PyUnicode_FromString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromString(const char *u)
     * }
     */
    public static MemorySegment PyUnicode_FromString$address() {
        return PyUnicode_FromString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromString(const char *u)
     * }
     */
    public static MemorySegment PyUnicode_FromString(MemorySegment u) {
        var mh$ = PyUnicode_FromString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_FromString", u);
            }
            return (MemorySegment)mh$.invokeExact(u);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Substring {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Substring");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Substring(PyObject *str, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static FunctionDescriptor PyUnicode_Substring$descriptor() {
        return PyUnicode_Substring.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Substring(PyObject *str, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static MethodHandle PyUnicode_Substring$handle() {
        return PyUnicode_Substring.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Substring(PyObject *str, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static MemorySegment PyUnicode_Substring$address() {
        return PyUnicode_Substring.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_Substring(PyObject *str, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static MemorySegment PyUnicode_Substring(MemorySegment str, long start, long end) {
        var mh$ = PyUnicode_Substring.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Substring", str, start, end);
            }
            return (MemorySegment)mh$.invokeExact(str, start, end);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsUCS4 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsUCS4");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_UCS4 *PyUnicode_AsUCS4(PyObject *unicode, Py_UCS4 *buffer, Py_ssize_t buflen, int copy_null)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsUCS4$descriptor() {
        return PyUnicode_AsUCS4.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_UCS4 *PyUnicode_AsUCS4(PyObject *unicode, Py_UCS4 *buffer, Py_ssize_t buflen, int copy_null)
     * }
     */
    public static MethodHandle PyUnicode_AsUCS4$handle() {
        return PyUnicode_AsUCS4.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_UCS4 *PyUnicode_AsUCS4(PyObject *unicode, Py_UCS4 *buffer, Py_ssize_t buflen, int copy_null)
     * }
     */
    public static MemorySegment PyUnicode_AsUCS4$address() {
        return PyUnicode_AsUCS4.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_UCS4 *PyUnicode_AsUCS4(PyObject *unicode, Py_UCS4 *buffer, Py_ssize_t buflen, int copy_null)
     * }
     */
    public static MemorySegment PyUnicode_AsUCS4(MemorySegment unicode, MemorySegment buffer, long buflen, int copy_null) {
        var mh$ = PyUnicode_AsUCS4.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsUCS4", unicode, buffer, buflen, copy_null);
            }
            return (MemorySegment)mh$.invokeExact(unicode, buffer, buflen, copy_null);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsUCS4Copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsUCS4Copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_UCS4 *PyUnicode_AsUCS4Copy(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsUCS4Copy$descriptor() {
        return PyUnicode_AsUCS4Copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_UCS4 *PyUnicode_AsUCS4Copy(PyObject *unicode)
     * }
     */
    public static MethodHandle PyUnicode_AsUCS4Copy$handle() {
        return PyUnicode_AsUCS4Copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_UCS4 *PyUnicode_AsUCS4Copy(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsUCS4Copy$address() {
        return PyUnicode_AsUCS4Copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_UCS4 *PyUnicode_AsUCS4Copy(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsUCS4Copy(MemorySegment unicode) {
        var mh$ = PyUnicode_AsUCS4Copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsUCS4Copy", unicode);
            }
            return (MemorySegment)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_GetLength {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_GetLength");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_GetLength(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor PyUnicode_GetLength$descriptor() {
        return PyUnicode_GetLength.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_GetLength(PyObject *unicode)
     * }
     */
    public static MethodHandle PyUnicode_GetLength$handle() {
        return PyUnicode_GetLength.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_GetLength(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_GetLength$address() {
        return PyUnicode_GetLength.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_GetLength(PyObject *unicode)
     * }
     */
    public static long PyUnicode_GetLength(MemorySegment unicode) {
        var mh$ = PyUnicode_GetLength.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_GetLength", unicode);
            }
            return (long)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_GetSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_GetSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_GetSize(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor PyUnicode_GetSize$descriptor() {
        return PyUnicode_GetSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_GetSize(PyObject *unicode)
     * }
     */
    public static MethodHandle PyUnicode_GetSize$handle() {
        return PyUnicode_GetSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_GetSize(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_GetSize$address() {
        return PyUnicode_GetSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_GetSize(PyObject *unicode)
     * }
     */
    public static long PyUnicode_GetSize(MemorySegment unicode) {
        var mh$ = PyUnicode_GetSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_GetSize", unicode);
            }
            return (long)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_ReadChar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_ReadChar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_UCS4 PyUnicode_ReadChar(PyObject *unicode, Py_ssize_t index)
     * }
     */
    public static FunctionDescriptor PyUnicode_ReadChar$descriptor() {
        return PyUnicode_ReadChar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_UCS4 PyUnicode_ReadChar(PyObject *unicode, Py_ssize_t index)
     * }
     */
    public static MethodHandle PyUnicode_ReadChar$handle() {
        return PyUnicode_ReadChar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_UCS4 PyUnicode_ReadChar(PyObject *unicode, Py_ssize_t index)
     * }
     */
    public static MemorySegment PyUnicode_ReadChar$address() {
        return PyUnicode_ReadChar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_UCS4 PyUnicode_ReadChar(PyObject *unicode, Py_ssize_t index)
     * }
     */
    public static int PyUnicode_ReadChar(MemorySegment unicode, long index) {
        var mh$ = PyUnicode_ReadChar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_ReadChar", unicode, index);
            }
            return (int)mh$.invokeExact(unicode, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_WriteChar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_WriteChar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicode_WriteChar(PyObject *unicode, Py_ssize_t index, Py_UCS4 character)
     * }
     */
    public static FunctionDescriptor PyUnicode_WriteChar$descriptor() {
        return PyUnicode_WriteChar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicode_WriteChar(PyObject *unicode, Py_ssize_t index, Py_UCS4 character)
     * }
     */
    public static MethodHandle PyUnicode_WriteChar$handle() {
        return PyUnicode_WriteChar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicode_WriteChar(PyObject *unicode, Py_ssize_t index, Py_UCS4 character)
     * }
     */
    public static MemorySegment PyUnicode_WriteChar$address() {
        return PyUnicode_WriteChar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicode_WriteChar(PyObject *unicode, Py_ssize_t index, Py_UCS4 character)
     * }
     */
    public static int PyUnicode_WriteChar(MemorySegment unicode, long index, int character) {
        var mh$ = PyUnicode_WriteChar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_WriteChar", unicode, index, character);
            }
            return (int)mh$.invokeExact(unicode, index, character);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Resize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Resize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicode_Resize(PyObject **unicode, Py_ssize_t length)
     * }
     */
    public static FunctionDescriptor PyUnicode_Resize$descriptor() {
        return PyUnicode_Resize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicode_Resize(PyObject **unicode, Py_ssize_t length)
     * }
     */
    public static MethodHandle PyUnicode_Resize$handle() {
        return PyUnicode_Resize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicode_Resize(PyObject **unicode, Py_ssize_t length)
     * }
     */
    public static MemorySegment PyUnicode_Resize$address() {
        return PyUnicode_Resize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicode_Resize(PyObject **unicode, Py_ssize_t length)
     * }
     */
    public static int PyUnicode_Resize(MemorySegment unicode, long length) {
        var mh$ = PyUnicode_Resize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Resize", unicode, length);
            }
            return (int)mh$.invokeExact(unicode, length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_FromEncodedObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FromEncodedObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromEncodedObject(PyObject *obj, const char *encoding, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_FromEncodedObject$descriptor() {
        return PyUnicode_FromEncodedObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromEncodedObject(PyObject *obj, const char *encoding, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_FromEncodedObject$handle() {
        return PyUnicode_FromEncodedObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromEncodedObject(PyObject *obj, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_FromEncodedObject$address() {
        return PyUnicode_FromEncodedObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromEncodedObject(PyObject *obj, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_FromEncodedObject(MemorySegment obj, MemorySegment encoding, MemorySegment errors) {
        var mh$ = PyUnicode_FromEncodedObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_FromEncodedObject", obj, encoding, errors);
            }
            return (MemorySegment)mh$.invokeExact(obj, encoding, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_FromObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FromObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromObject(PyObject *obj)
     * }
     */
    public static FunctionDescriptor PyUnicode_FromObject$descriptor() {
        return PyUnicode_FromObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromObject(PyObject *obj)
     * }
     */
    public static MethodHandle PyUnicode_FromObject$handle() {
        return PyUnicode_FromObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromObject(PyObject *obj)
     * }
     */
    public static MemorySegment PyUnicode_FromObject$address() {
        return PyUnicode_FromObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromObject(PyObject *obj)
     * }
     */
    public static MemorySegment PyUnicode_FromObject(MemorySegment obj) {
        var mh$ = PyUnicode_FromObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_FromObject", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_FromFormatV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FromFormatV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromFormatV(const char *format, va_list vargs)
     * }
     */
    public static FunctionDescriptor PyUnicode_FromFormatV$descriptor() {
        return PyUnicode_FromFormatV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromFormatV(const char *format, va_list vargs)
     * }
     */
    public static MethodHandle PyUnicode_FromFormatV$handle() {
        return PyUnicode_FromFormatV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromFormatV(const char *format, va_list vargs)
     * }
     */
    public static MemorySegment PyUnicode_FromFormatV$address() {
        return PyUnicode_FromFormatV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromFormatV(const char *format, va_list vargs)
     * }
     */
    public static MemorySegment PyUnicode_FromFormatV(MemorySegment format, MemorySegment vargs) {
        var mh$ = PyUnicode_FromFormatV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_FromFormatV", format, vargs);
            }
            return (MemorySegment)mh$.invokeExact(format, vargs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromFormat(const char *format, ...)
     * }
     */
    public static class PyUnicode_FromFormat {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FromFormat");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private PyUnicode_FromFormat(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * PyObject *PyUnicode_FromFormat(const char *format, ...)
         * }
         */
        public static PyUnicode_FromFormat makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new PyUnicode_FromFormat(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("PyUnicode_FromFormat", format, x1);
                }
                return (MemorySegment)spreader.invokeExact(format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class PyUnicode_InternInPlace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_InternInPlace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyUnicode_InternInPlace(PyObject **)
     * }
     */
    public static FunctionDescriptor PyUnicode_InternInPlace$descriptor() {
        return PyUnicode_InternInPlace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyUnicode_InternInPlace(PyObject **)
     * }
     */
    public static MethodHandle PyUnicode_InternInPlace$handle() {
        return PyUnicode_InternInPlace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyUnicode_InternInPlace(PyObject **)
     * }
     */
    public static MemorySegment PyUnicode_InternInPlace$address() {
        return PyUnicode_InternInPlace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyUnicode_InternInPlace(PyObject **)
     * }
     */
    public static void PyUnicode_InternInPlace(MemorySegment x0) {
        var mh$ = PyUnicode_InternInPlace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_InternInPlace", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_InternFromString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_InternFromString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_InternFromString(const char *u)
     * }
     */
    public static FunctionDescriptor PyUnicode_InternFromString$descriptor() {
        return PyUnicode_InternFromString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_InternFromString(const char *u)
     * }
     */
    public static MethodHandle PyUnicode_InternFromString$handle() {
        return PyUnicode_InternFromString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_InternFromString(const char *u)
     * }
     */
    public static MemorySegment PyUnicode_InternFromString$address() {
        return PyUnicode_InternFromString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_InternFromString(const char *u)
     * }
     */
    public static MemorySegment PyUnicode_InternFromString(MemorySegment u) {
        var mh$ = PyUnicode_InternFromString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_InternFromString", u);
            }
            return (MemorySegment)mh$.invokeExact(u);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_InternImmortal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_InternImmortal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyUnicode_InternImmortal(PyObject **)
     * }
     */
    public static FunctionDescriptor PyUnicode_InternImmortal$descriptor() {
        return PyUnicode_InternImmortal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyUnicode_InternImmortal(PyObject **)
     * }
     */
    public static MethodHandle PyUnicode_InternImmortal$handle() {
        return PyUnicode_InternImmortal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyUnicode_InternImmortal(PyObject **)
     * }
     */
    public static MemorySegment PyUnicode_InternImmortal$address() {
        return PyUnicode_InternImmortal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyUnicode_InternImmortal(PyObject **)
     * }
     */
    public static void PyUnicode_InternImmortal(MemorySegment x0) {
        var mh$ = PyUnicode_InternImmortal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_InternImmortal", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_FromWideChar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FromWideChar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromWideChar(const wchar_t *w, Py_ssize_t size)
     * }
     */
    public static FunctionDescriptor PyUnicode_FromWideChar$descriptor() {
        return PyUnicode_FromWideChar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromWideChar(const wchar_t *w, Py_ssize_t size)
     * }
     */
    public static MethodHandle PyUnicode_FromWideChar$handle() {
        return PyUnicode_FromWideChar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromWideChar(const wchar_t *w, Py_ssize_t size)
     * }
     */
    public static MemorySegment PyUnicode_FromWideChar$address() {
        return PyUnicode_FromWideChar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromWideChar(const wchar_t *w, Py_ssize_t size)
     * }
     */
    public static MemorySegment PyUnicode_FromWideChar(MemorySegment w, long size) {
        var mh$ = PyUnicode_FromWideChar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_FromWideChar", w, size);
            }
            return (MemorySegment)mh$.invokeExact(w, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsWideChar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsWideChar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_AsWideChar(PyObject *unicode, wchar_t *w, Py_ssize_t size)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsWideChar$descriptor() {
        return PyUnicode_AsWideChar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_AsWideChar(PyObject *unicode, wchar_t *w, Py_ssize_t size)
     * }
     */
    public static MethodHandle PyUnicode_AsWideChar$handle() {
        return PyUnicode_AsWideChar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_AsWideChar(PyObject *unicode, wchar_t *w, Py_ssize_t size)
     * }
     */
    public static MemorySegment PyUnicode_AsWideChar$address() {
        return PyUnicode_AsWideChar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_AsWideChar(PyObject *unicode, wchar_t *w, Py_ssize_t size)
     * }
     */
    public static long PyUnicode_AsWideChar(MemorySegment unicode, MemorySegment w, long size) {
        var mh$ = PyUnicode_AsWideChar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsWideChar", unicode, w, size);
            }
            return (long)mh$.invokeExact(unicode, w, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsWideCharString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsWideCharString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *PyUnicode_AsWideCharString(PyObject *unicode, Py_ssize_t *size)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsWideCharString$descriptor() {
        return PyUnicode_AsWideCharString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *PyUnicode_AsWideCharString(PyObject *unicode, Py_ssize_t *size)
     * }
     */
    public static MethodHandle PyUnicode_AsWideCharString$handle() {
        return PyUnicode_AsWideCharString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *PyUnicode_AsWideCharString(PyObject *unicode, Py_ssize_t *size)
     * }
     */
    public static MemorySegment PyUnicode_AsWideCharString$address() {
        return PyUnicode_AsWideCharString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *PyUnicode_AsWideCharString(PyObject *unicode, Py_ssize_t *size)
     * }
     */
    public static MemorySegment PyUnicode_AsWideCharString(MemorySegment unicode, MemorySegment size) {
        var mh$ = PyUnicode_AsWideCharString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsWideCharString", unicode, size);
            }
            return (MemorySegment)mh$.invokeExact(unicode, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_FromOrdinal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FromOrdinal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromOrdinal(int ordinal)
     * }
     */
    public static FunctionDescriptor PyUnicode_FromOrdinal$descriptor() {
        return PyUnicode_FromOrdinal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromOrdinal(int ordinal)
     * }
     */
    public static MethodHandle PyUnicode_FromOrdinal$handle() {
        return PyUnicode_FromOrdinal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromOrdinal(int ordinal)
     * }
     */
    public static MemorySegment PyUnicode_FromOrdinal$address() {
        return PyUnicode_FromOrdinal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromOrdinal(int ordinal)
     * }
     */
    public static MemorySegment PyUnicode_FromOrdinal(int ordinal) {
        var mh$ = PyUnicode_FromOrdinal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_FromOrdinal", ordinal);
            }
            return (MemorySegment)mh$.invokeExact(ordinal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_GetDefaultEncoding {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_GetDefaultEncoding");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *PyUnicode_GetDefaultEncoding()
     * }
     */
    public static FunctionDescriptor PyUnicode_GetDefaultEncoding$descriptor() {
        return PyUnicode_GetDefaultEncoding.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *PyUnicode_GetDefaultEncoding()
     * }
     */
    public static MethodHandle PyUnicode_GetDefaultEncoding$handle() {
        return PyUnicode_GetDefaultEncoding.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *PyUnicode_GetDefaultEncoding()
     * }
     */
    public static MemorySegment PyUnicode_GetDefaultEncoding$address() {
        return PyUnicode_GetDefaultEncoding.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *PyUnicode_GetDefaultEncoding()
     * }
     */
    public static MemorySegment PyUnicode_GetDefaultEncoding() {
        var mh$ = PyUnicode_GetDefaultEncoding.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_GetDefaultEncoding");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Decode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Decode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Decode(const char *s, Py_ssize_t size, const char *encoding, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_Decode$descriptor() {
        return PyUnicode_Decode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Decode(const char *s, Py_ssize_t size, const char *encoding, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_Decode$handle() {
        return PyUnicode_Decode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Decode(const char *s, Py_ssize_t size, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_Decode$address() {
        return PyUnicode_Decode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_Decode(const char *s, Py_ssize_t size, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_Decode(MemorySegment s, long size, MemorySegment encoding, MemorySegment errors) {
        var mh$ = PyUnicode_Decode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Decode", s, size, encoding, errors);
            }
            return (MemorySegment)mh$.invokeExact(s, size, encoding, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsDecodedObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsDecodedObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsDecodedObject(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsDecodedObject$descriptor() {
        return PyUnicode_AsDecodedObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsDecodedObject(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_AsDecodedObject$handle() {
        return PyUnicode_AsDecodedObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsDecodedObject(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_AsDecodedObject$address() {
        return PyUnicode_AsDecodedObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsDecodedObject(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_AsDecodedObject(MemorySegment unicode, MemorySegment encoding, MemorySegment errors) {
        var mh$ = PyUnicode_AsDecodedObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsDecodedObject", unicode, encoding, errors);
            }
            return (MemorySegment)mh$.invokeExact(unicode, encoding, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsDecodedUnicode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsDecodedUnicode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsDecodedUnicode(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsDecodedUnicode$descriptor() {
        return PyUnicode_AsDecodedUnicode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsDecodedUnicode(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_AsDecodedUnicode$handle() {
        return PyUnicode_AsDecodedUnicode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsDecodedUnicode(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_AsDecodedUnicode$address() {
        return PyUnicode_AsDecodedUnicode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsDecodedUnicode(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_AsDecodedUnicode(MemorySegment unicode, MemorySegment encoding, MemorySegment errors) {
        var mh$ = PyUnicode_AsDecodedUnicode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsDecodedUnicode", unicode, encoding, errors);
            }
            return (MemorySegment)mh$.invokeExact(unicode, encoding, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsEncodedObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsEncodedObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedObject(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsEncodedObject$descriptor() {
        return PyUnicode_AsEncodedObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedObject(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_AsEncodedObject$handle() {
        return PyUnicode_AsEncodedObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedObject(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_AsEncodedObject$address() {
        return PyUnicode_AsEncodedObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedObject(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_AsEncodedObject(MemorySegment unicode, MemorySegment encoding, MemorySegment errors) {
        var mh$ = PyUnicode_AsEncodedObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsEncodedObject", unicode, encoding, errors);
            }
            return (MemorySegment)mh$.invokeExact(unicode, encoding, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsEncodedString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsEncodedString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedString(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsEncodedString$descriptor() {
        return PyUnicode_AsEncodedString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedString(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_AsEncodedString$handle() {
        return PyUnicode_AsEncodedString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedString(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_AsEncodedString$address() {
        return PyUnicode_AsEncodedString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedString(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_AsEncodedString(MemorySegment unicode, MemorySegment encoding, MemorySegment errors) {
        var mh$ = PyUnicode_AsEncodedString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsEncodedString", unicode, encoding, errors);
            }
            return (MemorySegment)mh$.invokeExact(unicode, encoding, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsEncodedUnicode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsEncodedUnicode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedUnicode(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsEncodedUnicode$descriptor() {
        return PyUnicode_AsEncodedUnicode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedUnicode(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_AsEncodedUnicode$handle() {
        return PyUnicode_AsEncodedUnicode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedUnicode(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_AsEncodedUnicode$address() {
        return PyUnicode_AsEncodedUnicode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsEncodedUnicode(PyObject *unicode, const char *encoding, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_AsEncodedUnicode(MemorySegment unicode, MemorySegment encoding, MemorySegment errors) {
        var mh$ = PyUnicode_AsEncodedUnicode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsEncodedUnicode", unicode, encoding, errors);
            }
            return (MemorySegment)mh$.invokeExact(unicode, encoding, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_BuildEncodingMap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_BuildEncodingMap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_BuildEncodingMap(PyObject *string)
     * }
     */
    public static FunctionDescriptor PyUnicode_BuildEncodingMap$descriptor() {
        return PyUnicode_BuildEncodingMap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_BuildEncodingMap(PyObject *string)
     * }
     */
    public static MethodHandle PyUnicode_BuildEncodingMap$handle() {
        return PyUnicode_BuildEncodingMap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_BuildEncodingMap(PyObject *string)
     * }
     */
    public static MemorySegment PyUnicode_BuildEncodingMap$address() {
        return PyUnicode_BuildEncodingMap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_BuildEncodingMap(PyObject *string)
     * }
     */
    public static MemorySegment PyUnicode_BuildEncodingMap(MemorySegment string) {
        var mh$ = PyUnicode_BuildEncodingMap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_BuildEncodingMap", string);
            }
            return (MemorySegment)mh$.invokeExact(string);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeUTF7 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeUTF7");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF7(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeUTF7$descriptor() {
        return PyUnicode_DecodeUTF7.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF7(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_DecodeUTF7$handle() {
        return PyUnicode_DecodeUTF7.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF7(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF7$address() {
        return PyUnicode_DecodeUTF7.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF7(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF7(MemorySegment string, long length, MemorySegment errors) {
        var mh$ = PyUnicode_DecodeUTF7.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeUTF7", string, length, errors);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeUTF7Stateful {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeUTF7Stateful");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF7Stateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeUTF7Stateful$descriptor() {
        return PyUnicode_DecodeUTF7Stateful.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF7Stateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static MethodHandle PyUnicode_DecodeUTF7Stateful$handle() {
        return PyUnicode_DecodeUTF7Stateful.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF7Stateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF7Stateful$address() {
        return PyUnicode_DecodeUTF7Stateful.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF7Stateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF7Stateful(MemorySegment string, long length, MemorySegment errors, MemorySegment consumed) {
        var mh$ = PyUnicode_DecodeUTF7Stateful.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeUTF7Stateful", string, length, errors, consumed);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors, consumed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeUTF8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeUTF8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF8(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeUTF8$descriptor() {
        return PyUnicode_DecodeUTF8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF8(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_DecodeUTF8$handle() {
        return PyUnicode_DecodeUTF8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF8(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF8$address() {
        return PyUnicode_DecodeUTF8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF8(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF8(MemorySegment string, long length, MemorySegment errors) {
        var mh$ = PyUnicode_DecodeUTF8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeUTF8", string, length, errors);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeUTF8Stateful {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeUTF8Stateful");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF8Stateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeUTF8Stateful$descriptor() {
        return PyUnicode_DecodeUTF8Stateful.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF8Stateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static MethodHandle PyUnicode_DecodeUTF8Stateful$handle() {
        return PyUnicode_DecodeUTF8Stateful.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF8Stateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF8Stateful$address() {
        return PyUnicode_DecodeUTF8Stateful.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF8Stateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF8Stateful(MemorySegment string, long length, MemorySegment errors, MemorySegment consumed) {
        var mh$ = PyUnicode_DecodeUTF8Stateful.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeUTF8Stateful", string, length, errors, consumed);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors, consumed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsUTF8String {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsUTF8String");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF8String(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsUTF8String$descriptor() {
        return PyUnicode_AsUTF8String.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF8String(PyObject *unicode)
     * }
     */
    public static MethodHandle PyUnicode_AsUTF8String$handle() {
        return PyUnicode_AsUTF8String.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF8String(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsUTF8String$address() {
        return PyUnicode_AsUTF8String.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF8String(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsUTF8String(MemorySegment unicode) {
        var mh$ = PyUnicode_AsUTF8String.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsUTF8String", unicode);
            }
            return (MemorySegment)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsUTF8AndSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsUTF8AndSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *PyUnicode_AsUTF8AndSize(PyObject *unicode, Py_ssize_t *size)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsUTF8AndSize$descriptor() {
        return PyUnicode_AsUTF8AndSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *PyUnicode_AsUTF8AndSize(PyObject *unicode, Py_ssize_t *size)
     * }
     */
    public static MethodHandle PyUnicode_AsUTF8AndSize$handle() {
        return PyUnicode_AsUTF8AndSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *PyUnicode_AsUTF8AndSize(PyObject *unicode, Py_ssize_t *size)
     * }
     */
    public static MemorySegment PyUnicode_AsUTF8AndSize$address() {
        return PyUnicode_AsUTF8AndSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *PyUnicode_AsUTF8AndSize(PyObject *unicode, Py_ssize_t *size)
     * }
     */
    public static MemorySegment PyUnicode_AsUTF8AndSize(MemorySegment unicode, MemorySegment size) {
        var mh$ = PyUnicode_AsUTF8AndSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsUTF8AndSize", unicode, size);
            }
            return (MemorySegment)mh$.invokeExact(unicode, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeUTF32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeUTF32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF32(const char *string, Py_ssize_t length, const char *errors, int *byteorder)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeUTF32$descriptor() {
        return PyUnicode_DecodeUTF32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF32(const char *string, Py_ssize_t length, const char *errors, int *byteorder)
     * }
     */
    public static MethodHandle PyUnicode_DecodeUTF32$handle() {
        return PyUnicode_DecodeUTF32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF32(const char *string, Py_ssize_t length, const char *errors, int *byteorder)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF32$address() {
        return PyUnicode_DecodeUTF32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF32(const char *string, Py_ssize_t length, const char *errors, int *byteorder)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF32(MemorySegment string, long length, MemorySegment errors, MemorySegment byteorder) {
        var mh$ = PyUnicode_DecodeUTF32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeUTF32", string, length, errors, byteorder);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors, byteorder);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeUTF32Stateful {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeUTF32Stateful");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF32Stateful(const char *string, Py_ssize_t length, const char *errors, int *byteorder, Py_ssize_t *consumed)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeUTF32Stateful$descriptor() {
        return PyUnicode_DecodeUTF32Stateful.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF32Stateful(const char *string, Py_ssize_t length, const char *errors, int *byteorder, Py_ssize_t *consumed)
     * }
     */
    public static MethodHandle PyUnicode_DecodeUTF32Stateful$handle() {
        return PyUnicode_DecodeUTF32Stateful.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF32Stateful(const char *string, Py_ssize_t length, const char *errors, int *byteorder, Py_ssize_t *consumed)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF32Stateful$address() {
        return PyUnicode_DecodeUTF32Stateful.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF32Stateful(const char *string, Py_ssize_t length, const char *errors, int *byteorder, Py_ssize_t *consumed)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF32Stateful(MemorySegment string, long length, MemorySegment errors, MemorySegment byteorder, MemorySegment consumed) {
        var mh$ = PyUnicode_DecodeUTF32Stateful.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeUTF32Stateful", string, length, errors, byteorder, consumed);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors, byteorder, consumed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsUTF32String {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsUTF32String");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF32String(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsUTF32String$descriptor() {
        return PyUnicode_AsUTF32String.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF32String(PyObject *unicode)
     * }
     */
    public static MethodHandle PyUnicode_AsUTF32String$handle() {
        return PyUnicode_AsUTF32String.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF32String(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsUTF32String$address() {
        return PyUnicode_AsUTF32String.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF32String(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsUTF32String(MemorySegment unicode) {
        var mh$ = PyUnicode_AsUTF32String.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsUTF32String", unicode);
            }
            return (MemorySegment)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeUTF16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeUTF16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF16(const char *string, Py_ssize_t length, const char *errors, int *byteorder)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeUTF16$descriptor() {
        return PyUnicode_DecodeUTF16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF16(const char *string, Py_ssize_t length, const char *errors, int *byteorder)
     * }
     */
    public static MethodHandle PyUnicode_DecodeUTF16$handle() {
        return PyUnicode_DecodeUTF16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF16(const char *string, Py_ssize_t length, const char *errors, int *byteorder)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF16$address() {
        return PyUnicode_DecodeUTF16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF16(const char *string, Py_ssize_t length, const char *errors, int *byteorder)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF16(MemorySegment string, long length, MemorySegment errors, MemorySegment byteorder) {
        var mh$ = PyUnicode_DecodeUTF16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeUTF16", string, length, errors, byteorder);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors, byteorder);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeUTF16Stateful {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeUTF16Stateful");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF16Stateful(const char *string, Py_ssize_t length, const char *errors, int *byteorder, Py_ssize_t *consumed)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeUTF16Stateful$descriptor() {
        return PyUnicode_DecodeUTF16Stateful.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF16Stateful(const char *string, Py_ssize_t length, const char *errors, int *byteorder, Py_ssize_t *consumed)
     * }
     */
    public static MethodHandle PyUnicode_DecodeUTF16Stateful$handle() {
        return PyUnicode_DecodeUTF16Stateful.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF16Stateful(const char *string, Py_ssize_t length, const char *errors, int *byteorder, Py_ssize_t *consumed)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF16Stateful$address() {
        return PyUnicode_DecodeUTF16Stateful.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUTF16Stateful(const char *string, Py_ssize_t length, const char *errors, int *byteorder, Py_ssize_t *consumed)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUTF16Stateful(MemorySegment string, long length, MemorySegment errors, MemorySegment byteorder, MemorySegment consumed) {
        var mh$ = PyUnicode_DecodeUTF16Stateful.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeUTF16Stateful", string, length, errors, byteorder, consumed);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors, byteorder, consumed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsUTF16String {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsUTF16String");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF16String(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsUTF16String$descriptor() {
        return PyUnicode_AsUTF16String.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF16String(PyObject *unicode)
     * }
     */
    public static MethodHandle PyUnicode_AsUTF16String$handle() {
        return PyUnicode_AsUTF16String.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF16String(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsUTF16String$address() {
        return PyUnicode_AsUTF16String.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUTF16String(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsUTF16String(MemorySegment unicode) {
        var mh$ = PyUnicode_AsUTF16String.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsUTF16String", unicode);
            }
            return (MemorySegment)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeUnicodeEscape {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeUnicodeEscape");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUnicodeEscape(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeUnicodeEscape$descriptor() {
        return PyUnicode_DecodeUnicodeEscape.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUnicodeEscape(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_DecodeUnicodeEscape$handle() {
        return PyUnicode_DecodeUnicodeEscape.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUnicodeEscape(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUnicodeEscape$address() {
        return PyUnicode_DecodeUnicodeEscape.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeUnicodeEscape(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeUnicodeEscape(MemorySegment string, long length, MemorySegment errors) {
        var mh$ = PyUnicode_DecodeUnicodeEscape.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeUnicodeEscape", string, length, errors);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsUnicodeEscapeString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsUnicodeEscapeString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUnicodeEscapeString(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsUnicodeEscapeString$descriptor() {
        return PyUnicode_AsUnicodeEscapeString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUnicodeEscapeString(PyObject *unicode)
     * }
     */
    public static MethodHandle PyUnicode_AsUnicodeEscapeString$handle() {
        return PyUnicode_AsUnicodeEscapeString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUnicodeEscapeString(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsUnicodeEscapeString$address() {
        return PyUnicode_AsUnicodeEscapeString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsUnicodeEscapeString(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsUnicodeEscapeString(MemorySegment unicode) {
        var mh$ = PyUnicode_AsUnicodeEscapeString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsUnicodeEscapeString", unicode);
            }
            return (MemorySegment)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeRawUnicodeEscape {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeRawUnicodeEscape");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeRawUnicodeEscape(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeRawUnicodeEscape$descriptor() {
        return PyUnicode_DecodeRawUnicodeEscape.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeRawUnicodeEscape(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_DecodeRawUnicodeEscape$handle() {
        return PyUnicode_DecodeRawUnicodeEscape.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeRawUnicodeEscape(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeRawUnicodeEscape$address() {
        return PyUnicode_DecodeRawUnicodeEscape.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeRawUnicodeEscape(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeRawUnicodeEscape(MemorySegment string, long length, MemorySegment errors) {
        var mh$ = PyUnicode_DecodeRawUnicodeEscape.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeRawUnicodeEscape", string, length, errors);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsRawUnicodeEscapeString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsRawUnicodeEscapeString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsRawUnicodeEscapeString(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsRawUnicodeEscapeString$descriptor() {
        return PyUnicode_AsRawUnicodeEscapeString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsRawUnicodeEscapeString(PyObject *unicode)
     * }
     */
    public static MethodHandle PyUnicode_AsRawUnicodeEscapeString$handle() {
        return PyUnicode_AsRawUnicodeEscapeString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsRawUnicodeEscapeString(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsRawUnicodeEscapeString$address() {
        return PyUnicode_AsRawUnicodeEscapeString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsRawUnicodeEscapeString(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsRawUnicodeEscapeString(MemorySegment unicode) {
        var mh$ = PyUnicode_AsRawUnicodeEscapeString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsRawUnicodeEscapeString", unicode);
            }
            return (MemorySegment)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeLatin1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeLatin1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLatin1(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeLatin1$descriptor() {
        return PyUnicode_DecodeLatin1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLatin1(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_DecodeLatin1$handle() {
        return PyUnicode_DecodeLatin1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLatin1(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeLatin1$address() {
        return PyUnicode_DecodeLatin1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLatin1(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeLatin1(MemorySegment string, long length, MemorySegment errors) {
        var mh$ = PyUnicode_DecodeLatin1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeLatin1", string, length, errors);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsLatin1String {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsLatin1String");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsLatin1String(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsLatin1String$descriptor() {
        return PyUnicode_AsLatin1String.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsLatin1String(PyObject *unicode)
     * }
     */
    public static MethodHandle PyUnicode_AsLatin1String$handle() {
        return PyUnicode_AsLatin1String.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsLatin1String(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsLatin1String$address() {
        return PyUnicode_AsLatin1String.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsLatin1String(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsLatin1String(MemorySegment unicode) {
        var mh$ = PyUnicode_AsLatin1String.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsLatin1String", unicode);
            }
            return (MemorySegment)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeASCII {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeASCII");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeASCII(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeASCII$descriptor() {
        return PyUnicode_DecodeASCII.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeASCII(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_DecodeASCII$handle() {
        return PyUnicode_DecodeASCII.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeASCII(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeASCII$address() {
        return PyUnicode_DecodeASCII.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeASCII(const char *string, Py_ssize_t length, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeASCII(MemorySegment string, long length, MemorySegment errors) {
        var mh$ = PyUnicode_DecodeASCII.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeASCII", string, length, errors);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsASCIIString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsASCIIString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsASCIIString(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsASCIIString$descriptor() {
        return PyUnicode_AsASCIIString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsASCIIString(PyObject *unicode)
     * }
     */
    public static MethodHandle PyUnicode_AsASCIIString$handle() {
        return PyUnicode_AsASCIIString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsASCIIString(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsASCIIString$address() {
        return PyUnicode_AsASCIIString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsASCIIString(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsASCIIString(MemorySegment unicode) {
        var mh$ = PyUnicode_AsASCIIString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsASCIIString", unicode);
            }
            return (MemorySegment)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeCharmap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeCharmap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeCharmap(const char *string, Py_ssize_t length, PyObject *mapping, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeCharmap$descriptor() {
        return PyUnicode_DecodeCharmap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeCharmap(const char *string, Py_ssize_t length, PyObject *mapping, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_DecodeCharmap$handle() {
        return PyUnicode_DecodeCharmap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeCharmap(const char *string, Py_ssize_t length, PyObject *mapping, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeCharmap$address() {
        return PyUnicode_DecodeCharmap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeCharmap(const char *string, Py_ssize_t length, PyObject *mapping, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeCharmap(MemorySegment string, long length, MemorySegment mapping, MemorySegment errors) {
        var mh$ = PyUnicode_DecodeCharmap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeCharmap", string, length, mapping, errors);
            }
            return (MemorySegment)mh$.invokeExact(string, length, mapping, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsCharmapString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsCharmapString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsCharmapString(PyObject *unicode, PyObject *mapping)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsCharmapString$descriptor() {
        return PyUnicode_AsCharmapString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsCharmapString(PyObject *unicode, PyObject *mapping)
     * }
     */
    public static MethodHandle PyUnicode_AsCharmapString$handle() {
        return PyUnicode_AsCharmapString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsCharmapString(PyObject *unicode, PyObject *mapping)
     * }
     */
    public static MemorySegment PyUnicode_AsCharmapString$address() {
        return PyUnicode_AsCharmapString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_AsCharmapString(PyObject *unicode, PyObject *mapping)
     * }
     */
    public static MemorySegment PyUnicode_AsCharmapString(MemorySegment unicode, MemorySegment mapping) {
        var mh$ = PyUnicode_AsCharmapString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsCharmapString", unicode, mapping);
            }
            return (MemorySegment)mh$.invokeExact(unicode, mapping);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeLocaleAndSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeLocaleAndSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLocaleAndSize(const char *str, Py_ssize_t len, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeLocaleAndSize$descriptor() {
        return PyUnicode_DecodeLocaleAndSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLocaleAndSize(const char *str, Py_ssize_t len, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_DecodeLocaleAndSize$handle() {
        return PyUnicode_DecodeLocaleAndSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLocaleAndSize(const char *str, Py_ssize_t len, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeLocaleAndSize$address() {
        return PyUnicode_DecodeLocaleAndSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLocaleAndSize(const char *str, Py_ssize_t len, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeLocaleAndSize(MemorySegment str, long len, MemorySegment errors) {
        var mh$ = PyUnicode_DecodeLocaleAndSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeLocaleAndSize", str, len, errors);
            }
            return (MemorySegment)mh$.invokeExact(str, len, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeLocale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeLocale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLocale(const char *str, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeLocale$descriptor() {
        return PyUnicode_DecodeLocale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLocale(const char *str, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_DecodeLocale$handle() {
        return PyUnicode_DecodeLocale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLocale(const char *str, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeLocale$address() {
        return PyUnicode_DecodeLocale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeLocale(const char *str, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_DecodeLocale(MemorySegment str, MemorySegment errors) {
        var mh$ = PyUnicode_DecodeLocale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeLocale", str, errors);
            }
            return (MemorySegment)mh$.invokeExact(str, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_EncodeLocale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_EncodeLocale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_EncodeLocale(PyObject *unicode, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_EncodeLocale$descriptor() {
        return PyUnicode_EncodeLocale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_EncodeLocale(PyObject *unicode, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_EncodeLocale$handle() {
        return PyUnicode_EncodeLocale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_EncodeLocale(PyObject *unicode, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_EncodeLocale$address() {
        return PyUnicode_EncodeLocale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_EncodeLocale(PyObject *unicode, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_EncodeLocale(MemorySegment unicode, MemorySegment errors) {
        var mh$ = PyUnicode_EncodeLocale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_EncodeLocale", unicode, errors);
            }
            return (MemorySegment)mh$.invokeExact(unicode, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_FSConverter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FSConverter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicode_FSConverter(PyObject *, void *)
     * }
     */
    public static FunctionDescriptor PyUnicode_FSConverter$descriptor() {
        return PyUnicode_FSConverter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicode_FSConverter(PyObject *, void *)
     * }
     */
    public static MethodHandle PyUnicode_FSConverter$handle() {
        return PyUnicode_FSConverter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicode_FSConverter(PyObject *, void *)
     * }
     */
    public static MemorySegment PyUnicode_FSConverter$address() {
        return PyUnicode_FSConverter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicode_FSConverter(PyObject *, void *)
     * }
     */
    public static int PyUnicode_FSConverter(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyUnicode_FSConverter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_FSConverter", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_FSDecoder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FSDecoder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicode_FSDecoder(PyObject *, void *)
     * }
     */
    public static FunctionDescriptor PyUnicode_FSDecoder$descriptor() {
        return PyUnicode_FSDecoder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicode_FSDecoder(PyObject *, void *)
     * }
     */
    public static MethodHandle PyUnicode_FSDecoder$handle() {
        return PyUnicode_FSDecoder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicode_FSDecoder(PyObject *, void *)
     * }
     */
    public static MemorySegment PyUnicode_FSDecoder$address() {
        return PyUnicode_FSDecoder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicode_FSDecoder(PyObject *, void *)
     * }
     */
    public static int PyUnicode_FSDecoder(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyUnicode_FSDecoder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_FSDecoder", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeFSDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeFSDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeFSDefault(const char *s)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeFSDefault$descriptor() {
        return PyUnicode_DecodeFSDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeFSDefault(const char *s)
     * }
     */
    public static MethodHandle PyUnicode_DecodeFSDefault$handle() {
        return PyUnicode_DecodeFSDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeFSDefault(const char *s)
     * }
     */
    public static MemorySegment PyUnicode_DecodeFSDefault$address() {
        return PyUnicode_DecodeFSDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeFSDefault(const char *s)
     * }
     */
    public static MemorySegment PyUnicode_DecodeFSDefault(MemorySegment s) {
        var mh$ = PyUnicode_DecodeFSDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeFSDefault", s);
            }
            return (MemorySegment)mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_DecodeFSDefaultAndSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_DecodeFSDefaultAndSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeFSDefaultAndSize(const char *s, Py_ssize_t size)
     * }
     */
    public static FunctionDescriptor PyUnicode_DecodeFSDefaultAndSize$descriptor() {
        return PyUnicode_DecodeFSDefaultAndSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeFSDefaultAndSize(const char *s, Py_ssize_t size)
     * }
     */
    public static MethodHandle PyUnicode_DecodeFSDefaultAndSize$handle() {
        return PyUnicode_DecodeFSDefaultAndSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeFSDefaultAndSize(const char *s, Py_ssize_t size)
     * }
     */
    public static MemorySegment PyUnicode_DecodeFSDefaultAndSize$address() {
        return PyUnicode_DecodeFSDefaultAndSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_DecodeFSDefaultAndSize(const char *s, Py_ssize_t size)
     * }
     */
    public static MemorySegment PyUnicode_DecodeFSDefaultAndSize(MemorySegment s, long size) {
        var mh$ = PyUnicode_DecodeFSDefaultAndSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_DecodeFSDefaultAndSize", s, size);
            }
            return (MemorySegment)mh$.invokeExact(s, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_EncodeFSDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_EncodeFSDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_EncodeFSDefault(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor PyUnicode_EncodeFSDefault$descriptor() {
        return PyUnicode_EncodeFSDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_EncodeFSDefault(PyObject *unicode)
     * }
     */
    public static MethodHandle PyUnicode_EncodeFSDefault$handle() {
        return PyUnicode_EncodeFSDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_EncodeFSDefault(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_EncodeFSDefault$address() {
        return PyUnicode_EncodeFSDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_EncodeFSDefault(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_EncodeFSDefault(MemorySegment unicode) {
        var mh$ = PyUnicode_EncodeFSDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_EncodeFSDefault", unicode);
            }
            return (MemorySegment)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Concat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Concat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Concat(PyObject *left, PyObject *right)
     * }
     */
    public static FunctionDescriptor PyUnicode_Concat$descriptor() {
        return PyUnicode_Concat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Concat(PyObject *left, PyObject *right)
     * }
     */
    public static MethodHandle PyUnicode_Concat$handle() {
        return PyUnicode_Concat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Concat(PyObject *left, PyObject *right)
     * }
     */
    public static MemorySegment PyUnicode_Concat$address() {
        return PyUnicode_Concat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_Concat(PyObject *left, PyObject *right)
     * }
     */
    public static MemorySegment PyUnicode_Concat(MemorySegment left, MemorySegment right) {
        var mh$ = PyUnicode_Concat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Concat", left, right);
            }
            return (MemorySegment)mh$.invokeExact(left, right);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Append {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Append");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyUnicode_Append(PyObject **pleft, PyObject *right)
     * }
     */
    public static FunctionDescriptor PyUnicode_Append$descriptor() {
        return PyUnicode_Append.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyUnicode_Append(PyObject **pleft, PyObject *right)
     * }
     */
    public static MethodHandle PyUnicode_Append$handle() {
        return PyUnicode_Append.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyUnicode_Append(PyObject **pleft, PyObject *right)
     * }
     */
    public static MemorySegment PyUnicode_Append$address() {
        return PyUnicode_Append.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyUnicode_Append(PyObject **pleft, PyObject *right)
     * }
     */
    public static void PyUnicode_Append(MemorySegment pleft, MemorySegment right) {
        var mh$ = PyUnicode_Append.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Append", pleft, right);
            }
            mh$.invokeExact(pleft, right);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AppendAndDel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AppendAndDel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PyUnicode_AppendAndDel(PyObject **pleft, PyObject *right)
     * }
     */
    public static FunctionDescriptor PyUnicode_AppendAndDel$descriptor() {
        return PyUnicode_AppendAndDel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PyUnicode_AppendAndDel(PyObject **pleft, PyObject *right)
     * }
     */
    public static MethodHandle PyUnicode_AppendAndDel$handle() {
        return PyUnicode_AppendAndDel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PyUnicode_AppendAndDel(PyObject **pleft, PyObject *right)
     * }
     */
    public static MemorySegment PyUnicode_AppendAndDel$address() {
        return PyUnicode_AppendAndDel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PyUnicode_AppendAndDel(PyObject **pleft, PyObject *right)
     * }
     */
    public static void PyUnicode_AppendAndDel(MemorySegment pleft, MemorySegment right) {
        var mh$ = PyUnicode_AppendAndDel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AppendAndDel", pleft, right);
            }
            mh$.invokeExact(pleft, right);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Split {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Split");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Split(PyObject *s, PyObject *sep, Py_ssize_t maxsplit)
     * }
     */
    public static FunctionDescriptor PyUnicode_Split$descriptor() {
        return PyUnicode_Split.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Split(PyObject *s, PyObject *sep, Py_ssize_t maxsplit)
     * }
     */
    public static MethodHandle PyUnicode_Split$handle() {
        return PyUnicode_Split.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Split(PyObject *s, PyObject *sep, Py_ssize_t maxsplit)
     * }
     */
    public static MemorySegment PyUnicode_Split$address() {
        return PyUnicode_Split.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_Split(PyObject *s, PyObject *sep, Py_ssize_t maxsplit)
     * }
     */
    public static MemorySegment PyUnicode_Split(MemorySegment s, MemorySegment sep, long maxsplit) {
        var mh$ = PyUnicode_Split.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Split", s, sep, maxsplit);
            }
            return (MemorySegment)mh$.invokeExact(s, sep, maxsplit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Splitlines {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Splitlines");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Splitlines(PyObject *s, int keepends)
     * }
     */
    public static FunctionDescriptor PyUnicode_Splitlines$descriptor() {
        return PyUnicode_Splitlines.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Splitlines(PyObject *s, int keepends)
     * }
     */
    public static MethodHandle PyUnicode_Splitlines$handle() {
        return PyUnicode_Splitlines.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Splitlines(PyObject *s, int keepends)
     * }
     */
    public static MemorySegment PyUnicode_Splitlines$address() {
        return PyUnicode_Splitlines.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_Splitlines(PyObject *s, int keepends)
     * }
     */
    public static MemorySegment PyUnicode_Splitlines(MemorySegment s, int keepends) {
        var mh$ = PyUnicode_Splitlines.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Splitlines", s, keepends);
            }
            return (MemorySegment)mh$.invokeExact(s, keepends);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Partition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Partition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Partition(PyObject *s, PyObject *sep)
     * }
     */
    public static FunctionDescriptor PyUnicode_Partition$descriptor() {
        return PyUnicode_Partition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Partition(PyObject *s, PyObject *sep)
     * }
     */
    public static MethodHandle PyUnicode_Partition$handle() {
        return PyUnicode_Partition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Partition(PyObject *s, PyObject *sep)
     * }
     */
    public static MemorySegment PyUnicode_Partition$address() {
        return PyUnicode_Partition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_Partition(PyObject *s, PyObject *sep)
     * }
     */
    public static MemorySegment PyUnicode_Partition(MemorySegment s, MemorySegment sep) {
        var mh$ = PyUnicode_Partition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Partition", s, sep);
            }
            return (MemorySegment)mh$.invokeExact(s, sep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_RPartition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_RPartition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_RPartition(PyObject *s, PyObject *sep)
     * }
     */
    public static FunctionDescriptor PyUnicode_RPartition$descriptor() {
        return PyUnicode_RPartition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_RPartition(PyObject *s, PyObject *sep)
     * }
     */
    public static MethodHandle PyUnicode_RPartition$handle() {
        return PyUnicode_RPartition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_RPartition(PyObject *s, PyObject *sep)
     * }
     */
    public static MemorySegment PyUnicode_RPartition$address() {
        return PyUnicode_RPartition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_RPartition(PyObject *s, PyObject *sep)
     * }
     */
    public static MemorySegment PyUnicode_RPartition(MemorySegment s, MemorySegment sep) {
        var mh$ = PyUnicode_RPartition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_RPartition", s, sep);
            }
            return (MemorySegment)mh$.invokeExact(s, sep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_RSplit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_RSplit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_RSplit(PyObject *s, PyObject *sep, Py_ssize_t maxsplit)
     * }
     */
    public static FunctionDescriptor PyUnicode_RSplit$descriptor() {
        return PyUnicode_RSplit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_RSplit(PyObject *s, PyObject *sep, Py_ssize_t maxsplit)
     * }
     */
    public static MethodHandle PyUnicode_RSplit$handle() {
        return PyUnicode_RSplit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_RSplit(PyObject *s, PyObject *sep, Py_ssize_t maxsplit)
     * }
     */
    public static MemorySegment PyUnicode_RSplit$address() {
        return PyUnicode_RSplit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_RSplit(PyObject *s, PyObject *sep, Py_ssize_t maxsplit)
     * }
     */
    public static MemorySegment PyUnicode_RSplit(MemorySegment s, MemorySegment sep, long maxsplit) {
        var mh$ = PyUnicode_RSplit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_RSplit", s, sep, maxsplit);
            }
            return (MemorySegment)mh$.invokeExact(s, sep, maxsplit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Translate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Translate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Translate(PyObject *str, PyObject *table, const char *errors)
     * }
     */
    public static FunctionDescriptor PyUnicode_Translate$descriptor() {
        return PyUnicode_Translate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Translate(PyObject *str, PyObject *table, const char *errors)
     * }
     */
    public static MethodHandle PyUnicode_Translate$handle() {
        return PyUnicode_Translate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Translate(PyObject *str, PyObject *table, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_Translate$address() {
        return PyUnicode_Translate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_Translate(PyObject *str, PyObject *table, const char *errors)
     * }
     */
    public static MemorySegment PyUnicode_Translate(MemorySegment str, MemorySegment table, MemorySegment errors) {
        var mh$ = PyUnicode_Translate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Translate", str, table, errors);
            }
            return (MemorySegment)mh$.invokeExact(str, table, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Join {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Join");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Join(PyObject *separator, PyObject *seq)
     * }
     */
    public static FunctionDescriptor PyUnicode_Join$descriptor() {
        return PyUnicode_Join.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Join(PyObject *separator, PyObject *seq)
     * }
     */
    public static MethodHandle PyUnicode_Join$handle() {
        return PyUnicode_Join.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Join(PyObject *separator, PyObject *seq)
     * }
     */
    public static MemorySegment PyUnicode_Join$address() {
        return PyUnicode_Join.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_Join(PyObject *separator, PyObject *seq)
     * }
     */
    public static MemorySegment PyUnicode_Join(MemorySegment separator, MemorySegment seq) {
        var mh$ = PyUnicode_Join.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Join", separator, seq);
            }
            return (MemorySegment)mh$.invokeExact(separator, seq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Tailmatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Tailmatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Tailmatch(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static FunctionDescriptor PyUnicode_Tailmatch$descriptor() {
        return PyUnicode_Tailmatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Tailmatch(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static MethodHandle PyUnicode_Tailmatch$handle() {
        return PyUnicode_Tailmatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Tailmatch(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static MemorySegment PyUnicode_Tailmatch$address() {
        return PyUnicode_Tailmatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Tailmatch(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static long PyUnicode_Tailmatch(MemorySegment str, MemorySegment substr, long start, long end, int direction) {
        var mh$ = PyUnicode_Tailmatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Tailmatch", str, substr, start, end, direction);
            }
            return (long)mh$.invokeExact(str, substr, start, end, direction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Find {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Find");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Find(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static FunctionDescriptor PyUnicode_Find$descriptor() {
        return PyUnicode_Find.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Find(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static MethodHandle PyUnicode_Find$handle() {
        return PyUnicode_Find.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Find(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static MemorySegment PyUnicode_Find$address() {
        return PyUnicode_Find.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Find(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static long PyUnicode_Find(MemorySegment str, MemorySegment substr, long start, long end, int direction) {
        var mh$ = PyUnicode_Find.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Find", str, substr, start, end, direction);
            }
            return (long)mh$.invokeExact(str, substr, start, end, direction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_FindChar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FindChar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_FindChar(PyObject *str, Py_UCS4 ch, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static FunctionDescriptor PyUnicode_FindChar$descriptor() {
        return PyUnicode_FindChar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_FindChar(PyObject *str, Py_UCS4 ch, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static MethodHandle PyUnicode_FindChar$handle() {
        return PyUnicode_FindChar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_FindChar(PyObject *str, Py_UCS4 ch, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static MemorySegment PyUnicode_FindChar$address() {
        return PyUnicode_FindChar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_FindChar(PyObject *str, Py_UCS4 ch, Py_ssize_t start, Py_ssize_t end, int direction)
     * }
     */
    public static long PyUnicode_FindChar(MemorySegment str, int ch, long start, long end, int direction) {
        var mh$ = PyUnicode_FindChar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_FindChar", str, ch, start, end, direction);
            }
            return (long)mh$.invokeExact(str, ch, start, end, direction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Count(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static FunctionDescriptor PyUnicode_Count$descriptor() {
        return PyUnicode_Count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Count(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static MethodHandle PyUnicode_Count$handle() {
        return PyUnicode_Count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Count(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static MemorySegment PyUnicode_Count$address() {
        return PyUnicode_Count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Count(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static long PyUnicode_Count(MemorySegment str, MemorySegment substr, long start, long end) {
        var mh$ = PyUnicode_Count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Count", str, substr, start, end);
            }
            return (long)mh$.invokeExact(str, substr, start, end);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Replace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Replace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Replace(PyObject *str, PyObject *substr, PyObject *replstr, Py_ssize_t maxcount)
     * }
     */
    public static FunctionDescriptor PyUnicode_Replace$descriptor() {
        return PyUnicode_Replace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Replace(PyObject *str, PyObject *substr, PyObject *replstr, Py_ssize_t maxcount)
     * }
     */
    public static MethodHandle PyUnicode_Replace$handle() {
        return PyUnicode_Replace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Replace(PyObject *str, PyObject *substr, PyObject *replstr, Py_ssize_t maxcount)
     * }
     */
    public static MemorySegment PyUnicode_Replace$address() {
        return PyUnicode_Replace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_Replace(PyObject *str, PyObject *substr, PyObject *replstr, Py_ssize_t maxcount)
     * }
     */
    public static MemorySegment PyUnicode_Replace(MemorySegment str, MemorySegment substr, MemorySegment replstr, long maxcount) {
        var mh$ = PyUnicode_Replace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Replace", str, substr, replstr, maxcount);
            }
            return (MemorySegment)mh$.invokeExact(str, substr, replstr, maxcount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Compare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Compare");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicode_Compare(PyObject *left, PyObject *right)
     * }
     */
    public static FunctionDescriptor PyUnicode_Compare$descriptor() {
        return PyUnicode_Compare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicode_Compare(PyObject *left, PyObject *right)
     * }
     */
    public static MethodHandle PyUnicode_Compare$handle() {
        return PyUnicode_Compare.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicode_Compare(PyObject *left, PyObject *right)
     * }
     */
    public static MemorySegment PyUnicode_Compare$address() {
        return PyUnicode_Compare.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicode_Compare(PyObject *left, PyObject *right)
     * }
     */
    public static int PyUnicode_Compare(MemorySegment left, MemorySegment right) {
        var mh$ = PyUnicode_Compare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Compare", left, right);
            }
            return (int)mh$.invokeExact(left, right);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_CompareWithASCIIString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_CompareWithASCIIString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicode_CompareWithASCIIString(PyObject *left, const char *right)
     * }
     */
    public static FunctionDescriptor PyUnicode_CompareWithASCIIString$descriptor() {
        return PyUnicode_CompareWithASCIIString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicode_CompareWithASCIIString(PyObject *left, const char *right)
     * }
     */
    public static MethodHandle PyUnicode_CompareWithASCIIString$handle() {
        return PyUnicode_CompareWithASCIIString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicode_CompareWithASCIIString(PyObject *left, const char *right)
     * }
     */
    public static MemorySegment PyUnicode_CompareWithASCIIString$address() {
        return PyUnicode_CompareWithASCIIString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicode_CompareWithASCIIString(PyObject *left, const char *right)
     * }
     */
    public static int PyUnicode_CompareWithASCIIString(MemorySegment left, MemorySegment right) {
        var mh$ = PyUnicode_CompareWithASCIIString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_CompareWithASCIIString", left, right);
            }
            return (int)mh$.invokeExact(left, right);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_RichCompare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_RichCompare");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_RichCompare(PyObject *left, PyObject *right, int op)
     * }
     */
    public static FunctionDescriptor PyUnicode_RichCompare$descriptor() {
        return PyUnicode_RichCompare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_RichCompare(PyObject *left, PyObject *right, int op)
     * }
     */
    public static MethodHandle PyUnicode_RichCompare$handle() {
        return PyUnicode_RichCompare.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_RichCompare(PyObject *left, PyObject *right, int op)
     * }
     */
    public static MemorySegment PyUnicode_RichCompare$address() {
        return PyUnicode_RichCompare.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_RichCompare(PyObject *left, PyObject *right, int op)
     * }
     */
    public static MemorySegment PyUnicode_RichCompare(MemorySegment left, MemorySegment right, int op) {
        var mh$ = PyUnicode_RichCompare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_RichCompare", left, right, op);
            }
            return (MemorySegment)mh$.invokeExact(left, right, op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Format {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Format");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Format(PyObject *format, PyObject *args)
     * }
     */
    public static FunctionDescriptor PyUnicode_Format$descriptor() {
        return PyUnicode_Format.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Format(PyObject *format, PyObject *args)
     * }
     */
    public static MethodHandle PyUnicode_Format$handle() {
        return PyUnicode_Format.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_Format(PyObject *format, PyObject *args)
     * }
     */
    public static MemorySegment PyUnicode_Format$address() {
        return PyUnicode_Format.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_Format(PyObject *format, PyObject *args)
     * }
     */
    public static MemorySegment PyUnicode_Format(MemorySegment format, MemorySegment args) {
        var mh$ = PyUnicode_Format.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Format", format, args);
            }
            return (MemorySegment)mh$.invokeExact(format, args);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Contains {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Contains");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicode_Contains(PyObject *container, PyObject *element)
     * }
     */
    public static FunctionDescriptor PyUnicode_Contains$descriptor() {
        return PyUnicode_Contains.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicode_Contains(PyObject *container, PyObject *element)
     * }
     */
    public static MethodHandle PyUnicode_Contains$handle() {
        return PyUnicode_Contains.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicode_Contains(PyObject *container, PyObject *element)
     * }
     */
    public static MemorySegment PyUnicode_Contains$address() {
        return PyUnicode_Contains.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicode_Contains(PyObject *container, PyObject *element)
     * }
     */
    public static int PyUnicode_Contains(MemorySegment container, MemorySegment element) {
        var mh$ = PyUnicode_Contains.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Contains", container, element);
            }
            return (int)mh$.invokeExact(container, element);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_IsIdentifier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_IsIdentifier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyUnicode_IsIdentifier(PyObject *s)
     * }
     */
    public static FunctionDescriptor PyUnicode_IsIdentifier$descriptor() {
        return PyUnicode_IsIdentifier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyUnicode_IsIdentifier(PyObject *s)
     * }
     */
    public static MethodHandle PyUnicode_IsIdentifier$handle() {
        return PyUnicode_IsIdentifier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyUnicode_IsIdentifier(PyObject *s)
     * }
     */
    public static MemorySegment PyUnicode_IsIdentifier$address() {
        return PyUnicode_IsIdentifier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyUnicode_IsIdentifier(PyObject *s)
     * }
     */
    public static int PyUnicode_IsIdentifier(MemorySegment s) {
        var mh$ = PyUnicode_IsIdentifier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_IsIdentifier", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef wchar_t Py_UNICODE
     * }
     */
    public static final OfInt Py_UNICODE = Python_h.C_INT;

    private static class _PyUnicode_CheckConsistency {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_CheckConsistency");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicode_CheckConsistency(PyObject *op, int check_content)
     * }
     */
    public static FunctionDescriptor _PyUnicode_CheckConsistency$descriptor() {
        return _PyUnicode_CheckConsistency.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicode_CheckConsistency(PyObject *op, int check_content)
     * }
     */
    public static MethodHandle _PyUnicode_CheckConsistency$handle() {
        return _PyUnicode_CheckConsistency.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicode_CheckConsistency(PyObject *op, int check_content)
     * }
     */
    public static MemorySegment _PyUnicode_CheckConsistency$address() {
        return _PyUnicode_CheckConsistency.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicode_CheckConsistency(PyObject *op, int check_content)
     * }
     */
    public static int _PyUnicode_CheckConsistency(MemorySegment op, int check_content) {
        var mh$ = _PyUnicode_CheckConsistency.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_CheckConsistency", op, check_content);
            }
            return (int)mh$.invokeExact(op, check_content);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int PyUnicode_WCHAR_KIND = (int)0L;
    /**
     * {@snippet lang=c :
     * enum PyUnicode_Kind.PyUnicode_WCHAR_KIND = 0
     * }
     */
    public static int PyUnicode_WCHAR_KIND() {
        return PyUnicode_WCHAR_KIND;
    }
    private static final int PyUnicode_1BYTE_KIND = (int)1L;
    /**
     * {@snippet lang=c :
     * enum PyUnicode_Kind.PyUnicode_1BYTE_KIND = 1
     * }
     */
    public static int PyUnicode_1BYTE_KIND() {
        return PyUnicode_1BYTE_KIND;
    }
    private static final int PyUnicode_2BYTE_KIND = (int)2L;
    /**
     * {@snippet lang=c :
     * enum PyUnicode_Kind.PyUnicode_2BYTE_KIND = 2
     * }
     */
    public static int PyUnicode_2BYTE_KIND() {
        return PyUnicode_2BYTE_KIND;
    }
    private static final int PyUnicode_4BYTE_KIND = (int)4L;
    /**
     * {@snippet lang=c :
     * enum PyUnicode_Kind.PyUnicode_4BYTE_KIND = 4
     * }
     */
    public static int PyUnicode_4BYTE_KIND() {
        return PyUnicode_4BYTE_KIND;
    }

    private static class PyUnicode_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_New(Py_ssize_t size, Py_UCS4 maxchar)
     * }
     */
    public static FunctionDescriptor PyUnicode_New$descriptor() {
        return PyUnicode_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_New(Py_ssize_t size, Py_UCS4 maxchar)
     * }
     */
    public static MethodHandle PyUnicode_New$handle() {
        return PyUnicode_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_New(Py_ssize_t size, Py_UCS4 maxchar)
     * }
     */
    public static MemorySegment PyUnicode_New$address() {
        return PyUnicode_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_New(Py_ssize_t size, Py_UCS4 maxchar)
     * }
     */
    public static MemorySegment PyUnicode_New(long size, int maxchar) {
        var mh$ = PyUnicode_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_New", size, maxchar);
            }
            return (MemorySegment)mh$.invokeExact(size, maxchar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_Ready {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_Ready");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicode_Ready(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor _PyUnicode_Ready$descriptor() {
        return _PyUnicode_Ready.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicode_Ready(PyObject *unicode)
     * }
     */
    public static MethodHandle _PyUnicode_Ready$handle() {
        return _PyUnicode_Ready.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicode_Ready(PyObject *unicode)
     * }
     */
    public static MemorySegment _PyUnicode_Ready$address() {
        return _PyUnicode_Ready.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicode_Ready(PyObject *unicode)
     * }
     */
    public static int _PyUnicode_Ready(MemorySegment unicode) {
        var mh$ = _PyUnicode_Ready.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_Ready", unicode);
            }
            return (int)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_Copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_Copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_Copy(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor _PyUnicode_Copy$descriptor() {
        return _PyUnicode_Copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_Copy(PyObject *unicode)
     * }
     */
    public static MethodHandle _PyUnicode_Copy$handle() {
        return _PyUnicode_Copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_Copy(PyObject *unicode)
     * }
     */
    public static MemorySegment _PyUnicode_Copy$address() {
        return _PyUnicode_Copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyUnicode_Copy(PyObject *unicode)
     * }
     */
    public static MemorySegment _PyUnicode_Copy(MemorySegment unicode) {
        var mh$ = _PyUnicode_Copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_Copy", unicode);
            }
            return (MemorySegment)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_CopyCharacters {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_CopyCharacters");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_CopyCharacters(PyObject *to, Py_ssize_t to_start, PyObject *from, Py_ssize_t from_start, Py_ssize_t how_many)
     * }
     */
    public static FunctionDescriptor PyUnicode_CopyCharacters$descriptor() {
        return PyUnicode_CopyCharacters.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_CopyCharacters(PyObject *to, Py_ssize_t to_start, PyObject *from, Py_ssize_t from_start, Py_ssize_t how_many)
     * }
     */
    public static MethodHandle PyUnicode_CopyCharacters$handle() {
        return PyUnicode_CopyCharacters.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_CopyCharacters(PyObject *to, Py_ssize_t to_start, PyObject *from, Py_ssize_t from_start, Py_ssize_t how_many)
     * }
     */
    public static MemorySegment PyUnicode_CopyCharacters$address() {
        return PyUnicode_CopyCharacters.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_CopyCharacters(PyObject *to, Py_ssize_t to_start, PyObject *from, Py_ssize_t from_start, Py_ssize_t how_many)
     * }
     */
    public static long PyUnicode_CopyCharacters(MemorySegment to, long to_start, MemorySegment from, long from_start, long how_many) {
        var mh$ = PyUnicode_CopyCharacters.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_CopyCharacters", to, to_start, from, from_start, how_many);
            }
            return (long)mh$.invokeExact(to, to_start, from, from_start, how_many);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_FastCopyCharacters {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_FastCopyCharacters");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyUnicode_FastCopyCharacters(PyObject *to, Py_ssize_t to_start, PyObject *from, Py_ssize_t from_start, Py_ssize_t how_many)
     * }
     */
    public static FunctionDescriptor _PyUnicode_FastCopyCharacters$descriptor() {
        return _PyUnicode_FastCopyCharacters.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyUnicode_FastCopyCharacters(PyObject *to, Py_ssize_t to_start, PyObject *from, Py_ssize_t from_start, Py_ssize_t how_many)
     * }
     */
    public static MethodHandle _PyUnicode_FastCopyCharacters$handle() {
        return _PyUnicode_FastCopyCharacters.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyUnicode_FastCopyCharacters(PyObject *to, Py_ssize_t to_start, PyObject *from, Py_ssize_t from_start, Py_ssize_t how_many)
     * }
     */
    public static MemorySegment _PyUnicode_FastCopyCharacters$address() {
        return _PyUnicode_FastCopyCharacters.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyUnicode_FastCopyCharacters(PyObject *to, Py_ssize_t to_start, PyObject *from, Py_ssize_t from_start, Py_ssize_t how_many)
     * }
     */
    public static void _PyUnicode_FastCopyCharacters(MemorySegment to, long to_start, MemorySegment from, long from_start, long how_many) {
        var mh$ = _PyUnicode_FastCopyCharacters.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_FastCopyCharacters", to, to_start, from, from_start, how_many);
            }
            mh$.invokeExact(to, to_start, from, from_start, how_many);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_Fill {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_Fill");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Fill(PyObject *unicode, Py_ssize_t start, Py_ssize_t length, Py_UCS4 fill_char)
     * }
     */
    public static FunctionDescriptor PyUnicode_Fill$descriptor() {
        return PyUnicode_Fill.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Fill(PyObject *unicode, Py_ssize_t start, Py_ssize_t length, Py_UCS4 fill_char)
     * }
     */
    public static MethodHandle PyUnicode_Fill$handle() {
        return PyUnicode_Fill.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Fill(PyObject *unicode, Py_ssize_t start, Py_ssize_t length, Py_UCS4 fill_char)
     * }
     */
    public static MemorySegment PyUnicode_Fill$address() {
        return PyUnicode_Fill.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyUnicode_Fill(PyObject *unicode, Py_ssize_t start, Py_ssize_t length, Py_UCS4 fill_char)
     * }
     */
    public static long PyUnicode_Fill(MemorySegment unicode, long start, long length, int fill_char) {
        var mh$ = PyUnicode_Fill.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_Fill", unicode, start, length, fill_char);
            }
            return (long)mh$.invokeExact(unicode, start, length, fill_char);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_FastFill {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_FastFill");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyUnicode_FastFill(PyObject *unicode, Py_ssize_t start, Py_ssize_t length, Py_UCS4 fill_char)
     * }
     */
    public static FunctionDescriptor _PyUnicode_FastFill$descriptor() {
        return _PyUnicode_FastFill.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyUnicode_FastFill(PyObject *unicode, Py_ssize_t start, Py_ssize_t length, Py_UCS4 fill_char)
     * }
     */
    public static MethodHandle _PyUnicode_FastFill$handle() {
        return _PyUnicode_FastFill.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyUnicode_FastFill(PyObject *unicode, Py_ssize_t start, Py_ssize_t length, Py_UCS4 fill_char)
     * }
     */
    public static MemorySegment _PyUnicode_FastFill$address() {
        return _PyUnicode_FastFill.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyUnicode_FastFill(PyObject *unicode, Py_ssize_t start, Py_ssize_t length, Py_UCS4 fill_char)
     * }
     */
    public static void _PyUnicode_FastFill(MemorySegment unicode, long start, long length, int fill_char) {
        var mh$ = _PyUnicode_FastFill.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_FastFill", unicode, start, length, fill_char);
            }
            mh$.invokeExact(unicode, start, length, fill_char);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_FromKindAndData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FromKindAndData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromKindAndData(int kind, const void *buffer, Py_ssize_t size)
     * }
     */
    public static FunctionDescriptor PyUnicode_FromKindAndData$descriptor() {
        return PyUnicode_FromKindAndData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromKindAndData(int kind, const void *buffer, Py_ssize_t size)
     * }
     */
    public static MethodHandle PyUnicode_FromKindAndData$handle() {
        return PyUnicode_FromKindAndData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromKindAndData(int kind, const void *buffer, Py_ssize_t size)
     * }
     */
    public static MemorySegment PyUnicode_FromKindAndData$address() {
        return PyUnicode_FromKindAndData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromKindAndData(int kind, const void *buffer, Py_ssize_t size)
     * }
     */
    public static MemorySegment PyUnicode_FromKindAndData(int kind, MemorySegment buffer, long size) {
        var mh$ = PyUnicode_FromKindAndData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_FromKindAndData", kind, buffer, size);
            }
            return (MemorySegment)mh$.invokeExact(kind, buffer, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_FromASCII {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_FromASCII");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_FromASCII(const char *buffer, Py_ssize_t size)
     * }
     */
    public static FunctionDescriptor _PyUnicode_FromASCII$descriptor() {
        return _PyUnicode_FromASCII.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_FromASCII(const char *buffer, Py_ssize_t size)
     * }
     */
    public static MethodHandle _PyUnicode_FromASCII$handle() {
        return _PyUnicode_FromASCII.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_FromASCII(const char *buffer, Py_ssize_t size)
     * }
     */
    public static MemorySegment _PyUnicode_FromASCII$address() {
        return _PyUnicode_FromASCII.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyUnicode_FromASCII(const char *buffer, Py_ssize_t size)
     * }
     */
    public static MemorySegment _PyUnicode_FromASCII(MemorySegment buffer, long size) {
        var mh$ = _PyUnicode_FromASCII.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_FromASCII", buffer, size);
            }
            return (MemorySegment)mh$.invokeExact(buffer, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_FindMaxChar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_FindMaxChar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_UCS4 _PyUnicode_FindMaxChar(PyObject *unicode, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static FunctionDescriptor _PyUnicode_FindMaxChar$descriptor() {
        return _PyUnicode_FindMaxChar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_UCS4 _PyUnicode_FindMaxChar(PyObject *unicode, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static MethodHandle _PyUnicode_FindMaxChar$handle() {
        return _PyUnicode_FindMaxChar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_UCS4 _PyUnicode_FindMaxChar(PyObject *unicode, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static MemorySegment _PyUnicode_FindMaxChar$address() {
        return _PyUnicode_FindMaxChar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_UCS4 _PyUnicode_FindMaxChar(PyObject *unicode, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static int _PyUnicode_FindMaxChar(MemorySegment unicode, long start, long end) {
        var mh$ = _PyUnicode_FindMaxChar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_FindMaxChar", unicode, start, end);
            }
            return (int)mh$.invokeExact(unicode, start, end);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_FromUnicode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_FromUnicode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromUnicode(const Py_UNICODE *u, Py_ssize_t size)
     * }
     */
    public static FunctionDescriptor PyUnicode_FromUnicode$descriptor() {
        return PyUnicode_FromUnicode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromUnicode(const Py_UNICODE *u, Py_ssize_t size)
     * }
     */
    public static MethodHandle PyUnicode_FromUnicode$handle() {
        return PyUnicode_FromUnicode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromUnicode(const Py_UNICODE *u, Py_ssize_t size)
     * }
     */
    public static MemorySegment PyUnicode_FromUnicode$address() {
        return PyUnicode_FromUnicode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyUnicode_FromUnicode(const Py_UNICODE *u, Py_ssize_t size)
     * }
     */
    public static MemorySegment PyUnicode_FromUnicode(MemorySegment u, long size) {
        var mh$ = PyUnicode_FromUnicode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_FromUnicode", u, size);
            }
            return (MemorySegment)mh$.invokeExact(u, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsUnicode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsUnicode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_UNICODE *PyUnicode_AsUnicode(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsUnicode$descriptor() {
        return PyUnicode_AsUnicode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_UNICODE *PyUnicode_AsUnicode(PyObject *unicode)
     * }
     */
    public static MethodHandle PyUnicode_AsUnicode$handle() {
        return PyUnicode_AsUnicode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_UNICODE *PyUnicode_AsUnicode(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsUnicode$address() {
        return PyUnicode_AsUnicode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_UNICODE *PyUnicode_AsUnicode(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsUnicode(MemorySegment unicode) {
        var mh$ = PyUnicode_AsUnicode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsUnicode", unicode);
            }
            return (MemorySegment)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_AsUnicode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_AsUnicode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const Py_UNICODE *_PyUnicode_AsUnicode(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor _PyUnicode_AsUnicode$descriptor() {
        return _PyUnicode_AsUnicode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const Py_UNICODE *_PyUnicode_AsUnicode(PyObject *unicode)
     * }
     */
    public static MethodHandle _PyUnicode_AsUnicode$handle() {
        return _PyUnicode_AsUnicode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const Py_UNICODE *_PyUnicode_AsUnicode(PyObject *unicode)
     * }
     */
    public static MemorySegment _PyUnicode_AsUnicode$address() {
        return _PyUnicode_AsUnicode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const Py_UNICODE *_PyUnicode_AsUnicode(PyObject *unicode)
     * }
     */
    public static MemorySegment _PyUnicode_AsUnicode(MemorySegment unicode) {
        var mh$ = _PyUnicode_AsUnicode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_AsUnicode", unicode);
            }
            return (MemorySegment)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsUnicodeAndSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsUnicodeAndSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_UNICODE *PyUnicode_AsUnicodeAndSize(PyObject *unicode, Py_ssize_t *size)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsUnicodeAndSize$descriptor() {
        return PyUnicode_AsUnicodeAndSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_UNICODE *PyUnicode_AsUnicodeAndSize(PyObject *unicode, Py_ssize_t *size)
     * }
     */
    public static MethodHandle PyUnicode_AsUnicodeAndSize$handle() {
        return PyUnicode_AsUnicodeAndSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_UNICODE *PyUnicode_AsUnicodeAndSize(PyObject *unicode, Py_ssize_t *size)
     * }
     */
    public static MemorySegment PyUnicode_AsUnicodeAndSize$address() {
        return PyUnicode_AsUnicodeAndSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_UNICODE *PyUnicode_AsUnicodeAndSize(PyObject *unicode, Py_ssize_t *size)
     * }
     */
    public static MemorySegment PyUnicode_AsUnicodeAndSize(MemorySegment unicode, MemorySegment size) {
        var mh$ = PyUnicode_AsUnicodeAndSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsUnicodeAndSize", unicode, size);
            }
            return (MemorySegment)mh$.invokeExact(unicode, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicodeWriter_Init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicodeWriter_Init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyUnicodeWriter_Init(_PyUnicodeWriter *writer)
     * }
     */
    public static FunctionDescriptor _PyUnicodeWriter_Init$descriptor() {
        return _PyUnicodeWriter_Init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyUnicodeWriter_Init(_PyUnicodeWriter *writer)
     * }
     */
    public static MethodHandle _PyUnicodeWriter_Init$handle() {
        return _PyUnicodeWriter_Init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyUnicodeWriter_Init(_PyUnicodeWriter *writer)
     * }
     */
    public static MemorySegment _PyUnicodeWriter_Init$address() {
        return _PyUnicodeWriter_Init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyUnicodeWriter_Init(_PyUnicodeWriter *writer)
     * }
     */
    public static void _PyUnicodeWriter_Init(MemorySegment writer) {
        var mh$ = _PyUnicodeWriter_Init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicodeWriter_Init", writer);
            }
            mh$.invokeExact(writer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicodeWriter_PrepareInternal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicodeWriter_PrepareInternal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicodeWriter_PrepareInternal(_PyUnicodeWriter *writer, Py_ssize_t length, Py_UCS4 maxchar)
     * }
     */
    public static FunctionDescriptor _PyUnicodeWriter_PrepareInternal$descriptor() {
        return _PyUnicodeWriter_PrepareInternal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicodeWriter_PrepareInternal(_PyUnicodeWriter *writer, Py_ssize_t length, Py_UCS4 maxchar)
     * }
     */
    public static MethodHandle _PyUnicodeWriter_PrepareInternal$handle() {
        return _PyUnicodeWriter_PrepareInternal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicodeWriter_PrepareInternal(_PyUnicodeWriter *writer, Py_ssize_t length, Py_UCS4 maxchar)
     * }
     */
    public static MemorySegment _PyUnicodeWriter_PrepareInternal$address() {
        return _PyUnicodeWriter_PrepareInternal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicodeWriter_PrepareInternal(_PyUnicodeWriter *writer, Py_ssize_t length, Py_UCS4 maxchar)
     * }
     */
    public static int _PyUnicodeWriter_PrepareInternal(MemorySegment writer, long length, int maxchar) {
        var mh$ = _PyUnicodeWriter_PrepareInternal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicodeWriter_PrepareInternal", writer, length, maxchar);
            }
            return (int)mh$.invokeExact(writer, length, maxchar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicodeWriter_PrepareKindInternal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicodeWriter_PrepareKindInternal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicodeWriter_PrepareKindInternal(_PyUnicodeWriter *writer, enum PyUnicode_Kind kind)
     * }
     */
    public static FunctionDescriptor _PyUnicodeWriter_PrepareKindInternal$descriptor() {
        return _PyUnicodeWriter_PrepareKindInternal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicodeWriter_PrepareKindInternal(_PyUnicodeWriter *writer, enum PyUnicode_Kind kind)
     * }
     */
    public static MethodHandle _PyUnicodeWriter_PrepareKindInternal$handle() {
        return _PyUnicodeWriter_PrepareKindInternal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicodeWriter_PrepareKindInternal(_PyUnicodeWriter *writer, enum PyUnicode_Kind kind)
     * }
     */
    public static MemorySegment _PyUnicodeWriter_PrepareKindInternal$address() {
        return _PyUnicodeWriter_PrepareKindInternal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicodeWriter_PrepareKindInternal(_PyUnicodeWriter *writer, enum PyUnicode_Kind kind)
     * }
     */
    public static int _PyUnicodeWriter_PrepareKindInternal(MemorySegment writer, int kind) {
        var mh$ = _PyUnicodeWriter_PrepareKindInternal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicodeWriter_PrepareKindInternal", writer, kind);
            }
            return (int)mh$.invokeExact(writer, kind);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicodeWriter_WriteChar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicodeWriter_WriteChar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicodeWriter_WriteChar(_PyUnicodeWriter *writer, Py_UCS4 ch)
     * }
     */
    public static FunctionDescriptor _PyUnicodeWriter_WriteChar$descriptor() {
        return _PyUnicodeWriter_WriteChar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicodeWriter_WriteChar(_PyUnicodeWriter *writer, Py_UCS4 ch)
     * }
     */
    public static MethodHandle _PyUnicodeWriter_WriteChar$handle() {
        return _PyUnicodeWriter_WriteChar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicodeWriter_WriteChar(_PyUnicodeWriter *writer, Py_UCS4 ch)
     * }
     */
    public static MemorySegment _PyUnicodeWriter_WriteChar$address() {
        return _PyUnicodeWriter_WriteChar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicodeWriter_WriteChar(_PyUnicodeWriter *writer, Py_UCS4 ch)
     * }
     */
    public static int _PyUnicodeWriter_WriteChar(MemorySegment writer, int ch) {
        var mh$ = _PyUnicodeWriter_WriteChar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicodeWriter_WriteChar", writer, ch);
            }
            return (int)mh$.invokeExact(writer, ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicodeWriter_WriteStr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicodeWriter_WriteStr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicodeWriter_WriteStr(_PyUnicodeWriter *writer, PyObject *str)
     * }
     */
    public static FunctionDescriptor _PyUnicodeWriter_WriteStr$descriptor() {
        return _PyUnicodeWriter_WriteStr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicodeWriter_WriteStr(_PyUnicodeWriter *writer, PyObject *str)
     * }
     */
    public static MethodHandle _PyUnicodeWriter_WriteStr$handle() {
        return _PyUnicodeWriter_WriteStr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicodeWriter_WriteStr(_PyUnicodeWriter *writer, PyObject *str)
     * }
     */
    public static MemorySegment _PyUnicodeWriter_WriteStr$address() {
        return _PyUnicodeWriter_WriteStr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicodeWriter_WriteStr(_PyUnicodeWriter *writer, PyObject *str)
     * }
     */
    public static int _PyUnicodeWriter_WriteStr(MemorySegment writer, MemorySegment str) {
        var mh$ = _PyUnicodeWriter_WriteStr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicodeWriter_WriteStr", writer, str);
            }
            return (int)mh$.invokeExact(writer, str);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicodeWriter_WriteSubstring {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicodeWriter_WriteSubstring");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicodeWriter_WriteSubstring(_PyUnicodeWriter *writer, PyObject *str, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static FunctionDescriptor _PyUnicodeWriter_WriteSubstring$descriptor() {
        return _PyUnicodeWriter_WriteSubstring.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicodeWriter_WriteSubstring(_PyUnicodeWriter *writer, PyObject *str, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static MethodHandle _PyUnicodeWriter_WriteSubstring$handle() {
        return _PyUnicodeWriter_WriteSubstring.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicodeWriter_WriteSubstring(_PyUnicodeWriter *writer, PyObject *str, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static MemorySegment _PyUnicodeWriter_WriteSubstring$address() {
        return _PyUnicodeWriter_WriteSubstring.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicodeWriter_WriteSubstring(_PyUnicodeWriter *writer, PyObject *str, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static int _PyUnicodeWriter_WriteSubstring(MemorySegment writer, MemorySegment str, long start, long end) {
        var mh$ = _PyUnicodeWriter_WriteSubstring.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicodeWriter_WriteSubstring", writer, str, start, end);
            }
            return (int)mh$.invokeExact(writer, str, start, end);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicodeWriter_WriteASCIIString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicodeWriter_WriteASCIIString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicodeWriter_WriteASCIIString(_PyUnicodeWriter *writer, const char *str, Py_ssize_t len)
     * }
     */
    public static FunctionDescriptor _PyUnicodeWriter_WriteASCIIString$descriptor() {
        return _PyUnicodeWriter_WriteASCIIString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicodeWriter_WriteASCIIString(_PyUnicodeWriter *writer, const char *str, Py_ssize_t len)
     * }
     */
    public static MethodHandle _PyUnicodeWriter_WriteASCIIString$handle() {
        return _PyUnicodeWriter_WriteASCIIString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicodeWriter_WriteASCIIString(_PyUnicodeWriter *writer, const char *str, Py_ssize_t len)
     * }
     */
    public static MemorySegment _PyUnicodeWriter_WriteASCIIString$address() {
        return _PyUnicodeWriter_WriteASCIIString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicodeWriter_WriteASCIIString(_PyUnicodeWriter *writer, const char *str, Py_ssize_t len)
     * }
     */
    public static int _PyUnicodeWriter_WriteASCIIString(MemorySegment writer, MemorySegment str, long len) {
        var mh$ = _PyUnicodeWriter_WriteASCIIString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicodeWriter_WriteASCIIString", writer, str, len);
            }
            return (int)mh$.invokeExact(writer, str, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicodeWriter_WriteLatin1String {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicodeWriter_WriteLatin1String");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicodeWriter_WriteLatin1String(_PyUnicodeWriter *writer, const char *str, Py_ssize_t len)
     * }
     */
    public static FunctionDescriptor _PyUnicodeWriter_WriteLatin1String$descriptor() {
        return _PyUnicodeWriter_WriteLatin1String.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicodeWriter_WriteLatin1String(_PyUnicodeWriter *writer, const char *str, Py_ssize_t len)
     * }
     */
    public static MethodHandle _PyUnicodeWriter_WriteLatin1String$handle() {
        return _PyUnicodeWriter_WriteLatin1String.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicodeWriter_WriteLatin1String(_PyUnicodeWriter *writer, const char *str, Py_ssize_t len)
     * }
     */
    public static MemorySegment _PyUnicodeWriter_WriteLatin1String$address() {
        return _PyUnicodeWriter_WriteLatin1String.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicodeWriter_WriteLatin1String(_PyUnicodeWriter *writer, const char *str, Py_ssize_t len)
     * }
     */
    public static int _PyUnicodeWriter_WriteLatin1String(MemorySegment writer, MemorySegment str, long len) {
        var mh$ = _PyUnicodeWriter_WriteLatin1String.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicodeWriter_WriteLatin1String", writer, str, len);
            }
            return (int)mh$.invokeExact(writer, str, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicodeWriter_Finish {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicodeWriter_Finish");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyUnicodeWriter_Finish(_PyUnicodeWriter *writer)
     * }
     */
    public static FunctionDescriptor _PyUnicodeWriter_Finish$descriptor() {
        return _PyUnicodeWriter_Finish.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyUnicodeWriter_Finish(_PyUnicodeWriter *writer)
     * }
     */
    public static MethodHandle _PyUnicodeWriter_Finish$handle() {
        return _PyUnicodeWriter_Finish.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyUnicodeWriter_Finish(_PyUnicodeWriter *writer)
     * }
     */
    public static MemorySegment _PyUnicodeWriter_Finish$address() {
        return _PyUnicodeWriter_Finish.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyUnicodeWriter_Finish(_PyUnicodeWriter *writer)
     * }
     */
    public static MemorySegment _PyUnicodeWriter_Finish(MemorySegment writer) {
        var mh$ = _PyUnicodeWriter_Finish.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicodeWriter_Finish", writer);
            }
            return (MemorySegment)mh$.invokeExact(writer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicodeWriter_Dealloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicodeWriter_Dealloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _PyUnicodeWriter_Dealloc(_PyUnicodeWriter *writer)
     * }
     */
    public static FunctionDescriptor _PyUnicodeWriter_Dealloc$descriptor() {
        return _PyUnicodeWriter_Dealloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _PyUnicodeWriter_Dealloc(_PyUnicodeWriter *writer)
     * }
     */
    public static MethodHandle _PyUnicodeWriter_Dealloc$handle() {
        return _PyUnicodeWriter_Dealloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _PyUnicodeWriter_Dealloc(_PyUnicodeWriter *writer)
     * }
     */
    public static MemorySegment _PyUnicodeWriter_Dealloc$address() {
        return _PyUnicodeWriter_Dealloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _PyUnicodeWriter_Dealloc(_PyUnicodeWriter *writer)
     * }
     */
    public static void _PyUnicodeWriter_Dealloc(MemorySegment writer) {
        var mh$ = _PyUnicodeWriter_Dealloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicodeWriter_Dealloc", writer);
            }
            mh$.invokeExact(writer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_FormatAdvancedWriter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_FormatAdvancedWriter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicode_FormatAdvancedWriter(_PyUnicodeWriter *writer, PyObject *obj, PyObject *format_spec, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static FunctionDescriptor _PyUnicode_FormatAdvancedWriter$descriptor() {
        return _PyUnicode_FormatAdvancedWriter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicode_FormatAdvancedWriter(_PyUnicodeWriter *writer, PyObject *obj, PyObject *format_spec, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static MethodHandle _PyUnicode_FormatAdvancedWriter$handle() {
        return _PyUnicode_FormatAdvancedWriter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicode_FormatAdvancedWriter(_PyUnicodeWriter *writer, PyObject *obj, PyObject *format_spec, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static MemorySegment _PyUnicode_FormatAdvancedWriter$address() {
        return _PyUnicode_FormatAdvancedWriter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicode_FormatAdvancedWriter(_PyUnicodeWriter *writer, PyObject *obj, PyObject *format_spec, Py_ssize_t start, Py_ssize_t end)
     * }
     */
    public static int _PyUnicode_FormatAdvancedWriter(MemorySegment writer, MemorySegment obj, MemorySegment format_spec, long start, long end) {
        var mh$ = _PyUnicode_FormatAdvancedWriter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_FormatAdvancedWriter", writer, obj, format_spec, start, end);
            }
            return (int)mh$.invokeExact(writer, obj, format_spec, start, end);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyUnicode_AsUTF8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyUnicode_AsUTF8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *PyUnicode_AsUTF8(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor PyUnicode_AsUTF8$descriptor() {
        return PyUnicode_AsUTF8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *PyUnicode_AsUTF8(PyObject *unicode)
     * }
     */
    public static MethodHandle PyUnicode_AsUTF8$handle() {
        return PyUnicode_AsUTF8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *PyUnicode_AsUTF8(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsUTF8$address() {
        return PyUnicode_AsUTF8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *PyUnicode_AsUTF8(PyObject *unicode)
     * }
     */
    public static MemorySegment PyUnicode_AsUTF8(MemorySegment unicode) {
        var mh$ = PyUnicode_AsUTF8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyUnicode_AsUTF8", unicode);
            }
            return (MemorySegment)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_EncodeUTF7 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_EncodeUTF7");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_EncodeUTF7(PyObject *unicode, int base64SetO, int base64WhiteSpace, const char *errors)
     * }
     */
    public static FunctionDescriptor _PyUnicode_EncodeUTF7$descriptor() {
        return _PyUnicode_EncodeUTF7.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_EncodeUTF7(PyObject *unicode, int base64SetO, int base64WhiteSpace, const char *errors)
     * }
     */
    public static MethodHandle _PyUnicode_EncodeUTF7$handle() {
        return _PyUnicode_EncodeUTF7.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_EncodeUTF7(PyObject *unicode, int base64SetO, int base64WhiteSpace, const char *errors)
     * }
     */
    public static MemorySegment _PyUnicode_EncodeUTF7$address() {
        return _PyUnicode_EncodeUTF7.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyUnicode_EncodeUTF7(PyObject *unicode, int base64SetO, int base64WhiteSpace, const char *errors)
     * }
     */
    public static MemorySegment _PyUnicode_EncodeUTF7(MemorySegment unicode, int base64SetO, int base64WhiteSpace, MemorySegment errors) {
        var mh$ = _PyUnicode_EncodeUTF7.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_EncodeUTF7", unicode, base64SetO, base64WhiteSpace, errors);
            }
            return (MemorySegment)mh$.invokeExact(unicode, base64SetO, base64WhiteSpace, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_AsUTF8String {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_AsUTF8String");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_AsUTF8String(PyObject *unicode, const char *errors)
     * }
     */
    public static FunctionDescriptor _PyUnicode_AsUTF8String$descriptor() {
        return _PyUnicode_AsUTF8String.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_AsUTF8String(PyObject *unicode, const char *errors)
     * }
     */
    public static MethodHandle _PyUnicode_AsUTF8String$handle() {
        return _PyUnicode_AsUTF8String.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_AsUTF8String(PyObject *unicode, const char *errors)
     * }
     */
    public static MemorySegment _PyUnicode_AsUTF8String$address() {
        return _PyUnicode_AsUTF8String.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyUnicode_AsUTF8String(PyObject *unicode, const char *errors)
     * }
     */
    public static MemorySegment _PyUnicode_AsUTF8String(MemorySegment unicode, MemorySegment errors) {
        var mh$ = _PyUnicode_AsUTF8String.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_AsUTF8String", unicode, errors);
            }
            return (MemorySegment)mh$.invokeExact(unicode, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_EncodeUTF32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_EncodeUTF32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_EncodeUTF32(PyObject *object, const char *errors, int byteorder)
     * }
     */
    public static FunctionDescriptor _PyUnicode_EncodeUTF32$descriptor() {
        return _PyUnicode_EncodeUTF32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_EncodeUTF32(PyObject *object, const char *errors, int byteorder)
     * }
     */
    public static MethodHandle _PyUnicode_EncodeUTF32$handle() {
        return _PyUnicode_EncodeUTF32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_EncodeUTF32(PyObject *object, const char *errors, int byteorder)
     * }
     */
    public static MemorySegment _PyUnicode_EncodeUTF32$address() {
        return _PyUnicode_EncodeUTF32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyUnicode_EncodeUTF32(PyObject *object, const char *errors, int byteorder)
     * }
     */
    public static MemorySegment _PyUnicode_EncodeUTF32(MemorySegment object, MemorySegment errors, int byteorder) {
        var mh$ = _PyUnicode_EncodeUTF32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_EncodeUTF32", object, errors, byteorder);
            }
            return (MemorySegment)mh$.invokeExact(object, errors, byteorder);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_EncodeUTF16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_EncodeUTF16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_EncodeUTF16(PyObject *unicode, const char *errors, int byteorder)
     * }
     */
    public static FunctionDescriptor _PyUnicode_EncodeUTF16$descriptor() {
        return _PyUnicode_EncodeUTF16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_EncodeUTF16(PyObject *unicode, const char *errors, int byteorder)
     * }
     */
    public static MethodHandle _PyUnicode_EncodeUTF16$handle() {
        return _PyUnicode_EncodeUTF16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_EncodeUTF16(PyObject *unicode, const char *errors, int byteorder)
     * }
     */
    public static MemorySegment _PyUnicode_EncodeUTF16$address() {
        return _PyUnicode_EncodeUTF16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyUnicode_EncodeUTF16(PyObject *unicode, const char *errors, int byteorder)
     * }
     */
    public static MemorySegment _PyUnicode_EncodeUTF16(MemorySegment unicode, MemorySegment errors, int byteorder) {
        var mh$ = _PyUnicode_EncodeUTF16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_EncodeUTF16", unicode, errors, byteorder);
            }
            return (MemorySegment)mh$.invokeExact(unicode, errors, byteorder);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_DecodeUnicodeEscapeStateful {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_DecodeUnicodeEscapeStateful");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_DecodeUnicodeEscapeStateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static FunctionDescriptor _PyUnicode_DecodeUnicodeEscapeStateful$descriptor() {
        return _PyUnicode_DecodeUnicodeEscapeStateful.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_DecodeUnicodeEscapeStateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static MethodHandle _PyUnicode_DecodeUnicodeEscapeStateful$handle() {
        return _PyUnicode_DecodeUnicodeEscapeStateful.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_DecodeUnicodeEscapeStateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static MemorySegment _PyUnicode_DecodeUnicodeEscapeStateful$address() {
        return _PyUnicode_DecodeUnicodeEscapeStateful.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyUnicode_DecodeUnicodeEscapeStateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static MemorySegment _PyUnicode_DecodeUnicodeEscapeStateful(MemorySegment string, long length, MemorySegment errors, MemorySegment consumed) {
        var mh$ = _PyUnicode_DecodeUnicodeEscapeStateful.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_DecodeUnicodeEscapeStateful", string, length, errors, consumed);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors, consumed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_DecodeUnicodeEscapeInternal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_DecodeUnicodeEscapeInternal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_DecodeUnicodeEscapeInternal(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed, const char **first_invalid_escape)
     * }
     */
    public static FunctionDescriptor _PyUnicode_DecodeUnicodeEscapeInternal$descriptor() {
        return _PyUnicode_DecodeUnicodeEscapeInternal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_DecodeUnicodeEscapeInternal(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed, const char **first_invalid_escape)
     * }
     */
    public static MethodHandle _PyUnicode_DecodeUnicodeEscapeInternal$handle() {
        return _PyUnicode_DecodeUnicodeEscapeInternal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_DecodeUnicodeEscapeInternal(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed, const char **first_invalid_escape)
     * }
     */
    public static MemorySegment _PyUnicode_DecodeUnicodeEscapeInternal$address() {
        return _PyUnicode_DecodeUnicodeEscapeInternal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyUnicode_DecodeUnicodeEscapeInternal(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed, const char **first_invalid_escape)
     * }
     */
    public static MemorySegment _PyUnicode_DecodeUnicodeEscapeInternal(MemorySegment string, long length, MemorySegment errors, MemorySegment consumed, MemorySegment first_invalid_escape) {
        var mh$ = _PyUnicode_DecodeUnicodeEscapeInternal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_DecodeUnicodeEscapeInternal", string, length, errors, consumed, first_invalid_escape);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors, consumed, first_invalid_escape);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_DecodeRawUnicodeEscapeStateful {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_DecodeRawUnicodeEscapeStateful");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_DecodeRawUnicodeEscapeStateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static FunctionDescriptor _PyUnicode_DecodeRawUnicodeEscapeStateful$descriptor() {
        return _PyUnicode_DecodeRawUnicodeEscapeStateful.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_DecodeRawUnicodeEscapeStateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static MethodHandle _PyUnicode_DecodeRawUnicodeEscapeStateful$handle() {
        return _PyUnicode_DecodeRawUnicodeEscapeStateful.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_DecodeRawUnicodeEscapeStateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static MemorySegment _PyUnicode_DecodeRawUnicodeEscapeStateful$address() {
        return _PyUnicode_DecodeRawUnicodeEscapeStateful.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyUnicode_DecodeRawUnicodeEscapeStateful(const char *string, Py_ssize_t length, const char *errors, Py_ssize_t *consumed)
     * }
     */
    public static MemorySegment _PyUnicode_DecodeRawUnicodeEscapeStateful(MemorySegment string, long length, MemorySegment errors, MemorySegment consumed) {
        var mh$ = _PyUnicode_DecodeRawUnicodeEscapeStateful.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_DecodeRawUnicodeEscapeStateful", string, length, errors, consumed);
            }
            return (MemorySegment)mh$.invokeExact(string, length, errors, consumed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_AsLatin1String {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_AsLatin1String");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_AsLatin1String(PyObject *unicode, const char *errors)
     * }
     */
    public static FunctionDescriptor _PyUnicode_AsLatin1String$descriptor() {
        return _PyUnicode_AsLatin1String.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_AsLatin1String(PyObject *unicode, const char *errors)
     * }
     */
    public static MethodHandle _PyUnicode_AsLatin1String$handle() {
        return _PyUnicode_AsLatin1String.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_AsLatin1String(PyObject *unicode, const char *errors)
     * }
     */
    public static MemorySegment _PyUnicode_AsLatin1String$address() {
        return _PyUnicode_AsLatin1String.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyUnicode_AsLatin1String(PyObject *unicode, const char *errors)
     * }
     */
    public static MemorySegment _PyUnicode_AsLatin1String(MemorySegment unicode, MemorySegment errors) {
        var mh$ = _PyUnicode_AsLatin1String.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_AsLatin1String", unicode, errors);
            }
            return (MemorySegment)mh$.invokeExact(unicode, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_AsASCIIString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_AsASCIIString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_AsASCIIString(PyObject *unicode, const char *errors)
     * }
     */
    public static FunctionDescriptor _PyUnicode_AsASCIIString$descriptor() {
        return _PyUnicode_AsASCIIString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_AsASCIIString(PyObject *unicode, const char *errors)
     * }
     */
    public static MethodHandle _PyUnicode_AsASCIIString$handle() {
        return _PyUnicode_AsASCIIString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_AsASCIIString(PyObject *unicode, const char *errors)
     * }
     */
    public static MemorySegment _PyUnicode_AsASCIIString$address() {
        return _PyUnicode_AsASCIIString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyUnicode_AsASCIIString(PyObject *unicode, const char *errors)
     * }
     */
    public static MemorySegment _PyUnicode_AsASCIIString(MemorySegment unicode, MemorySegment errors) {
        var mh$ = _PyUnicode_AsASCIIString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_AsASCIIString", unicode, errors);
            }
            return (MemorySegment)mh$.invokeExact(unicode, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_EncodeCharmap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_EncodeCharmap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_EncodeCharmap(PyObject *unicode, PyObject *mapping, const char *errors)
     * }
     */
    public static FunctionDescriptor _PyUnicode_EncodeCharmap$descriptor() {
        return _PyUnicode_EncodeCharmap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_EncodeCharmap(PyObject *unicode, PyObject *mapping, const char *errors)
     * }
     */
    public static MethodHandle _PyUnicode_EncodeCharmap$handle() {
        return _PyUnicode_EncodeCharmap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_EncodeCharmap(PyObject *unicode, PyObject *mapping, const char *errors)
     * }
     */
    public static MemorySegment _PyUnicode_EncodeCharmap$address() {
        return _PyUnicode_EncodeCharmap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyUnicode_EncodeCharmap(PyObject *unicode, PyObject *mapping, const char *errors)
     * }
     */
    public static MemorySegment _PyUnicode_EncodeCharmap(MemorySegment unicode, MemorySegment mapping, MemorySegment errors) {
        var mh$ = _PyUnicode_EncodeCharmap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_EncodeCharmap", unicode, mapping, errors);
            }
            return (MemorySegment)mh$.invokeExact(unicode, mapping, errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_TransformDecimalAndSpaceToASCII {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_TransformDecimalAndSpaceToASCII");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_TransformDecimalAndSpaceToASCII(PyObject *unicode)
     * }
     */
    public static FunctionDescriptor _PyUnicode_TransformDecimalAndSpaceToASCII$descriptor() {
        return _PyUnicode_TransformDecimalAndSpaceToASCII.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_TransformDecimalAndSpaceToASCII(PyObject *unicode)
     * }
     */
    public static MethodHandle _PyUnicode_TransformDecimalAndSpaceToASCII$handle() {
        return _PyUnicode_TransformDecimalAndSpaceToASCII.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_TransformDecimalAndSpaceToASCII(PyObject *unicode)
     * }
     */
    public static MemorySegment _PyUnicode_TransformDecimalAndSpaceToASCII$address() {
        return _PyUnicode_TransformDecimalAndSpaceToASCII.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyUnicode_TransformDecimalAndSpaceToASCII(PyObject *unicode)
     * }
     */
    public static MemorySegment _PyUnicode_TransformDecimalAndSpaceToASCII(MemorySegment unicode) {
        var mh$ = _PyUnicode_TransformDecimalAndSpaceToASCII.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_TransformDecimalAndSpaceToASCII", unicode);
            }
            return (MemorySegment)mh$.invokeExact(unicode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_JoinArray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_JoinArray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_JoinArray(PyObject *separator, PyObject *const *items, Py_ssize_t seqlen)
     * }
     */
    public static FunctionDescriptor _PyUnicode_JoinArray$descriptor() {
        return _PyUnicode_JoinArray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_JoinArray(PyObject *separator, PyObject *const *items, Py_ssize_t seqlen)
     * }
     */
    public static MethodHandle _PyUnicode_JoinArray$handle() {
        return _PyUnicode_JoinArray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_JoinArray(PyObject *separator, PyObject *const *items, Py_ssize_t seqlen)
     * }
     */
    public static MemorySegment _PyUnicode_JoinArray$address() {
        return _PyUnicode_JoinArray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyUnicode_JoinArray(PyObject *separator, PyObject *const *items, Py_ssize_t seqlen)
     * }
     */
    public static MemorySegment _PyUnicode_JoinArray(MemorySegment separator, MemorySegment items, long seqlen) {
        var mh$ = _PyUnicode_JoinArray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_JoinArray", separator, items, seqlen);
            }
            return (MemorySegment)mh$.invokeExact(separator, items, seqlen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_EqualToASCIIId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_EqualToASCIIId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicode_EqualToASCIIId(PyObject *left, _Py_Identifier *right)
     * }
     */
    public static FunctionDescriptor _PyUnicode_EqualToASCIIId$descriptor() {
        return _PyUnicode_EqualToASCIIId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicode_EqualToASCIIId(PyObject *left, _Py_Identifier *right)
     * }
     */
    public static MethodHandle _PyUnicode_EqualToASCIIId$handle() {
        return _PyUnicode_EqualToASCIIId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicode_EqualToASCIIId(PyObject *left, _Py_Identifier *right)
     * }
     */
    public static MemorySegment _PyUnicode_EqualToASCIIId$address() {
        return _PyUnicode_EqualToASCIIId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicode_EqualToASCIIId(PyObject *left, _Py_Identifier *right)
     * }
     */
    public static int _PyUnicode_EqualToASCIIId(MemorySegment left, MemorySegment right) {
        var mh$ = _PyUnicode_EqualToASCIIId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_EqualToASCIIId", left, right);
            }
            return (int)mh$.invokeExact(left, right);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_EqualToASCIIString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_EqualToASCIIString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicode_EqualToASCIIString(PyObject *left, const char *right)
     * }
     */
    public static FunctionDescriptor _PyUnicode_EqualToASCIIString$descriptor() {
        return _PyUnicode_EqualToASCIIString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicode_EqualToASCIIString(PyObject *left, const char *right)
     * }
     */
    public static MethodHandle _PyUnicode_EqualToASCIIString$handle() {
        return _PyUnicode_EqualToASCIIString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicode_EqualToASCIIString(PyObject *left, const char *right)
     * }
     */
    public static MemorySegment _PyUnicode_EqualToASCIIString$address() {
        return _PyUnicode_EqualToASCIIString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicode_EqualToASCIIString(PyObject *left, const char *right)
     * }
     */
    public static int _PyUnicode_EqualToASCIIString(MemorySegment left, MemorySegment right) {
        var mh$ = _PyUnicode_EqualToASCIIString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_EqualToASCIIString", left, right);
            }
            return (int)mh$.invokeExact(left, right);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_XStrip {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_XStrip");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_XStrip(PyObject *self, int striptype, PyObject *sepobj)
     * }
     */
    public static FunctionDescriptor _PyUnicode_XStrip$descriptor() {
        return _PyUnicode_XStrip.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_XStrip(PyObject *self, int striptype, PyObject *sepobj)
     * }
     */
    public static MethodHandle _PyUnicode_XStrip$handle() {
        return _PyUnicode_XStrip.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_XStrip(PyObject *self, int striptype, PyObject *sepobj)
     * }
     */
    public static MemorySegment _PyUnicode_XStrip$address() {
        return _PyUnicode_XStrip.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyUnicode_XStrip(PyObject *self, int striptype, PyObject *sepobj)
     * }
     */
    public static MemorySegment _PyUnicode_XStrip(MemorySegment self, int striptype, MemorySegment sepobj) {
        var mh$ = _PyUnicode_XStrip.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_XStrip", self, striptype, sepobj);
            }
            return (MemorySegment)mh$.invokeExact(self, striptype, sepobj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_InsertThousandsGrouping {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_InsertThousandsGrouping");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t _PyUnicode_InsertThousandsGrouping(_PyUnicodeWriter *writer, Py_ssize_t n_buffer, PyObject *digits, Py_ssize_t d_pos, Py_ssize_t n_digits, Py_ssize_t min_width, const char *grouping, PyObject *thousands_sep, Py_UCS4 *maxchar)
     * }
     */
    public static FunctionDescriptor _PyUnicode_InsertThousandsGrouping$descriptor() {
        return _PyUnicode_InsertThousandsGrouping.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t _PyUnicode_InsertThousandsGrouping(_PyUnicodeWriter *writer, Py_ssize_t n_buffer, PyObject *digits, Py_ssize_t d_pos, Py_ssize_t n_digits, Py_ssize_t min_width, const char *grouping, PyObject *thousands_sep, Py_UCS4 *maxchar)
     * }
     */
    public static MethodHandle _PyUnicode_InsertThousandsGrouping$handle() {
        return _PyUnicode_InsertThousandsGrouping.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t _PyUnicode_InsertThousandsGrouping(_PyUnicodeWriter *writer, Py_ssize_t n_buffer, PyObject *digits, Py_ssize_t d_pos, Py_ssize_t n_digits, Py_ssize_t min_width, const char *grouping, PyObject *thousands_sep, Py_UCS4 *maxchar)
     * }
     */
    public static MemorySegment _PyUnicode_InsertThousandsGrouping$address() {
        return _PyUnicode_InsertThousandsGrouping.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t _PyUnicode_InsertThousandsGrouping(_PyUnicodeWriter *writer, Py_ssize_t n_buffer, PyObject *digits, Py_ssize_t d_pos, Py_ssize_t n_digits, Py_ssize_t min_width, const char *grouping, PyObject *thousands_sep, Py_UCS4 *maxchar)
     * }
     */
    public static long _PyUnicode_InsertThousandsGrouping(MemorySegment writer, long n_buffer, MemorySegment digits, long d_pos, long n_digits, long min_width, MemorySegment grouping, MemorySegment thousands_sep, MemorySegment maxchar) {
        var mh$ = _PyUnicode_InsertThousandsGrouping.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_InsertThousandsGrouping", writer, n_buffer, digits, d_pos, n_digits, min_width, grouping, thousands_sep, maxchar);
            }
            return (long)mh$.invokeExact(writer, n_buffer, digits, d_pos, n_digits, min_width, grouping, thousands_sep, maxchar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_ascii_whitespace$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(0, Python_h.C_CHAR);
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_Py_ascii_whitespace").reinterpret(LAYOUT.byteSize());
        public static final VarHandle HANDLE = LAYOUT.varHandle();

        public static final long[] DIMS = {  };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const unsigned char _Py_ascii_whitespace[]
     * }
     */
    public static SequenceLayout _Py_ascii_whitespace$layout() {
        return _Py_ascii_whitespace$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern const unsigned char _Py_ascii_whitespace[]
     * }
     */
    public static long[] _Py_ascii_whitespace$dimensions() {
        return _Py_ascii_whitespace$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const unsigned char _Py_ascii_whitespace[]
     * }
     */
    public static MemorySegment _Py_ascii_whitespace() {
        return _Py_ascii_whitespace$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const unsigned char _Py_ascii_whitespace[]
     * }
     */
    public static void _Py_ascii_whitespace(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Py_ascii_whitespace$constants.SEGMENT, 0L, _Py_ascii_whitespace$constants.LAYOUT.byteSize());
    }

    private static class _PyUnicode_IsLowercase {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_IsLowercase");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicode_IsLowercase(Py_UCS4 ch)
     * }
     */
    public static FunctionDescriptor _PyUnicode_IsLowercase$descriptor() {
        return _PyUnicode_IsLowercase.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicode_IsLowercase(Py_UCS4 ch)
     * }
     */
    public static MethodHandle _PyUnicode_IsLowercase$handle() {
        return _PyUnicode_IsLowercase.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicode_IsLowercase(Py_UCS4 ch)
     * }
     */
    public static MemorySegment _PyUnicode_IsLowercase$address() {
        return _PyUnicode_IsLowercase.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicode_IsLowercase(Py_UCS4 ch)
     * }
     */
    public static int _PyUnicode_IsLowercase(int ch) {
        var mh$ = _PyUnicode_IsLowercase.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_IsLowercase", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_IsUppercase {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_IsUppercase");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicode_IsUppercase(Py_UCS4 ch)
     * }
     */
    public static FunctionDescriptor _PyUnicode_IsUppercase$descriptor() {
        return _PyUnicode_IsUppercase.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicode_IsUppercase(Py_UCS4 ch)
     * }
     */
    public static MethodHandle _PyUnicode_IsUppercase$handle() {
        return _PyUnicode_IsUppercase.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicode_IsUppercase(Py_UCS4 ch)
     * }
     */
    public static MemorySegment _PyUnicode_IsUppercase$address() {
        return _PyUnicode_IsUppercase.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicode_IsUppercase(Py_UCS4 ch)
     * }
     */
    public static int _PyUnicode_IsUppercase(int ch) {
        var mh$ = _PyUnicode_IsUppercase.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_IsUppercase", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_IsTitlecase {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_IsTitlecase");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicode_IsTitlecase(Py_UCS4 ch)
     * }
     */
    public static FunctionDescriptor _PyUnicode_IsTitlecase$descriptor() {
        return _PyUnicode_IsTitlecase.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicode_IsTitlecase(Py_UCS4 ch)
     * }
     */
    public static MethodHandle _PyUnicode_IsTitlecase$handle() {
        return _PyUnicode_IsTitlecase.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicode_IsTitlecase(Py_UCS4 ch)
     * }
     */
    public static MemorySegment _PyUnicode_IsTitlecase$address() {
        return _PyUnicode_IsTitlecase.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicode_IsTitlecase(Py_UCS4 ch)
     * }
     */
    public static int _PyUnicode_IsTitlecase(int ch) {
        var mh$ = _PyUnicode_IsTitlecase.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_IsTitlecase", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_IsXidStart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_IsXidStart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicode_IsXidStart(Py_UCS4 ch)
     * }
     */
    public static FunctionDescriptor _PyUnicode_IsXidStart$descriptor() {
        return _PyUnicode_IsXidStart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicode_IsXidStart(Py_UCS4 ch)
     * }
     */
    public static MethodHandle _PyUnicode_IsXidStart$handle() {
        return _PyUnicode_IsXidStart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicode_IsXidStart(Py_UCS4 ch)
     * }
     */
    public static MemorySegment _PyUnicode_IsXidStart$address() {
        return _PyUnicode_IsXidStart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicode_IsXidStart(Py_UCS4 ch)
     * }
     */
    public static int _PyUnicode_IsXidStart(int ch) {
        var mh$ = _PyUnicode_IsXidStart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_IsXidStart", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_IsXidContinue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_IsXidContinue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicode_IsXidContinue(Py_UCS4 ch)
     * }
     */
    public static FunctionDescriptor _PyUnicode_IsXidContinue$descriptor() {
        return _PyUnicode_IsXidContinue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicode_IsXidContinue(Py_UCS4 ch)
     * }
     */
    public static MethodHandle _PyUnicode_IsXidContinue$handle() {
        return _PyUnicode_IsXidContinue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicode_IsXidContinue(Py_UCS4 ch)
     * }
     */
    public static MemorySegment _PyUnicode_IsXidContinue$address() {
        return _PyUnicode_IsXidContinue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicode_IsXidContinue(Py_UCS4 ch)
     * }
     */
    public static int _PyUnicode_IsXidContinue(int ch) {
        var mh$ = _PyUnicode_IsXidContinue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_IsXidContinue", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_IsWhitespace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_IsWhitespace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicode_IsWhitespace(const Py_UCS4 ch)
     * }
     */
    public static FunctionDescriptor _PyUnicode_IsWhitespace$descriptor() {
        return _PyUnicode_IsWhitespace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicode_IsWhitespace(const Py_UCS4 ch)
     * }
     */
    public static MethodHandle _PyUnicode_IsWhitespace$handle() {
        return _PyUnicode_IsWhitespace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicode_IsWhitespace(const Py_UCS4 ch)
     * }
     */
    public static MemorySegment _PyUnicode_IsWhitespace$address() {
        return _PyUnicode_IsWhitespace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicode_IsWhitespace(const Py_UCS4 ch)
     * }
     */
    public static int _PyUnicode_IsWhitespace(int ch) {
        var mh$ = _PyUnicode_IsWhitespace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_IsWhitespace", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_IsLinebreak {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_IsLinebreak");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicode_IsLinebreak(const Py_UCS4 ch)
     * }
     */
    public static FunctionDescriptor _PyUnicode_IsLinebreak$descriptor() {
        return _PyUnicode_IsLinebreak.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicode_IsLinebreak(const Py_UCS4 ch)
     * }
     */
    public static MethodHandle _PyUnicode_IsLinebreak$handle() {
        return _PyUnicode_IsLinebreak.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicode_IsLinebreak(const Py_UCS4 ch)
     * }
     */
    public static MemorySegment _PyUnicode_IsLinebreak$address() {
        return _PyUnicode_IsLinebreak.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicode_IsLinebreak(const Py_UCS4 ch)
     * }
     */
    public static int _PyUnicode_IsLinebreak(int ch) {
        var mh$ = _PyUnicode_IsLinebreak.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_IsLinebreak", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_ToLowercase {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_ToLowercase");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_UCS4 _PyUnicode_ToLowercase(Py_UCS4 ch)
     * }
     */
    public static FunctionDescriptor _PyUnicode_ToLowercase$descriptor() {
        return _PyUnicode_ToLowercase.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_UCS4 _PyUnicode_ToLowercase(Py_UCS4 ch)
     * }
     */
    public static MethodHandle _PyUnicode_ToLowercase$handle() {
        return _PyUnicode_ToLowercase.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_UCS4 _PyUnicode_ToLowercase(Py_UCS4 ch)
     * }
     */
    public static MemorySegment _PyUnicode_ToLowercase$address() {
        return _PyUnicode_ToLowercase.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_UCS4 _PyUnicode_ToLowercase(Py_UCS4 ch)
     * }
     */
    public static int _PyUnicode_ToLowercase(int ch) {
        var mh$ = _PyUnicode_ToLowercase.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_ToLowercase", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_ToUppercase {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_ToUppercase");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_UCS4 _PyUnicode_ToUppercase(Py_UCS4 ch)
     * }
     */
    public static FunctionDescriptor _PyUnicode_ToUppercase$descriptor() {
        return _PyUnicode_ToUppercase.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_UCS4 _PyUnicode_ToUppercase(Py_UCS4 ch)
     * }
     */
    public static MethodHandle _PyUnicode_ToUppercase$handle() {
        return _PyUnicode_ToUppercase.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_UCS4 _PyUnicode_ToUppercase(Py_UCS4 ch)
     * }
     */
    public static MemorySegment _PyUnicode_ToUppercase$address() {
        return _PyUnicode_ToUppercase.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_UCS4 _PyUnicode_ToUppercase(Py_UCS4 ch)
     * }
     */
    public static int _PyUnicode_ToUppercase(int ch) {
        var mh$ = _PyUnicode_ToUppercase.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_ToUppercase", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_ToTitlecase {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_ToTitlecase");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_UCS4 _PyUnicode_ToTitlecase(Py_UCS4 ch)
     * }
     */
    public static FunctionDescriptor _PyUnicode_ToTitlecase$descriptor() {
        return _PyUnicode_ToTitlecase.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_UCS4 _PyUnicode_ToTitlecase(Py_UCS4 ch)
     * }
     */
    public static MethodHandle _PyUnicode_ToTitlecase$handle() {
        return _PyUnicode_ToTitlecase.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_UCS4 _PyUnicode_ToTitlecase(Py_UCS4 ch)
     * }
     */
    public static MemorySegment _PyUnicode_ToTitlecase$address() {
        return _PyUnicode_ToTitlecase.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_UCS4 _PyUnicode_ToTitlecase(Py_UCS4 ch)
     * }
     */
    public static int _PyUnicode_ToTitlecase(int ch) {
        var mh$ = _PyUnicode_ToTitlecase.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_ToTitlecase", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_ToLowerFull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_ToLowerFull");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicode_ToLowerFull(Py_UCS4 ch, Py_UCS4 *res)
     * }
     */
    public static FunctionDescriptor _PyUnicode_ToLowerFull$descriptor() {
        return _PyUnicode_ToLowerFull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicode_ToLowerFull(Py_UCS4 ch, Py_UCS4 *res)
     * }
     */
    public static MethodHandle _PyUnicode_ToLowerFull$handle() {
        return _PyUnicode_ToLowerFull.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicode_ToLowerFull(Py_UCS4 ch, Py_UCS4 *res)
     * }
     */
    public static MemorySegment _PyUnicode_ToLowerFull$address() {
        return _PyUnicode_ToLowerFull.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicode_ToLowerFull(Py_UCS4 ch, Py_UCS4 *res)
     * }
     */
    public static int _PyUnicode_ToLowerFull(int ch, MemorySegment res) {
        var mh$ = _PyUnicode_ToLowerFull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_ToLowerFull", ch, res);
            }
            return (int)mh$.invokeExact(ch, res);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_ToTitleFull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_ToTitleFull");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicode_ToTitleFull(Py_UCS4 ch, Py_UCS4 *res)
     * }
     */
    public static FunctionDescriptor _PyUnicode_ToTitleFull$descriptor() {
        return _PyUnicode_ToTitleFull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicode_ToTitleFull(Py_UCS4 ch, Py_UCS4 *res)
     * }
     */
    public static MethodHandle _PyUnicode_ToTitleFull$handle() {
        return _PyUnicode_ToTitleFull.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicode_ToTitleFull(Py_UCS4 ch, Py_UCS4 *res)
     * }
     */
    public static MemorySegment _PyUnicode_ToTitleFull$address() {
        return _PyUnicode_ToTitleFull.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicode_ToTitleFull(Py_UCS4 ch, Py_UCS4 *res)
     * }
     */
    public static int _PyUnicode_ToTitleFull(int ch, MemorySegment res) {
        var mh$ = _PyUnicode_ToTitleFull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_ToTitleFull", ch, res);
            }
            return (int)mh$.invokeExact(ch, res);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_ToUpperFull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_ToUpperFull");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicode_ToUpperFull(Py_UCS4 ch, Py_UCS4 *res)
     * }
     */
    public static FunctionDescriptor _PyUnicode_ToUpperFull$descriptor() {
        return _PyUnicode_ToUpperFull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicode_ToUpperFull(Py_UCS4 ch, Py_UCS4 *res)
     * }
     */
    public static MethodHandle _PyUnicode_ToUpperFull$handle() {
        return _PyUnicode_ToUpperFull.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicode_ToUpperFull(Py_UCS4 ch, Py_UCS4 *res)
     * }
     */
    public static MemorySegment _PyUnicode_ToUpperFull$address() {
        return _PyUnicode_ToUpperFull.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicode_ToUpperFull(Py_UCS4 ch, Py_UCS4 *res)
     * }
     */
    public static int _PyUnicode_ToUpperFull(int ch, MemorySegment res) {
        var mh$ = _PyUnicode_ToUpperFull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_ToUpperFull", ch, res);
            }
            return (int)mh$.invokeExact(ch, res);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_ToFoldedFull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_ToFoldedFull");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicode_ToFoldedFull(Py_UCS4 ch, Py_UCS4 *res)
     * }
     */
    public static FunctionDescriptor _PyUnicode_ToFoldedFull$descriptor() {
        return _PyUnicode_ToFoldedFull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicode_ToFoldedFull(Py_UCS4 ch, Py_UCS4 *res)
     * }
     */
    public static MethodHandle _PyUnicode_ToFoldedFull$handle() {
        return _PyUnicode_ToFoldedFull.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicode_ToFoldedFull(Py_UCS4 ch, Py_UCS4 *res)
     * }
     */
    public static MemorySegment _PyUnicode_ToFoldedFull$address() {
        return _PyUnicode_ToFoldedFull.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicode_ToFoldedFull(Py_UCS4 ch, Py_UCS4 *res)
     * }
     */
    public static int _PyUnicode_ToFoldedFull(int ch, MemorySegment res) {
        var mh$ = _PyUnicode_ToFoldedFull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_ToFoldedFull", ch, res);
            }
            return (int)mh$.invokeExact(ch, res);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_IsCaseIgnorable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_IsCaseIgnorable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicode_IsCaseIgnorable(Py_UCS4 ch)
     * }
     */
    public static FunctionDescriptor _PyUnicode_IsCaseIgnorable$descriptor() {
        return _PyUnicode_IsCaseIgnorable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicode_IsCaseIgnorable(Py_UCS4 ch)
     * }
     */
    public static MethodHandle _PyUnicode_IsCaseIgnorable$handle() {
        return _PyUnicode_IsCaseIgnorable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicode_IsCaseIgnorable(Py_UCS4 ch)
     * }
     */
    public static MemorySegment _PyUnicode_IsCaseIgnorable$address() {
        return _PyUnicode_IsCaseIgnorable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicode_IsCaseIgnorable(Py_UCS4 ch)
     * }
     */
    public static int _PyUnicode_IsCaseIgnorable(int ch) {
        var mh$ = _PyUnicode_IsCaseIgnorable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_IsCaseIgnorable", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_IsCased {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_IsCased");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicode_IsCased(Py_UCS4 ch)
     * }
     */
    public static FunctionDescriptor _PyUnicode_IsCased$descriptor() {
        return _PyUnicode_IsCased.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicode_IsCased(Py_UCS4 ch)
     * }
     */
    public static MethodHandle _PyUnicode_IsCased$handle() {
        return _PyUnicode_IsCased.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicode_IsCased(Py_UCS4 ch)
     * }
     */
    public static MemorySegment _PyUnicode_IsCased$address() {
        return _PyUnicode_IsCased.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicode_IsCased(Py_UCS4 ch)
     * }
     */
    public static int _PyUnicode_IsCased(int ch) {
        var mh$ = _PyUnicode_IsCased.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_IsCased", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_ToDecimalDigit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_ToDecimalDigit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicode_ToDecimalDigit(Py_UCS4 ch)
     * }
     */
    public static FunctionDescriptor _PyUnicode_ToDecimalDigit$descriptor() {
        return _PyUnicode_ToDecimalDigit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicode_ToDecimalDigit(Py_UCS4 ch)
     * }
     */
    public static MethodHandle _PyUnicode_ToDecimalDigit$handle() {
        return _PyUnicode_ToDecimalDigit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicode_ToDecimalDigit(Py_UCS4 ch)
     * }
     */
    public static MemorySegment _PyUnicode_ToDecimalDigit$address() {
        return _PyUnicode_ToDecimalDigit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicode_ToDecimalDigit(Py_UCS4 ch)
     * }
     */
    public static int _PyUnicode_ToDecimalDigit(int ch) {
        var mh$ = _PyUnicode_ToDecimalDigit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_ToDecimalDigit", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_ToDigit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_ToDigit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicode_ToDigit(Py_UCS4 ch)
     * }
     */
    public static FunctionDescriptor _PyUnicode_ToDigit$descriptor() {
        return _PyUnicode_ToDigit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicode_ToDigit(Py_UCS4 ch)
     * }
     */
    public static MethodHandle _PyUnicode_ToDigit$handle() {
        return _PyUnicode_ToDigit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicode_ToDigit(Py_UCS4 ch)
     * }
     */
    public static MemorySegment _PyUnicode_ToDigit$address() {
        return _PyUnicode_ToDigit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicode_ToDigit(Py_UCS4 ch)
     * }
     */
    public static int _PyUnicode_ToDigit(int ch) {
        var mh$ = _PyUnicode_ToDigit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_ToDigit", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_ToNumeric {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_ToNumeric");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _PyUnicode_ToNumeric(Py_UCS4 ch)
     * }
     */
    public static FunctionDescriptor _PyUnicode_ToNumeric$descriptor() {
        return _PyUnicode_ToNumeric.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _PyUnicode_ToNumeric(Py_UCS4 ch)
     * }
     */
    public static MethodHandle _PyUnicode_ToNumeric$handle() {
        return _PyUnicode_ToNumeric.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _PyUnicode_ToNumeric(Py_UCS4 ch)
     * }
     */
    public static MemorySegment _PyUnicode_ToNumeric$address() {
        return _PyUnicode_ToNumeric.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _PyUnicode_ToNumeric(Py_UCS4 ch)
     * }
     */
    public static double _PyUnicode_ToNumeric(int ch) {
        var mh$ = _PyUnicode_ToNumeric.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_ToNumeric", ch);
            }
            return (double)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_IsDecimalDigit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_IsDecimalDigit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicode_IsDecimalDigit(Py_UCS4 ch)
     * }
     */
    public static FunctionDescriptor _PyUnicode_IsDecimalDigit$descriptor() {
        return _PyUnicode_IsDecimalDigit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicode_IsDecimalDigit(Py_UCS4 ch)
     * }
     */
    public static MethodHandle _PyUnicode_IsDecimalDigit$handle() {
        return _PyUnicode_IsDecimalDigit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicode_IsDecimalDigit(Py_UCS4 ch)
     * }
     */
    public static MemorySegment _PyUnicode_IsDecimalDigit$address() {
        return _PyUnicode_IsDecimalDigit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicode_IsDecimalDigit(Py_UCS4 ch)
     * }
     */
    public static int _PyUnicode_IsDecimalDigit(int ch) {
        var mh$ = _PyUnicode_IsDecimalDigit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_IsDecimalDigit", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_IsDigit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_IsDigit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicode_IsDigit(Py_UCS4 ch)
     * }
     */
    public static FunctionDescriptor _PyUnicode_IsDigit$descriptor() {
        return _PyUnicode_IsDigit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicode_IsDigit(Py_UCS4 ch)
     * }
     */
    public static MethodHandle _PyUnicode_IsDigit$handle() {
        return _PyUnicode_IsDigit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicode_IsDigit(Py_UCS4 ch)
     * }
     */
    public static MemorySegment _PyUnicode_IsDigit$address() {
        return _PyUnicode_IsDigit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicode_IsDigit(Py_UCS4 ch)
     * }
     */
    public static int _PyUnicode_IsDigit(int ch) {
        var mh$ = _PyUnicode_IsDigit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_IsDigit", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_IsNumeric {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_IsNumeric");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicode_IsNumeric(Py_UCS4 ch)
     * }
     */
    public static FunctionDescriptor _PyUnicode_IsNumeric$descriptor() {
        return _PyUnicode_IsNumeric.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicode_IsNumeric(Py_UCS4 ch)
     * }
     */
    public static MethodHandle _PyUnicode_IsNumeric$handle() {
        return _PyUnicode_IsNumeric.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicode_IsNumeric(Py_UCS4 ch)
     * }
     */
    public static MemorySegment _PyUnicode_IsNumeric$address() {
        return _PyUnicode_IsNumeric.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicode_IsNumeric(Py_UCS4 ch)
     * }
     */
    public static int _PyUnicode_IsNumeric(int ch) {
        var mh$ = _PyUnicode_IsNumeric.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_IsNumeric", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_IsPrintable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_IsPrintable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicode_IsPrintable(Py_UCS4 ch)
     * }
     */
    public static FunctionDescriptor _PyUnicode_IsPrintable$descriptor() {
        return _PyUnicode_IsPrintable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicode_IsPrintable(Py_UCS4 ch)
     * }
     */
    public static MethodHandle _PyUnicode_IsPrintable$handle() {
        return _PyUnicode_IsPrintable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicode_IsPrintable(Py_UCS4 ch)
     * }
     */
    public static MemorySegment _PyUnicode_IsPrintable$address() {
        return _PyUnicode_IsPrintable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicode_IsPrintable(Py_UCS4 ch)
     * }
     */
    public static int _PyUnicode_IsPrintable(int ch) {
        var mh$ = _PyUnicode_IsPrintable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_IsPrintable", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_IsAlpha {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_IsAlpha");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicode_IsAlpha(Py_UCS4 ch)
     * }
     */
    public static FunctionDescriptor _PyUnicode_IsAlpha$descriptor() {
        return _PyUnicode_IsAlpha.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicode_IsAlpha(Py_UCS4 ch)
     * }
     */
    public static MethodHandle _PyUnicode_IsAlpha$handle() {
        return _PyUnicode_IsAlpha.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicode_IsAlpha(Py_UCS4 ch)
     * }
     */
    public static MemorySegment _PyUnicode_IsAlpha$address() {
        return _PyUnicode_IsAlpha.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicode_IsAlpha(Py_UCS4 ch)
     * }
     */
    public static int _PyUnicode_IsAlpha(int ch) {
        var mh$ = _PyUnicode_IsAlpha.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_IsAlpha", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_FormatLong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_FormatLong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_FormatLong(PyObject *, int, int, int)
     * }
     */
    public static FunctionDescriptor _PyUnicode_FormatLong$descriptor() {
        return _PyUnicode_FormatLong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_FormatLong(PyObject *, int, int, int)
     * }
     */
    public static MethodHandle _PyUnicode_FormatLong$handle() {
        return _PyUnicode_FormatLong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_FormatLong(PyObject *, int, int, int)
     * }
     */
    public static MemorySegment _PyUnicode_FormatLong$address() {
        return _PyUnicode_FormatLong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyUnicode_FormatLong(PyObject *, int, int, int)
     * }
     */
    public static MemorySegment _PyUnicode_FormatLong(MemorySegment x0, int x1, int x2, int x3) {
        var mh$ = _PyUnicode_FormatLong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_FormatLong", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_FromId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_FromId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_FromId(_Py_Identifier *)
     * }
     */
    public static FunctionDescriptor _PyUnicode_FromId$descriptor() {
        return _PyUnicode_FromId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_FromId(_Py_Identifier *)
     * }
     */
    public static MethodHandle _PyUnicode_FromId$handle() {
        return _PyUnicode_FromId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyUnicode_FromId(_Py_Identifier *)
     * }
     */
    public static MemorySegment _PyUnicode_FromId$address() {
        return _PyUnicode_FromId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyUnicode_FromId(_Py_Identifier *)
     * }
     */
    public static MemorySegment _PyUnicode_FromId(MemorySegment x0) {
        var mh$ = _PyUnicode_FromId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_FromId", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_EQ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_EQ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicode_EQ(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor _PyUnicode_EQ$descriptor() {
        return _PyUnicode_EQ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicode_EQ(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle _PyUnicode_EQ$handle() {
        return _PyUnicode_EQ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicode_EQ(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment _PyUnicode_EQ$address() {
        return _PyUnicode_EQ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicode_EQ(PyObject *, PyObject *)
     * }
     */
    public static int _PyUnicode_EQ(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyUnicode_EQ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_EQ", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_Equal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_Equal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicode_Equal(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor _PyUnicode_Equal$descriptor() {
        return _PyUnicode_Equal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicode_Equal(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle _PyUnicode_Equal$handle() {
        return _PyUnicode_Equal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicode_Equal(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment _PyUnicode_Equal$address() {
        return _PyUnicode_Equal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicode_Equal(PyObject *, PyObject *)
     * }
     */
    public static int _PyUnicode_Equal(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyUnicode_Equal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_Equal", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_WideCharString_Converter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_WideCharString_Converter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicode_WideCharString_Converter(PyObject *, void *)
     * }
     */
    public static FunctionDescriptor _PyUnicode_WideCharString_Converter$descriptor() {
        return _PyUnicode_WideCharString_Converter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicode_WideCharString_Converter(PyObject *, void *)
     * }
     */
    public static MethodHandle _PyUnicode_WideCharString_Converter$handle() {
        return _PyUnicode_WideCharString_Converter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicode_WideCharString_Converter(PyObject *, void *)
     * }
     */
    public static MemorySegment _PyUnicode_WideCharString_Converter$address() {
        return _PyUnicode_WideCharString_Converter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicode_WideCharString_Converter(PyObject *, void *)
     * }
     */
    public static int _PyUnicode_WideCharString_Converter(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyUnicode_WideCharString_Converter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_WideCharString_Converter", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_WideCharString_Opt_Converter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_WideCharString_Opt_Converter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyUnicode_WideCharString_Opt_Converter(PyObject *, void *)
     * }
     */
    public static FunctionDescriptor _PyUnicode_WideCharString_Opt_Converter$descriptor() {
        return _PyUnicode_WideCharString_Opt_Converter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyUnicode_WideCharString_Opt_Converter(PyObject *, void *)
     * }
     */
    public static MethodHandle _PyUnicode_WideCharString_Opt_Converter$handle() {
        return _PyUnicode_WideCharString_Opt_Converter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyUnicode_WideCharString_Opt_Converter(PyObject *, void *)
     * }
     */
    public static MemorySegment _PyUnicode_WideCharString_Opt_Converter$address() {
        return _PyUnicode_WideCharString_Opt_Converter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyUnicode_WideCharString_Opt_Converter(PyObject *, void *)
     * }
     */
    public static int _PyUnicode_WideCharString_Opt_Converter(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyUnicode_WideCharString_Opt_Converter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_WideCharString_Opt_Converter", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyUnicode_ScanIdentifier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyUnicode_ScanIdentifier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t _PyUnicode_ScanIdentifier(PyObject *)
     * }
     */
    public static FunctionDescriptor _PyUnicode_ScanIdentifier$descriptor() {
        return _PyUnicode_ScanIdentifier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t _PyUnicode_ScanIdentifier(PyObject *)
     * }
     */
    public static MethodHandle _PyUnicode_ScanIdentifier$handle() {
        return _PyUnicode_ScanIdentifier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t _PyUnicode_ScanIdentifier(PyObject *)
     * }
     */
    public static MemorySegment _PyUnicode_ScanIdentifier$address() {
        return _PyUnicode_ScanIdentifier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t _PyUnicode_ScanIdentifier(PyObject *)
     * }
     */
    public static long _PyUnicode_ScanIdentifier(MemorySegment x0) {
        var mh$ = _PyUnicode_ScanIdentifier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyUnicode_ScanIdentifier", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyLong_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyLong_Type
     * }
     */
    public static GroupLayout PyLong_Type$layout() {
        return PyLong_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyLong_Type
     * }
     */
    public static MemorySegment PyLong_Type() {
        return PyLong_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyLong_Type
     * }
     */
    public static void PyLong_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyLong_Type$constants.SEGMENT, 0L, PyLong_Type$constants.LAYOUT.byteSize());
    }

    private static class PyLong_FromLong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_FromLong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromLong(long)
     * }
     */
    public static FunctionDescriptor PyLong_FromLong$descriptor() {
        return PyLong_FromLong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromLong(long)
     * }
     */
    public static MethodHandle PyLong_FromLong$handle() {
        return PyLong_FromLong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromLong(long)
     * }
     */
    public static MemorySegment PyLong_FromLong$address() {
        return PyLong_FromLong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyLong_FromLong(long)
     * }
     */
    public static MemorySegment PyLong_FromLong(long x0) {
        var mh$ = PyLong_FromLong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_FromLong", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_FromUnsignedLong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_FromUnsignedLong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromUnsignedLong(unsigned long)
     * }
     */
    public static FunctionDescriptor PyLong_FromUnsignedLong$descriptor() {
        return PyLong_FromUnsignedLong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromUnsignedLong(unsigned long)
     * }
     */
    public static MethodHandle PyLong_FromUnsignedLong$handle() {
        return PyLong_FromUnsignedLong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromUnsignedLong(unsigned long)
     * }
     */
    public static MemorySegment PyLong_FromUnsignedLong$address() {
        return PyLong_FromUnsignedLong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyLong_FromUnsignedLong(unsigned long)
     * }
     */
    public static MemorySegment PyLong_FromUnsignedLong(long x0) {
        var mh$ = PyLong_FromUnsignedLong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_FromUnsignedLong", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_FromSize_t {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_FromSize_t");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromSize_t(size_t)
     * }
     */
    public static FunctionDescriptor PyLong_FromSize_t$descriptor() {
        return PyLong_FromSize_t.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromSize_t(size_t)
     * }
     */
    public static MethodHandle PyLong_FromSize_t$handle() {
        return PyLong_FromSize_t.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromSize_t(size_t)
     * }
     */
    public static MemorySegment PyLong_FromSize_t$address() {
        return PyLong_FromSize_t.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyLong_FromSize_t(size_t)
     * }
     */
    public static MemorySegment PyLong_FromSize_t(long x0) {
        var mh$ = PyLong_FromSize_t.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_FromSize_t", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_FromSsize_t {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_FromSsize_t");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromSsize_t(Py_ssize_t)
     * }
     */
    public static FunctionDescriptor PyLong_FromSsize_t$descriptor() {
        return PyLong_FromSsize_t.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromSsize_t(Py_ssize_t)
     * }
     */
    public static MethodHandle PyLong_FromSsize_t$handle() {
        return PyLong_FromSsize_t.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromSsize_t(Py_ssize_t)
     * }
     */
    public static MemorySegment PyLong_FromSsize_t$address() {
        return PyLong_FromSsize_t.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyLong_FromSsize_t(Py_ssize_t)
     * }
     */
    public static MemorySegment PyLong_FromSsize_t(long x0) {
        var mh$ = PyLong_FromSsize_t.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_FromSsize_t", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_FromDouble {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_FromDouble");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromDouble(double)
     * }
     */
    public static FunctionDescriptor PyLong_FromDouble$descriptor() {
        return PyLong_FromDouble.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromDouble(double)
     * }
     */
    public static MethodHandle PyLong_FromDouble$handle() {
        return PyLong_FromDouble.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromDouble(double)
     * }
     */
    public static MemorySegment PyLong_FromDouble$address() {
        return PyLong_FromDouble.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyLong_FromDouble(double)
     * }
     */
    public static MemorySegment PyLong_FromDouble(double x0) {
        var mh$ = PyLong_FromDouble.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_FromDouble", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_AsLong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_AsLong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long PyLong_AsLong(PyObject *)
     * }
     */
    public static FunctionDescriptor PyLong_AsLong$descriptor() {
        return PyLong_AsLong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long PyLong_AsLong(PyObject *)
     * }
     */
    public static MethodHandle PyLong_AsLong$handle() {
        return PyLong_AsLong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long PyLong_AsLong(PyObject *)
     * }
     */
    public static MemorySegment PyLong_AsLong$address() {
        return PyLong_AsLong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long PyLong_AsLong(PyObject *)
     * }
     */
    public static long PyLong_AsLong(MemorySegment x0) {
        var mh$ = PyLong_AsLong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_AsLong", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_AsLongAndOverflow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_AsLongAndOverflow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long PyLong_AsLongAndOverflow(PyObject *, int *)
     * }
     */
    public static FunctionDescriptor PyLong_AsLongAndOverflow$descriptor() {
        return PyLong_AsLongAndOverflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long PyLong_AsLongAndOverflow(PyObject *, int *)
     * }
     */
    public static MethodHandle PyLong_AsLongAndOverflow$handle() {
        return PyLong_AsLongAndOverflow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long PyLong_AsLongAndOverflow(PyObject *, int *)
     * }
     */
    public static MemorySegment PyLong_AsLongAndOverflow$address() {
        return PyLong_AsLongAndOverflow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long PyLong_AsLongAndOverflow(PyObject *, int *)
     * }
     */
    public static long PyLong_AsLongAndOverflow(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyLong_AsLongAndOverflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_AsLongAndOverflow", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_AsSsize_t {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_AsSsize_t");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_ssize_t PyLong_AsSsize_t(PyObject *)
     * }
     */
    public static FunctionDescriptor PyLong_AsSsize_t$descriptor() {
        return PyLong_AsSsize_t.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_ssize_t PyLong_AsSsize_t(PyObject *)
     * }
     */
    public static MethodHandle PyLong_AsSsize_t$handle() {
        return PyLong_AsSsize_t.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_ssize_t PyLong_AsSsize_t(PyObject *)
     * }
     */
    public static MemorySegment PyLong_AsSsize_t$address() {
        return PyLong_AsSsize_t.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_ssize_t PyLong_AsSsize_t(PyObject *)
     * }
     */
    public static long PyLong_AsSsize_t(MemorySegment x0) {
        var mh$ = PyLong_AsSsize_t.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_AsSsize_t", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_AsSize_t {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_AsSize_t");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t PyLong_AsSize_t(PyObject *)
     * }
     */
    public static FunctionDescriptor PyLong_AsSize_t$descriptor() {
        return PyLong_AsSize_t.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t PyLong_AsSize_t(PyObject *)
     * }
     */
    public static MethodHandle PyLong_AsSize_t$handle() {
        return PyLong_AsSize_t.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t PyLong_AsSize_t(PyObject *)
     * }
     */
    public static MemorySegment PyLong_AsSize_t$address() {
        return PyLong_AsSize_t.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t PyLong_AsSize_t(PyObject *)
     * }
     */
    public static long PyLong_AsSize_t(MemorySegment x0) {
        var mh$ = PyLong_AsSize_t.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_AsSize_t", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_AsUnsignedLong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_AsUnsignedLong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long PyLong_AsUnsignedLong(PyObject *)
     * }
     */
    public static FunctionDescriptor PyLong_AsUnsignedLong$descriptor() {
        return PyLong_AsUnsignedLong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long PyLong_AsUnsignedLong(PyObject *)
     * }
     */
    public static MethodHandle PyLong_AsUnsignedLong$handle() {
        return PyLong_AsUnsignedLong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long PyLong_AsUnsignedLong(PyObject *)
     * }
     */
    public static MemorySegment PyLong_AsUnsignedLong$address() {
        return PyLong_AsUnsignedLong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long PyLong_AsUnsignedLong(PyObject *)
     * }
     */
    public static long PyLong_AsUnsignedLong(MemorySegment x0) {
        var mh$ = PyLong_AsUnsignedLong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_AsUnsignedLong", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_AsUnsignedLongMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_AsUnsignedLongMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long PyLong_AsUnsignedLongMask(PyObject *)
     * }
     */
    public static FunctionDescriptor PyLong_AsUnsignedLongMask$descriptor() {
        return PyLong_AsUnsignedLongMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long PyLong_AsUnsignedLongMask(PyObject *)
     * }
     */
    public static MethodHandle PyLong_AsUnsignedLongMask$handle() {
        return PyLong_AsUnsignedLongMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long PyLong_AsUnsignedLongMask(PyObject *)
     * }
     */
    public static MemorySegment PyLong_AsUnsignedLongMask$address() {
        return PyLong_AsUnsignedLongMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long PyLong_AsUnsignedLongMask(PyObject *)
     * }
     */
    public static long PyLong_AsUnsignedLongMask(MemorySegment x0) {
        var mh$ = PyLong_AsUnsignedLongMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_AsUnsignedLongMask", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_GetInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_GetInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyLong_GetInfo()
     * }
     */
    public static FunctionDescriptor PyLong_GetInfo$descriptor() {
        return PyLong_GetInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyLong_GetInfo()
     * }
     */
    public static MethodHandle PyLong_GetInfo$handle() {
        return PyLong_GetInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyLong_GetInfo()
     * }
     */
    public static MemorySegment PyLong_GetInfo$address() {
        return PyLong_GetInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyLong_GetInfo()
     * }
     */
    public static MemorySegment PyLong_GetInfo() {
        var mh$ = PyLong_GetInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_GetInfo");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_AsDouble {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_AsDouble");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double PyLong_AsDouble(PyObject *)
     * }
     */
    public static FunctionDescriptor PyLong_AsDouble$descriptor() {
        return PyLong_AsDouble.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double PyLong_AsDouble(PyObject *)
     * }
     */
    public static MethodHandle PyLong_AsDouble$handle() {
        return PyLong_AsDouble.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double PyLong_AsDouble(PyObject *)
     * }
     */
    public static MemorySegment PyLong_AsDouble$address() {
        return PyLong_AsDouble.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double PyLong_AsDouble(PyObject *)
     * }
     */
    public static double PyLong_AsDouble(MemorySegment x0) {
        var mh$ = PyLong_AsDouble.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_AsDouble", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_FromVoidPtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_FromVoidPtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromVoidPtr(void *)
     * }
     */
    public static FunctionDescriptor PyLong_FromVoidPtr$descriptor() {
        return PyLong_FromVoidPtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromVoidPtr(void *)
     * }
     */
    public static MethodHandle PyLong_FromVoidPtr$handle() {
        return PyLong_FromVoidPtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromVoidPtr(void *)
     * }
     */
    public static MemorySegment PyLong_FromVoidPtr$address() {
        return PyLong_FromVoidPtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyLong_FromVoidPtr(void *)
     * }
     */
    public static MemorySegment PyLong_FromVoidPtr(MemorySegment x0) {
        var mh$ = PyLong_FromVoidPtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_FromVoidPtr", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_AsVoidPtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_AsVoidPtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *PyLong_AsVoidPtr(PyObject *)
     * }
     */
    public static FunctionDescriptor PyLong_AsVoidPtr$descriptor() {
        return PyLong_AsVoidPtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *PyLong_AsVoidPtr(PyObject *)
     * }
     */
    public static MethodHandle PyLong_AsVoidPtr$handle() {
        return PyLong_AsVoidPtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *PyLong_AsVoidPtr(PyObject *)
     * }
     */
    public static MemorySegment PyLong_AsVoidPtr$address() {
        return PyLong_AsVoidPtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *PyLong_AsVoidPtr(PyObject *)
     * }
     */
    public static MemorySegment PyLong_AsVoidPtr(MemorySegment x0) {
        var mh$ = PyLong_AsVoidPtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_AsVoidPtr", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_FromLongLong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_FromLongLong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromLongLong(long long)
     * }
     */
    public static FunctionDescriptor PyLong_FromLongLong$descriptor() {
        return PyLong_FromLongLong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromLongLong(long long)
     * }
     */
    public static MethodHandle PyLong_FromLongLong$handle() {
        return PyLong_FromLongLong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromLongLong(long long)
     * }
     */
    public static MemorySegment PyLong_FromLongLong$address() {
        return PyLong_FromLongLong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyLong_FromLongLong(long long)
     * }
     */
    public static MemorySegment PyLong_FromLongLong(long x0) {
        var mh$ = PyLong_FromLongLong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_FromLongLong", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_FromUnsignedLongLong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_FromUnsignedLongLong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromUnsignedLongLong(unsigned long long)
     * }
     */
    public static FunctionDescriptor PyLong_FromUnsignedLongLong$descriptor() {
        return PyLong_FromUnsignedLongLong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromUnsignedLongLong(unsigned long long)
     * }
     */
    public static MethodHandle PyLong_FromUnsignedLongLong$handle() {
        return PyLong_FromUnsignedLongLong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromUnsignedLongLong(unsigned long long)
     * }
     */
    public static MemorySegment PyLong_FromUnsignedLongLong$address() {
        return PyLong_FromUnsignedLongLong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyLong_FromUnsignedLongLong(unsigned long long)
     * }
     */
    public static MemorySegment PyLong_FromUnsignedLongLong(long x0) {
        var mh$ = PyLong_FromUnsignedLongLong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_FromUnsignedLongLong", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_AsLongLong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_AsLongLong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long PyLong_AsLongLong(PyObject *)
     * }
     */
    public static FunctionDescriptor PyLong_AsLongLong$descriptor() {
        return PyLong_AsLongLong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long PyLong_AsLongLong(PyObject *)
     * }
     */
    public static MethodHandle PyLong_AsLongLong$handle() {
        return PyLong_AsLongLong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long PyLong_AsLongLong(PyObject *)
     * }
     */
    public static MemorySegment PyLong_AsLongLong$address() {
        return PyLong_AsLongLong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long PyLong_AsLongLong(PyObject *)
     * }
     */
    public static long PyLong_AsLongLong(MemorySegment x0) {
        var mh$ = PyLong_AsLongLong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_AsLongLong", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_AsUnsignedLongLong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_AsUnsignedLongLong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long PyLong_AsUnsignedLongLong(PyObject *)
     * }
     */
    public static FunctionDescriptor PyLong_AsUnsignedLongLong$descriptor() {
        return PyLong_AsUnsignedLongLong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long PyLong_AsUnsignedLongLong(PyObject *)
     * }
     */
    public static MethodHandle PyLong_AsUnsignedLongLong$handle() {
        return PyLong_AsUnsignedLongLong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long PyLong_AsUnsignedLongLong(PyObject *)
     * }
     */
    public static MemorySegment PyLong_AsUnsignedLongLong$address() {
        return PyLong_AsUnsignedLongLong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long PyLong_AsUnsignedLongLong(PyObject *)
     * }
     */
    public static long PyLong_AsUnsignedLongLong(MemorySegment x0) {
        var mh$ = PyLong_AsUnsignedLongLong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_AsUnsignedLongLong", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_AsUnsignedLongLongMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_AsUnsignedLongLongMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long PyLong_AsUnsignedLongLongMask(PyObject *)
     * }
     */
    public static FunctionDescriptor PyLong_AsUnsignedLongLongMask$descriptor() {
        return PyLong_AsUnsignedLongLongMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long PyLong_AsUnsignedLongLongMask(PyObject *)
     * }
     */
    public static MethodHandle PyLong_AsUnsignedLongLongMask$handle() {
        return PyLong_AsUnsignedLongLongMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long PyLong_AsUnsignedLongLongMask(PyObject *)
     * }
     */
    public static MemorySegment PyLong_AsUnsignedLongLongMask$address() {
        return PyLong_AsUnsignedLongLongMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long PyLong_AsUnsignedLongLongMask(PyObject *)
     * }
     */
    public static long PyLong_AsUnsignedLongLongMask(MemorySegment x0) {
        var mh$ = PyLong_AsUnsignedLongLongMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_AsUnsignedLongLongMask", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_AsLongLongAndOverflow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_AsLongLongAndOverflow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long PyLong_AsLongLongAndOverflow(PyObject *, int *)
     * }
     */
    public static FunctionDescriptor PyLong_AsLongLongAndOverflow$descriptor() {
        return PyLong_AsLongLongAndOverflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long PyLong_AsLongLongAndOverflow(PyObject *, int *)
     * }
     */
    public static MethodHandle PyLong_AsLongLongAndOverflow$handle() {
        return PyLong_AsLongLongAndOverflow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long PyLong_AsLongLongAndOverflow(PyObject *, int *)
     * }
     */
    public static MemorySegment PyLong_AsLongLongAndOverflow$address() {
        return PyLong_AsLongLongAndOverflow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long PyLong_AsLongLongAndOverflow(PyObject *, int *)
     * }
     */
    public static long PyLong_AsLongLongAndOverflow(MemorySegment x0, MemorySegment x1) {
        var mh$ = PyLong_AsLongLongAndOverflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_AsLongLongAndOverflow", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_FromString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_FromString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromString(const char *, char **, int)
     * }
     */
    public static FunctionDescriptor PyLong_FromString$descriptor() {
        return PyLong_FromString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromString(const char *, char **, int)
     * }
     */
    public static MethodHandle PyLong_FromString$handle() {
        return PyLong_FromString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromString(const char *, char **, int)
     * }
     */
    public static MemorySegment PyLong_FromString$address() {
        return PyLong_FromString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyLong_FromString(const char *, char **, int)
     * }
     */
    public static MemorySegment PyLong_FromString(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = PyLong_FromString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_FromString", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyOS_strtoul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyOS_strtoul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long PyOS_strtoul(const char *, char **, int)
     * }
     */
    public static FunctionDescriptor PyOS_strtoul$descriptor() {
        return PyOS_strtoul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long PyOS_strtoul(const char *, char **, int)
     * }
     */
    public static MethodHandle PyOS_strtoul$handle() {
        return PyOS_strtoul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long PyOS_strtoul(const char *, char **, int)
     * }
     */
    public static MemorySegment PyOS_strtoul$address() {
        return PyOS_strtoul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long PyOS_strtoul(const char *, char **, int)
     * }
     */
    public static long PyOS_strtoul(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = PyOS_strtoul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyOS_strtoul", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyOS_strtol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyOS_strtol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long PyOS_strtol(const char *, char **, int)
     * }
     */
    public static FunctionDescriptor PyOS_strtol$descriptor() {
        return PyOS_strtol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long PyOS_strtol(const char *, char **, int)
     * }
     */
    public static MethodHandle PyOS_strtol$handle() {
        return PyOS_strtol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long PyOS_strtol(const char *, char **, int)
     * }
     */
    public static MemorySegment PyOS_strtol$address() {
        return PyOS_strtol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long PyOS_strtol(const char *, char **, int)
     * }
     */
    public static long PyOS_strtol(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = PyOS_strtol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyOS_strtol", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyLong_AsInt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyLong_AsInt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyLong_AsInt(PyObject *)
     * }
     */
    public static FunctionDescriptor _PyLong_AsInt$descriptor() {
        return _PyLong_AsInt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyLong_AsInt(PyObject *)
     * }
     */
    public static MethodHandle _PyLong_AsInt$handle() {
        return _PyLong_AsInt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyLong_AsInt(PyObject *)
     * }
     */
    public static MemorySegment _PyLong_AsInt$address() {
        return _PyLong_AsInt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyLong_AsInt(PyObject *)
     * }
     */
    public static int _PyLong_AsInt(MemorySegment x0) {
        var mh$ = _PyLong_AsInt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyLong_AsInt", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyLong_UnsignedShort_Converter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyLong_UnsignedShort_Converter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyLong_UnsignedShort_Converter(PyObject *, void *)
     * }
     */
    public static FunctionDescriptor _PyLong_UnsignedShort_Converter$descriptor() {
        return _PyLong_UnsignedShort_Converter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyLong_UnsignedShort_Converter(PyObject *, void *)
     * }
     */
    public static MethodHandle _PyLong_UnsignedShort_Converter$handle() {
        return _PyLong_UnsignedShort_Converter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyLong_UnsignedShort_Converter(PyObject *, void *)
     * }
     */
    public static MemorySegment _PyLong_UnsignedShort_Converter$address() {
        return _PyLong_UnsignedShort_Converter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyLong_UnsignedShort_Converter(PyObject *, void *)
     * }
     */
    public static int _PyLong_UnsignedShort_Converter(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyLong_UnsignedShort_Converter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyLong_UnsignedShort_Converter", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyLong_UnsignedInt_Converter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyLong_UnsignedInt_Converter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyLong_UnsignedInt_Converter(PyObject *, void *)
     * }
     */
    public static FunctionDescriptor _PyLong_UnsignedInt_Converter$descriptor() {
        return _PyLong_UnsignedInt_Converter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyLong_UnsignedInt_Converter(PyObject *, void *)
     * }
     */
    public static MethodHandle _PyLong_UnsignedInt_Converter$handle() {
        return _PyLong_UnsignedInt_Converter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyLong_UnsignedInt_Converter(PyObject *, void *)
     * }
     */
    public static MemorySegment _PyLong_UnsignedInt_Converter$address() {
        return _PyLong_UnsignedInt_Converter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyLong_UnsignedInt_Converter(PyObject *, void *)
     * }
     */
    public static int _PyLong_UnsignedInt_Converter(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyLong_UnsignedInt_Converter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyLong_UnsignedInt_Converter", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyLong_UnsignedLong_Converter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyLong_UnsignedLong_Converter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyLong_UnsignedLong_Converter(PyObject *, void *)
     * }
     */
    public static FunctionDescriptor _PyLong_UnsignedLong_Converter$descriptor() {
        return _PyLong_UnsignedLong_Converter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyLong_UnsignedLong_Converter(PyObject *, void *)
     * }
     */
    public static MethodHandle _PyLong_UnsignedLong_Converter$handle() {
        return _PyLong_UnsignedLong_Converter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyLong_UnsignedLong_Converter(PyObject *, void *)
     * }
     */
    public static MemorySegment _PyLong_UnsignedLong_Converter$address() {
        return _PyLong_UnsignedLong_Converter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyLong_UnsignedLong_Converter(PyObject *, void *)
     * }
     */
    public static int _PyLong_UnsignedLong_Converter(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyLong_UnsignedLong_Converter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyLong_UnsignedLong_Converter", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyLong_UnsignedLongLong_Converter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyLong_UnsignedLongLong_Converter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyLong_UnsignedLongLong_Converter(PyObject *, void *)
     * }
     */
    public static FunctionDescriptor _PyLong_UnsignedLongLong_Converter$descriptor() {
        return _PyLong_UnsignedLongLong_Converter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyLong_UnsignedLongLong_Converter(PyObject *, void *)
     * }
     */
    public static MethodHandle _PyLong_UnsignedLongLong_Converter$handle() {
        return _PyLong_UnsignedLongLong_Converter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyLong_UnsignedLongLong_Converter(PyObject *, void *)
     * }
     */
    public static MemorySegment _PyLong_UnsignedLongLong_Converter$address() {
        return _PyLong_UnsignedLongLong_Converter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyLong_UnsignedLongLong_Converter(PyObject *, void *)
     * }
     */
    public static int _PyLong_UnsignedLongLong_Converter(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyLong_UnsignedLongLong_Converter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyLong_UnsignedLongLong_Converter", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyLong_Size_t_Converter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyLong_Size_t_Converter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyLong_Size_t_Converter(PyObject *, void *)
     * }
     */
    public static FunctionDescriptor _PyLong_Size_t_Converter$descriptor() {
        return _PyLong_Size_t_Converter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyLong_Size_t_Converter(PyObject *, void *)
     * }
     */
    public static MethodHandle _PyLong_Size_t_Converter$handle() {
        return _PyLong_Size_t_Converter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyLong_Size_t_Converter(PyObject *, void *)
     * }
     */
    public static MemorySegment _PyLong_Size_t_Converter$address() {
        return _PyLong_Size_t_Converter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyLong_Size_t_Converter(PyObject *, void *)
     * }
     */
    public static int _PyLong_Size_t_Converter(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyLong_Size_t_Converter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyLong_Size_t_Converter", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyLong_Frexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyLong_Frexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _PyLong_Frexp(PyLongObject *a, Py_ssize_t *e)
     * }
     */
    public static FunctionDescriptor _PyLong_Frexp$descriptor() {
        return _PyLong_Frexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _PyLong_Frexp(PyLongObject *a, Py_ssize_t *e)
     * }
     */
    public static MethodHandle _PyLong_Frexp$handle() {
        return _PyLong_Frexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _PyLong_Frexp(PyLongObject *a, Py_ssize_t *e)
     * }
     */
    public static MemorySegment _PyLong_Frexp$address() {
        return _PyLong_Frexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _PyLong_Frexp(PyLongObject *a, Py_ssize_t *e)
     * }
     */
    public static double _PyLong_Frexp(MemorySegment a, MemorySegment e) {
        var mh$ = _PyLong_Frexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyLong_Frexp", a, e);
            }
            return (double)mh$.invokeExact(a, e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyLong_FromUnicodeObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyLong_FromUnicodeObject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromUnicodeObject(PyObject *u, int base)
     * }
     */
    public static FunctionDescriptor PyLong_FromUnicodeObject$descriptor() {
        return PyLong_FromUnicodeObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromUnicodeObject(PyObject *u, int base)
     * }
     */
    public static MethodHandle PyLong_FromUnicodeObject$handle() {
        return PyLong_FromUnicodeObject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyLong_FromUnicodeObject(PyObject *u, int base)
     * }
     */
    public static MemorySegment PyLong_FromUnicodeObject$address() {
        return PyLong_FromUnicodeObject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyLong_FromUnicodeObject(PyObject *u, int base)
     * }
     */
    public static MemorySegment PyLong_FromUnicodeObject(MemorySegment u, int base) {
        var mh$ = PyLong_FromUnicodeObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyLong_FromUnicodeObject", u, base);
            }
            return (MemorySegment)mh$.invokeExact(u, base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyLong_FromBytes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyLong_FromBytes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyLong_FromBytes(const char *, Py_ssize_t, int)
     * }
     */
    public static FunctionDescriptor _PyLong_FromBytes$descriptor() {
        return _PyLong_FromBytes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyLong_FromBytes(const char *, Py_ssize_t, int)
     * }
     */
    public static MethodHandle _PyLong_FromBytes$handle() {
        return _PyLong_FromBytes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyLong_FromBytes(const char *, Py_ssize_t, int)
     * }
     */
    public static MemorySegment _PyLong_FromBytes$address() {
        return _PyLong_FromBytes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyLong_FromBytes(const char *, Py_ssize_t, int)
     * }
     */
    public static MemorySegment _PyLong_FromBytes(MemorySegment x0, long x1, int x2) {
        var mh$ = _PyLong_FromBytes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyLong_FromBytes", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyLong_Sign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyLong_Sign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyLong_Sign(PyObject *v)
     * }
     */
    public static FunctionDescriptor _PyLong_Sign$descriptor() {
        return _PyLong_Sign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyLong_Sign(PyObject *v)
     * }
     */
    public static MethodHandle _PyLong_Sign$handle() {
        return _PyLong_Sign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyLong_Sign(PyObject *v)
     * }
     */
    public static MemorySegment _PyLong_Sign$address() {
        return _PyLong_Sign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyLong_Sign(PyObject *v)
     * }
     */
    public static int _PyLong_Sign(MemorySegment v) {
        var mh$ = _PyLong_Sign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyLong_Sign", v);
            }
            return (int)mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyLong_NumBits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyLong_NumBits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _PyLong_NumBits(PyObject *v)
     * }
     */
    public static FunctionDescriptor _PyLong_NumBits$descriptor() {
        return _PyLong_NumBits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _PyLong_NumBits(PyObject *v)
     * }
     */
    public static MethodHandle _PyLong_NumBits$handle() {
        return _PyLong_NumBits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _PyLong_NumBits(PyObject *v)
     * }
     */
    public static MemorySegment _PyLong_NumBits$address() {
        return _PyLong_NumBits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _PyLong_NumBits(PyObject *v)
     * }
     */
    public static long _PyLong_NumBits(MemorySegment v) {
        var mh$ = _PyLong_NumBits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyLong_NumBits", v);
            }
            return (long)mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyLong_DivmodNear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyLong_DivmodNear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyLong_DivmodNear(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor _PyLong_DivmodNear$descriptor() {
        return _PyLong_DivmodNear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyLong_DivmodNear(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle _PyLong_DivmodNear$handle() {
        return _PyLong_DivmodNear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyLong_DivmodNear(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment _PyLong_DivmodNear$address() {
        return _PyLong_DivmodNear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyLong_DivmodNear(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment _PyLong_DivmodNear(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyLong_DivmodNear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyLong_DivmodNear", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyLong_FromByteArray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyLong_FromByteArray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyLong_FromByteArray(const unsigned char *bytes, size_t n, int little_endian, int is_signed)
     * }
     */
    public static FunctionDescriptor _PyLong_FromByteArray$descriptor() {
        return _PyLong_FromByteArray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyLong_FromByteArray(const unsigned char *bytes, size_t n, int little_endian, int is_signed)
     * }
     */
    public static MethodHandle _PyLong_FromByteArray$handle() {
        return _PyLong_FromByteArray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyLong_FromByteArray(const unsigned char *bytes, size_t n, int little_endian, int is_signed)
     * }
     */
    public static MemorySegment _PyLong_FromByteArray$address() {
        return _PyLong_FromByteArray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyLong_FromByteArray(const unsigned char *bytes, size_t n, int little_endian, int is_signed)
     * }
     */
    public static MemorySegment _PyLong_FromByteArray(MemorySegment bytes, long n, int little_endian, int is_signed) {
        var mh$ = _PyLong_FromByteArray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyLong_FromByteArray", bytes, n, little_endian, is_signed);
            }
            return (MemorySegment)mh$.invokeExact(bytes, n, little_endian, is_signed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyLong_AsByteArray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyLong_AsByteArray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _PyLong_AsByteArray(PyLongObject *v, unsigned char *bytes, size_t n, int little_endian, int is_signed)
     * }
     */
    public static FunctionDescriptor _PyLong_AsByteArray$descriptor() {
        return _PyLong_AsByteArray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _PyLong_AsByteArray(PyLongObject *v, unsigned char *bytes, size_t n, int little_endian, int is_signed)
     * }
     */
    public static MethodHandle _PyLong_AsByteArray$handle() {
        return _PyLong_AsByteArray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _PyLong_AsByteArray(PyLongObject *v, unsigned char *bytes, size_t n, int little_endian, int is_signed)
     * }
     */
    public static MemorySegment _PyLong_AsByteArray$address() {
        return _PyLong_AsByteArray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _PyLong_AsByteArray(PyLongObject *v, unsigned char *bytes, size_t n, int little_endian, int is_signed)
     * }
     */
    public static int _PyLong_AsByteArray(MemorySegment v, MemorySegment bytes, long n, int little_endian, int is_signed) {
        var mh$ = _PyLong_AsByteArray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyLong_AsByteArray", v, bytes, n, little_endian, is_signed);
            }
            return (int)mh$.invokeExact(v, bytes, n, little_endian, is_signed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyLong_Format {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyLong_Format");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyLong_Format(PyObject *obj, int base)
     * }
     */
    public static FunctionDescriptor _PyLong_Format$descriptor() {
        return _PyLong_Format.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyLong_Format(PyObject *obj, int base)
     * }
     */
    public static MethodHandle _PyLong_Format$handle() {
        return _PyLong_Format.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyLong_Format(PyObject *obj, int base)
     * }
     */
    public static MemorySegment _PyLong_Format$address() {
        return _PyLong_Format.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyLong_Format(PyObject *obj, int base)
     * }
     */
    public static MemorySegment _PyLong_Format(MemorySegment obj, int base) {
        var mh$ = _PyLong_Format.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyLong_Format", obj, base);
            }
            return (MemorySegment)mh$.invokeExact(obj, base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyLong_GCD {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyLong_GCD");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyLong_GCD(PyObject *, PyObject *)
     * }
     */
    public static FunctionDescriptor _PyLong_GCD$descriptor() {
        return _PyLong_GCD.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyLong_GCD(PyObject *, PyObject *)
     * }
     */
    public static MethodHandle _PyLong_GCD$handle() {
        return _PyLong_GCD.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyLong_GCD(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment _PyLong_GCD$address() {
        return _PyLong_GCD.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyLong_GCD(PyObject *, PyObject *)
     * }
     */
    public static MemorySegment _PyLong_GCD(MemorySegment x0, MemorySegment x1) {
        var mh$ = _PyLong_GCD.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyLong_GCD", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyLong_Rshift {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyLong_Rshift");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyLong_Rshift(PyObject *, size_t)
     * }
     */
    public static FunctionDescriptor _PyLong_Rshift$descriptor() {
        return _PyLong_Rshift.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyLong_Rshift(PyObject *, size_t)
     * }
     */
    public static MethodHandle _PyLong_Rshift$handle() {
        return _PyLong_Rshift.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyLong_Rshift(PyObject *, size_t)
     * }
     */
    public static MemorySegment _PyLong_Rshift$address() {
        return _PyLong_Rshift.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyLong_Rshift(PyObject *, size_t)
     * }
     */
    public static MemorySegment _PyLong_Rshift(MemorySegment x0, long x1) {
        var mh$ = _PyLong_Rshift.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyLong_Rshift", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyLong_Lshift {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyLong_Lshift");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyLong_Lshift(PyObject *, size_t)
     * }
     */
    public static FunctionDescriptor _PyLong_Lshift$descriptor() {
        return _PyLong_Lshift.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyLong_Lshift(PyObject *, size_t)
     * }
     */
    public static MethodHandle _PyLong_Lshift$handle() {
        return _PyLong_Lshift.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyLong_Lshift(PyObject *, size_t)
     * }
     */
    public static MemorySegment _PyLong_Lshift$address() {
        return _PyLong_Lshift.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyLong_Lshift(PyObject *, size_t)
     * }
     */
    public static MemorySegment _PyLong_Lshift(MemorySegment x0, long x1) {
        var mh$ = _PyLong_Lshift.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyLong_Lshift", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef uint32_t digit
     * }
     */
    public static final OfInt digit = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int32_t sdigit
     * }
     */
    public static final OfInt sdigit = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint64_t twodigits
     * }
     */
    public static final OfLong twodigits = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t stwodigits
     * }
     */
    public static final OfLong stwodigits = Python_h.C_LONG_LONG;

    private static class _PyLong_New {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyLong_New");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyLongObject *_PyLong_New(Py_ssize_t)
     * }
     */
    public static FunctionDescriptor _PyLong_New$descriptor() {
        return _PyLong_New.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyLongObject *_PyLong_New(Py_ssize_t)
     * }
     */
    public static MethodHandle _PyLong_New$handle() {
        return _PyLong_New.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyLongObject *_PyLong_New(Py_ssize_t)
     * }
     */
    public static MemorySegment _PyLong_New$address() {
        return _PyLong_New.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyLongObject *_PyLong_New(Py_ssize_t)
     * }
     */
    public static MemorySegment _PyLong_New(long x0) {
        var mh$ = _PyLong_New.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyLong_New", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _PyLong_Copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_PyLong_Copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *_PyLong_Copy(PyLongObject *src)
     * }
     */
    public static FunctionDescriptor _PyLong_Copy$descriptor() {
        return _PyLong_Copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *_PyLong_Copy(PyLongObject *src)
     * }
     */
    public static MethodHandle _PyLong_Copy$handle() {
        return _PyLong_Copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *_PyLong_Copy(PyLongObject *src)
     * }
     */
    public static MemorySegment _PyLong_Copy$address() {
        return _PyLong_Copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *_PyLong_Copy(PyLongObject *src)
     * }
     */
    public static MemorySegment _PyLong_Copy(MemorySegment src) {
        var mh$ = _PyLong_Copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_PyLong_Copy", src);
            }
            return (MemorySegment)mh$.invokeExact(src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBool_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyBool_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBool_Type
     * }
     */
    public static GroupLayout PyBool_Type$layout() {
        return PyBool_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBool_Type
     * }
     */
    public static MemorySegment PyBool_Type() {
        return PyBool_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyBool_Type
     * }
     */
    public static void PyBool_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyBool_Type$constants.SEGMENT, 0L, PyBool_Type$constants.LAYOUT.byteSize());
    }

    private static class _Py_FalseStruct$constants {
        public static final GroupLayout LAYOUT = _longobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_Py_FalseStruct").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyLongObject _Py_FalseStruct
     * }
     */
    public static GroupLayout _Py_FalseStruct$layout() {
        return _Py_FalseStruct$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyLongObject _Py_FalseStruct
     * }
     */
    public static MemorySegment _Py_FalseStruct() {
        return _Py_FalseStruct$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyLongObject _Py_FalseStruct
     * }
     */
    public static void _Py_FalseStruct(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Py_FalseStruct$constants.SEGMENT, 0L, _Py_FalseStruct$constants.LAYOUT.byteSize());
    }

    private static class _Py_TrueStruct$constants {
        public static final GroupLayout LAYOUT = _longobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_Py_TrueStruct").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyLongObject _Py_TrueStruct
     * }
     */
    public static GroupLayout _Py_TrueStruct$layout() {
        return _Py_TrueStruct$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyLongObject _Py_TrueStruct
     * }
     */
    public static MemorySegment _Py_TrueStruct() {
        return _Py_TrueStruct$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyLongObject _Py_TrueStruct
     * }
     */
    public static void _Py_TrueStruct(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Py_TrueStruct$constants.SEGMENT, 0L, _Py_TrueStruct$constants.LAYOUT.byteSize());
    }

    private static class Py_IsTrue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_IsTrue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_IsTrue(PyObject *x)
     * }
     */
    public static FunctionDescriptor Py_IsTrue$descriptor() {
        return Py_IsTrue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_IsTrue(PyObject *x)
     * }
     */
    public static MethodHandle Py_IsTrue$handle() {
        return Py_IsTrue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_IsTrue(PyObject *x)
     * }
     */
    public static MemorySegment Py_IsTrue$address() {
        return Py_IsTrue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_IsTrue(PyObject *x)
     * }
     */
    public static int Py_IsTrue(MemorySegment x) {
        var mh$ = Py_IsTrue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_IsTrue", x);
            }
            return (int)mh$.invokeExact(x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Py_IsFalse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("Py_IsFalse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Py_IsFalse(PyObject *x)
     * }
     */
    public static FunctionDescriptor Py_IsFalse$descriptor() {
        return Py_IsFalse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Py_IsFalse(PyObject *x)
     * }
     */
    public static MethodHandle Py_IsFalse$handle() {
        return Py_IsFalse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Py_IsFalse(PyObject *x)
     * }
     */
    public static MemorySegment Py_IsFalse$address() {
        return Py_IsFalse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Py_IsFalse(PyObject *x)
     * }
     */
    public static int Py_IsFalse(MemorySegment x) {
        var mh$ = Py_IsFalse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Py_IsFalse", x);
            }
            return (int)mh$.invokeExact(x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyBool_FromLong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyBool_FromLong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyBool_FromLong(long)
     * }
     */
    public static FunctionDescriptor PyBool_FromLong$descriptor() {
        return PyBool_FromLong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyBool_FromLong(long)
     * }
     */
    public static MethodHandle PyBool_FromLong$handle() {
        return PyBool_FromLong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyBool_FromLong(long)
     * }
     */
    public static MemorySegment PyBool_FromLong$address() {
        return PyBool_FromLong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyBool_FromLong(long)
     * }
     */
    public static MemorySegment PyBool_FromLong(long x0) {
        var mh$ = PyBool_FromLong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyBool_FromLong", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFloat_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyFloat_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyFloat_Type
     * }
     */
    public static GroupLayout PyFloat_Type$layout() {
        return PyFloat_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyFloat_Type
     * }
     */
    public static MemorySegment PyFloat_Type() {
        return PyFloat_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyFloat_Type
     * }
     */
    public static void PyFloat_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyFloat_Type$constants.SEGMENT, 0L, PyFloat_Type$constants.LAYOUT.byteSize());
    }

    private static class PyFloat_GetMax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFloat_GetMax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double PyFloat_GetMax()
     * }
     */
    public static FunctionDescriptor PyFloat_GetMax$descriptor() {
        return PyFloat_GetMax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double PyFloat_GetMax()
     * }
     */
    public static MethodHandle PyFloat_GetMax$handle() {
        return PyFloat_GetMax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double PyFloat_GetMax()
     * }
     */
    public static MemorySegment PyFloat_GetMax$address() {
        return PyFloat_GetMax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double PyFloat_GetMax()
     * }
     */
    public static double PyFloat_GetMax() {
        var mh$ = PyFloat_GetMax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFloat_GetMax");
            }
            return (double)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFloat_GetMin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFloat_GetMin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double PyFloat_GetMin()
     * }
     */
    public static FunctionDescriptor PyFloat_GetMin$descriptor() {
        return PyFloat_GetMin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double PyFloat_GetMin()
     * }
     */
    public static MethodHandle PyFloat_GetMin$handle() {
        return PyFloat_GetMin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double PyFloat_GetMin()
     * }
     */
    public static MemorySegment PyFloat_GetMin$address() {
        return PyFloat_GetMin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double PyFloat_GetMin()
     * }
     */
    public static double PyFloat_GetMin() {
        var mh$ = PyFloat_GetMin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFloat_GetMin");
            }
            return (double)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFloat_GetInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFloat_GetInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFloat_GetInfo()
     * }
     */
    public static FunctionDescriptor PyFloat_GetInfo$descriptor() {
        return PyFloat_GetInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFloat_GetInfo()
     * }
     */
    public static MethodHandle PyFloat_GetInfo$handle() {
        return PyFloat_GetInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFloat_GetInfo()
     * }
     */
    public static MemorySegment PyFloat_GetInfo$address() {
        return PyFloat_GetInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFloat_GetInfo()
     * }
     */
    public static MemorySegment PyFloat_GetInfo() {
        var mh$ = PyFloat_GetInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFloat_GetInfo");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFloat_FromString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFloat_FromString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFloat_FromString(PyObject *)
     * }
     */
    public static FunctionDescriptor PyFloat_FromString$descriptor() {
        return PyFloat_FromString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFloat_FromString(PyObject *)
     * }
     */
    public static MethodHandle PyFloat_FromString$handle() {
        return PyFloat_FromString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFloat_FromString(PyObject *)
     * }
     */
    public static MemorySegment PyFloat_FromString$address() {
        return PyFloat_FromString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFloat_FromString(PyObject *)
     * }
     */
    public static MemorySegment PyFloat_FromString(MemorySegment x0) {
        var mh$ = PyFloat_FromString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFloat_FromString", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFloat_FromDouble {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFloat_FromDouble");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyFloat_FromDouble(double)
     * }
     */
    public static FunctionDescriptor PyFloat_FromDouble$descriptor() {
        return PyFloat_FromDouble.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyFloat_FromDouble(double)
     * }
     */
    public static MethodHandle PyFloat_FromDouble$handle() {
        return PyFloat_FromDouble.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyFloat_FromDouble(double)
     * }
     */
    public static MemorySegment PyFloat_FromDouble$address() {
        return PyFloat_FromDouble.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyFloat_FromDouble(double)
     * }
     */
    public static MemorySegment PyFloat_FromDouble(double x0) {
        var mh$ = PyFloat_FromDouble.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFloat_FromDouble", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFloat_AsDouble {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFloat_AsDouble");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double PyFloat_AsDouble(PyObject *)
     * }
     */
    public static FunctionDescriptor PyFloat_AsDouble$descriptor() {
        return PyFloat_AsDouble.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double PyFloat_AsDouble(PyObject *)
     * }
     */
    public static MethodHandle PyFloat_AsDouble$handle() {
        return PyFloat_AsDouble.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double PyFloat_AsDouble(PyObject *)
     * }
     */
    public static MemorySegment PyFloat_AsDouble$address() {
        return PyFloat_AsDouble.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double PyFloat_AsDouble(PyObject *)
     * }
     */
    public static double PyFloat_AsDouble(MemorySegment x0) {
        var mh$ = PyFloat_AsDouble.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFloat_AsDouble", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFloat_Pack2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_DOUBLE,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFloat_Pack2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyFloat_Pack2(double x, char *p, int le)
     * }
     */
    public static FunctionDescriptor PyFloat_Pack2$descriptor() {
        return PyFloat_Pack2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyFloat_Pack2(double x, char *p, int le)
     * }
     */
    public static MethodHandle PyFloat_Pack2$handle() {
        return PyFloat_Pack2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyFloat_Pack2(double x, char *p, int le)
     * }
     */
    public static MemorySegment PyFloat_Pack2$address() {
        return PyFloat_Pack2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyFloat_Pack2(double x, char *p, int le)
     * }
     */
    public static int PyFloat_Pack2(double x, MemorySegment p, int le) {
        var mh$ = PyFloat_Pack2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFloat_Pack2", x, p, le);
            }
            return (int)mh$.invokeExact(x, p, le);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFloat_Pack4 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_DOUBLE,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFloat_Pack4");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyFloat_Pack4(double x, char *p, int le)
     * }
     */
    public static FunctionDescriptor PyFloat_Pack4$descriptor() {
        return PyFloat_Pack4.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyFloat_Pack4(double x, char *p, int le)
     * }
     */
    public static MethodHandle PyFloat_Pack4$handle() {
        return PyFloat_Pack4.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyFloat_Pack4(double x, char *p, int le)
     * }
     */
    public static MemorySegment PyFloat_Pack4$address() {
        return PyFloat_Pack4.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyFloat_Pack4(double x, char *p, int le)
     * }
     */
    public static int PyFloat_Pack4(double x, MemorySegment p, int le) {
        var mh$ = PyFloat_Pack4.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFloat_Pack4", x, p, le);
            }
            return (int)mh$.invokeExact(x, p, le);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFloat_Pack8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_DOUBLE,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFloat_Pack8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PyFloat_Pack8(double x, char *p, int le)
     * }
     */
    public static FunctionDescriptor PyFloat_Pack8$descriptor() {
        return PyFloat_Pack8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PyFloat_Pack8(double x, char *p, int le)
     * }
     */
    public static MethodHandle PyFloat_Pack8$handle() {
        return PyFloat_Pack8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PyFloat_Pack8(double x, char *p, int le)
     * }
     */
    public static MemorySegment PyFloat_Pack8$address() {
        return PyFloat_Pack8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PyFloat_Pack8(double x, char *p, int le)
     * }
     */
    public static int PyFloat_Pack8(double x, MemorySegment p, int le) {
        var mh$ = PyFloat_Pack8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFloat_Pack8", x, p, le);
            }
            return (int)mh$.invokeExact(x, p, le);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFloat_Unpack2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFloat_Unpack2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double PyFloat_Unpack2(const char *p, int le)
     * }
     */
    public static FunctionDescriptor PyFloat_Unpack2$descriptor() {
        return PyFloat_Unpack2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double PyFloat_Unpack2(const char *p, int le)
     * }
     */
    public static MethodHandle PyFloat_Unpack2$handle() {
        return PyFloat_Unpack2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double PyFloat_Unpack2(const char *p, int le)
     * }
     */
    public static MemorySegment PyFloat_Unpack2$address() {
        return PyFloat_Unpack2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double PyFloat_Unpack2(const char *p, int le)
     * }
     */
    public static double PyFloat_Unpack2(MemorySegment p, int le) {
        var mh$ = PyFloat_Unpack2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFloat_Unpack2", p, le);
            }
            return (double)mh$.invokeExact(p, le);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFloat_Unpack4 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFloat_Unpack4");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double PyFloat_Unpack4(const char *p, int le)
     * }
     */
    public static FunctionDescriptor PyFloat_Unpack4$descriptor() {
        return PyFloat_Unpack4.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double PyFloat_Unpack4(const char *p, int le)
     * }
     */
    public static MethodHandle PyFloat_Unpack4$handle() {
        return PyFloat_Unpack4.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double PyFloat_Unpack4(const char *p, int le)
     * }
     */
    public static MemorySegment PyFloat_Unpack4$address() {
        return PyFloat_Unpack4.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double PyFloat_Unpack4(const char *p, int le)
     * }
     */
    public static double PyFloat_Unpack4(MemorySegment p, int le) {
        var mh$ = PyFloat_Unpack4.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFloat_Unpack4", p, le);
            }
            return (double)mh$.invokeExact(p, le);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyFloat_Unpack8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyFloat_Unpack8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double PyFloat_Unpack8(const char *p, int le)
     * }
     */
    public static FunctionDescriptor PyFloat_Unpack8$descriptor() {
        return PyFloat_Unpack8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double PyFloat_Unpack8(const char *p, int le)
     * }
     */
    public static MethodHandle PyFloat_Unpack8$handle() {
        return PyFloat_Unpack8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double PyFloat_Unpack8(const char *p, int le)
     * }
     */
    public static MemorySegment PyFloat_Unpack8$address() {
        return PyFloat_Unpack8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double PyFloat_Unpack8(const char *p, int le)
     * }
     */
    public static double PyFloat_Unpack8(MemorySegment p, int le) {
        var mh$ = PyFloat_Unpack8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyFloat_Unpack8", p, le);
            }
            return (double)mh$.invokeExact(p, le);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyComplex_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyComplex_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyComplex_Type
     * }
     */
    public static GroupLayout PyComplex_Type$layout() {
        return PyComplex_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyComplex_Type
     * }
     */
    public static MemorySegment PyComplex_Type() {
        return PyComplex_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyComplex_Type
     * }
     */
    public static void PyComplex_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyComplex_Type$constants.SEGMENT, 0L, PyComplex_Type$constants.LAYOUT.byteSize());
    }

    private static class PyComplex_FromDoubles {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_DOUBLE,
            Python_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyComplex_FromDoubles");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyComplex_FromDoubles(double real, double imag)
     * }
     */
    public static FunctionDescriptor PyComplex_FromDoubles$descriptor() {
        return PyComplex_FromDoubles.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyComplex_FromDoubles(double real, double imag)
     * }
     */
    public static MethodHandle PyComplex_FromDoubles$handle() {
        return PyComplex_FromDoubles.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyComplex_FromDoubles(double real, double imag)
     * }
     */
    public static MemorySegment PyComplex_FromDoubles$address() {
        return PyComplex_FromDoubles.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyComplex_FromDoubles(double real, double imag)
     * }
     */
    public static MemorySegment PyComplex_FromDoubles(double real, double imag) {
        var mh$ = PyComplex_FromDoubles.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyComplex_FromDoubles", real, imag);
            }
            return (MemorySegment)mh$.invokeExact(real, imag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyComplex_RealAsDouble {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyComplex_RealAsDouble");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double PyComplex_RealAsDouble(PyObject *op)
     * }
     */
    public static FunctionDescriptor PyComplex_RealAsDouble$descriptor() {
        return PyComplex_RealAsDouble.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double PyComplex_RealAsDouble(PyObject *op)
     * }
     */
    public static MethodHandle PyComplex_RealAsDouble$handle() {
        return PyComplex_RealAsDouble.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double PyComplex_RealAsDouble(PyObject *op)
     * }
     */
    public static MemorySegment PyComplex_RealAsDouble$address() {
        return PyComplex_RealAsDouble.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double PyComplex_RealAsDouble(PyObject *op)
     * }
     */
    public static double PyComplex_RealAsDouble(MemorySegment op) {
        var mh$ = PyComplex_RealAsDouble.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyComplex_RealAsDouble", op);
            }
            return (double)mh$.invokeExact(op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyComplex_ImagAsDouble {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyComplex_ImagAsDouble");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double PyComplex_ImagAsDouble(PyObject *op)
     * }
     */
    public static FunctionDescriptor PyComplex_ImagAsDouble$descriptor() {
        return PyComplex_ImagAsDouble.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double PyComplex_ImagAsDouble(PyObject *op)
     * }
     */
    public static MethodHandle PyComplex_ImagAsDouble$handle() {
        return PyComplex_ImagAsDouble.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double PyComplex_ImagAsDouble(PyObject *op)
     * }
     */
    public static MemorySegment PyComplex_ImagAsDouble$address() {
        return PyComplex_ImagAsDouble.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double PyComplex_ImagAsDouble(PyObject *op)
     * }
     */
    public static double PyComplex_ImagAsDouble(MemorySegment op) {
        var mh$ = PyComplex_ImagAsDouble.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyComplex_ImagAsDouble", op);
            }
            return (double)mh$.invokeExact(op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_c_sum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Py_complex.layout(),
            Py_complex.layout(),
            Py_complex.layout()
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_c_sum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_complex _Py_c_sum(Py_complex, Py_complex)
     * }
     */
    public static FunctionDescriptor _Py_c_sum$descriptor() {
        return _Py_c_sum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_complex _Py_c_sum(Py_complex, Py_complex)
     * }
     */
    public static MethodHandle _Py_c_sum$handle() {
        return _Py_c_sum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_complex _Py_c_sum(Py_complex, Py_complex)
     * }
     */
    public static MemorySegment _Py_c_sum$address() {
        return _Py_c_sum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_complex _Py_c_sum(Py_complex, Py_complex)
     * }
     */
    public static MemorySegment _Py_c_sum(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1) {
        var mh$ = _Py_c_sum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_c_sum", allocator, x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_c_diff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Py_complex.layout(),
            Py_complex.layout(),
            Py_complex.layout()
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_c_diff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_complex _Py_c_diff(Py_complex, Py_complex)
     * }
     */
    public static FunctionDescriptor _Py_c_diff$descriptor() {
        return _Py_c_diff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_complex _Py_c_diff(Py_complex, Py_complex)
     * }
     */
    public static MethodHandle _Py_c_diff$handle() {
        return _Py_c_diff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_complex _Py_c_diff(Py_complex, Py_complex)
     * }
     */
    public static MemorySegment _Py_c_diff$address() {
        return _Py_c_diff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_complex _Py_c_diff(Py_complex, Py_complex)
     * }
     */
    public static MemorySegment _Py_c_diff(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1) {
        var mh$ = _Py_c_diff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_c_diff", allocator, x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_c_neg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Py_complex.layout(),
            Py_complex.layout()
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_c_neg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_complex _Py_c_neg(Py_complex)
     * }
     */
    public static FunctionDescriptor _Py_c_neg$descriptor() {
        return _Py_c_neg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_complex _Py_c_neg(Py_complex)
     * }
     */
    public static MethodHandle _Py_c_neg$handle() {
        return _Py_c_neg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_complex _Py_c_neg(Py_complex)
     * }
     */
    public static MemorySegment _Py_c_neg$address() {
        return _Py_c_neg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_complex _Py_c_neg(Py_complex)
     * }
     */
    public static MemorySegment _Py_c_neg(SegmentAllocator allocator, MemorySegment x0) {
        var mh$ = _Py_c_neg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_c_neg", allocator, x0);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_c_prod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Py_complex.layout(),
            Py_complex.layout(),
            Py_complex.layout()
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_c_prod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_complex _Py_c_prod(Py_complex, Py_complex)
     * }
     */
    public static FunctionDescriptor _Py_c_prod$descriptor() {
        return _Py_c_prod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_complex _Py_c_prod(Py_complex, Py_complex)
     * }
     */
    public static MethodHandle _Py_c_prod$handle() {
        return _Py_c_prod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_complex _Py_c_prod(Py_complex, Py_complex)
     * }
     */
    public static MemorySegment _Py_c_prod$address() {
        return _Py_c_prod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_complex _Py_c_prod(Py_complex, Py_complex)
     * }
     */
    public static MemorySegment _Py_c_prod(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1) {
        var mh$ = _Py_c_prod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_c_prod", allocator, x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_c_quot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Py_complex.layout(),
            Py_complex.layout(),
            Py_complex.layout()
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_c_quot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_complex _Py_c_quot(Py_complex, Py_complex)
     * }
     */
    public static FunctionDescriptor _Py_c_quot$descriptor() {
        return _Py_c_quot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_complex _Py_c_quot(Py_complex, Py_complex)
     * }
     */
    public static MethodHandle _Py_c_quot$handle() {
        return _Py_c_quot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_complex _Py_c_quot(Py_complex, Py_complex)
     * }
     */
    public static MemorySegment _Py_c_quot$address() {
        return _Py_c_quot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_complex _Py_c_quot(Py_complex, Py_complex)
     * }
     */
    public static MemorySegment _Py_c_quot(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1) {
        var mh$ = _Py_c_quot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_c_quot", allocator, x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_c_pow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Py_complex.layout(),
            Py_complex.layout(),
            Py_complex.layout()
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_c_pow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_complex _Py_c_pow(Py_complex, Py_complex)
     * }
     */
    public static FunctionDescriptor _Py_c_pow$descriptor() {
        return _Py_c_pow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_complex _Py_c_pow(Py_complex, Py_complex)
     * }
     */
    public static MethodHandle _Py_c_pow$handle() {
        return _Py_c_pow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_complex _Py_c_pow(Py_complex, Py_complex)
     * }
     */
    public static MemorySegment _Py_c_pow$address() {
        return _Py_c_pow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_complex _Py_c_pow(Py_complex, Py_complex)
     * }
     */
    public static MemorySegment _Py_c_pow(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1) {
        var mh$ = _Py_c_pow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_c_pow", allocator, x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Py_c_abs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Py_complex.layout()
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Py_c_abs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _Py_c_abs(Py_complex)
     * }
     */
    public static FunctionDescriptor _Py_c_abs$descriptor() {
        return _Py_c_abs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _Py_c_abs(Py_complex)
     * }
     */
    public static MethodHandle _Py_c_abs$handle() {
        return _Py_c_abs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _Py_c_abs(Py_complex)
     * }
     */
    public static MemorySegment _Py_c_abs$address() {
        return _Py_c_abs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _Py_c_abs(Py_complex)
     * }
     */
    public static double _Py_c_abs(MemorySegment x0) {
        var mh$ = _Py_c_abs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Py_c_abs", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyComplex_FromCComplex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Py_complex.layout()
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyComplex_FromCComplex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PyObject *PyComplex_FromCComplex(Py_complex)
     * }
     */
    public static FunctionDescriptor PyComplex_FromCComplex$descriptor() {
        return PyComplex_FromCComplex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PyObject *PyComplex_FromCComplex(Py_complex)
     * }
     */
    public static MethodHandle PyComplex_FromCComplex$handle() {
        return PyComplex_FromCComplex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PyObject *PyComplex_FromCComplex(Py_complex)
     * }
     */
    public static MemorySegment PyComplex_FromCComplex$address() {
        return PyComplex_FromCComplex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PyObject *PyComplex_FromCComplex(Py_complex)
     * }
     */
    public static MemorySegment PyComplex_FromCComplex(MemorySegment x0) {
        var mh$ = PyComplex_FromCComplex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyComplex_FromCComplex", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyComplex_AsCComplex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Py_complex.layout(),
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("PyComplex_AsCComplex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Py_complex PyComplex_AsCComplex(PyObject *op)
     * }
     */
    public static FunctionDescriptor PyComplex_AsCComplex$descriptor() {
        return PyComplex_AsCComplex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Py_complex PyComplex_AsCComplex(PyObject *op)
     * }
     */
    public static MethodHandle PyComplex_AsCComplex$handle() {
        return PyComplex_AsCComplex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Py_complex PyComplex_AsCComplex(PyObject *op)
     * }
     */
    public static MemorySegment PyComplex_AsCComplex$address() {
        return PyComplex_AsCComplex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Py_complex PyComplex_AsCComplex(PyObject *op)
     * }
     */
    public static MemorySegment PyComplex_AsCComplex(SegmentAllocator allocator, MemorySegment op) {
        var mh$ = PyComplex_AsCComplex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PyComplex_AsCComplex", allocator, op);
            }
            return (MemorySegment)mh$.invokeExact(allocator, op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PyRange_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyRange_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyRange_Type
     * }
     */
    public static GroupLayout PyRange_Type$layout() {
        return PyRange_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyRange_Type
     * }
     */
    public static MemorySegment PyRange_Type() {
        return PyRange_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyRange_Type
     * }
     */
    public static void PyRange_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyRange_Type$constants.SEGMENT, 0L, PyRange_Type$constants.LAYOUT.byteSize());
    }

    private static class PyRangeIter_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyRangeIter_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyRangeIter_Type
     * }
     */
    public static GroupLayout PyRangeIter_Type$layout() {
        return PyRangeIter_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyRangeIter_Type
     * }
     */
    public static MemorySegment PyRangeIter_Type() {
        return PyRangeIter_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyRangeIter_Type
     * }
     */
    public static void PyRangeIter_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyRangeIter_Type$constants.SEGMENT, 0L, PyRangeIter_Type$constants.LAYOUT.byteSize());
    }

    private static class PyLongRangeIter_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyLongRangeIter_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyLongRangeIter_Type
     * }
     */
    public static GroupLayout PyLongRangeIter_Type$layout() {
        return PyLongRangeIter_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyLongRangeIter_Type
     * }
     */
    public static MemorySegment PyLongRangeIter_Type() {
        return PyLongRangeIter_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyLongRangeIter_Type
     * }
     */
    public static void PyLongRangeIter_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyLongRangeIter_Type$constants.SEGMENT, 0L, PyLongRangeIter_Type$constants.LAYOUT.byteSize());
    }

    private static class _PyManagedBuffer_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("_PyManagedBuffer_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyManagedBuffer_Type
     * }
     */
    public static GroupLayout _PyManagedBuffer_Type$layout() {
        return _PyManagedBuffer_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyManagedBuffer_Type
     * }
     */
    public static MemorySegment _PyManagedBuffer_Type() {
        return _PyManagedBuffer_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject _PyManagedBuffer_Type
     * }
     */
    public static void _PyManagedBuffer_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _PyManagedBuffer_Type$constants.SEGMENT, 0L, _PyManagedBuffer_Type$constants.LAYOUT.byteSize());
    }

    private static class PyMemoryView_Type$constants {
        public static final GroupLayout LAYOUT = _typeobject.layout();
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("PyMemoryView_Type").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyMemoryView_Type
     * }
     */
    public static GroupLayout PyMemoryView_Type$layout() {
        return PyMemoryView_Type$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyMemoryView_Type
     * }
     */
    public static MemorySegment PyMemoryView_Type() {
        return PyMemoryView_Type$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern PyTypeObject PyMemoryView_Type
     * }
     */
    public static void PyMemoryView_Type(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, PyMemoryView_Type$constants.SEGMENT, 0L, PyMemoryView_Type$constants.LAYOUT.byteSize());
    }
}

