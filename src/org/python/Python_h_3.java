// Generated by jextract

package org.python;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class Python_h_3 extends Python_h_4 {

    Python_h_3() {
        // Should not be called directly
    }
    private static final int EPROCUNAVAIL = (int)76L;
    /**
     * {@snippet lang=c :
     * #define EPROCUNAVAIL 76
     * }
     */
    public static int EPROCUNAVAIL() {
        return EPROCUNAVAIL;
    }
    private static final int ENOLCK = (int)77L;
    /**
     * {@snippet lang=c :
     * #define ENOLCK 77
     * }
     */
    public static int ENOLCK() {
        return ENOLCK;
    }
    private static final int ENOSYS = (int)78L;
    /**
     * {@snippet lang=c :
     * #define ENOSYS 78
     * }
     */
    public static int ENOSYS() {
        return ENOSYS;
    }
    private static final int EFTYPE = (int)79L;
    /**
     * {@snippet lang=c :
     * #define EFTYPE 79
     * }
     */
    public static int EFTYPE() {
        return EFTYPE;
    }
    private static final int EAUTH = (int)80L;
    /**
     * {@snippet lang=c :
     * #define EAUTH 80
     * }
     */
    public static int EAUTH() {
        return EAUTH;
    }
    private static final int ENEEDAUTH = (int)81L;
    /**
     * {@snippet lang=c :
     * #define ENEEDAUTH 81
     * }
     */
    public static int ENEEDAUTH() {
        return ENEEDAUTH;
    }
    private static final int EPWROFF = (int)82L;
    /**
     * {@snippet lang=c :
     * #define EPWROFF 82
     * }
     */
    public static int EPWROFF() {
        return EPWROFF;
    }
    private static final int EDEVERR = (int)83L;
    /**
     * {@snippet lang=c :
     * #define EDEVERR 83
     * }
     */
    public static int EDEVERR() {
        return EDEVERR;
    }
    private static final int EOVERFLOW = (int)84L;
    /**
     * {@snippet lang=c :
     * #define EOVERFLOW 84
     * }
     */
    public static int EOVERFLOW() {
        return EOVERFLOW;
    }
    private static final int EBADEXEC = (int)85L;
    /**
     * {@snippet lang=c :
     * #define EBADEXEC 85
     * }
     */
    public static int EBADEXEC() {
        return EBADEXEC;
    }
    private static final int EBADARCH = (int)86L;
    /**
     * {@snippet lang=c :
     * #define EBADARCH 86
     * }
     */
    public static int EBADARCH() {
        return EBADARCH;
    }
    private static final int ESHLIBVERS = (int)87L;
    /**
     * {@snippet lang=c :
     * #define ESHLIBVERS 87
     * }
     */
    public static int ESHLIBVERS() {
        return ESHLIBVERS;
    }
    private static final int EBADMACHO = (int)88L;
    /**
     * {@snippet lang=c :
     * #define EBADMACHO 88
     * }
     */
    public static int EBADMACHO() {
        return EBADMACHO;
    }
    private static final int ECANCELED = (int)89L;
    /**
     * {@snippet lang=c :
     * #define ECANCELED 89
     * }
     */
    public static int ECANCELED() {
        return ECANCELED;
    }
    private static final int EIDRM = (int)90L;
    /**
     * {@snippet lang=c :
     * #define EIDRM 90
     * }
     */
    public static int EIDRM() {
        return EIDRM;
    }
    private static final int ENOMSG = (int)91L;
    /**
     * {@snippet lang=c :
     * #define ENOMSG 91
     * }
     */
    public static int ENOMSG() {
        return ENOMSG;
    }
    private static final int EILSEQ = (int)92L;
    /**
     * {@snippet lang=c :
     * #define EILSEQ 92
     * }
     */
    public static int EILSEQ() {
        return EILSEQ;
    }
    private static final int ENOATTR = (int)93L;
    /**
     * {@snippet lang=c :
     * #define ENOATTR 93
     * }
     */
    public static int ENOATTR() {
        return ENOATTR;
    }
    private static final int EBADMSG = (int)94L;
    /**
     * {@snippet lang=c :
     * #define EBADMSG 94
     * }
     */
    public static int EBADMSG() {
        return EBADMSG;
    }
    private static final int EMULTIHOP = (int)95L;
    /**
     * {@snippet lang=c :
     * #define EMULTIHOP 95
     * }
     */
    public static int EMULTIHOP() {
        return EMULTIHOP;
    }
    private static final int ENODATA = (int)96L;
    /**
     * {@snippet lang=c :
     * #define ENODATA 96
     * }
     */
    public static int ENODATA() {
        return ENODATA;
    }
    private static final int ENOLINK = (int)97L;
    /**
     * {@snippet lang=c :
     * #define ENOLINK 97
     * }
     */
    public static int ENOLINK() {
        return ENOLINK;
    }
    private static final int ENOSR = (int)98L;
    /**
     * {@snippet lang=c :
     * #define ENOSR 98
     * }
     */
    public static int ENOSR() {
        return ENOSR;
    }
    private static final int ENOSTR = (int)99L;
    /**
     * {@snippet lang=c :
     * #define ENOSTR 99
     * }
     */
    public static int ENOSTR() {
        return ENOSTR;
    }
    private static final int EPROTO = (int)100L;
    /**
     * {@snippet lang=c :
     * #define EPROTO 100
     * }
     */
    public static int EPROTO() {
        return EPROTO;
    }
    private static final int ETIME = (int)101L;
    /**
     * {@snippet lang=c :
     * #define ETIME 101
     * }
     */
    public static int ETIME() {
        return ETIME;
    }
    private static final int EOPNOTSUPP = (int)102L;
    /**
     * {@snippet lang=c :
     * #define EOPNOTSUPP 102
     * }
     */
    public static int EOPNOTSUPP() {
        return EOPNOTSUPP;
    }
    private static final int ENOPOLICY = (int)103L;
    /**
     * {@snippet lang=c :
     * #define ENOPOLICY 103
     * }
     */
    public static int ENOPOLICY() {
        return ENOPOLICY;
    }
    private static final int ENOTRECOVERABLE = (int)104L;
    /**
     * {@snippet lang=c :
     * #define ENOTRECOVERABLE 104
     * }
     */
    public static int ENOTRECOVERABLE() {
        return ENOTRECOVERABLE;
    }
    private static final int EOWNERDEAD = (int)105L;
    /**
     * {@snippet lang=c :
     * #define EOWNERDEAD 105
     * }
     */
    public static int EOWNERDEAD() {
        return EOWNERDEAD;
    }
    private static final int EQFULL = (int)106L;
    /**
     * {@snippet lang=c :
     * #define EQFULL 106
     * }
     */
    public static int EQFULL() {
        return EQFULL;
    }
    private static final int ELAST = (int)106L;
    /**
     * {@snippet lang=c :
     * #define ELAST 106
     * }
     */
    public static int ELAST() {
        return ELAST;
    }
    private static final int __HAS_FIXED_CHK_PROTOTYPES = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAS_FIXED_CHK_PROTOTYPES 1
     * }
     */
    public static int __HAS_FIXED_CHK_PROTOTYPES() {
        return __HAS_FIXED_CHK_PROTOTYPES;
    }
    private static final int _POSIX_THREAD_KEYS_MAX = (int)128L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_KEYS_MAX 128
     * }
     */
    public static int _POSIX_THREAD_KEYS_MAX() {
        return _POSIX_THREAD_KEYS_MAX;
    }
    private static final int F_OK = (int)0L;
    /**
     * {@snippet lang=c :
     * #define F_OK 0
     * }
     */
    public static int F_OK() {
        return F_OK;
    }
    private static final int ACCESSX_MAX_DESCRIPTORS = (int)100L;
    /**
     * {@snippet lang=c :
     * #define ACCESSX_MAX_DESCRIPTORS 100
     * }
     */
    public static int ACCESSX_MAX_DESCRIPTORS() {
        return ACCESSX_MAX_DESCRIPTORS;
    }
    private static final int _PC_LINK_MAX = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _PC_LINK_MAX 1
     * }
     */
    public static int _PC_LINK_MAX() {
        return _PC_LINK_MAX;
    }
    private static final int _PC_MAX_CANON = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _PC_MAX_CANON 2
     * }
     */
    public static int _PC_MAX_CANON() {
        return _PC_MAX_CANON;
    }
    private static final int _PC_MAX_INPUT = (int)3L;
    /**
     * {@snippet lang=c :
     * #define _PC_MAX_INPUT 3
     * }
     */
    public static int _PC_MAX_INPUT() {
        return _PC_MAX_INPUT;
    }
    private static final int _PC_NAME_MAX = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _PC_NAME_MAX 4
     * }
     */
    public static int _PC_NAME_MAX() {
        return _PC_NAME_MAX;
    }
    private static final int _PC_PATH_MAX = (int)5L;
    /**
     * {@snippet lang=c :
     * #define _PC_PATH_MAX 5
     * }
     */
    public static int _PC_PATH_MAX() {
        return _PC_PATH_MAX;
    }
    private static final int _PC_PIPE_BUF = (int)6L;
    /**
     * {@snippet lang=c :
     * #define _PC_PIPE_BUF 6
     * }
     */
    public static int _PC_PIPE_BUF() {
        return _PC_PIPE_BUF;
    }
    private static final int _PC_CHOWN_RESTRICTED = (int)7L;
    /**
     * {@snippet lang=c :
     * #define _PC_CHOWN_RESTRICTED 7
     * }
     */
    public static int _PC_CHOWN_RESTRICTED() {
        return _PC_CHOWN_RESTRICTED;
    }
    private static final int _PC_NO_TRUNC = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _PC_NO_TRUNC 8
     * }
     */
    public static int _PC_NO_TRUNC() {
        return _PC_NO_TRUNC;
    }
    private static final int _PC_VDISABLE = (int)9L;
    /**
     * {@snippet lang=c :
     * #define _PC_VDISABLE 9
     * }
     */
    public static int _PC_VDISABLE() {
        return _PC_VDISABLE;
    }
    private static final int _PC_NAME_CHARS_MAX = (int)10L;
    /**
     * {@snippet lang=c :
     * #define _PC_NAME_CHARS_MAX 10
     * }
     */
    public static int _PC_NAME_CHARS_MAX() {
        return _PC_NAME_CHARS_MAX;
    }
    private static final int _PC_CASE_SENSITIVE = (int)11L;
    /**
     * {@snippet lang=c :
     * #define _PC_CASE_SENSITIVE 11
     * }
     */
    public static int _PC_CASE_SENSITIVE() {
        return _PC_CASE_SENSITIVE;
    }
    private static final int _PC_CASE_PRESERVING = (int)12L;
    /**
     * {@snippet lang=c :
     * #define _PC_CASE_PRESERVING 12
     * }
     */
    public static int _PC_CASE_PRESERVING() {
        return _PC_CASE_PRESERVING;
    }
    private static final int _PC_EXTENDED_SECURITY_NP = (int)13L;
    /**
     * {@snippet lang=c :
     * #define _PC_EXTENDED_SECURITY_NP 13
     * }
     */
    public static int _PC_EXTENDED_SECURITY_NP() {
        return _PC_EXTENDED_SECURITY_NP;
    }
    private static final int _PC_AUTH_OPAQUE_NP = (int)14L;
    /**
     * {@snippet lang=c :
     * #define _PC_AUTH_OPAQUE_NP 14
     * }
     */
    public static int _PC_AUTH_OPAQUE_NP() {
        return _PC_AUTH_OPAQUE_NP;
    }
    private static final int _PC_2_SYMLINKS = (int)15L;
    /**
     * {@snippet lang=c :
     * #define _PC_2_SYMLINKS 15
     * }
     */
    public static int _PC_2_SYMLINKS() {
        return _PC_2_SYMLINKS;
    }
    private static final int _PC_ALLOC_SIZE_MIN = (int)16L;
    /**
     * {@snippet lang=c :
     * #define _PC_ALLOC_SIZE_MIN 16
     * }
     */
    public static int _PC_ALLOC_SIZE_MIN() {
        return _PC_ALLOC_SIZE_MIN;
    }
    private static final int _PC_ASYNC_IO = (int)17L;
    /**
     * {@snippet lang=c :
     * #define _PC_ASYNC_IO 17
     * }
     */
    public static int _PC_ASYNC_IO() {
        return _PC_ASYNC_IO;
    }
    private static final int _PC_FILESIZEBITS = (int)18L;
    /**
     * {@snippet lang=c :
     * #define _PC_FILESIZEBITS 18
     * }
     */
    public static int _PC_FILESIZEBITS() {
        return _PC_FILESIZEBITS;
    }
    private static final int _PC_PRIO_IO = (int)19L;
    /**
     * {@snippet lang=c :
     * #define _PC_PRIO_IO 19
     * }
     */
    public static int _PC_PRIO_IO() {
        return _PC_PRIO_IO;
    }
    private static final int _PC_REC_INCR_XFER_SIZE = (int)20L;
    /**
     * {@snippet lang=c :
     * #define _PC_REC_INCR_XFER_SIZE 20
     * }
     */
    public static int _PC_REC_INCR_XFER_SIZE() {
        return _PC_REC_INCR_XFER_SIZE;
    }
    private static final int _PC_REC_MAX_XFER_SIZE = (int)21L;
    /**
     * {@snippet lang=c :
     * #define _PC_REC_MAX_XFER_SIZE 21
     * }
     */
    public static int _PC_REC_MAX_XFER_SIZE() {
        return _PC_REC_MAX_XFER_SIZE;
    }
    private static final int _PC_REC_MIN_XFER_SIZE = (int)22L;
    /**
     * {@snippet lang=c :
     * #define _PC_REC_MIN_XFER_SIZE 22
     * }
     */
    public static int _PC_REC_MIN_XFER_SIZE() {
        return _PC_REC_MIN_XFER_SIZE;
    }
    private static final int _PC_REC_XFER_ALIGN = (int)23L;
    /**
     * {@snippet lang=c :
     * #define _PC_REC_XFER_ALIGN 23
     * }
     */
    public static int _PC_REC_XFER_ALIGN() {
        return _PC_REC_XFER_ALIGN;
    }
    private static final int _PC_SYMLINK_MAX = (int)24L;
    /**
     * {@snippet lang=c :
     * #define _PC_SYMLINK_MAX 24
     * }
     */
    public static int _PC_SYMLINK_MAX() {
        return _PC_SYMLINK_MAX;
    }
    private static final int _PC_SYNC_IO = (int)25L;
    /**
     * {@snippet lang=c :
     * #define _PC_SYNC_IO 25
     * }
     */
    public static int _PC_SYNC_IO() {
        return _PC_SYNC_IO;
    }
    private static final int _PC_XATTR_SIZE_BITS = (int)26L;
    /**
     * {@snippet lang=c :
     * #define _PC_XATTR_SIZE_BITS 26
     * }
     */
    public static int _PC_XATTR_SIZE_BITS() {
        return _PC_XATTR_SIZE_BITS;
    }
    private static final int _PC_MIN_HOLE_SIZE = (int)27L;
    /**
     * {@snippet lang=c :
     * #define _PC_MIN_HOLE_SIZE 27
     * }
     */
    public static int _PC_MIN_HOLE_SIZE() {
        return _PC_MIN_HOLE_SIZE;
    }
    private static final int _CS_PATH = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _CS_PATH 1
     * }
     */
    public static int _CS_PATH() {
        return _CS_PATH;
    }
    private static final int STDIN_FILENO = (int)0L;
    /**
     * {@snippet lang=c :
     * #define STDIN_FILENO 0
     * }
     */
    public static int STDIN_FILENO() {
        return STDIN_FILENO;
    }
    private static final int STDOUT_FILENO = (int)1L;
    /**
     * {@snippet lang=c :
     * #define STDOUT_FILENO 1
     * }
     */
    public static int STDOUT_FILENO() {
        return STDOUT_FILENO;
    }
    private static final int STDERR_FILENO = (int)2L;
    /**
     * {@snippet lang=c :
     * #define STDERR_FILENO 2
     * }
     */
    public static int STDERR_FILENO() {
        return STDERR_FILENO;
    }
    private static final int _XOPEN_VERSION = (int)600L;
    /**
     * {@snippet lang=c :
     * #define _XOPEN_VERSION 600
     * }
     */
    public static int _XOPEN_VERSION() {
        return _XOPEN_VERSION;
    }
    private static final int _XOPEN_XCU_VERSION = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _XOPEN_XCU_VERSION 4
     * }
     */
    public static int _XOPEN_XCU_VERSION() {
        return _XOPEN_XCU_VERSION;
    }
    private static final int _SC_ARG_MAX = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SC_ARG_MAX 1
     * }
     */
    public static int _SC_ARG_MAX() {
        return _SC_ARG_MAX;
    }
    private static final int _SC_CHILD_MAX = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _SC_CHILD_MAX 2
     * }
     */
    public static int _SC_CHILD_MAX() {
        return _SC_CHILD_MAX;
    }
    private static final int _SC_CLK_TCK = (int)3L;
    /**
     * {@snippet lang=c :
     * #define _SC_CLK_TCK 3
     * }
     */
    public static int _SC_CLK_TCK() {
        return _SC_CLK_TCK;
    }
    private static final int _SC_NGROUPS_MAX = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _SC_NGROUPS_MAX 4
     * }
     */
    public static int _SC_NGROUPS_MAX() {
        return _SC_NGROUPS_MAX;
    }
    private static final int _SC_OPEN_MAX = (int)5L;
    /**
     * {@snippet lang=c :
     * #define _SC_OPEN_MAX 5
     * }
     */
    public static int _SC_OPEN_MAX() {
        return _SC_OPEN_MAX;
    }
    private static final int _SC_JOB_CONTROL = (int)6L;
    /**
     * {@snippet lang=c :
     * #define _SC_JOB_CONTROL 6
     * }
     */
    public static int _SC_JOB_CONTROL() {
        return _SC_JOB_CONTROL;
    }
    private static final int _SC_SAVED_IDS = (int)7L;
    /**
     * {@snippet lang=c :
     * #define _SC_SAVED_IDS 7
     * }
     */
    public static int _SC_SAVED_IDS() {
        return _SC_SAVED_IDS;
    }
    private static final int _SC_VERSION = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _SC_VERSION 8
     * }
     */
    public static int _SC_VERSION() {
        return _SC_VERSION;
    }
    private static final int _SC_BC_BASE_MAX = (int)9L;
    /**
     * {@snippet lang=c :
     * #define _SC_BC_BASE_MAX 9
     * }
     */
    public static int _SC_BC_BASE_MAX() {
        return _SC_BC_BASE_MAX;
    }
    private static final int _SC_BC_DIM_MAX = (int)10L;
    /**
     * {@snippet lang=c :
     * #define _SC_BC_DIM_MAX 10
     * }
     */
    public static int _SC_BC_DIM_MAX() {
        return _SC_BC_DIM_MAX;
    }
    private static final int _SC_BC_SCALE_MAX = (int)11L;
    /**
     * {@snippet lang=c :
     * #define _SC_BC_SCALE_MAX 11
     * }
     */
    public static int _SC_BC_SCALE_MAX() {
        return _SC_BC_SCALE_MAX;
    }
    private static final int _SC_BC_STRING_MAX = (int)12L;
    /**
     * {@snippet lang=c :
     * #define _SC_BC_STRING_MAX 12
     * }
     */
    public static int _SC_BC_STRING_MAX() {
        return _SC_BC_STRING_MAX;
    }
    private static final int _SC_COLL_WEIGHTS_MAX = (int)13L;
    /**
     * {@snippet lang=c :
     * #define _SC_COLL_WEIGHTS_MAX 13
     * }
     */
    public static int _SC_COLL_WEIGHTS_MAX() {
        return _SC_COLL_WEIGHTS_MAX;
    }
    private static final int _SC_EXPR_NEST_MAX = (int)14L;
    /**
     * {@snippet lang=c :
     * #define _SC_EXPR_NEST_MAX 14
     * }
     */
    public static int _SC_EXPR_NEST_MAX() {
        return _SC_EXPR_NEST_MAX;
    }
    private static final int _SC_LINE_MAX = (int)15L;
    /**
     * {@snippet lang=c :
     * #define _SC_LINE_MAX 15
     * }
     */
    public static int _SC_LINE_MAX() {
        return _SC_LINE_MAX;
    }
    private static final int _SC_RE_DUP_MAX = (int)16L;
    /**
     * {@snippet lang=c :
     * #define _SC_RE_DUP_MAX 16
     * }
     */
    public static int _SC_RE_DUP_MAX() {
        return _SC_RE_DUP_MAX;
    }
    private static final int _SC_2_VERSION = (int)17L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_VERSION 17
     * }
     */
    public static int _SC_2_VERSION() {
        return _SC_2_VERSION;
    }
    private static final int _SC_2_C_BIND = (int)18L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_C_BIND 18
     * }
     */
    public static int _SC_2_C_BIND() {
        return _SC_2_C_BIND;
    }
    private static final int _SC_2_C_DEV = (int)19L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_C_DEV 19
     * }
     */
    public static int _SC_2_C_DEV() {
        return _SC_2_C_DEV;
    }
    private static final int _SC_2_CHAR_TERM = (int)20L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_CHAR_TERM 20
     * }
     */
    public static int _SC_2_CHAR_TERM() {
        return _SC_2_CHAR_TERM;
    }
    private static final int _SC_2_FORT_DEV = (int)21L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_FORT_DEV 21
     * }
     */
    public static int _SC_2_FORT_DEV() {
        return _SC_2_FORT_DEV;
    }
    private static final int _SC_2_FORT_RUN = (int)22L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_FORT_RUN 22
     * }
     */
    public static int _SC_2_FORT_RUN() {
        return _SC_2_FORT_RUN;
    }
    private static final int _SC_2_LOCALEDEF = (int)23L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_LOCALEDEF 23
     * }
     */
    public static int _SC_2_LOCALEDEF() {
        return _SC_2_LOCALEDEF;
    }
    private static final int _SC_2_SW_DEV = (int)24L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_SW_DEV 24
     * }
     */
    public static int _SC_2_SW_DEV() {
        return _SC_2_SW_DEV;
    }
    private static final int _SC_2_UPE = (int)25L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_UPE 25
     * }
     */
    public static int _SC_2_UPE() {
        return _SC_2_UPE;
    }
    private static final int _SC_STREAM_MAX = (int)26L;
    /**
     * {@snippet lang=c :
     * #define _SC_STREAM_MAX 26
     * }
     */
    public static int _SC_STREAM_MAX() {
        return _SC_STREAM_MAX;
    }
    private static final int _SC_TZNAME_MAX = (int)27L;
    /**
     * {@snippet lang=c :
     * #define _SC_TZNAME_MAX 27
     * }
     */
    public static int _SC_TZNAME_MAX() {
        return _SC_TZNAME_MAX;
    }
    private static final int _SC_ASYNCHRONOUS_IO = (int)28L;
    /**
     * {@snippet lang=c :
     * #define _SC_ASYNCHRONOUS_IO 28
     * }
     */
    public static int _SC_ASYNCHRONOUS_IO() {
        return _SC_ASYNCHRONOUS_IO;
    }
    private static final int _SC_PAGESIZE = (int)29L;
    /**
     * {@snippet lang=c :
     * #define _SC_PAGESIZE 29
     * }
     */
    public static int _SC_PAGESIZE() {
        return _SC_PAGESIZE;
    }
    private static final int _SC_MEMLOCK = (int)30L;
    /**
     * {@snippet lang=c :
     * #define _SC_MEMLOCK 30
     * }
     */
    public static int _SC_MEMLOCK() {
        return _SC_MEMLOCK;
    }
    private static final int _SC_MEMLOCK_RANGE = (int)31L;
    /**
     * {@snippet lang=c :
     * #define _SC_MEMLOCK_RANGE 31
     * }
     */
    public static int _SC_MEMLOCK_RANGE() {
        return _SC_MEMLOCK_RANGE;
    }
    private static final int _SC_MEMORY_PROTECTION = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _SC_MEMORY_PROTECTION 32
     * }
     */
    public static int _SC_MEMORY_PROTECTION() {
        return _SC_MEMORY_PROTECTION;
    }
    private static final int _SC_MESSAGE_PASSING = (int)33L;
    /**
     * {@snippet lang=c :
     * #define _SC_MESSAGE_PASSING 33
     * }
     */
    public static int _SC_MESSAGE_PASSING() {
        return _SC_MESSAGE_PASSING;
    }
    private static final int _SC_PRIORITIZED_IO = (int)34L;
    /**
     * {@snippet lang=c :
     * #define _SC_PRIORITIZED_IO 34
     * }
     */
    public static int _SC_PRIORITIZED_IO() {
        return _SC_PRIORITIZED_IO;
    }
    private static final int _SC_PRIORITY_SCHEDULING = (int)35L;
    /**
     * {@snippet lang=c :
     * #define _SC_PRIORITY_SCHEDULING 35
     * }
     */
    public static int _SC_PRIORITY_SCHEDULING() {
        return _SC_PRIORITY_SCHEDULING;
    }
    private static final int _SC_REALTIME_SIGNALS = (int)36L;
    /**
     * {@snippet lang=c :
     * #define _SC_REALTIME_SIGNALS 36
     * }
     */
    public static int _SC_REALTIME_SIGNALS() {
        return _SC_REALTIME_SIGNALS;
    }
    private static final int _SC_SEMAPHORES = (int)37L;
    /**
     * {@snippet lang=c :
     * #define _SC_SEMAPHORES 37
     * }
     */
    public static int _SC_SEMAPHORES() {
        return _SC_SEMAPHORES;
    }
    private static final int _SC_FSYNC = (int)38L;
    /**
     * {@snippet lang=c :
     * #define _SC_FSYNC 38
     * }
     */
    public static int _SC_FSYNC() {
        return _SC_FSYNC;
    }
    private static final int _SC_SHARED_MEMORY_OBJECTS = (int)39L;
    /**
     * {@snippet lang=c :
     * #define _SC_SHARED_MEMORY_OBJECTS 39
     * }
     */
    public static int _SC_SHARED_MEMORY_OBJECTS() {
        return _SC_SHARED_MEMORY_OBJECTS;
    }
    private static final int _SC_SYNCHRONIZED_IO = (int)40L;
    /**
     * {@snippet lang=c :
     * #define _SC_SYNCHRONIZED_IO 40
     * }
     */
    public static int _SC_SYNCHRONIZED_IO() {
        return _SC_SYNCHRONIZED_IO;
    }
    private static final int _SC_TIMERS = (int)41L;
    /**
     * {@snippet lang=c :
     * #define _SC_TIMERS 41
     * }
     */
    public static int _SC_TIMERS() {
        return _SC_TIMERS;
    }
    private static final int _SC_AIO_LISTIO_MAX = (int)42L;
    /**
     * {@snippet lang=c :
     * #define _SC_AIO_LISTIO_MAX 42
     * }
     */
    public static int _SC_AIO_LISTIO_MAX() {
        return _SC_AIO_LISTIO_MAX;
    }
    private static final int _SC_AIO_MAX = (int)43L;
    /**
     * {@snippet lang=c :
     * #define _SC_AIO_MAX 43
     * }
     */
    public static int _SC_AIO_MAX() {
        return _SC_AIO_MAX;
    }
    private static final int _SC_AIO_PRIO_DELTA_MAX = (int)44L;
    /**
     * {@snippet lang=c :
     * #define _SC_AIO_PRIO_DELTA_MAX 44
     * }
     */
    public static int _SC_AIO_PRIO_DELTA_MAX() {
        return _SC_AIO_PRIO_DELTA_MAX;
    }
    private static final int _SC_DELAYTIMER_MAX = (int)45L;
    /**
     * {@snippet lang=c :
     * #define _SC_DELAYTIMER_MAX 45
     * }
     */
    public static int _SC_DELAYTIMER_MAX() {
        return _SC_DELAYTIMER_MAX;
    }
    private static final int _SC_MQ_OPEN_MAX = (int)46L;
    /**
     * {@snippet lang=c :
     * #define _SC_MQ_OPEN_MAX 46
     * }
     */
    public static int _SC_MQ_OPEN_MAX() {
        return _SC_MQ_OPEN_MAX;
    }
    private static final int _SC_MAPPED_FILES = (int)47L;
    /**
     * {@snippet lang=c :
     * #define _SC_MAPPED_FILES 47
     * }
     */
    public static int _SC_MAPPED_FILES() {
        return _SC_MAPPED_FILES;
    }
    private static final int _SC_RTSIG_MAX = (int)48L;
    /**
     * {@snippet lang=c :
     * #define _SC_RTSIG_MAX 48
     * }
     */
    public static int _SC_RTSIG_MAX() {
        return _SC_RTSIG_MAX;
    }
    private static final int _SC_SEM_NSEMS_MAX = (int)49L;
    /**
     * {@snippet lang=c :
     * #define _SC_SEM_NSEMS_MAX 49
     * }
     */
    public static int _SC_SEM_NSEMS_MAX() {
        return _SC_SEM_NSEMS_MAX;
    }
    private static final int _SC_SEM_VALUE_MAX = (int)50L;
    /**
     * {@snippet lang=c :
     * #define _SC_SEM_VALUE_MAX 50
     * }
     */
    public static int _SC_SEM_VALUE_MAX() {
        return _SC_SEM_VALUE_MAX;
    }
    private static final int _SC_SIGQUEUE_MAX = (int)51L;
    /**
     * {@snippet lang=c :
     * #define _SC_SIGQUEUE_MAX 51
     * }
     */
    public static int _SC_SIGQUEUE_MAX() {
        return _SC_SIGQUEUE_MAX;
    }
    private static final int _SC_TIMER_MAX = (int)52L;
    /**
     * {@snippet lang=c :
     * #define _SC_TIMER_MAX 52
     * }
     */
    public static int _SC_TIMER_MAX() {
        return _SC_TIMER_MAX;
    }
    private static final int _SC_NPROCESSORS_CONF = (int)57L;
    /**
     * {@snippet lang=c :
     * #define _SC_NPROCESSORS_CONF 57
     * }
     */
    public static int _SC_NPROCESSORS_CONF() {
        return _SC_NPROCESSORS_CONF;
    }
    private static final int _SC_NPROCESSORS_ONLN = (int)58L;
    /**
     * {@snippet lang=c :
     * #define _SC_NPROCESSORS_ONLN 58
     * }
     */
    public static int _SC_NPROCESSORS_ONLN() {
        return _SC_NPROCESSORS_ONLN;
    }
    private static final int _SC_2_PBS = (int)59L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_PBS 59
     * }
     */
    public static int _SC_2_PBS() {
        return _SC_2_PBS;
    }
    private static final int _SC_2_PBS_ACCOUNTING = (int)60L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_PBS_ACCOUNTING 60
     * }
     */
    public static int _SC_2_PBS_ACCOUNTING() {
        return _SC_2_PBS_ACCOUNTING;
    }
    private static final int _SC_2_PBS_CHECKPOINT = (int)61L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_PBS_CHECKPOINT 61
     * }
     */
    public static int _SC_2_PBS_CHECKPOINT() {
        return _SC_2_PBS_CHECKPOINT;
    }
    private static final int _SC_2_PBS_LOCATE = (int)62L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_PBS_LOCATE 62
     * }
     */
    public static int _SC_2_PBS_LOCATE() {
        return _SC_2_PBS_LOCATE;
    }
    private static final int _SC_2_PBS_MESSAGE = (int)63L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_PBS_MESSAGE 63
     * }
     */
    public static int _SC_2_PBS_MESSAGE() {
        return _SC_2_PBS_MESSAGE;
    }
    private static final int _SC_2_PBS_TRACK = (int)64L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_PBS_TRACK 64
     * }
     */
    public static int _SC_2_PBS_TRACK() {
        return _SC_2_PBS_TRACK;
    }
    private static final int _SC_ADVISORY_INFO = (int)65L;
    /**
     * {@snippet lang=c :
     * #define _SC_ADVISORY_INFO 65
     * }
     */
    public static int _SC_ADVISORY_INFO() {
        return _SC_ADVISORY_INFO;
    }
    private static final int _SC_BARRIERS = (int)66L;
    /**
     * {@snippet lang=c :
     * #define _SC_BARRIERS 66
     * }
     */
    public static int _SC_BARRIERS() {
        return _SC_BARRIERS;
    }
    private static final int _SC_CLOCK_SELECTION = (int)67L;
    /**
     * {@snippet lang=c :
     * #define _SC_CLOCK_SELECTION 67
     * }
     */
    public static int _SC_CLOCK_SELECTION() {
        return _SC_CLOCK_SELECTION;
    }
    private static final int _SC_CPUTIME = (int)68L;
    /**
     * {@snippet lang=c :
     * #define _SC_CPUTIME 68
     * }
     */
    public static int _SC_CPUTIME() {
        return _SC_CPUTIME;
    }
    private static final int _SC_FILE_LOCKING = (int)69L;
    /**
     * {@snippet lang=c :
     * #define _SC_FILE_LOCKING 69
     * }
     */
    public static int _SC_FILE_LOCKING() {
        return _SC_FILE_LOCKING;
    }
    private static final int _SC_GETGR_R_SIZE_MAX = (int)70L;
    /**
     * {@snippet lang=c :
     * #define _SC_GETGR_R_SIZE_MAX 70
     * }
     */
    public static int _SC_GETGR_R_SIZE_MAX() {
        return _SC_GETGR_R_SIZE_MAX;
    }
    private static final int _SC_GETPW_R_SIZE_MAX = (int)71L;
    /**
     * {@snippet lang=c :
     * #define _SC_GETPW_R_SIZE_MAX 71
     * }
     */
    public static int _SC_GETPW_R_SIZE_MAX() {
        return _SC_GETPW_R_SIZE_MAX;
    }
    private static final int _SC_HOST_NAME_MAX = (int)72L;
    /**
     * {@snippet lang=c :
     * #define _SC_HOST_NAME_MAX 72
     * }
     */
    public static int _SC_HOST_NAME_MAX() {
        return _SC_HOST_NAME_MAX;
    }
    private static final int _SC_LOGIN_NAME_MAX = (int)73L;
    /**
     * {@snippet lang=c :
     * #define _SC_LOGIN_NAME_MAX 73
     * }
     */
    public static int _SC_LOGIN_NAME_MAX() {
        return _SC_LOGIN_NAME_MAX;
    }
    private static final int _SC_MONOTONIC_CLOCK = (int)74L;
    /**
     * {@snippet lang=c :
     * #define _SC_MONOTONIC_CLOCK 74
     * }
     */
    public static int _SC_MONOTONIC_CLOCK() {
        return _SC_MONOTONIC_CLOCK;
    }
    private static final int _SC_MQ_PRIO_MAX = (int)75L;
    /**
     * {@snippet lang=c :
     * #define _SC_MQ_PRIO_MAX 75
     * }
     */
    public static int _SC_MQ_PRIO_MAX() {
        return _SC_MQ_PRIO_MAX;
    }
    private static final int _SC_READER_WRITER_LOCKS = (int)76L;
    /**
     * {@snippet lang=c :
     * #define _SC_READER_WRITER_LOCKS 76
     * }
     */
    public static int _SC_READER_WRITER_LOCKS() {
        return _SC_READER_WRITER_LOCKS;
    }
    private static final int _SC_REGEXP = (int)77L;
    /**
     * {@snippet lang=c :
     * #define _SC_REGEXP 77
     * }
     */
    public static int _SC_REGEXP() {
        return _SC_REGEXP;
    }
    private static final int _SC_SHELL = (int)78L;
    /**
     * {@snippet lang=c :
     * #define _SC_SHELL 78
     * }
     */
    public static int _SC_SHELL() {
        return _SC_SHELL;
    }
    private static final int _SC_SPAWN = (int)79L;
    /**
     * {@snippet lang=c :
     * #define _SC_SPAWN 79
     * }
     */
    public static int _SC_SPAWN() {
        return _SC_SPAWN;
    }
    private static final int _SC_SPIN_LOCKS = (int)80L;
    /**
     * {@snippet lang=c :
     * #define _SC_SPIN_LOCKS 80
     * }
     */
    public static int _SC_SPIN_LOCKS() {
        return _SC_SPIN_LOCKS;
    }
    private static final int _SC_SPORADIC_SERVER = (int)81L;
    /**
     * {@snippet lang=c :
     * #define _SC_SPORADIC_SERVER 81
     * }
     */
    public static int _SC_SPORADIC_SERVER() {
        return _SC_SPORADIC_SERVER;
    }
    private static final int _SC_THREAD_ATTR_STACKADDR = (int)82L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_ATTR_STACKADDR 82
     * }
     */
    public static int _SC_THREAD_ATTR_STACKADDR() {
        return _SC_THREAD_ATTR_STACKADDR;
    }
    private static final int _SC_THREAD_ATTR_STACKSIZE = (int)83L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_ATTR_STACKSIZE 83
     * }
     */
    public static int _SC_THREAD_ATTR_STACKSIZE() {
        return _SC_THREAD_ATTR_STACKSIZE;
    }
    private static final int _SC_THREAD_CPUTIME = (int)84L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_CPUTIME 84
     * }
     */
    public static int _SC_THREAD_CPUTIME() {
        return _SC_THREAD_CPUTIME;
    }
    private static final int _SC_THREAD_DESTRUCTOR_ITERATIONS = (int)85L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_DESTRUCTOR_ITERATIONS 85
     * }
     */
    public static int _SC_THREAD_DESTRUCTOR_ITERATIONS() {
        return _SC_THREAD_DESTRUCTOR_ITERATIONS;
    }
    private static final int _SC_THREAD_KEYS_MAX = (int)86L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_KEYS_MAX 86
     * }
     */
    public static int _SC_THREAD_KEYS_MAX() {
        return _SC_THREAD_KEYS_MAX;
    }
    private static final int _SC_THREAD_PRIO_INHERIT = (int)87L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_PRIO_INHERIT 87
     * }
     */
    public static int _SC_THREAD_PRIO_INHERIT() {
        return _SC_THREAD_PRIO_INHERIT;
    }
    private static final int _SC_THREAD_PRIO_PROTECT = (int)88L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_PRIO_PROTECT 88
     * }
     */
    public static int _SC_THREAD_PRIO_PROTECT() {
        return _SC_THREAD_PRIO_PROTECT;
    }
    private static final int _SC_THREAD_PRIORITY_SCHEDULING = (int)89L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_PRIORITY_SCHEDULING 89
     * }
     */
    public static int _SC_THREAD_PRIORITY_SCHEDULING() {
        return _SC_THREAD_PRIORITY_SCHEDULING;
    }
    private static final int _SC_THREAD_PROCESS_SHARED = (int)90L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_PROCESS_SHARED 90
     * }
     */
    public static int _SC_THREAD_PROCESS_SHARED() {
        return _SC_THREAD_PROCESS_SHARED;
    }
    private static final int _SC_THREAD_SAFE_FUNCTIONS = (int)91L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_SAFE_FUNCTIONS 91
     * }
     */
    public static int _SC_THREAD_SAFE_FUNCTIONS() {
        return _SC_THREAD_SAFE_FUNCTIONS;
    }
    private static final int _SC_THREAD_SPORADIC_SERVER = (int)92L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_SPORADIC_SERVER 92
     * }
     */
    public static int _SC_THREAD_SPORADIC_SERVER() {
        return _SC_THREAD_SPORADIC_SERVER;
    }
    private static final int _SC_THREAD_STACK_MIN = (int)93L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_STACK_MIN 93
     * }
     */
    public static int _SC_THREAD_STACK_MIN() {
        return _SC_THREAD_STACK_MIN;
    }
    private static final int _SC_THREAD_THREADS_MAX = (int)94L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_THREADS_MAX 94
     * }
     */
    public static int _SC_THREAD_THREADS_MAX() {
        return _SC_THREAD_THREADS_MAX;
    }
    private static final int _SC_TIMEOUTS = (int)95L;
    /**
     * {@snippet lang=c :
     * #define _SC_TIMEOUTS 95
     * }
     */
    public static int _SC_TIMEOUTS() {
        return _SC_TIMEOUTS;
    }
    private static final int _SC_THREADS = (int)96L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREADS 96
     * }
     */
    public static int _SC_THREADS() {
        return _SC_THREADS;
    }
    private static final int _SC_TRACE = (int)97L;
    /**
     * {@snippet lang=c :
     * #define _SC_TRACE 97
     * }
     */
    public static int _SC_TRACE() {
        return _SC_TRACE;
    }
    private static final int _SC_TRACE_EVENT_FILTER = (int)98L;
    /**
     * {@snippet lang=c :
     * #define _SC_TRACE_EVENT_FILTER 98
     * }
     */
    public static int _SC_TRACE_EVENT_FILTER() {
        return _SC_TRACE_EVENT_FILTER;
    }
    private static final int _SC_TRACE_INHERIT = (int)99L;
    /**
     * {@snippet lang=c :
     * #define _SC_TRACE_INHERIT 99
     * }
     */
    public static int _SC_TRACE_INHERIT() {
        return _SC_TRACE_INHERIT;
    }
    private static final int _SC_TRACE_LOG = (int)100L;
    /**
     * {@snippet lang=c :
     * #define _SC_TRACE_LOG 100
     * }
     */
    public static int _SC_TRACE_LOG() {
        return _SC_TRACE_LOG;
    }
    private static final int _SC_TTY_NAME_MAX = (int)101L;
    /**
     * {@snippet lang=c :
     * #define _SC_TTY_NAME_MAX 101
     * }
     */
    public static int _SC_TTY_NAME_MAX() {
        return _SC_TTY_NAME_MAX;
    }
    private static final int _SC_TYPED_MEMORY_OBJECTS = (int)102L;
    /**
     * {@snippet lang=c :
     * #define _SC_TYPED_MEMORY_OBJECTS 102
     * }
     */
    public static int _SC_TYPED_MEMORY_OBJECTS() {
        return _SC_TYPED_MEMORY_OBJECTS;
    }
    private static final int _SC_V6_ILP32_OFF32 = (int)103L;
    /**
     * {@snippet lang=c :
     * #define _SC_V6_ILP32_OFF32 103
     * }
     */
    public static int _SC_V6_ILP32_OFF32() {
        return _SC_V6_ILP32_OFF32;
    }
    private static final int _SC_V6_ILP32_OFFBIG = (int)104L;
    /**
     * {@snippet lang=c :
     * #define _SC_V6_ILP32_OFFBIG 104
     * }
     */
    public static int _SC_V6_ILP32_OFFBIG() {
        return _SC_V6_ILP32_OFFBIG;
    }
    private static final int _SC_V6_LP64_OFF64 = (int)105L;
    /**
     * {@snippet lang=c :
     * #define _SC_V6_LP64_OFF64 105
     * }
     */
    public static int _SC_V6_LP64_OFF64() {
        return _SC_V6_LP64_OFF64;
    }
    private static final int _SC_V6_LPBIG_OFFBIG = (int)106L;
    /**
     * {@snippet lang=c :
     * #define _SC_V6_LPBIG_OFFBIG 106
     * }
     */
    public static int _SC_V6_LPBIG_OFFBIG() {
        return _SC_V6_LPBIG_OFFBIG;
    }
    private static final int _SC_IPV6 = (int)118L;
    /**
     * {@snippet lang=c :
     * #define _SC_IPV6 118
     * }
     */
    public static int _SC_IPV6() {
        return _SC_IPV6;
    }
    private static final int _SC_RAW_SOCKETS = (int)119L;
    /**
     * {@snippet lang=c :
     * #define _SC_RAW_SOCKETS 119
     * }
     */
    public static int _SC_RAW_SOCKETS() {
        return _SC_RAW_SOCKETS;
    }
    private static final int _SC_SYMLOOP_MAX = (int)120L;
    /**
     * {@snippet lang=c :
     * #define _SC_SYMLOOP_MAX 120
     * }
     */
    public static int _SC_SYMLOOP_MAX() {
        return _SC_SYMLOOP_MAX;
    }
    private static final int _SC_ATEXIT_MAX = (int)107L;
    /**
     * {@snippet lang=c :
     * #define _SC_ATEXIT_MAX 107
     * }
     */
    public static int _SC_ATEXIT_MAX() {
        return _SC_ATEXIT_MAX;
    }
    private static final int _SC_IOV_MAX = (int)56L;
    /**
     * {@snippet lang=c :
     * #define _SC_IOV_MAX 56
     * }
     */
    public static int _SC_IOV_MAX() {
        return _SC_IOV_MAX;
    }
    private static final int _SC_XOPEN_CRYPT = (int)108L;
    /**
     * {@snippet lang=c :
     * #define _SC_XOPEN_CRYPT 108
     * }
     */
    public static int _SC_XOPEN_CRYPT() {
        return _SC_XOPEN_CRYPT;
    }
    private static final int _SC_XOPEN_ENH_I18N = (int)109L;
    /**
     * {@snippet lang=c :
     * #define _SC_XOPEN_ENH_I18N 109
     * }
     */
    public static int _SC_XOPEN_ENH_I18N() {
        return _SC_XOPEN_ENH_I18N;
    }
    private static final int _SC_XOPEN_LEGACY = (int)110L;
    /**
     * {@snippet lang=c :
     * #define _SC_XOPEN_LEGACY 110
     * }
     */
    public static int _SC_XOPEN_LEGACY() {
        return _SC_XOPEN_LEGACY;
    }
    private static final int _SC_XOPEN_REALTIME = (int)111L;
    /**
     * {@snippet lang=c :
     * #define _SC_XOPEN_REALTIME 111
     * }
     */
    public static int _SC_XOPEN_REALTIME() {
        return _SC_XOPEN_REALTIME;
    }
    private static final int _SC_XOPEN_REALTIME_THREADS = (int)112L;
    /**
     * {@snippet lang=c :
     * #define _SC_XOPEN_REALTIME_THREADS 112
     * }
     */
    public static int _SC_XOPEN_REALTIME_THREADS() {
        return _SC_XOPEN_REALTIME_THREADS;
    }
    private static final int _SC_XOPEN_SHM = (int)113L;
    /**
     * {@snippet lang=c :
     * #define _SC_XOPEN_SHM 113
     * }
     */
    public static int _SC_XOPEN_SHM() {
        return _SC_XOPEN_SHM;
    }
    private static final int _SC_XOPEN_STREAMS = (int)114L;
    /**
     * {@snippet lang=c :
     * #define _SC_XOPEN_STREAMS 114
     * }
     */
    public static int _SC_XOPEN_STREAMS() {
        return _SC_XOPEN_STREAMS;
    }
    private static final int _SC_XOPEN_UNIX = (int)115L;
    /**
     * {@snippet lang=c :
     * #define _SC_XOPEN_UNIX 115
     * }
     */
    public static int _SC_XOPEN_UNIX() {
        return _SC_XOPEN_UNIX;
    }
    private static final int _SC_XOPEN_VERSION = (int)116L;
    /**
     * {@snippet lang=c :
     * #define _SC_XOPEN_VERSION 116
     * }
     */
    public static int _SC_XOPEN_VERSION() {
        return _SC_XOPEN_VERSION;
    }
    private static final int _SC_XOPEN_XCU_VERSION = (int)121L;
    /**
     * {@snippet lang=c :
     * #define _SC_XOPEN_XCU_VERSION 121
     * }
     */
    public static int _SC_XOPEN_XCU_VERSION() {
        return _SC_XOPEN_XCU_VERSION;
    }
    private static final int _SC_XBS5_ILP32_OFF32 = (int)122L;
    /**
     * {@snippet lang=c :
     * #define _SC_XBS5_ILP32_OFF32 122
     * }
     */
    public static int _SC_XBS5_ILP32_OFF32() {
        return _SC_XBS5_ILP32_OFF32;
    }
    private static final int _SC_XBS5_ILP32_OFFBIG = (int)123L;
    /**
     * {@snippet lang=c :
     * #define _SC_XBS5_ILP32_OFFBIG 123
     * }
     */
    public static int _SC_XBS5_ILP32_OFFBIG() {
        return _SC_XBS5_ILP32_OFFBIG;
    }
    private static final int _SC_XBS5_LP64_OFF64 = (int)124L;
    /**
     * {@snippet lang=c :
     * #define _SC_XBS5_LP64_OFF64 124
     * }
     */
    public static int _SC_XBS5_LP64_OFF64() {
        return _SC_XBS5_LP64_OFF64;
    }
    private static final int _SC_XBS5_LPBIG_OFFBIG = (int)125L;
    /**
     * {@snippet lang=c :
     * #define _SC_XBS5_LPBIG_OFFBIG 125
     * }
     */
    public static int _SC_XBS5_LPBIG_OFFBIG() {
        return _SC_XBS5_LPBIG_OFFBIG;
    }
    private static final int _SC_SS_REPL_MAX = (int)126L;
    /**
     * {@snippet lang=c :
     * #define _SC_SS_REPL_MAX 126
     * }
     */
    public static int _SC_SS_REPL_MAX() {
        return _SC_SS_REPL_MAX;
    }
    private static final int _SC_TRACE_EVENT_NAME_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define _SC_TRACE_EVENT_NAME_MAX 127
     * }
     */
    public static int _SC_TRACE_EVENT_NAME_MAX() {
        return _SC_TRACE_EVENT_NAME_MAX;
    }
    private static final int _SC_TRACE_NAME_MAX = (int)128L;
    /**
     * {@snippet lang=c :
     * #define _SC_TRACE_NAME_MAX 128
     * }
     */
    public static int _SC_TRACE_NAME_MAX() {
        return _SC_TRACE_NAME_MAX;
    }
    private static final int _SC_TRACE_SYS_MAX = (int)129L;
    /**
     * {@snippet lang=c :
     * #define _SC_TRACE_SYS_MAX 129
     * }
     */
    public static int _SC_TRACE_SYS_MAX() {
        return _SC_TRACE_SYS_MAX;
    }
    private static final int _SC_TRACE_USER_EVENT_MAX = (int)130L;
    /**
     * {@snippet lang=c :
     * #define _SC_TRACE_USER_EVENT_MAX 130
     * }
     */
    public static int _SC_TRACE_USER_EVENT_MAX() {
        return _SC_TRACE_USER_EVENT_MAX;
    }
    private static final int _SC_PASS_MAX = (int)131L;
    /**
     * {@snippet lang=c :
     * #define _SC_PASS_MAX 131
     * }
     */
    public static int _SC_PASS_MAX() {
        return _SC_PASS_MAX;
    }
    private static final int _SC_PHYS_PAGES = (int)200L;
    /**
     * {@snippet lang=c :
     * #define _SC_PHYS_PAGES 200
     * }
     */
    public static int _SC_PHYS_PAGES() {
        return _SC_PHYS_PAGES;
    }
    private static final int _CS_POSIX_V6_ILP32_OFF32_CFLAGS = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_ILP32_OFF32_CFLAGS 2
     * }
     */
    public static int _CS_POSIX_V6_ILP32_OFF32_CFLAGS() {
        return _CS_POSIX_V6_ILP32_OFF32_CFLAGS;
    }
    private static final int _CS_POSIX_V6_ILP32_OFF32_LDFLAGS = (int)3L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_ILP32_OFF32_LDFLAGS 3
     * }
     */
    public static int _CS_POSIX_V6_ILP32_OFF32_LDFLAGS() {
        return _CS_POSIX_V6_ILP32_OFF32_LDFLAGS;
    }
    private static final int _CS_POSIX_V6_ILP32_OFF32_LIBS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_ILP32_OFF32_LIBS 4
     * }
     */
    public static int _CS_POSIX_V6_ILP32_OFF32_LIBS() {
        return _CS_POSIX_V6_ILP32_OFF32_LIBS;
    }
    private static final int _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = (int)5L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS 5
     * }
     */
    public static int _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS() {
        return _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS;
    }
    private static final int _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = (int)6L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS 6
     * }
     */
    public static int _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS() {
        return _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS;
    }
    private static final int _CS_POSIX_V6_ILP32_OFFBIG_LIBS = (int)7L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_ILP32_OFFBIG_LIBS 7
     * }
     */
    public static int _CS_POSIX_V6_ILP32_OFFBIG_LIBS() {
        return _CS_POSIX_V6_ILP32_OFFBIG_LIBS;
    }
    private static final int _CS_POSIX_V6_LP64_OFF64_CFLAGS = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_LP64_OFF64_CFLAGS 8
     * }
     */
    public static int _CS_POSIX_V6_LP64_OFF64_CFLAGS() {
        return _CS_POSIX_V6_LP64_OFF64_CFLAGS;
    }
    private static final int _CS_POSIX_V6_LP64_OFF64_LDFLAGS = (int)9L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_LP64_OFF64_LDFLAGS 9
     * }
     */
    public static int _CS_POSIX_V6_LP64_OFF64_LDFLAGS() {
        return _CS_POSIX_V6_LP64_OFF64_LDFLAGS;
    }
    private static final int _CS_POSIX_V6_LP64_OFF64_LIBS = (int)10L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_LP64_OFF64_LIBS 10
     * }
     */
    public static int _CS_POSIX_V6_LP64_OFF64_LIBS() {
        return _CS_POSIX_V6_LP64_OFF64_LIBS;
    }
    private static final int _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = (int)11L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS 11
     * }
     */
    public static int _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS() {
        return _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS;
    }
    private static final int _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = (int)12L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS 12
     * }
     */
    public static int _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS() {
        return _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS;
    }
    private static final int _CS_POSIX_V6_LPBIG_OFFBIG_LIBS = (int)13L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_LPBIG_OFFBIG_LIBS 13
     * }
     */
    public static int _CS_POSIX_V6_LPBIG_OFFBIG_LIBS() {
        return _CS_POSIX_V6_LPBIG_OFFBIG_LIBS;
    }
    private static final int _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS = (int)14L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS 14
     * }
     */
    public static int _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS() {
        return _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS;
    }
    private static final int _CS_XBS5_ILP32_OFF32_CFLAGS = (int)20L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_ILP32_OFF32_CFLAGS 20
     * }
     */
    public static int _CS_XBS5_ILP32_OFF32_CFLAGS() {
        return _CS_XBS5_ILP32_OFF32_CFLAGS;
    }
    private static final int _CS_XBS5_ILP32_OFF32_LDFLAGS = (int)21L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_ILP32_OFF32_LDFLAGS 21
     * }
     */
    public static int _CS_XBS5_ILP32_OFF32_LDFLAGS() {
        return _CS_XBS5_ILP32_OFF32_LDFLAGS;
    }
    private static final int _CS_XBS5_ILP32_OFF32_LIBS = (int)22L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_ILP32_OFF32_LIBS 22
     * }
     */
    public static int _CS_XBS5_ILP32_OFF32_LIBS() {
        return _CS_XBS5_ILP32_OFF32_LIBS;
    }
    private static final int _CS_XBS5_ILP32_OFF32_LINTFLAGS = (int)23L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_ILP32_OFF32_LINTFLAGS 23
     * }
     */
    public static int _CS_XBS5_ILP32_OFF32_LINTFLAGS() {
        return _CS_XBS5_ILP32_OFF32_LINTFLAGS;
    }
    private static final int _CS_XBS5_ILP32_OFFBIG_CFLAGS = (int)24L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_ILP32_OFFBIG_CFLAGS 24
     * }
     */
    public static int _CS_XBS5_ILP32_OFFBIG_CFLAGS() {
        return _CS_XBS5_ILP32_OFFBIG_CFLAGS;
    }
    private static final int _CS_XBS5_ILP32_OFFBIG_LDFLAGS = (int)25L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_ILP32_OFFBIG_LDFLAGS 25
     * }
     */
    public static int _CS_XBS5_ILP32_OFFBIG_LDFLAGS() {
        return _CS_XBS5_ILP32_OFFBIG_LDFLAGS;
    }
    private static final int _CS_XBS5_ILP32_OFFBIG_LIBS = (int)26L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_ILP32_OFFBIG_LIBS 26
     * }
     */
    public static int _CS_XBS5_ILP32_OFFBIG_LIBS() {
        return _CS_XBS5_ILP32_OFFBIG_LIBS;
    }
    private static final int _CS_XBS5_ILP32_OFFBIG_LINTFLAGS = (int)27L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_ILP32_OFFBIG_LINTFLAGS 27
     * }
     */
    public static int _CS_XBS5_ILP32_OFFBIG_LINTFLAGS() {
        return _CS_XBS5_ILP32_OFFBIG_LINTFLAGS;
    }
    private static final int _CS_XBS5_LP64_OFF64_CFLAGS = (int)28L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_LP64_OFF64_CFLAGS 28
     * }
     */
    public static int _CS_XBS5_LP64_OFF64_CFLAGS() {
        return _CS_XBS5_LP64_OFF64_CFLAGS;
    }
    private static final int _CS_XBS5_LP64_OFF64_LDFLAGS = (int)29L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_LP64_OFF64_LDFLAGS 29
     * }
     */
    public static int _CS_XBS5_LP64_OFF64_LDFLAGS() {
        return _CS_XBS5_LP64_OFF64_LDFLAGS;
    }
    private static final int _CS_XBS5_LP64_OFF64_LIBS = (int)30L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_LP64_OFF64_LIBS 30
     * }
     */
    public static int _CS_XBS5_LP64_OFF64_LIBS() {
        return _CS_XBS5_LP64_OFF64_LIBS;
    }
    private static final int _CS_XBS5_LP64_OFF64_LINTFLAGS = (int)31L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_LP64_OFF64_LINTFLAGS 31
     * }
     */
    public static int _CS_XBS5_LP64_OFF64_LINTFLAGS() {
        return _CS_XBS5_LP64_OFF64_LINTFLAGS;
    }
    private static final int _CS_XBS5_LPBIG_OFFBIG_CFLAGS = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_LPBIG_OFFBIG_CFLAGS 32
     * }
     */
    public static int _CS_XBS5_LPBIG_OFFBIG_CFLAGS() {
        return _CS_XBS5_LPBIG_OFFBIG_CFLAGS;
    }
    private static final int _CS_XBS5_LPBIG_OFFBIG_LDFLAGS = (int)33L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_LPBIG_OFFBIG_LDFLAGS 33
     * }
     */
    public static int _CS_XBS5_LPBIG_OFFBIG_LDFLAGS() {
        return _CS_XBS5_LPBIG_OFFBIG_LDFLAGS;
    }
    private static final int _CS_XBS5_LPBIG_OFFBIG_LIBS = (int)34L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_LPBIG_OFFBIG_LIBS 34
     * }
     */
    public static int _CS_XBS5_LPBIG_OFFBIG_LIBS() {
        return _CS_XBS5_LPBIG_OFFBIG_LIBS;
    }
    private static final int _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = (int)35L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS 35
     * }
     */
    public static int _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS() {
        return _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS;
    }
    private static final int _CS_DARWIN_USER_DIR = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define _CS_DARWIN_USER_DIR 65536
     * }
     */
    public static int _CS_DARWIN_USER_DIR() {
        return _CS_DARWIN_USER_DIR;
    }
    private static final int _CS_DARWIN_USER_TEMP_DIR = (int)65537L;
    /**
     * {@snippet lang=c :
     * #define _CS_DARWIN_USER_TEMP_DIR 65537
     * }
     */
    public static int _CS_DARWIN_USER_TEMP_DIR() {
        return _CS_DARWIN_USER_TEMP_DIR;
    }
    private static final int _CS_DARWIN_USER_CACHE_DIR = (int)65538L;
    /**
     * {@snippet lang=c :
     * #define _CS_DARWIN_USER_CACHE_DIR 65538
     * }
     */
    public static int _CS_DARWIN_USER_CACHE_DIR() {
        return _CS_DARWIN_USER_CACHE_DIR;
    }
    private static final int F_ULOCK = (int)0L;
    /**
     * {@snippet lang=c :
     * #define F_ULOCK 0
     * }
     */
    public static int F_ULOCK() {
        return F_ULOCK;
    }
    private static final int F_LOCK = (int)1L;
    /**
     * {@snippet lang=c :
     * #define F_LOCK 1
     * }
     */
    public static int F_LOCK() {
        return F_LOCK;
    }
    private static final int F_TLOCK = (int)2L;
    /**
     * {@snippet lang=c :
     * #define F_TLOCK 2
     * }
     */
    public static int F_TLOCK() {
        return F_TLOCK;
    }
    private static final int F_TEST = (int)3L;
    /**
     * {@snippet lang=c :
     * #define F_TEST 3
     * }
     */
    public static int F_TEST() {
        return F_TEST;
    }
    private static final int __DARWIN_FD_SETSIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_FD_SETSIZE 1024
     * }
     */
    public static int __DARWIN_FD_SETSIZE() {
        return __DARWIN_FD_SETSIZE;
    }
    private static final int __DARWIN_NBBY = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NBBY 8
     * }
     */
    public static int __DARWIN_NBBY() {
        return __DARWIN_NBBY;
    }
    private static final int SYNC_VOLUME_FULLSYNC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SYNC_VOLUME_FULLSYNC 1
     * }
     */
    public static int SYNC_VOLUME_FULLSYNC() {
        return SYNC_VOLUME_FULLSYNC;
    }
    private static final int SYNC_VOLUME_WAIT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SYNC_VOLUME_WAIT 2
     * }
     */
    public static int SYNC_VOLUME_WAIT() {
        return SYNC_VOLUME_WAIT;
    }
    private static final int __GNUC_VA_LIST = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __GNUC_VA_LIST 1
     * }
     */
    public static int __GNUC_VA_LIST() {
        return __GNUC_VA_LIST;
    }
    private static final int TIME_UTC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TIME_UTC 1
     * }
     */
    public static int TIME_UTC() {
        return TIME_UTC;
    }
    private static final int _CTYPE_SWS = (int)30L;
    /**
     * {@snippet lang=c :
     * #define _CTYPE_SWS 30
     * }
     */
    public static int _CTYPE_SWS() {
        return _CTYPE_SWS;
    }
    private static final int __DARWIN_CLK_TCK = (int)100L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_CLK_TCK 100
     * }
     */
    public static int __DARWIN_CLK_TCK() {
        return __DARWIN_CLK_TCK;
    }
    private static final int MB_LEN_MAX = (int)6L;
    /**
     * {@snippet lang=c :
     * #define MB_LEN_MAX 6
     * }
     */
    public static int MB_LEN_MAX() {
        return MB_LEN_MAX;
    }
    private static final int CHAR_BIT = (int)8L;
    /**
     * {@snippet lang=c :
     * #define CHAR_BIT 8
     * }
     */
    public static int CHAR_BIT() {
        return CHAR_BIT;
    }
    private static final int SCHAR_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define SCHAR_MAX 127
     * }
     */
    public static int SCHAR_MAX() {
        return SCHAR_MAX;
    }
    private static final int UCHAR_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UCHAR_MAX 255
     * }
     */
    public static int UCHAR_MAX() {
        return UCHAR_MAX;
    }
    private static final int CHAR_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define CHAR_MAX 127
     * }
     */
    public static int CHAR_MAX() {
        return CHAR_MAX;
    }
    private static final int USHRT_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define USHRT_MAX 65535
     * }
     */
    public static int USHRT_MAX() {
        return USHRT_MAX;
    }
    private static final int SHRT_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define SHRT_MAX 32767
     * }
     */
    public static int SHRT_MAX() {
        return SHRT_MAX;
    }
    private static final int INT_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_MAX 2147483647
     * }
     */
    public static int INT_MAX() {
        return INT_MAX;
    }
    private static final int LONG_BIT = (int)64L;
    /**
     * {@snippet lang=c :
     * #define LONG_BIT 64
     * }
     */
    public static int LONG_BIT() {
        return LONG_BIT;
    }
    private static final int WORD_BIT = (int)32L;
    /**
     * {@snippet lang=c :
     * #define WORD_BIT 32
     * }
     */
    public static int WORD_BIT() {
        return WORD_BIT;
    }
    private static final int CHILD_MAX = (int)266L;
    /**
     * {@snippet lang=c :
     * #define CHILD_MAX 266
     * }
     */
    public static int CHILD_MAX() {
        return CHILD_MAX;
    }
    private static final int LINK_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define LINK_MAX 32767
     * }
     */
    public static int LINK_MAX() {
        return LINK_MAX;
    }
    private static final int MAX_CANON = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define MAX_CANON 1024
     * }
     */
    public static int MAX_CANON() {
        return MAX_CANON;
    }
    private static final int MAX_INPUT = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define MAX_INPUT 1024
     * }
     */
    public static int MAX_INPUT() {
        return MAX_INPUT;
    }
    private static final int NAME_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define NAME_MAX 255
     * }
     */
    public static int NAME_MAX() {
        return NAME_MAX;
    }
    private static final int NGROUPS_MAX = (int)16L;
    /**
     * {@snippet lang=c :
     * #define NGROUPS_MAX 16
     * }
     */
    public static int NGROUPS_MAX() {
        return NGROUPS_MAX;
    }
    private static final int OPEN_MAX = (int)10240L;
    /**
     * {@snippet lang=c :
     * #define OPEN_MAX 10240
     * }
     */
    public static int OPEN_MAX() {
        return OPEN_MAX;
    }
    private static final int PATH_MAX = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define PATH_MAX 1024
     * }
     */
    public static int PATH_MAX() {
        return PATH_MAX;
    }
    private static final int PIPE_BUF = (int)512L;
    /**
     * {@snippet lang=c :
     * #define PIPE_BUF 512
     * }
     */
    public static int PIPE_BUF() {
        return PIPE_BUF;
    }
    private static final int BC_BASE_MAX = (int)99L;
    /**
     * {@snippet lang=c :
     * #define BC_BASE_MAX 99
     * }
     */
    public static int BC_BASE_MAX() {
        return BC_BASE_MAX;
    }
    private static final int BC_DIM_MAX = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define BC_DIM_MAX 2048
     * }
     */
    public static int BC_DIM_MAX() {
        return BC_DIM_MAX;
    }
    private static final int BC_SCALE_MAX = (int)99L;
    /**
     * {@snippet lang=c :
     * #define BC_SCALE_MAX 99
     * }
     */
    public static int BC_SCALE_MAX() {
        return BC_SCALE_MAX;
    }
    private static final int BC_STRING_MAX = (int)1000L;
    /**
     * {@snippet lang=c :
     * #define BC_STRING_MAX 1000
     * }
     */
    public static int BC_STRING_MAX() {
        return BC_STRING_MAX;
    }
    private static final int CHARCLASS_NAME_MAX = (int)14L;
    /**
     * {@snippet lang=c :
     * #define CHARCLASS_NAME_MAX 14
     * }
     */
    public static int CHARCLASS_NAME_MAX() {
        return CHARCLASS_NAME_MAX;
    }
    private static final int COLL_WEIGHTS_MAX = (int)2L;
    /**
     * {@snippet lang=c :
     * #define COLL_WEIGHTS_MAX 2
     * }
     */
    public static int COLL_WEIGHTS_MAX() {
        return COLL_WEIGHTS_MAX;
    }
    private static final int EQUIV_CLASS_MAX = (int)2L;
    /**
     * {@snippet lang=c :
     * #define EQUIV_CLASS_MAX 2
     * }
     */
    public static int EQUIV_CLASS_MAX() {
        return EQUIV_CLASS_MAX;
    }
    private static final int EXPR_NEST_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define EXPR_NEST_MAX 32
     * }
     */
    public static int EXPR_NEST_MAX() {
        return EXPR_NEST_MAX;
    }
    private static final int LINE_MAX = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define LINE_MAX 2048
     * }
     */
    public static int LINE_MAX() {
        return LINE_MAX;
    }
    private static final int RE_DUP_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define RE_DUP_MAX 255
     * }
     */
    public static int RE_DUP_MAX() {
        return RE_DUP_MAX;
    }
    private static final int NZERO = (int)20L;
    /**
     * {@snippet lang=c :
     * #define NZERO 20
     * }
     */
    public static int NZERO() {
        return NZERO;
    }
    private static final int _POSIX_ARG_MAX = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_ARG_MAX 4096
     * }
     */
    public static int _POSIX_ARG_MAX() {
        return _POSIX_ARG_MAX;
    }
    private static final int _POSIX_CHILD_MAX = (int)25L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_CHILD_MAX 25
     * }
     */
    public static int _POSIX_CHILD_MAX() {
        return _POSIX_CHILD_MAX;
    }
    private static final int _POSIX_LINK_MAX = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_LINK_MAX 8
     * }
     */
    public static int _POSIX_LINK_MAX() {
        return _POSIX_LINK_MAX;
    }
    private static final int _POSIX_MAX_CANON = (int)255L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_MAX_CANON 255
     * }
     */
    public static int _POSIX_MAX_CANON() {
        return _POSIX_MAX_CANON;
    }
    private static final int _POSIX_MAX_INPUT = (int)255L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_MAX_INPUT 255
     * }
     */
    public static int _POSIX_MAX_INPUT() {
        return _POSIX_MAX_INPUT;
    }
    private static final int _POSIX_NAME_MAX = (int)14L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_NAME_MAX 14
     * }
     */
    public static int _POSIX_NAME_MAX() {
        return _POSIX_NAME_MAX;
    }
    private static final int _POSIX_NGROUPS_MAX = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_NGROUPS_MAX 8
     * }
     */
    public static int _POSIX_NGROUPS_MAX() {
        return _POSIX_NGROUPS_MAX;
    }
    private static final int _POSIX_OPEN_MAX = (int)20L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_OPEN_MAX 20
     * }
     */
    public static int _POSIX_OPEN_MAX() {
        return _POSIX_OPEN_MAX;
    }
    private static final int _POSIX_PATH_MAX = (int)256L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_PATH_MAX 256
     * }
     */
    public static int _POSIX_PATH_MAX() {
        return _POSIX_PATH_MAX;
    }
    private static final int _POSIX_PIPE_BUF = (int)512L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_PIPE_BUF 512
     * }
     */
    public static int _POSIX_PIPE_BUF() {
        return _POSIX_PIPE_BUF;
    }
    private static final int _POSIX_SSIZE_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SSIZE_MAX 32767
     * }
     */
    public static int _POSIX_SSIZE_MAX() {
        return _POSIX_SSIZE_MAX;
    }
    private static final int _POSIX_STREAM_MAX = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_STREAM_MAX 8
     * }
     */
    public static int _POSIX_STREAM_MAX() {
        return _POSIX_STREAM_MAX;
    }
    private static final int _POSIX_TZNAME_MAX = (int)6L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TZNAME_MAX 6
     * }
     */
    public static int _POSIX_TZNAME_MAX() {
        return _POSIX_TZNAME_MAX;
    }
    private static final int _POSIX2_BC_BASE_MAX = (int)99L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_BC_BASE_MAX 99
     * }
     */
    public static int _POSIX2_BC_BASE_MAX() {
        return _POSIX2_BC_BASE_MAX;
    }
    private static final int _POSIX2_BC_DIM_MAX = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_BC_DIM_MAX 2048
     * }
     */
    public static int _POSIX2_BC_DIM_MAX() {
        return _POSIX2_BC_DIM_MAX;
    }
    private static final int _POSIX2_BC_SCALE_MAX = (int)99L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_BC_SCALE_MAX 99
     * }
     */
    public static int _POSIX2_BC_SCALE_MAX() {
        return _POSIX2_BC_SCALE_MAX;
    }
    private static final int _POSIX2_BC_STRING_MAX = (int)1000L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_BC_STRING_MAX 1000
     * }
     */
    public static int _POSIX2_BC_STRING_MAX() {
        return _POSIX2_BC_STRING_MAX;
    }
    private static final int _POSIX2_EQUIV_CLASS_MAX = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_EQUIV_CLASS_MAX 2
     * }
     */
    public static int _POSIX2_EQUIV_CLASS_MAX() {
        return _POSIX2_EQUIV_CLASS_MAX;
    }
    private static final int _POSIX2_EXPR_NEST_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_EXPR_NEST_MAX 32
     * }
     */
    public static int _POSIX2_EXPR_NEST_MAX() {
        return _POSIX2_EXPR_NEST_MAX;
    }
    private static final int _POSIX2_LINE_MAX = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_LINE_MAX 2048
     * }
     */
    public static int _POSIX2_LINE_MAX() {
        return _POSIX2_LINE_MAX;
    }
    private static final int _POSIX2_RE_DUP_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_RE_DUP_MAX 255
     * }
     */
    public static int _POSIX2_RE_DUP_MAX() {
        return _POSIX2_RE_DUP_MAX;
    }
    private static final int _POSIX_AIO_LISTIO_MAX = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_AIO_LISTIO_MAX 2
     * }
     */
    public static int _POSIX_AIO_LISTIO_MAX() {
        return _POSIX_AIO_LISTIO_MAX;
    }
    private static final int _POSIX_AIO_MAX = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_AIO_MAX 1
     * }
     */
    public static int _POSIX_AIO_MAX() {
        return _POSIX_AIO_MAX;
    }
    private static final int _POSIX_DELAYTIMER_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_DELAYTIMER_MAX 32
     * }
     */
    public static int _POSIX_DELAYTIMER_MAX() {
        return _POSIX_DELAYTIMER_MAX;
    }
    private static final int _POSIX_MQ_OPEN_MAX = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_MQ_OPEN_MAX 8
     * }
     */
    public static int _POSIX_MQ_OPEN_MAX() {
        return _POSIX_MQ_OPEN_MAX;
    }
    private static final int _POSIX_MQ_PRIO_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_MQ_PRIO_MAX 32
     * }
     */
    public static int _POSIX_MQ_PRIO_MAX() {
        return _POSIX_MQ_PRIO_MAX;
    }
    private static final int _POSIX_RTSIG_MAX = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_RTSIG_MAX 8
     * }
     */
    public static int _POSIX_RTSIG_MAX() {
        return _POSIX_RTSIG_MAX;
    }
    private static final int _POSIX_SEM_NSEMS_MAX = (int)256L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SEM_NSEMS_MAX 256
     * }
     */
    public static int _POSIX_SEM_NSEMS_MAX() {
        return _POSIX_SEM_NSEMS_MAX;
    }
    private static final int _POSIX_SEM_VALUE_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SEM_VALUE_MAX 32767
     * }
     */
    public static int _POSIX_SEM_VALUE_MAX() {
        return _POSIX_SEM_VALUE_MAX;
    }
    private static final int _POSIX_SIGQUEUE_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SIGQUEUE_MAX 32
     * }
     */
    public static int _POSIX_SIGQUEUE_MAX() {
        return _POSIX_SIGQUEUE_MAX;
    }
    private static final int _POSIX_TIMER_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TIMER_MAX 32
     * }
     */
    public static int _POSIX_TIMER_MAX() {
        return _POSIX_TIMER_MAX;
    }
    private static final int _POSIX_CLOCKRES_MIN = (int)20000000L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_CLOCKRES_MIN 20000000
     * }
     */
    public static int _POSIX_CLOCKRES_MIN() {
        return _POSIX_CLOCKRES_MIN;
    }
    private static final int _POSIX_THREAD_DESTRUCTOR_ITERATIONS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_DESTRUCTOR_ITERATIONS 4
     * }
     */
    public static int _POSIX_THREAD_DESTRUCTOR_ITERATIONS() {
        return _POSIX_THREAD_DESTRUCTOR_ITERATIONS;
    }
    private static final int _POSIX_THREAD_THREADS_MAX = (int)64L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_THREADS_MAX 64
     * }
     */
    public static int _POSIX_THREAD_THREADS_MAX() {
        return _POSIX_THREAD_THREADS_MAX;
    }
    private static final int PTHREAD_DESTRUCTOR_ITERATIONS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_DESTRUCTOR_ITERATIONS 4
     * }
     */
    public static int PTHREAD_DESTRUCTOR_ITERATIONS() {
        return PTHREAD_DESTRUCTOR_ITERATIONS;
    }
    private static final int PTHREAD_KEYS_MAX = (int)512L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_KEYS_MAX 512
     * }
     */
    public static int PTHREAD_KEYS_MAX() {
        return PTHREAD_KEYS_MAX;
    }
    private static final int PTHREAD_STACK_MIN = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_STACK_MIN 16384
     * }
     */
    public static int PTHREAD_STACK_MIN() {
        return PTHREAD_STACK_MIN;
    }
    private static final int _POSIX_HOST_NAME_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_HOST_NAME_MAX 255
     * }
     */
    public static int _POSIX_HOST_NAME_MAX() {
        return _POSIX_HOST_NAME_MAX;
    }
    private static final int _POSIX_LOGIN_NAME_MAX = (int)9L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_LOGIN_NAME_MAX 9
     * }
     */
    public static int _POSIX_LOGIN_NAME_MAX() {
        return _POSIX_LOGIN_NAME_MAX;
    }
    private static final int _POSIX_SS_REPL_MAX = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SS_REPL_MAX 4
     * }
     */
    public static int _POSIX_SS_REPL_MAX() {
        return _POSIX_SS_REPL_MAX;
    }
    private static final int _POSIX_SYMLINK_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SYMLINK_MAX 255
     * }
     */
    public static int _POSIX_SYMLINK_MAX() {
        return _POSIX_SYMLINK_MAX;
    }
    private static final int _POSIX_SYMLOOP_MAX = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SYMLOOP_MAX 8
     * }
     */
    public static int _POSIX_SYMLOOP_MAX() {
        return _POSIX_SYMLOOP_MAX;
    }
    private static final int _POSIX_TRACE_EVENT_NAME_MAX = (int)30L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TRACE_EVENT_NAME_MAX 30
     * }
     */
    public static int _POSIX_TRACE_EVENT_NAME_MAX() {
        return _POSIX_TRACE_EVENT_NAME_MAX;
    }
    private static final int _POSIX_TRACE_NAME_MAX = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TRACE_NAME_MAX 8
     * }
     */
    public static int _POSIX_TRACE_NAME_MAX() {
        return _POSIX_TRACE_NAME_MAX;
    }
    private static final int _POSIX_TRACE_SYS_MAX = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TRACE_SYS_MAX 8
     * }
     */
    public static int _POSIX_TRACE_SYS_MAX() {
        return _POSIX_TRACE_SYS_MAX;
    }
    private static final int _POSIX_TRACE_USER_EVENT_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TRACE_USER_EVENT_MAX 32
     * }
     */
    public static int _POSIX_TRACE_USER_EVENT_MAX() {
        return _POSIX_TRACE_USER_EVENT_MAX;
    }
    private static final int _POSIX_TTY_NAME_MAX = (int)9L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TTY_NAME_MAX 9
     * }
     */
    public static int _POSIX_TTY_NAME_MAX() {
        return _POSIX_TTY_NAME_MAX;
    }
    private static final int _POSIX2_CHARCLASS_NAME_MAX = (int)14L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_CHARCLASS_NAME_MAX 14
     * }
     */
    public static int _POSIX2_CHARCLASS_NAME_MAX() {
        return _POSIX2_CHARCLASS_NAME_MAX;
    }
    private static final int _POSIX2_COLL_WEIGHTS_MAX = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_COLL_WEIGHTS_MAX 2
     * }
     */
    public static int _POSIX2_COLL_WEIGHTS_MAX() {
        return _POSIX2_COLL_WEIGHTS_MAX;
    }
    private static final int PASS_MAX = (int)128L;
    /**
     * {@snippet lang=c :
     * #define PASS_MAX 128
     * }
     */
    public static int PASS_MAX() {
        return PASS_MAX;
    }
    private static final int NL_ARGMAX = (int)9L;
    /**
     * {@snippet lang=c :
     * #define NL_ARGMAX 9
     * }
     */
    public static int NL_ARGMAX() {
        return NL_ARGMAX;
    }
    private static final int NL_LANGMAX = (int)14L;
    /**
     * {@snippet lang=c :
     * #define NL_LANGMAX 14
     * }
     */
    public static int NL_LANGMAX() {
        return NL_LANGMAX;
    }
    private static final int NL_MSGMAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define NL_MSGMAX 32767
     * }
     */
    public static int NL_MSGMAX() {
        return NL_MSGMAX;
    }
    private static final int NL_NMAX = (int)1L;
    /**
     * {@snippet lang=c :
     * #define NL_NMAX 1
     * }
     */
    public static int NL_NMAX() {
        return NL_NMAX;
    }
    private static final int NL_SETMAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define NL_SETMAX 255
     * }
     */
    public static int NL_SETMAX() {
        return NL_SETMAX;
    }
    private static final int NL_TEXTMAX = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define NL_TEXTMAX 2048
     * }
     */
    public static int NL_TEXTMAX() {
        return NL_TEXTMAX;
    }
    private static final int _XOPEN_IOV_MAX = (int)16L;
    /**
     * {@snippet lang=c :
     * #define _XOPEN_IOV_MAX 16
     * }
     */
    public static int _XOPEN_IOV_MAX() {
        return _XOPEN_IOV_MAX;
    }
    private static final int IOV_MAX = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define IOV_MAX 1024
     * }
     */
    public static int IOV_MAX() {
        return IOV_MAX;
    }
    private static final int _XOPEN_NAME_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define _XOPEN_NAME_MAX 255
     * }
     */
    public static int _XOPEN_NAME_MAX() {
        return _XOPEN_NAME_MAX;
    }
    private static final int _XOPEN_PATH_MAX = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define _XOPEN_PATH_MAX 1024
     * }
     */
    public static int _XOPEN_PATH_MAX() {
        return _XOPEN_PATH_MAX;
    }
    private static final int HAVE_LONG_LONG = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HAVE_LONG_LONG 1
     * }
     */
    public static int HAVE_LONG_LONG() {
        return HAVE_LONG_LONG;
    }
    private static final int PYLONG_BITS_IN_DIGIT = (int)30L;
    /**
     * {@snippet lang=c :
     * #define PYLONG_BITS_IN_DIGIT 30
     * }
     */
    public static int PYLONG_BITS_IN_DIGIT() {
        return PYLONG_BITS_IN_DIGIT;
    }
    private static final int FP_NAN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FP_NAN 1
     * }
     */
    public static int FP_NAN() {
        return FP_NAN;
    }
    private static final int FP_INFINITE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FP_INFINITE 2
     * }
     */
    public static int FP_INFINITE() {
        return FP_INFINITE;
    }
    private static final int FP_ZERO = (int)3L;
    /**
     * {@snippet lang=c :
     * #define FP_ZERO 3
     * }
     */
    public static int FP_ZERO() {
        return FP_ZERO;
    }
    private static final int FP_NORMAL = (int)4L;
    /**
     * {@snippet lang=c :
     * #define FP_NORMAL 4
     * }
     */
    public static int FP_NORMAL() {
        return FP_NORMAL;
    }
    private static final int FP_SUBNORMAL = (int)5L;
    /**
     * {@snippet lang=c :
     * #define FP_SUBNORMAL 5
     * }
     */
    public static int FP_SUBNORMAL() {
        return FP_SUBNORMAL;
    }
    private static final int FP_SUPERNORMAL = (int)6L;
    /**
     * {@snippet lang=c :
     * #define FP_SUPERNORMAL 6
     * }
     */
    public static int FP_SUPERNORMAL() {
        return FP_SUPERNORMAL;
    }
    private static final int FP_FAST_FMA = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FP_FAST_FMA 1
     * }
     */
    public static int FP_FAST_FMA() {
        return FP_FAST_FMA;
    }
    private static final int FP_FAST_FMAF = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FP_FAST_FMAF 1
     * }
     */
    public static int FP_FAST_FMAF() {
        return FP_FAST_FMAF;
    }
    private static final int FP_FAST_FMAL = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FP_FAST_FMAL 1
     * }
     */
    public static int FP_FAST_FMAL() {
        return FP_FAST_FMAL;
    }
    private static final int MATH_ERRNO = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MATH_ERRNO 1
     * }
     */
    public static int MATH_ERRNO() {
        return MATH_ERRNO;
    }
    private static final int MATH_ERREXCEPT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define MATH_ERREXCEPT 2
     * }
     */
    public static int MATH_ERREXCEPT() {
        return MATH_ERREXCEPT;
    }
    private static final int DOMAIN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define DOMAIN 1
     * }
     */
    public static int DOMAIN() {
        return DOMAIN;
    }
    private static final int SING = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SING 2
     * }
     */
    public static int SING() {
        return SING;
    }
    private static final int OVERFLOW = (int)3L;
    /**
     * {@snippet lang=c :
     * #define OVERFLOW 3
     * }
     */
    public static int OVERFLOW() {
        return OVERFLOW;
    }
    private static final int UNDERFLOW = (int)4L;
    /**
     * {@snippet lang=c :
     * #define UNDERFLOW 4
     * }
     */
    public static int UNDERFLOW() {
        return UNDERFLOW;
    }
    private static final int TLOSS = (int)5L;
    /**
     * {@snippet lang=c :
     * #define TLOSS 5
     * }
     */
    public static int TLOSS() {
        return TLOSS;
    }
    private static final int PLOSS = (int)6L;
    /**
     * {@snippet lang=c :
     * #define PLOSS 6
     * }
     */
    public static int PLOSS() {
        return PLOSS;
    }
    private static final int ITIMER_REAL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define ITIMER_REAL 0
     * }
     */
    public static int ITIMER_REAL() {
        return ITIMER_REAL;
    }
    private static final int ITIMER_VIRTUAL = (int)1L;
    /**
     * {@snippet lang=c :
     * #define ITIMER_VIRTUAL 1
     * }
     */
    public static int ITIMER_VIRTUAL() {
        return ITIMER_VIRTUAL;
    }
    private static final int ITIMER_PROF = (int)2L;
    /**
     * {@snippet lang=c :
     * #define ITIMER_PROF 2
     * }
     */
    public static int ITIMER_PROF() {
        return ITIMER_PROF;
    }
    private static final int DST_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define DST_NONE 0
     * }
     */
    public static int DST_NONE() {
        return DST_NONE;
    }
    private static final int DST_USA = (int)1L;
    /**
     * {@snippet lang=c :
     * #define DST_USA 1
     * }
     */
    public static int DST_USA() {
        return DST_USA;
    }
    private static final int DST_AUST = (int)2L;
    /**
     * {@snippet lang=c :
     * #define DST_AUST 2
     * }
     */
    public static int DST_AUST() {
        return DST_AUST;
    }
    private static final int DST_WET = (int)3L;
    /**
     * {@snippet lang=c :
     * #define DST_WET 3
     * }
     */
    public static int DST_WET() {
        return DST_WET;
    }
    private static final int DST_MET = (int)4L;
    /**
     * {@snippet lang=c :
     * #define DST_MET 4
     * }
     */
    public static int DST_MET() {
        return DST_MET;
    }
    private static final int DST_EET = (int)5L;
    /**
     * {@snippet lang=c :
     * #define DST_EET 5
     * }
     */
    public static int DST_EET() {
        return DST_EET;
    }
    private static final int DST_CAN = (int)6L;
    /**
     * {@snippet lang=c :
     * #define DST_CAN 6
     * }
     */
    public static int DST_CAN() {
        return DST_CAN;
    }
    private static final int S_IFMT = (int)61440L;
    /**
     * {@snippet lang=c :
     * #define S_IFMT 61440
     * }
     */
    public static int S_IFMT() {
        return S_IFMT;
    }
    private static final int S_IFIFO = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define S_IFIFO 4096
     * }
     */
    public static int S_IFIFO() {
        return S_IFIFO;
    }
    private static final int S_IFCHR = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define S_IFCHR 8192
     * }
     */
    public static int S_IFCHR() {
        return S_IFCHR;
    }
    private static final int S_IFDIR = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define S_IFDIR 16384
     * }
     */
    public static int S_IFDIR() {
        return S_IFDIR;
    }
    private static final int S_IFBLK = (int)24576L;
    /**
     * {@snippet lang=c :
     * #define S_IFBLK 24576
     * }
     */
    public static int S_IFBLK() {
        return S_IFBLK;
    }
    private static final int S_IFREG = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define S_IFREG 32768
     * }
     */
    public static int S_IFREG() {
        return S_IFREG;
    }
    private static final int S_IFLNK = (int)40960L;
    /**
     * {@snippet lang=c :
     * #define S_IFLNK 40960
     * }
     */
    public static int S_IFLNK() {
        return S_IFLNK;
    }
    private static final int S_IFSOCK = (int)49152L;
    /**
     * {@snippet lang=c :
     * #define S_IFSOCK 49152
     * }
     */
    public static int S_IFSOCK() {
        return S_IFSOCK;
    }
    private static final int S_IFWHT = (int)57344L;
    /**
     * {@snippet lang=c :
     * #define S_IFWHT 57344
     * }
     */
    public static int S_IFWHT() {
        return S_IFWHT;
    }
    private static final int S_IRWXU = (int)448L;
    /**
     * {@snippet lang=c :
     * #define S_IRWXU 448
     * }
     */
    public static int S_IRWXU() {
        return S_IRWXU;
    }
    private static final int S_IRUSR = (int)256L;
    /**
     * {@snippet lang=c :
     * #define S_IRUSR 256
     * }
     */
    public static int S_IRUSR() {
        return S_IRUSR;
    }
    private static final int S_IWUSR = (int)128L;
    /**
     * {@snippet lang=c :
     * #define S_IWUSR 128
     * }
     */
    public static int S_IWUSR() {
        return S_IWUSR;
    }
    private static final int S_IXUSR = (int)64L;
    /**
     * {@snippet lang=c :
     * #define S_IXUSR 64
     * }
     */
    public static int S_IXUSR() {
        return S_IXUSR;
    }
    private static final int S_IRWXG = (int)56L;
    /**
     * {@snippet lang=c :
     * #define S_IRWXG 56
     * }
     */
    public static int S_IRWXG() {
        return S_IRWXG;
    }
    private static final int S_IRGRP = (int)32L;
    /**
     * {@snippet lang=c :
     * #define S_IRGRP 32
     * }
     */
    public static int S_IRGRP() {
        return S_IRGRP;
    }
    private static final int S_IWGRP = (int)16L;
    /**
     * {@snippet lang=c :
     * #define S_IWGRP 16
     * }
     */
    public static int S_IWGRP() {
        return S_IWGRP;
    }
    private static final int S_IXGRP = (int)8L;
    /**
     * {@snippet lang=c :
     * #define S_IXGRP 8
     * }
     */
    public static int S_IXGRP() {
        return S_IXGRP;
    }
    private static final int S_IRWXO = (int)7L;
    /**
     * {@snippet lang=c :
     * #define S_IRWXO 7
     * }
     */
    public static int S_IRWXO() {
        return S_IRWXO;
    }
    private static final int S_IROTH = (int)4L;
    /**
     * {@snippet lang=c :
     * #define S_IROTH 4
     * }
     */
    public static int S_IROTH() {
        return S_IROTH;
    }
    private static final int S_IWOTH = (int)2L;
    /**
     * {@snippet lang=c :
     * #define S_IWOTH 2
     * }
     */
    public static int S_IWOTH() {
        return S_IWOTH;
    }
    private static final int S_IXOTH = (int)1L;
    /**
     * {@snippet lang=c :
     * #define S_IXOTH 1
     * }
     */
    public static int S_IXOTH() {
        return S_IXOTH;
    }
    private static final int S_ISUID = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define S_ISUID 2048
     * }
     */
    public static int S_ISUID() {
        return S_ISUID;
    }
    private static final int S_ISGID = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define S_ISGID 1024
     * }
     */
    public static int S_ISGID() {
        return S_ISGID;
    }
    private static final int S_ISVTX = (int)512L;
    /**
     * {@snippet lang=c :
     * #define S_ISVTX 512
     * }
     */
    public static int S_ISVTX() {
        return S_ISVTX;
    }
    private static final int S_BLKSIZE = (int)512L;
    /**
     * {@snippet lang=c :
     * #define S_BLKSIZE 512
     * }
     */
    public static int S_BLKSIZE() {
        return S_BLKSIZE;
    }
    private static final int UF_SETTABLE = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UF_SETTABLE 65535
     * }
     */
    public static int UF_SETTABLE() {
        return UF_SETTABLE;
    }
    private static final int UF_NODUMP = (int)1L;
    /**
     * {@snippet lang=c :
     * #define UF_NODUMP 1
     * }
     */
    public static int UF_NODUMP() {
        return UF_NODUMP;
    }
    private static final int UF_IMMUTABLE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define UF_IMMUTABLE 2
     * }
     */
    public static int UF_IMMUTABLE() {
        return UF_IMMUTABLE;
    }
    private static final int UF_APPEND = (int)4L;
    /**
     * {@snippet lang=c :
     * #define UF_APPEND 4
     * }
     */
    public static int UF_APPEND() {
        return UF_APPEND;
    }
    private static final int UF_OPAQUE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define UF_OPAQUE 8
     * }
     */
    public static int UF_OPAQUE() {
        return UF_OPAQUE;
    }
    private static final int UF_COMPRESSED = (int)32L;
    /**
     * {@snippet lang=c :
     * #define UF_COMPRESSED 32
     * }
     */
    public static int UF_COMPRESSED() {
        return UF_COMPRESSED;
    }
    private static final int UF_TRACKED = (int)64L;
    /**
     * {@snippet lang=c :
     * #define UF_TRACKED 64
     * }
     */
    public static int UF_TRACKED() {
        return UF_TRACKED;
    }
    private static final int UF_DATAVAULT = (int)128L;
    /**
     * {@snippet lang=c :
     * #define UF_DATAVAULT 128
     * }
     */
    public static int UF_DATAVAULT() {
        return UF_DATAVAULT;
    }
    private static final int UF_HIDDEN = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define UF_HIDDEN 32768
     * }
     */
    public static int UF_HIDDEN() {
        return UF_HIDDEN;
    }
    private static final int SF_SUPPORTED = (int)10420224L;
    /**
     * {@snippet lang=c :
     * #define SF_SUPPORTED 10420224
     * }
     */
    public static int SF_SUPPORTED() {
        return SF_SUPPORTED;
    }
    private static final int SF_SETTABLE = (int)1073676288L;
    /**
     * {@snippet lang=c :
     * #define SF_SETTABLE 1073676288
     * }
     */
    public static int SF_SETTABLE() {
        return SF_SETTABLE;
    }
    private static final int SF_ARCHIVED = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define SF_ARCHIVED 65536
     * }
     */
    public static int SF_ARCHIVED() {
        return SF_ARCHIVED;
    }
    private static final int SF_IMMUTABLE = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define SF_IMMUTABLE 131072
     * }
     */
    public static int SF_IMMUTABLE() {
        return SF_IMMUTABLE;
    }
    private static final int SF_APPEND = (int)262144L;
    /**
     * {@snippet lang=c :
     * #define SF_APPEND 262144
     * }
     */
    public static int SF_APPEND() {
        return SF_APPEND;
    }
    private static final int SF_RESTRICTED = (int)524288L;
    /**
     * {@snippet lang=c :
     * #define SF_RESTRICTED 524288
     * }
     */
    public static int SF_RESTRICTED() {
        return SF_RESTRICTED;
    }
    private static final int SF_NOUNLINK = (int)1048576L;
    /**
     * {@snippet lang=c :
     * #define SF_NOUNLINK 1048576
     * }
     */
    public static int SF_NOUNLINK() {
        return SF_NOUNLINK;
    }
    private static final int SF_FIRMLINK = (int)8388608L;
    /**
     * {@snippet lang=c :
     * #define SF_FIRMLINK 8388608
     * }
     */
    public static int SF_FIRMLINK() {
        return SF_FIRMLINK;
    }
    private static final int SF_DATALESS = (int)1073741824L;
    /**
     * {@snippet lang=c :
     * #define SF_DATALESS 1073741824
     * }
     */
    public static int SF_DATALESS() {
        return SF_DATALESS;
    }
    private static final int EF_MAY_SHARE_BLOCKS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define EF_MAY_SHARE_BLOCKS 1
     * }
     */
    public static int EF_MAY_SHARE_BLOCKS() {
        return EF_MAY_SHARE_BLOCKS;
    }
    private static final int EF_NO_XATTRS = (int)2L;
    /**
     * {@snippet lang=c :
     * #define EF_NO_XATTRS 2
     * }
     */
    public static int EF_NO_XATTRS() {
        return EF_NO_XATTRS;
    }
    private static final int EF_IS_SYNC_ROOT = (int)4L;
    /**
     * {@snippet lang=c :
     * #define EF_IS_SYNC_ROOT 4
     * }
     */
    public static int EF_IS_SYNC_ROOT() {
        return EF_IS_SYNC_ROOT;
    }
    private static final int EF_IS_PURGEABLE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define EF_IS_PURGEABLE 8
     * }
     */
    public static int EF_IS_PURGEABLE() {
        return EF_IS_PURGEABLE;
    }
    private static final int EF_IS_SPARSE = (int)16L;
    /**
     * {@snippet lang=c :
     * #define EF_IS_SPARSE 16
     * }
     */
    public static int EF_IS_SPARSE() {
        return EF_IS_SPARSE;
    }
    private static final int EF_IS_SYNTHETIC = (int)32L;
    /**
     * {@snippet lang=c :
     * #define EF_IS_SYNTHETIC 32
     * }
     */
    public static int EF_IS_SYNTHETIC() {
        return EF_IS_SYNTHETIC;
    }
    private static final int EF_SHARES_ALL_BLOCKS = (int)64L;
    /**
     * {@snippet lang=c :
     * #define EF_SHARES_ALL_BLOCKS 64
     * }
     */
    public static int EF_SHARES_ALL_BLOCKS() {
        return EF_SHARES_ALL_BLOCKS;
    }
    private static final int PY_BIG_ENDIAN = (int)0L;
    /**
     * {@snippet lang=c :
     * #define PY_BIG_ENDIAN 0
     * }
     */
    public static int PY_BIG_ENDIAN() {
        return PY_BIG_ENDIAN;
    }
    private static final int PY_LITTLE_ENDIAN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PY_LITTLE_ENDIAN 1
     * }
     */
    public static int PY_LITTLE_ENDIAN() {
        return PY_LITTLE_ENDIAN;
    }
    private static final int PyBUF_MAX_NDIM = (int)64L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_MAX_NDIM 64
     * }
     */
    public static int PyBUF_MAX_NDIM() {
        return PyBUF_MAX_NDIM;
    }
    private static final int PyBUF_SIMPLE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_SIMPLE 0
     * }
     */
    public static int PyBUF_SIMPLE() {
        return PyBUF_SIMPLE;
    }
    private static final int PyBUF_WRITABLE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_WRITABLE 1
     * }
     */
    public static int PyBUF_WRITABLE() {
        return PyBUF_WRITABLE;
    }
    private static final int PyBUF_FORMAT = (int)4L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_FORMAT 4
     * }
     */
    public static int PyBUF_FORMAT() {
        return PyBUF_FORMAT;
    }
    private static final int PyBUF_ND = (int)8L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_ND 8
     * }
     */
    public static int PyBUF_ND() {
        return PyBUF_ND;
    }
    private static final int PyBUF_READ = (int)256L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_READ 256
     * }
     */
    public static int PyBUF_READ() {
        return PyBUF_READ;
    }
    private static final int PyBUF_WRITE = (int)512L;
    /**
     * {@snippet lang=c :
     * #define PyBUF_WRITE 512
     * }
     */
    public static int PyBUF_WRITE() {
        return PyBUF_WRITE;
    }
    private static final int Py_PRINT_RAW = (int)1L;
    /**
     * {@snippet lang=c :
     * #define Py_PRINT_RAW 1
     * }
     */
    public static int Py_PRINT_RAW() {
        return Py_PRINT_RAW;
    }
    private static final int Py_TPFLAGS_HAVE_STACKLESS_EXTENSION = (int)0L;
    /**
     * {@snippet lang=c :
     * #define Py_TPFLAGS_HAVE_STACKLESS_EXTENSION 0
     * }
     */
    public static int Py_TPFLAGS_HAVE_STACKLESS_EXTENSION() {
        return Py_TPFLAGS_HAVE_STACKLESS_EXTENSION;
    }
    private static final int Py_LT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define Py_LT 0
     * }
     */
    public static int Py_LT() {
        return Py_LT;
    }
    private static final int Py_LE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define Py_LE 1
     * }
     */
    public static int Py_LE() {
        return Py_LE;
    }
    private static final int Py_EQ = (int)2L;
    /**
     * {@snippet lang=c :
     * #define Py_EQ 2
     * }
     */
    public static int Py_EQ() {
        return Py_EQ;
    }
    private static final int Py_NE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define Py_NE 3
     * }
     */
    public static int Py_NE() {
        return Py_NE;
    }
    private static final int Py_GT = (int)4L;
    /**
     * {@snippet lang=c :
     * #define Py_GT 4
     * }
     */
    public static int Py_GT() {
        return Py_GT;
    }
    private static final int Py_GE = (int)5L;
    /**
     * {@snippet lang=c :
     * #define Py_GE 5
     * }
     */
    public static int Py_GE() {
        return Py_GE;
    }
    private static final int Py_bf_getbuffer = (int)1L;
    /**
     * {@snippet lang=c :
     * #define Py_bf_getbuffer 1
     * }
     */
    public static int Py_bf_getbuffer() {
        return Py_bf_getbuffer;
    }
    private static final int Py_bf_releasebuffer = (int)2L;
    /**
     * {@snippet lang=c :
     * #define Py_bf_releasebuffer 2
     * }
     */
    public static int Py_bf_releasebuffer() {
        return Py_bf_releasebuffer;
    }
    private static final int Py_mp_ass_subscript = (int)3L;
    /**
     * {@snippet lang=c :
     * #define Py_mp_ass_subscript 3
     * }
     */
    public static int Py_mp_ass_subscript() {
        return Py_mp_ass_subscript;
    }
    private static final int Py_mp_length = (int)4L;
    /**
     * {@snippet lang=c :
     * #define Py_mp_length 4
     * }
     */
    public static int Py_mp_length() {
        return Py_mp_length;
    }
    private static final int Py_mp_subscript = (int)5L;
    /**
     * {@snippet lang=c :
     * #define Py_mp_subscript 5
     * }
     */
    public static int Py_mp_subscript() {
        return Py_mp_subscript;
    }
    private static final int Py_nb_absolute = (int)6L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_absolute 6
     * }
     */
    public static int Py_nb_absolute() {
        return Py_nb_absolute;
    }
    private static final int Py_nb_add = (int)7L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_add 7
     * }
     */
    public static int Py_nb_add() {
        return Py_nb_add;
    }
    private static final int Py_nb_and = (int)8L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_and 8
     * }
     */
    public static int Py_nb_and() {
        return Py_nb_and;
    }
    private static final int Py_nb_bool = (int)9L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_bool 9
     * }
     */
    public static int Py_nb_bool() {
        return Py_nb_bool;
    }
    private static final int Py_nb_divmod = (int)10L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_divmod 10
     * }
     */
    public static int Py_nb_divmod() {
        return Py_nb_divmod;
    }
    private static final int Py_nb_float = (int)11L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_float 11
     * }
     */
    public static int Py_nb_float() {
        return Py_nb_float;
    }
    private static final int Py_nb_floor_divide = (int)12L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_floor_divide 12
     * }
     */
    public static int Py_nb_floor_divide() {
        return Py_nb_floor_divide;
    }
    private static final int Py_nb_index = (int)13L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_index 13
     * }
     */
    public static int Py_nb_index() {
        return Py_nb_index;
    }
    private static final int Py_nb_inplace_add = (int)14L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_inplace_add 14
     * }
     */
    public static int Py_nb_inplace_add() {
        return Py_nb_inplace_add;
    }
    private static final int Py_nb_inplace_and = (int)15L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_inplace_and 15
     * }
     */
    public static int Py_nb_inplace_and() {
        return Py_nb_inplace_and;
    }
    private static final int Py_nb_inplace_floor_divide = (int)16L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_inplace_floor_divide 16
     * }
     */
    public static int Py_nb_inplace_floor_divide() {
        return Py_nb_inplace_floor_divide;
    }
    private static final int Py_nb_inplace_lshift = (int)17L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_inplace_lshift 17
     * }
     */
    public static int Py_nb_inplace_lshift() {
        return Py_nb_inplace_lshift;
    }
    private static final int Py_nb_inplace_multiply = (int)18L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_inplace_multiply 18
     * }
     */
    public static int Py_nb_inplace_multiply() {
        return Py_nb_inplace_multiply;
    }
    private static final int Py_nb_inplace_or = (int)19L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_inplace_or 19
     * }
     */
    public static int Py_nb_inplace_or() {
        return Py_nb_inplace_or;
    }
    private static final int Py_nb_inplace_power = (int)20L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_inplace_power 20
     * }
     */
    public static int Py_nb_inplace_power() {
        return Py_nb_inplace_power;
    }
    private static final int Py_nb_inplace_remainder = (int)21L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_inplace_remainder 21
     * }
     */
    public static int Py_nb_inplace_remainder() {
        return Py_nb_inplace_remainder;
    }
    private static final int Py_nb_inplace_rshift = (int)22L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_inplace_rshift 22
     * }
     */
    public static int Py_nb_inplace_rshift() {
        return Py_nb_inplace_rshift;
    }
    private static final int Py_nb_inplace_subtract = (int)23L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_inplace_subtract 23
     * }
     */
    public static int Py_nb_inplace_subtract() {
        return Py_nb_inplace_subtract;
    }
    private static final int Py_nb_inplace_true_divide = (int)24L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_inplace_true_divide 24
     * }
     */
    public static int Py_nb_inplace_true_divide() {
        return Py_nb_inplace_true_divide;
    }
    private static final int Py_nb_inplace_xor = (int)25L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_inplace_xor 25
     * }
     */
    public static int Py_nb_inplace_xor() {
        return Py_nb_inplace_xor;
    }
    private static final int Py_nb_int = (int)26L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_int 26
     * }
     */
    public static int Py_nb_int() {
        return Py_nb_int;
    }
    private static final int Py_nb_invert = (int)27L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_invert 27
     * }
     */
    public static int Py_nb_invert() {
        return Py_nb_invert;
    }
    private static final int Py_nb_lshift = (int)28L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_lshift 28
     * }
     */
    public static int Py_nb_lshift() {
        return Py_nb_lshift;
    }
    private static final int Py_nb_multiply = (int)29L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_multiply 29
     * }
     */
    public static int Py_nb_multiply() {
        return Py_nb_multiply;
    }
    private static final int Py_nb_negative = (int)30L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_negative 30
     * }
     */
    public static int Py_nb_negative() {
        return Py_nb_negative;
    }
    private static final int Py_nb_or = (int)31L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_or 31
     * }
     */
    public static int Py_nb_or() {
        return Py_nb_or;
    }
    private static final int Py_nb_positive = (int)32L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_positive 32
     * }
     */
    public static int Py_nb_positive() {
        return Py_nb_positive;
    }
    private static final int Py_nb_power = (int)33L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_power 33
     * }
     */
    public static int Py_nb_power() {
        return Py_nb_power;
    }
    private static final int Py_nb_remainder = (int)34L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_remainder 34
     * }
     */
    public static int Py_nb_remainder() {
        return Py_nb_remainder;
    }
    private static final int Py_nb_rshift = (int)35L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_rshift 35
     * }
     */
    public static int Py_nb_rshift() {
        return Py_nb_rshift;
    }
    private static final int Py_nb_subtract = (int)36L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_subtract 36
     * }
     */
    public static int Py_nb_subtract() {
        return Py_nb_subtract;
    }
    private static final int Py_nb_true_divide = (int)37L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_true_divide 37
     * }
     */
    public static int Py_nb_true_divide() {
        return Py_nb_true_divide;
    }
    private static final int Py_nb_xor = (int)38L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_xor 38
     * }
     */
    public static int Py_nb_xor() {
        return Py_nb_xor;
    }
    private static final int Py_sq_ass_item = (int)39L;
    /**
     * {@snippet lang=c :
     * #define Py_sq_ass_item 39
     * }
     */
    public static int Py_sq_ass_item() {
        return Py_sq_ass_item;
    }
    private static final int Py_sq_concat = (int)40L;
    /**
     * {@snippet lang=c :
     * #define Py_sq_concat 40
     * }
     */
    public static int Py_sq_concat() {
        return Py_sq_concat;
    }
    private static final int Py_sq_contains = (int)41L;
    /**
     * {@snippet lang=c :
     * #define Py_sq_contains 41
     * }
     */
    public static int Py_sq_contains() {
        return Py_sq_contains;
    }
    private static final int Py_sq_inplace_concat = (int)42L;
    /**
     * {@snippet lang=c :
     * #define Py_sq_inplace_concat 42
     * }
     */
    public static int Py_sq_inplace_concat() {
        return Py_sq_inplace_concat;
    }
    private static final int Py_sq_inplace_repeat = (int)43L;
    /**
     * {@snippet lang=c :
     * #define Py_sq_inplace_repeat 43
     * }
     */
    public static int Py_sq_inplace_repeat() {
        return Py_sq_inplace_repeat;
    }
    private static final int Py_sq_item = (int)44L;
    /**
     * {@snippet lang=c :
     * #define Py_sq_item 44
     * }
     */
    public static int Py_sq_item() {
        return Py_sq_item;
    }
    private static final int Py_sq_length = (int)45L;
    /**
     * {@snippet lang=c :
     * #define Py_sq_length 45
     * }
     */
    public static int Py_sq_length() {
        return Py_sq_length;
    }
    private static final int Py_sq_repeat = (int)46L;
    /**
     * {@snippet lang=c :
     * #define Py_sq_repeat 46
     * }
     */
    public static int Py_sq_repeat() {
        return Py_sq_repeat;
    }
    private static final int Py_tp_alloc = (int)47L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_alloc 47
     * }
     */
    public static int Py_tp_alloc() {
        return Py_tp_alloc;
    }
    private static final int Py_tp_base = (int)48L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_base 48
     * }
     */
    public static int Py_tp_base() {
        return Py_tp_base;
    }
    private static final int Py_tp_bases = (int)49L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_bases 49
     * }
     */
    public static int Py_tp_bases() {
        return Py_tp_bases;
    }
    private static final int Py_tp_call = (int)50L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_call 50
     * }
     */
    public static int Py_tp_call() {
        return Py_tp_call;
    }
    private static final int Py_tp_clear = (int)51L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_clear 51
     * }
     */
    public static int Py_tp_clear() {
        return Py_tp_clear;
    }
    private static final int Py_tp_dealloc = (int)52L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_dealloc 52
     * }
     */
    public static int Py_tp_dealloc() {
        return Py_tp_dealloc;
    }
    private static final int Py_tp_del = (int)53L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_del 53
     * }
     */
    public static int Py_tp_del() {
        return Py_tp_del;
    }
    private static final int Py_tp_descr_get = (int)54L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_descr_get 54
     * }
     */
    public static int Py_tp_descr_get() {
        return Py_tp_descr_get;
    }
    private static final int Py_tp_descr_set = (int)55L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_descr_set 55
     * }
     */
    public static int Py_tp_descr_set() {
        return Py_tp_descr_set;
    }
    private static final int Py_tp_doc = (int)56L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_doc 56
     * }
     */
    public static int Py_tp_doc() {
        return Py_tp_doc;
    }
    private static final int Py_tp_getattr = (int)57L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_getattr 57
     * }
     */
    public static int Py_tp_getattr() {
        return Py_tp_getattr;
    }
    private static final int Py_tp_getattro = (int)58L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_getattro 58
     * }
     */
    public static int Py_tp_getattro() {
        return Py_tp_getattro;
    }
    private static final int Py_tp_hash = (int)59L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_hash 59
     * }
     */
    public static int Py_tp_hash() {
        return Py_tp_hash;
    }
    private static final int Py_tp_init = (int)60L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_init 60
     * }
     */
    public static int Py_tp_init() {
        return Py_tp_init;
    }
    private static final int Py_tp_is_gc = (int)61L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_is_gc 61
     * }
     */
    public static int Py_tp_is_gc() {
        return Py_tp_is_gc;
    }
    private static final int Py_tp_iter = (int)62L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_iter 62
     * }
     */
    public static int Py_tp_iter() {
        return Py_tp_iter;
    }
    private static final int Py_tp_iternext = (int)63L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_iternext 63
     * }
     */
    public static int Py_tp_iternext() {
        return Py_tp_iternext;
    }
    private static final int Py_tp_methods = (int)64L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_methods 64
     * }
     */
    public static int Py_tp_methods() {
        return Py_tp_methods;
    }
    private static final int Py_tp_new = (int)65L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_new 65
     * }
     */
    public static int Py_tp_new() {
        return Py_tp_new;
    }
    private static final int Py_tp_repr = (int)66L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_repr 66
     * }
     */
    public static int Py_tp_repr() {
        return Py_tp_repr;
    }
    private static final int Py_tp_richcompare = (int)67L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_richcompare 67
     * }
     */
    public static int Py_tp_richcompare() {
        return Py_tp_richcompare;
    }
    private static final int Py_tp_setattr = (int)68L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_setattr 68
     * }
     */
    public static int Py_tp_setattr() {
        return Py_tp_setattr;
    }
    private static final int Py_tp_setattro = (int)69L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_setattro 69
     * }
     */
    public static int Py_tp_setattro() {
        return Py_tp_setattro;
    }
    private static final int Py_tp_str = (int)70L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_str 70
     * }
     */
    public static int Py_tp_str() {
        return Py_tp_str;
    }
    private static final int Py_tp_traverse = (int)71L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_traverse 71
     * }
     */
    public static int Py_tp_traverse() {
        return Py_tp_traverse;
    }
    private static final int Py_tp_members = (int)72L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_members 72
     * }
     */
    public static int Py_tp_members() {
        return Py_tp_members;
    }
    private static final int Py_tp_getset = (int)73L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_getset 73
     * }
     */
    public static int Py_tp_getset() {
        return Py_tp_getset;
    }
    private static final int Py_tp_free = (int)74L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_free 74
     * }
     */
    public static int Py_tp_free() {
        return Py_tp_free;
    }
    private static final int Py_nb_matrix_multiply = (int)75L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_matrix_multiply 75
     * }
     */
    public static int Py_nb_matrix_multiply() {
        return Py_nb_matrix_multiply;
    }
    private static final int Py_nb_inplace_matrix_multiply = (int)76L;
    /**
     * {@snippet lang=c :
     * #define Py_nb_inplace_matrix_multiply 76
     * }
     */
    public static int Py_nb_inplace_matrix_multiply() {
        return Py_nb_inplace_matrix_multiply;
    }
    private static final int Py_am_await = (int)77L;
    /**
     * {@snippet lang=c :
     * #define Py_am_await 77
     * }
     */
    public static int Py_am_await() {
        return Py_am_await;
    }
    private static final int Py_am_aiter = (int)78L;
    /**
     * {@snippet lang=c :
     * #define Py_am_aiter 78
     * }
     */
    public static int Py_am_aiter() {
        return Py_am_aiter;
    }
    private static final int Py_am_anext = (int)79L;
    /**
     * {@snippet lang=c :
     * #define Py_am_anext 79
     * }
     */
    public static int Py_am_anext() {
        return Py_am_anext;
    }
    private static final int Py_tp_finalize = (int)80L;
    /**
     * {@snippet lang=c :
     * #define Py_tp_finalize 80
     * }
     */
    public static int Py_tp_finalize() {
        return Py_tp_finalize;
    }
    private static final int Py_am_send = (int)81L;
    /**
     * {@snippet lang=c :
     * #define Py_am_send 81
     * }
     */
    public static int Py_am_send() {
        return Py_am_send;
    }
    private static final int _PyHASH_BITS = (int)61L;
    /**
     * {@snippet lang=c :
     * #define _PyHASH_BITS 61
     * }
     */
    public static int _PyHASH_BITS() {
        return _PyHASH_BITS;
    }
    private static final int _PyHASH_INF = (int)314159L;
    /**
     * {@snippet lang=c :
     * #define _PyHASH_INF 314159
     * }
     */
    public static int _PyHASH_INF() {
        return _PyHASH_INF;
    }
    private static final int Py_HASH_CUTOFF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define Py_HASH_CUTOFF 0
     * }
     */
    public static int Py_HASH_CUTOFF() {
        return Py_HASH_CUTOFF;
    }
    private static final int Py_HASH_EXTERNAL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define Py_HASH_EXTERNAL 0
     * }
     */
    public static int Py_HASH_EXTERNAL() {
        return Py_HASH_EXTERNAL;
    }
    private static final int Py_HASH_SIPHASH24 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define Py_HASH_SIPHASH24 1
     * }
     */
    public static int Py_HASH_SIPHASH24() {
        return Py_HASH_SIPHASH24;
    }
    private static final int Py_HASH_FNV = (int)2L;
    /**
     * {@snippet lang=c :
     * #define Py_HASH_FNV 2
     * }
     */
    public static int Py_HASH_FNV() {
        return Py_HASH_FNV;
    }
    private static final int Py_HASH_SIPHASH13 = (int)3L;
    /**
     * {@snippet lang=c :
     * #define Py_HASH_SIPHASH13 3
     * }
     */
    public static int Py_HASH_SIPHASH13() {
        return Py_HASH_SIPHASH13;
    }
    private static final int USE_UNICODE_WCHAR_CACHE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define USE_UNICODE_WCHAR_CACHE 1
     * }
     */
    public static int USE_UNICODE_WCHAR_CACHE() {
        return USE_UNICODE_WCHAR_CACHE;
    }
    private static final int SSTATE_NOT_INTERNED = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SSTATE_NOT_INTERNED 0
     * }
     */
    public static int SSTATE_NOT_INTERNED() {
        return SSTATE_NOT_INTERNED;
    }
    private static final int SSTATE_INTERNED_MORTAL = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SSTATE_INTERNED_MORTAL 1
     * }
     */
    public static int SSTATE_INTERNED_MORTAL() {
        return SSTATE_INTERNED_MORTAL;
    }
    private static final int SSTATE_INTERNED_IMMORTAL = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SSTATE_INTERNED_IMMORTAL 2
     * }
     */
    public static int SSTATE_INTERNED_IMMORTAL() {
        return SSTATE_INTERNED_IMMORTAL;
    }
    private static final int PyLong_SHIFT = (int)30L;
    /**
     * {@snippet lang=c :
     * #define PyLong_SHIFT 30
     * }
     */
    public static int PyLong_SHIFT() {
        return PyLong_SHIFT;
    }
    private static final int _PyLong_DECIMAL_SHIFT = (int)9L;
    /**
     * {@snippet lang=c :
     * #define _PyLong_DECIMAL_SHIFT 9
     * }
     */
    public static int _PyLong_DECIMAL_SHIFT() {
        return _PyLong_DECIMAL_SHIFT;
    }
    private static final int _Py_MANAGED_BUFFER_RELEASED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _Py_MANAGED_BUFFER_RELEASED 1
     * }
     */
    public static int _Py_MANAGED_BUFFER_RELEASED() {
        return _Py_MANAGED_BUFFER_RELEASED;
    }
    private static final int _Py_MANAGED_BUFFER_FREE_FORMAT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _Py_MANAGED_BUFFER_FREE_FORMAT 2
     * }
     */
    public static int _Py_MANAGED_BUFFER_FREE_FORMAT() {
        return _Py_MANAGED_BUFFER_FREE_FORMAT;
    }
    private static final int _Py_MEMORYVIEW_RELEASED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _Py_MEMORYVIEW_RELEASED 1
     * }
     */
    public static int _Py_MEMORYVIEW_RELEASED() {
        return _Py_MEMORYVIEW_RELEASED;
    }
    private static final int _Py_MEMORYVIEW_C = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _Py_MEMORYVIEW_C 2
     * }
     */
    public static int _Py_MEMORYVIEW_C() {
        return _Py_MEMORYVIEW_C;
    }
    private static final int _Py_MEMORYVIEW_FORTRAN = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _Py_MEMORYVIEW_FORTRAN 4
     * }
     */
    public static int _Py_MEMORYVIEW_FORTRAN() {
        return _Py_MEMORYVIEW_FORTRAN;
    }
    private static final int _Py_MEMORYVIEW_SCALAR = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _Py_MEMORYVIEW_SCALAR 8
     * }
     */
    public static int _Py_MEMORYVIEW_SCALAR() {
        return _Py_MEMORYVIEW_SCALAR;
    }
    private static final int _Py_MEMORYVIEW_PIL = (int)16L;
    /**
     * {@snippet lang=c :
     * #define _Py_MEMORYVIEW_PIL 16
     * }
     */
    public static int _Py_MEMORYVIEW_PIL() {
        return _Py_MEMORYVIEW_PIL;
    }
    private static final int PySet_MINSIZE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define PySet_MINSIZE 8
     * }
     */
    public static int PySet_MINSIZE() {
        return PySet_MINSIZE;
    }
    private static final int METH_VARARGS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define METH_VARARGS 1
     * }
     */
    public static int METH_VARARGS() {
        return METH_VARARGS;
    }
    private static final int METH_KEYWORDS = (int)2L;
    /**
     * {@snippet lang=c :
     * #define METH_KEYWORDS 2
     * }
     */
    public static int METH_KEYWORDS() {
        return METH_KEYWORDS;
    }
    private static final int METH_NOARGS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define METH_NOARGS 4
     * }
     */
    public static int METH_NOARGS() {
        return METH_NOARGS;
    }
    private static final int METH_O = (int)8L;
    /**
     * {@snippet lang=c :
     * #define METH_O 8
     * }
     */
    public static int METH_O() {
        return METH_O;
    }
    private static final int METH_CLASS = (int)16L;
    /**
     * {@snippet lang=c :
     * #define METH_CLASS 16
     * }
     */
    public static int METH_CLASS() {
        return METH_CLASS;
    }
    private static final int METH_STATIC = (int)32L;
    /**
     * {@snippet lang=c :
     * #define METH_STATIC 32
     * }
     */
    public static int METH_STATIC() {
        return METH_STATIC;
    }
    private static final int METH_COEXIST = (int)64L;
    /**
     * {@snippet lang=c :
     * #define METH_COEXIST 64
     * }
     */
    public static int METH_COEXIST() {
        return METH_COEXIST;
    }
    private static final int METH_FASTCALL = (int)128L;
    /**
     * {@snippet lang=c :
     * #define METH_FASTCALL 128
     * }
     */
    public static int METH_FASTCALL() {
        return METH_FASTCALL;
    }
    private static final int METH_STACKLESS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define METH_STACKLESS 0
     * }
     */
    public static int METH_STACKLESS() {
        return METH_STACKLESS;
    }
    private static final int METH_METHOD = (int)512L;
    /**
     * {@snippet lang=c :
     * #define METH_METHOD 512
     * }
     */
    public static int METH_METHOD() {
        return METH_METHOD;
    }
    private static final int Py_mod_create = (int)1L;
    /**
     * {@snippet lang=c :
     * #define Py_mod_create 1
     * }
     */
    public static int Py_mod_create() {
        return Py_mod_create;
    }
    private static final int Py_mod_exec = (int)2L;
    /**
     * {@snippet lang=c :
     * #define Py_mod_exec 2
     * }
     */
    public static int Py_mod_exec() {
        return Py_mod_exec;
    }
    private static final int _Py_mod_LAST_SLOT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _Py_mod_LAST_SLOT 2
     * }
     */
    public static int _Py_mod_LAST_SLOT() {
        return _Py_mod_LAST_SLOT;
    }
    private static final int CO_OPTIMIZED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CO_OPTIMIZED 1
     * }
     */
    public static int CO_OPTIMIZED() {
        return CO_OPTIMIZED;
    }
    private static final int CO_NEWLOCALS = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CO_NEWLOCALS 2
     * }
     */
    public static int CO_NEWLOCALS() {
        return CO_NEWLOCALS;
    }
    private static final int CO_VARARGS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define CO_VARARGS 4
     * }
     */
    public static int CO_VARARGS() {
        return CO_VARARGS;
    }
    private static final int CO_VARKEYWORDS = (int)8L;
    /**
     * {@snippet lang=c :
     * #define CO_VARKEYWORDS 8
     * }
     */
    public static int CO_VARKEYWORDS() {
        return CO_VARKEYWORDS;
    }
    private static final int CO_NESTED = (int)16L;
    /**
     * {@snippet lang=c :
     * #define CO_NESTED 16
     * }
     */
    public static int CO_NESTED() {
        return CO_NESTED;
    }
    private static final int CO_GENERATOR = (int)32L;
    /**
     * {@snippet lang=c :
     * #define CO_GENERATOR 32
     * }
     */
    public static int CO_GENERATOR() {
        return CO_GENERATOR;
    }
    private static final int CO_COROUTINE = (int)128L;
    /**
     * {@snippet lang=c :
     * #define CO_COROUTINE 128
     * }
     */
    public static int CO_COROUTINE() {
        return CO_COROUTINE;
    }
    private static final int CO_ITERABLE_COROUTINE = (int)256L;
    /**
     * {@snippet lang=c :
     * #define CO_ITERABLE_COROUTINE 256
     * }
     */
    public static int CO_ITERABLE_COROUTINE() {
        return CO_ITERABLE_COROUTINE;
    }
    private static final int CO_ASYNC_GENERATOR = (int)512L;
    /**
     * {@snippet lang=c :
     * #define CO_ASYNC_GENERATOR 512
     * }
     */
    public static int CO_ASYNC_GENERATOR() {
        return CO_ASYNC_GENERATOR;
    }
    private static final int CO_FUTURE_DIVISION = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define CO_FUTURE_DIVISION 131072
     * }
     */
    public static int CO_FUTURE_DIVISION() {
        return CO_FUTURE_DIVISION;
    }
    private static final int CO_FUTURE_ABSOLUTE_IMPORT = (int)262144L;
    /**
     * {@snippet lang=c :
     * #define CO_FUTURE_ABSOLUTE_IMPORT 262144
     * }
     */
    public static int CO_FUTURE_ABSOLUTE_IMPORT() {
        return CO_FUTURE_ABSOLUTE_IMPORT;
    }
    private static final int CO_FUTURE_WITH_STATEMENT = (int)524288L;
    /**
     * {@snippet lang=c :
     * #define CO_FUTURE_WITH_STATEMENT 524288
     * }
     */
    public static int CO_FUTURE_WITH_STATEMENT() {
        return CO_FUTURE_WITH_STATEMENT;
    }
    private static final int CO_FUTURE_PRINT_FUNCTION = (int)1048576L;
    /**
     * {@snippet lang=c :
     * #define CO_FUTURE_PRINT_FUNCTION 1048576
     * }
     */
    public static int CO_FUTURE_PRINT_FUNCTION() {
        return CO_FUTURE_PRINT_FUNCTION;
    }
    private static final int CO_FUTURE_UNICODE_LITERALS = (int)2097152L;
    /**
     * {@snippet lang=c :
     * #define CO_FUTURE_UNICODE_LITERALS 2097152
     * }
     */
    public static int CO_FUTURE_UNICODE_LITERALS() {
        return CO_FUTURE_UNICODE_LITERALS;
    }
    private static final int CO_FUTURE_BARRY_AS_BDFL = (int)4194304L;
    /**
     * {@snippet lang=c :
     * #define CO_FUTURE_BARRY_AS_BDFL 4194304
     * }
     */
    public static int CO_FUTURE_BARRY_AS_BDFL() {
        return CO_FUTURE_BARRY_AS_BDFL;
    }
    private static final int CO_FUTURE_GENERATOR_STOP = (int)8388608L;
    /**
     * {@snippet lang=c :
     * #define CO_FUTURE_GENERATOR_STOP 8388608
     * }
     */
    public static int CO_FUTURE_GENERATOR_STOP() {
        return CO_FUTURE_GENERATOR_STOP;
    }
    private static final int CO_FUTURE_ANNOTATIONS = (int)16777216L;
    /**
     * {@snippet lang=c :
     * #define CO_FUTURE_ANNOTATIONS 16777216
     * }
     */
    public static int CO_FUTURE_ANNOTATIONS() {
        return CO_FUTURE_ANNOTATIONS;
    }
    private static final int CO_MAXBLOCKS = (int)20L;
    /**
     * {@snippet lang=c :
     * #define CO_MAXBLOCKS 20
     * }
     */
    public static int CO_MAXBLOCKS() {
        return CO_MAXBLOCKS;
    }
    private static final int MAX_CO_EXTRA_USERS = (int)255L;
    /**
     * {@snippet lang=c :
     * #define MAX_CO_EXTRA_USERS 255
     * }
     */
    public static int MAX_CO_EXTRA_USERS() {
        return MAX_CO_EXTRA_USERS;
    }
    private static final int PyTrace_CALL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define PyTrace_CALL 0
     * }
     */
    public static int PyTrace_CALL() {
        return PyTrace_CALL;
    }
    private static final int PyTrace_EXCEPTION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PyTrace_EXCEPTION 1
     * }
     */
    public static int PyTrace_EXCEPTION() {
        return PyTrace_EXCEPTION;
    }
    private static final int PyTrace_LINE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define PyTrace_LINE 2
     * }
     */
    public static int PyTrace_LINE() {
        return PyTrace_LINE;
    }
    private static final int PyTrace_RETURN = (int)3L;
    /**
     * {@snippet lang=c :
     * #define PyTrace_RETURN 3
     * }
     */
    public static int PyTrace_RETURN() {
        return PyTrace_RETURN;
    }
    private static final int PyTrace_C_CALL = (int)4L;
    /**
     * {@snippet lang=c :
     * #define PyTrace_C_CALL 4
     * }
     */
    public static int PyTrace_C_CALL() {
        return PyTrace_C_CALL;
    }
    private static final int PyTrace_C_EXCEPTION = (int)5L;
    /**
     * {@snippet lang=c :
     * #define PyTrace_C_EXCEPTION 5
     * }
     */
    public static int PyTrace_C_EXCEPTION() {
        return PyTrace_C_EXCEPTION;
    }
    private static final int PyTrace_C_RETURN = (int)6L;
    /**
     * {@snippet lang=c :
     * #define PyTrace_C_RETURN 6
     * }
     */
    public static int PyTrace_C_RETURN() {
        return PyTrace_C_RETURN;
    }
    private static final int PyTrace_OPCODE = (int)7L;
    /**
     * {@snippet lang=c :
     * #define PyTrace_OPCODE 7
     * }
     */
    public static int PyTrace_OPCODE() {
        return PyTrace_OPCODE;
    }
    private static final int PyWrapperFlag_KEYWORDS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PyWrapperFlag_KEYWORDS 1
     * }
     */
    public static int PyWrapperFlag_KEYWORDS() {
        return PyWrapperFlag_KEYWORDS;
    }
    private static final int _SIZEOF_PYTIME_T = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _SIZEOF_PYTIME_T 8
     * }
     */
    public static int _SIZEOF_PYTIME_T() {
        return _SIZEOF_PYTIME_T;
    }
    private static final int WAIT_LOCK = (int)1L;
    /**
     * {@snippet lang=c :
     * #define WAIT_LOCK 1
     * }
     */
    public static int WAIT_LOCK() {
        return WAIT_LOCK;
    }
    private static final int NOWAIT_LOCK = (int)0L;
    /**
     * {@snippet lang=c :
     * #define NOWAIT_LOCK 0
     * }
     */
    public static int NOWAIT_LOCK() {
        return NOWAIT_LOCK;
    }
    private static final int _PTHREAD_MUTEX_SIG_init = (int)850045863L;
    /**
     * {@snippet lang=c :
     * #define _PTHREAD_MUTEX_SIG_init 850045863
     * }
     */
    public static int _PTHREAD_MUTEX_SIG_init() {
        return _PTHREAD_MUTEX_SIG_init;
    }
    private static final int _PTHREAD_ERRORCHECK_MUTEX_SIG_init = (int)850045857L;
    /**
     * {@snippet lang=c :
     * #define _PTHREAD_ERRORCHECK_MUTEX_SIG_init 850045857
     * }
     */
    public static int _PTHREAD_ERRORCHECK_MUTEX_SIG_init() {
        return _PTHREAD_ERRORCHECK_MUTEX_SIG_init;
    }
    private static final int _PTHREAD_RECURSIVE_MUTEX_SIG_init = (int)850045858L;
    /**
     * {@snippet lang=c :
     * #define _PTHREAD_RECURSIVE_MUTEX_SIG_init 850045858
     * }
     */
    public static int _PTHREAD_RECURSIVE_MUTEX_SIG_init() {
        return _PTHREAD_RECURSIVE_MUTEX_SIG_init;
    }
    private static final int _PTHREAD_FIRSTFIT_MUTEX_SIG_init = (int)850045859L;
    /**
     * {@snippet lang=c :
     * #define _PTHREAD_FIRSTFIT_MUTEX_SIG_init 850045859
     * }
     */
    public static int _PTHREAD_FIRSTFIT_MUTEX_SIG_init() {
        return _PTHREAD_FIRSTFIT_MUTEX_SIG_init;
    }
    private static final int _PTHREAD_COND_SIG_init = (int)1018212795L;
    /**
     * {@snippet lang=c :
     * #define _PTHREAD_COND_SIG_init 1018212795
     * }
     */
    public static int _PTHREAD_COND_SIG_init() {
        return _PTHREAD_COND_SIG_init;
    }
    private static final int _PTHREAD_ONCE_SIG_init = (int)816954554L;
    /**
     * {@snippet lang=c :
     * #define _PTHREAD_ONCE_SIG_init 816954554
     * }
     */
    public static int _PTHREAD_ONCE_SIG_init() {
        return _PTHREAD_ONCE_SIG_init;
    }
    private static final int _PTHREAD_RWLOCK_SIG_init = (int)766030772L;
    /**
     * {@snippet lang=c :
     * #define _PTHREAD_RWLOCK_SIG_init 766030772
     * }
     */
    public static int _PTHREAD_RWLOCK_SIG_init() {
        return _PTHREAD_RWLOCK_SIG_init;
    }
    private static final int SCHED_OTHER = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SCHED_OTHER 1
     * }
     */
    public static int SCHED_OTHER() {
        return SCHED_OTHER;
    }
    private static final int SCHED_FIFO = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SCHED_FIFO 4
     * }
     */
    public static int SCHED_FIFO() {
        return SCHED_FIFO;
    }
    private static final int SCHED_RR = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SCHED_RR 2
     * }
     */
    public static int SCHED_RR() {
        return SCHED_RR;
    }
    private static final int __SCHED_PARAM_SIZE__ = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SCHED_PARAM_SIZE__ 4
     * }
     */
    public static int __SCHED_PARAM_SIZE__() {
        return __SCHED_PARAM_SIZE__;
    }
    private static final int PTHREAD_CREATE_JOINABLE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_CREATE_JOINABLE 1
     * }
     */
    public static int PTHREAD_CREATE_JOINABLE() {
        return PTHREAD_CREATE_JOINABLE;
    }
    private static final int PTHREAD_CREATE_DETACHED = (int)2L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_CREATE_DETACHED 2
     * }
     */
    public static int PTHREAD_CREATE_DETACHED() {
        return PTHREAD_CREATE_DETACHED;
    }
    private static final int PTHREAD_INHERIT_SCHED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_INHERIT_SCHED 1
     * }
     */
    public static int PTHREAD_INHERIT_SCHED() {
        return PTHREAD_INHERIT_SCHED;
    }
    private static final int PTHREAD_EXPLICIT_SCHED = (int)2L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_EXPLICIT_SCHED 2
     * }
     */
    public static int PTHREAD_EXPLICIT_SCHED() {
        return PTHREAD_EXPLICIT_SCHED;
    }
    private static final int PTHREAD_CANCEL_ENABLE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_CANCEL_ENABLE 1
     * }
     */
    public static int PTHREAD_CANCEL_ENABLE() {
        return PTHREAD_CANCEL_ENABLE;
    }
    private static final int PTHREAD_CANCEL_DISABLE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_CANCEL_DISABLE 0
     * }
     */
    public static int PTHREAD_CANCEL_DISABLE() {
        return PTHREAD_CANCEL_DISABLE;
    }
    private static final int PTHREAD_CANCEL_DEFERRED = (int)2L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_CANCEL_DEFERRED 2
     * }
     */
    public static int PTHREAD_CANCEL_DEFERRED() {
        return PTHREAD_CANCEL_DEFERRED;
    }
    private static final int PTHREAD_CANCEL_ASYNCHRONOUS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_CANCEL_ASYNCHRONOUS 0
     * }
     */
    public static int PTHREAD_CANCEL_ASYNCHRONOUS() {
        return PTHREAD_CANCEL_ASYNCHRONOUS;
    }
    private static final int PTHREAD_SCOPE_SYSTEM = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_SCOPE_SYSTEM 1
     * }
     */
    public static int PTHREAD_SCOPE_SYSTEM() {
        return PTHREAD_SCOPE_SYSTEM;
    }
    private static final int PTHREAD_SCOPE_PROCESS = (int)2L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_SCOPE_PROCESS 2
     * }
     */
    public static int PTHREAD_SCOPE_PROCESS() {
        return PTHREAD_SCOPE_PROCESS;
    }
    private static final int PTHREAD_PROCESS_SHARED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_PROCESS_SHARED 1
     * }
     */
    public static int PTHREAD_PROCESS_SHARED() {
        return PTHREAD_PROCESS_SHARED;
    }
    private static final int PTHREAD_PROCESS_PRIVATE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_PROCESS_PRIVATE 2
     * }
     */
    public static int PTHREAD_PROCESS_PRIVATE() {
        return PTHREAD_PROCESS_PRIVATE;
    }
    private static final int PTHREAD_PRIO_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_PRIO_NONE 0
     * }
     */
    public static int PTHREAD_PRIO_NONE() {
        return PTHREAD_PRIO_NONE;
    }
    private static final int PTHREAD_PRIO_INHERIT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_PRIO_INHERIT 1
     * }
     */
    public static int PTHREAD_PRIO_INHERIT() {
        return PTHREAD_PRIO_INHERIT;
    }
    private static final int PTHREAD_PRIO_PROTECT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_PRIO_PROTECT 2
     * }
     */
    public static int PTHREAD_PRIO_PROTECT() {
        return PTHREAD_PRIO_PROTECT;
    }
    private static final int PTHREAD_MUTEX_NORMAL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_MUTEX_NORMAL 0
     * }
     */
    public static int PTHREAD_MUTEX_NORMAL() {
        return PTHREAD_MUTEX_NORMAL;
    }
    private static final int PTHREAD_MUTEX_ERRORCHECK = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_MUTEX_ERRORCHECK 1
     * }
     */
    public static int PTHREAD_MUTEX_ERRORCHECK() {
        return PTHREAD_MUTEX_ERRORCHECK;
    }
    private static final int PTHREAD_MUTEX_RECURSIVE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_MUTEX_RECURSIVE 2
     * }
     */
    public static int PTHREAD_MUTEX_RECURSIVE() {
        return PTHREAD_MUTEX_RECURSIVE;
    }
    private static final int PTHREAD_MUTEX_POLICY_FAIRSHARE_NP = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_MUTEX_POLICY_FAIRSHARE_NP 1
     * }
     */
    public static int PTHREAD_MUTEX_POLICY_FAIRSHARE_NP() {
        return PTHREAD_MUTEX_POLICY_FAIRSHARE_NP;
    }
    private static final int PTHREAD_MUTEX_POLICY_FIRSTFIT_NP = (int)3L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_MUTEX_POLICY_FIRSTFIT_NP 3
     * }
     */
    public static int PTHREAD_MUTEX_POLICY_FIRSTFIT_NP() {
        return PTHREAD_MUTEX_POLICY_FIRSTFIT_NP;
    }
    private static final int Py_CLEANUP_SUPPORTED = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define Py_CLEANUP_SUPPORTED 131072
     * }
     */
    public static int Py_CLEANUP_SUPPORTED() {
        return Py_CLEANUP_SUPPORTED;
    }
    private static final int PYTHON_API_VERSION = (int)1013L;
    /**
     * {@snippet lang=c :
     * #define PYTHON_API_VERSION 1013
     * }
     */
    public static int PYTHON_API_VERSION() {
        return PYTHON_API_VERSION;
    }
    private static final int PYTHON_ABI_VERSION = (int)3L;
    /**
     * {@snippet lang=c :
     * #define PYTHON_ABI_VERSION 3
     * }
     */
    public static int PYTHON_ABI_VERSION() {
        return PYTHON_ABI_VERSION;
    }
    private static final int Py_single_input = (int)256L;
    /**
     * {@snippet lang=c :
     * #define Py_single_input 256
     * }
     */
    public static int Py_single_input() {
        return Py_single_input;
    }
    private static final int Py_file_input = (int)257L;
    /**
     * {@snippet lang=c :
     * #define Py_file_input 257
     * }
     */
    public static int Py_file_input() {
        return Py_file_input;
    }
    private static final int Py_eval_input = (int)258L;
    /**
     * {@snippet lang=c :
     * #define Py_eval_input 258
     * }
     */
    public static int Py_eval_input() {
        return Py_eval_input;
    }
    private static final int Py_func_type_input = (int)345L;
    /**
     * {@snippet lang=c :
     * #define Py_func_type_input 345
     * }
     */
    public static int Py_func_type_input() {
        return Py_func_type_input;
    }
    private static final int Py_fstring_input = (int)800L;
    /**
     * {@snippet lang=c :
     * #define Py_fstring_input 800
     * }
     */
    public static int Py_fstring_input() {
        return Py_fstring_input;
    }
    private static final int PyCF_SOURCE_IS_UTF8 = (int)256L;
    /**
     * {@snippet lang=c :
     * #define PyCF_SOURCE_IS_UTF8 256
     * }
     */
    public static int PyCF_SOURCE_IS_UTF8() {
        return PyCF_SOURCE_IS_UTF8;
    }
    private static final int PyCF_DONT_IMPLY_DEDENT = (int)512L;
    /**
     * {@snippet lang=c :
     * #define PyCF_DONT_IMPLY_DEDENT 512
     * }
     */
    public static int PyCF_DONT_IMPLY_DEDENT() {
        return PyCF_DONT_IMPLY_DEDENT;
    }
    private static final int PyCF_ONLY_AST = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define PyCF_ONLY_AST 1024
     * }
     */
    public static int PyCF_ONLY_AST() {
        return PyCF_ONLY_AST;
    }
    private static final int PyCF_IGNORE_COOKIE = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define PyCF_IGNORE_COOKIE 2048
     * }
     */
    public static int PyCF_IGNORE_COOKIE() {
        return PyCF_IGNORE_COOKIE;
    }
    private static final int PyCF_TYPE_COMMENTS = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define PyCF_TYPE_COMMENTS 4096
     * }
     */
    public static int PyCF_TYPE_COMMENTS() {
        return PyCF_TYPE_COMMENTS;
    }
    private static final int PyCF_ALLOW_TOP_LEVEL_AWAIT = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define PyCF_ALLOW_TOP_LEVEL_AWAIT 8192
     * }
     */
    public static int PyCF_ALLOW_TOP_LEVEL_AWAIT() {
        return PyCF_ALLOW_TOP_LEVEL_AWAIT;
    }
    private static final int PyCF_ALLOW_INCOMPLETE_INPUT = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define PyCF_ALLOW_INCOMPLETE_INPUT 16384
     * }
     */
    public static int PyCF_ALLOW_INCOMPLETE_INPUT() {
        return PyCF_ALLOW_INCOMPLETE_INPUT;
    }
    private static final int PYOS_STACK_MARGIN = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define PYOS_STACK_MARGIN 2048
     * }
     */
    public static int PYOS_STACK_MARGIN() {
        return PYOS_STACK_MARGIN;
    }
    private static final int FVC_MASK = (int)3L;
    /**
     * {@snippet lang=c :
     * #define FVC_MASK 3
     * }
     */
    public static int FVC_MASK() {
        return FVC_MASK;
    }
    private static final int FVC_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define FVC_NONE 0
     * }
     */
    public static int FVC_NONE() {
        return FVC_NONE;
    }
    private static final int FVC_STR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FVC_STR 1
     * }
     */
    public static int FVC_STR() {
        return FVC_STR;
    }
    private static final int FVC_REPR = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FVC_REPR 2
     * }
     */
    public static int FVC_REPR() {
        return FVC_REPR;
    }
    private static final int FVC_ASCII = (int)3L;
    /**
     * {@snippet lang=c :
     * #define FVC_ASCII 3
     * }
     */
    public static int FVC_ASCII() {
        return FVC_ASCII;
    }
    private static final int FVS_MASK = (int)4L;
    /**
     * {@snippet lang=c :
     * #define FVS_MASK 4
     * }
     */
    public static int FVS_MASK() {
        return FVS_MASK;
    }
    private static final int FVS_HAVE_SPEC = (int)4L;
    /**
     * {@snippet lang=c :
     * #define FVS_HAVE_SPEC 4
     * }
     */
    public static int FVS_HAVE_SPEC() {
        return FVS_HAVE_SPEC;
    }
    private static final int _PY_FASTCALL_SMALL_STACK = (int)5L;
    /**
     * {@snippet lang=c :
     * #define _PY_FASTCALL_SMALL_STACK 5
     * }
     */
    public static int _PY_FASTCALL_SMALL_STACK() {
        return _PY_FASTCALL_SMALL_STACK;
    }
    private static final int PY_ITERSEARCH_COUNT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PY_ITERSEARCH_COUNT 1
     * }
     */
    public static int PY_ITERSEARCH_COUNT() {
        return PY_ITERSEARCH_COUNT;
    }
    private static final int PY_ITERSEARCH_INDEX = (int)2L;
    /**
     * {@snippet lang=c :
     * #define PY_ITERSEARCH_INDEX 2
     * }
     */
    public static int PY_ITERSEARCH_INDEX() {
        return PY_ITERSEARCH_INDEX;
    }
    private static final int PY_ITERSEARCH_CONTAINS = (int)3L;
    /**
     * {@snippet lang=c :
     * #define PY_ITERSEARCH_CONTAINS 3
     * }
     */
    public static int PY_ITERSEARCH_CONTAINS() {
        return PY_ITERSEARCH_CONTAINS;
    }
    private static final int PY_CTF_LOWER = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PY_CTF_LOWER 1
     * }
     */
    public static int PY_CTF_LOWER() {
        return PY_CTF_LOWER;
    }
    private static final int PY_CTF_UPPER = (int)2L;
    /**
     * {@snippet lang=c :
     * #define PY_CTF_UPPER 2
     * }
     */
    public static int PY_CTF_UPPER() {
        return PY_CTF_UPPER;
    }
    private static final int PY_CTF_DIGIT = (int)4L;
    /**
     * {@snippet lang=c :
     * #define PY_CTF_DIGIT 4
     * }
     */
    public static int PY_CTF_DIGIT() {
        return PY_CTF_DIGIT;
    }
    private static final int PY_CTF_SPACE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define PY_CTF_SPACE 8
     * }
     */
    public static int PY_CTF_SPACE() {
        return PY_CTF_SPACE;
    }
    private static final int PY_CTF_XDIGIT = (int)16L;
    /**
     * {@snippet lang=c :
     * #define PY_CTF_XDIGIT 16
     * }
     */
    public static int PY_CTF_XDIGIT() {
        return PY_CTF_XDIGIT;
    }
    private static final int Py_DTSF_SIGN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define Py_DTSF_SIGN 1
     * }
     */
    public static int Py_DTSF_SIGN() {
        return Py_DTSF_SIGN;
    }
    private static final int Py_DTSF_ADD_DOT_0 = (int)2L;
    /**
     * {@snippet lang=c :
     * #define Py_DTSF_ADD_DOT_0 2
     * }
     */
    public static int Py_DTSF_ADD_DOT_0() {
        return Py_DTSF_ADD_DOT_0;
    }
    private static final int Py_DTSF_ALT = (int)4L;
    /**
     * {@snippet lang=c :
     * #define Py_DTSF_ALT 4
     * }
     */
    public static int Py_DTSF_ALT() {
        return Py_DTSF_ALT;
    }
    private static final int Py_DTSF_NO_NEG_0 = (int)8L;
    /**
     * {@snippet lang=c :
     * #define Py_DTSF_NO_NEG_0 8
     * }
     */
    public static int Py_DTSF_NO_NEG_0() {
        return Py_DTSF_NO_NEG_0;
    }
    private static final int Py_DTST_FINITE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define Py_DTST_FINITE 0
     * }
     */
    public static int Py_DTST_FINITE() {
        return Py_DTST_FINITE;
    }
    private static final int Py_DTST_INFINITE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define Py_DTST_INFINITE 1
     * }
     */
    public static int Py_DTST_INFINITE() {
        return Py_DTST_INFINITE;
    }
    private static final int Py_DTST_NAN = (int)2L;
    /**
     * {@snippet lang=c :
     * #define Py_DTST_NAN 2
     * }
     */
    public static int Py_DTST_NAN() {
        return Py_DTST_NAN;
    }
    /**
     * {@snippet lang=c :
     * typedef signed char __int8_t
     * }
     */
    public static final OfByte __int8_t = Python_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __uint8_t
     * }
     */
    public static final OfByte __uint8_t = Python_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short __int16_t
     * }
     */
    public static final OfShort __int16_t = Python_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __uint16_t
     * }
     */
    public static final OfShort __uint16_t = Python_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int __int32_t
     * }
     */
    public static final OfInt __int32_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uint32_t
     * }
     */
    public static final OfInt __uint32_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long __int64_t
     * }
     */
    public static final OfLong __int64_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long __uint64_t
     * }
     */
    public static final OfLong __uint64_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_intptr_t
     * }
     */
    public static final OfLong __darwin_intptr_t = Python_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_natural_t
     * }
     */
    public static final OfInt __darwin_natural_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_ct_rune_t
     * }
     */
    public static final OfInt __darwin_ct_rune_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_ptrdiff_t
     * }
     */
    public static final OfLong __darwin_ptrdiff_t = Python_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_size_t
     * }
     */
    public static final OfLong __darwin_size_t = Python_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __builtin_va_list __darwin_va_list
     * }
     */
    public static final AddressLayout __darwin_va_list = Python_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_wchar_t
     * }
     */
    public static final OfInt __darwin_wchar_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_wchar_t __darwin_rune_t
     * }
     */
    public static final OfInt __darwin_rune_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_wint_t
     * }
     */
    public static final OfInt __darwin_wint_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_clock_t
     * }
     */
    public static final OfLong __darwin_clock_t = Python_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_socklen_t
     * }
     */
    public static final OfInt __darwin_socklen_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_ssize_t
     * }
     */
    public static final OfLong __darwin_ssize_t = Python_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_time_t
     * }
     */
    public static final OfLong __darwin_time_t = Python_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __darwin_blkcnt_t
     * }
     */
    public static final OfLong __darwin_blkcnt_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_blksize_t
     * }
     */
    public static final OfInt __darwin_blksize_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_dev_t
     * }
     */
    public static final OfInt __darwin_dev_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_fsblkcnt_t
     * }
     */
    public static final OfInt __darwin_fsblkcnt_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_fsfilcnt_t
     * }
     */
    public static final OfInt __darwin_fsfilcnt_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_gid_t
     * }
     */
    public static final OfInt __darwin_gid_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_id_t
     * }
     */
    public static final OfInt __darwin_id_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t __darwin_ino64_t
     * }
     */
    public static final OfLong __darwin_ino64_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_ino64_t __darwin_ino_t
     * }
     */
    public static final OfLong __darwin_ino_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_natural_t __darwin_mach_port_name_t
     * }
     */
    public static final OfInt __darwin_mach_port_name_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_mach_port_name_t __darwin_mach_port_t
     * }
     */
    public static final OfInt __darwin_mach_port_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t __darwin_mode_t
     * }
     */
    public static final OfShort __darwin_mode_t = Python_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __darwin_off_t
     * }
     */
    public static final OfLong __darwin_off_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_pid_t
     * }
     */
    public static final OfInt __darwin_pid_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_sigset_t
     * }
     */
    public static final OfInt __darwin_sigset_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_suseconds_t
     * }
     */
    public static final OfInt __darwin_suseconds_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_uid_t
     * }
     */
    public static final OfInt __darwin_uid_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_useconds_t
     * }
     */
    public static final OfInt __darwin_useconds_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_pthread_key_t
     * }
     */
    public static final OfLong __darwin_pthread_key_t = Python_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _opaque_pthread_t {
     *     long __sig;
     *     struct __darwin_pthread_handler_rec *__cleanup_stack;
     *     char __opaque[8176];
     * } *__darwin_pthread_t
     * }
     */
    public static final AddressLayout __darwin_pthread_t = Python_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_nl_item
     * }
     */
    public static final OfInt __darwin_nl_item = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_wctrans_t
     * }
     */
    public static final OfInt __darwin_wctrans_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_wctype_t
     * }
     */
    public static final OfInt __darwin_wctype_t = Python_h.C_INT;
    private static final int P_ALL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.P_ALL = 0
     * }
     */
    public static int P_ALL() {
        return P_ALL;
    }
    private static final int P_PID = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.P_PID = 1
     * }
     */
    public static int P_PID() {
        return P_PID;
    }
    private static final int P_PGID = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.P_PGID = 2
     * }
     */
    public static int P_PGID() {
        return P_PGID;
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_pid_t pid_t
     * }
     */
    public static final OfInt pid_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_id_t id_t
     * }
     */
    public static final OfInt id_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int sig_atomic_t
     * }
     */
    public static final OfInt sig_atomic_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef signed char int8_t
     * }
     */
    public static final OfByte int8_t = Python_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short int16_t
     * }
     */
    public static final OfShort int16_t = Python_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int int32_t
     * }
     */
    public static final OfInt int32_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long int64_t
     * }
     */
    public static final OfLong int64_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char u_int8_t
     * }
     */
    public static final OfByte u_int8_t = Python_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short u_int16_t
     * }
     */
    public static final OfShort u_int16_t = Python_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int u_int32_t
     * }
     */
    public static final OfInt u_int32_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long u_int64_t
     * }
     */
    public static final OfLong u_int64_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t register_t
     * }
     */
    public static final OfLong register_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_intptr_t intptr_t
     * }
     */
    public static final OfLong intptr_t = Python_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = Python_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t user_addr_t
     * }
     */
    public static final OfLong user_addr_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t user_size_t
     * }
     */
    public static final OfLong user_size_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_ssize_t
     * }
     */
    public static final OfLong user_ssize_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_long_t
     * }
     */
    public static final OfLong user_long_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t user_ulong_t
     * }
     */
    public static final OfLong user_ulong_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_time_t
     * }
     */
    public static final OfLong user_time_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_off_t
     * }
     */
    public static final OfLong user_off_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t syscall_arg_t
     * }
     */
    public static final OfLong syscall_arg_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct __darwin_mcontext64 {
     *     struct __darwin_arm_exception_state64 __es;
     *     struct __darwin_arm_thread_state64 __ss;
     *     struct __darwin_arm_neon_state64 __ns;
     * } *mcontext_t
     * }
     */
    public static final AddressLayout mcontext_t = Python_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __darwin_sigset_t sigset_t
     * }
     */
    public static final OfInt sigset_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_size_t size_t
     * }
     */
    public static final OfLong size_t = Python_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_uid_t uid_t
     * }
     */
    public static final OfInt uid_t = Python_h.C_INT;

    private static class signal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("signal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static FunctionDescriptor signal$descriptor() {
        return signal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static MethodHandle signal$handle() {
        return signal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static MemorySegment signal$address() {
        return signal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static MemorySegment signal(int x0, MemorySegment x1) {
        var mh$ = signal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("signal", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint8_t
     * }
     */
    public static final OfByte uint8_t = Python_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short uint16_t
     * }
     */
    public static final OfShort uint16_t = Python_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint32_t
     * }
     */
    public static final OfInt uint32_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uint64_t
     * }
     */
    public static final OfLong uint64_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int8_t int_least8_t
     * }
     */
    public static final OfByte int_least8_t = Python_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef int16_t int_least16_t
     * }
     */
    public static final OfShort int_least16_t = Python_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int32_t int_least32_t
     * }
     */
    public static final OfInt int_least32_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int64_t int_least64_t
     * }
     */
    public static final OfLong int_least64_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint8_t uint_least8_t
     * }
     */
    public static final OfByte uint_least8_t = Python_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint16_t uint_least16_t
     * }
     */
    public static final OfShort uint_least16_t = Python_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t uint_least32_t
     * }
     */
    public static final OfInt uint_least32_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint64_t uint_least64_t
     * }
     */
    public static final OfLong uint_least64_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int8_t int_fast8_t
     * }
     */
    public static final OfByte int_fast8_t = Python_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef int16_t int_fast16_t
     * }
     */
    public static final OfShort int_fast16_t = Python_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int32_t int_fast32_t
     * }
     */
    public static final OfInt int_fast32_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int64_t int_fast64_t
     * }
     */
    public static final OfLong int_fast64_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint8_t uint_fast8_t
     * }
     */
    public static final OfByte uint_fast8_t = Python_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint16_t uint_fast16_t
     * }
     */
    public static final OfShort uint_fast16_t = Python_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t uint_fast32_t
     * }
     */
    public static final OfInt uint_fast32_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint64_t uint_fast64_t
     * }
     */
    public static final OfLong uint_fast64_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long intmax_t
     * }
     */
    public static final OfLong intmax_t = Python_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintmax_t
     * }
     */
    public static final OfLong uintmax_t = Python_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t rlim_t
     * }
     */
    public static final OfLong rlim_t = Python_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef void *rusage_info_t
     * }
     */
    public static final AddressLayout rusage_info_t = Python_h.C_POINTER;

    private static class getpriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getpriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getpriority(int, id_t)
     * }
     */
    public static FunctionDescriptor getpriority$descriptor() {
        return getpriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getpriority(int, id_t)
     * }
     */
    public static MethodHandle getpriority$handle() {
        return getpriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getpriority(int, id_t)
     * }
     */
    public static MemorySegment getpriority$address() {
        return getpriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getpriority(int, id_t)
     * }
     */
    public static int getpriority(int x0, int x1) {
        var mh$ = getpriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpriority", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getiopolicy_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getiopolicy_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getiopolicy_np(int, int)
     * }
     */
    public static FunctionDescriptor getiopolicy_np$descriptor() {
        return getiopolicy_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getiopolicy_np(int, int)
     * }
     */
    public static MethodHandle getiopolicy_np$handle() {
        return getiopolicy_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getiopolicy_np(int, int)
     * }
     */
    public static MemorySegment getiopolicy_np$address() {
        return getiopolicy_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getiopolicy_np(int, int)
     * }
     */
    public static int getiopolicy_np(int x0, int x1) {
        var mh$ = getiopolicy_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getiopolicy_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getrlimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getrlimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getrlimit(int, struct rlimit *)
     * }
     */
    public static FunctionDescriptor getrlimit$descriptor() {
        return getrlimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getrlimit(int, struct rlimit *)
     * }
     */
    public static MethodHandle getrlimit$handle() {
        return getrlimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getrlimit(int, struct rlimit *)
     * }
     */
    public static MemorySegment getrlimit$address() {
        return getrlimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getrlimit(int, struct rlimit *)
     * }
     */
    public static int getrlimit(int x0, MemorySegment x1) {
        var mh$ = getrlimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getrlimit", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getrusage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getrusage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getrusage(int, struct rusage *)
     * }
     */
    public static FunctionDescriptor getrusage$descriptor() {
        return getrusage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getrusage(int, struct rusage *)
     * }
     */
    public static MethodHandle getrusage$handle() {
        return getrusage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getrusage(int, struct rusage *)
     * }
     */
    public static MemorySegment getrusage$address() {
        return getrusage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getrusage(int, struct rusage *)
     * }
     */
    public static int getrusage(int x0, MemorySegment x1) {
        var mh$ = getrusage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getrusage", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setpriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setpriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setpriority(int, id_t, int)
     * }
     */
    public static FunctionDescriptor setpriority$descriptor() {
        return setpriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setpriority(int, id_t, int)
     * }
     */
    public static MethodHandle setpriority$handle() {
        return setpriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setpriority(int, id_t, int)
     * }
     */
    public static MemorySegment setpriority$address() {
        return setpriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setpriority(int, id_t, int)
     * }
     */
    public static int setpriority(int x0, int x1, int x2) {
        var mh$ = setpriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setpriority", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setiopolicy_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setiopolicy_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setiopolicy_np(int, int, int)
     * }
     */
    public static FunctionDescriptor setiopolicy_np$descriptor() {
        return setiopolicy_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setiopolicy_np(int, int, int)
     * }
     */
    public static MethodHandle setiopolicy_np$handle() {
        return setiopolicy_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setiopolicy_np(int, int, int)
     * }
     */
    public static MemorySegment setiopolicy_np$address() {
        return setiopolicy_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setiopolicy_np(int, int, int)
     * }
     */
    public static int setiopolicy_np(int x0, int x1, int x2) {
        var mh$ = setiopolicy_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setiopolicy_np", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setrlimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setrlimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setrlimit(int, const struct rlimit *)
     * }
     */
    public static FunctionDescriptor setrlimit$descriptor() {
        return setrlimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setrlimit(int, const struct rlimit *)
     * }
     */
    public static MethodHandle setrlimit$handle() {
        return setrlimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setrlimit(int, const struct rlimit *)
     * }
     */
    public static MemorySegment setrlimit$address() {
        return setrlimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setrlimit(int, const struct rlimit *)
     * }
     */
    public static int setrlimit(int x0, MemorySegment x1) {
        var mh$ = setrlimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setrlimit", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t wait(int *)
     * }
     */
    public static FunctionDescriptor wait$descriptor() {
        return wait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t wait(int *)
     * }
     */
    public static MethodHandle wait$handle() {
        return wait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t wait(int *)
     * }
     */
    public static MemorySegment wait$address() {
        return wait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t wait(int *)
     * }
     */
    public static int wait(MemorySegment x0) {
        var mh$ = wait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wait", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waitpid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("waitpid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t waitpid(pid_t, int *, int)
     * }
     */
    public static FunctionDescriptor waitpid$descriptor() {
        return waitpid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t waitpid(pid_t, int *, int)
     * }
     */
    public static MethodHandle waitpid$handle() {
        return waitpid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t waitpid(pid_t, int *, int)
     * }
     */
    public static MemorySegment waitpid$address() {
        return waitpid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t waitpid(pid_t, int *, int)
     * }
     */
    public static int waitpid(int x0, MemorySegment x1, int x2) {
        var mh$ = waitpid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waitpid", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waitid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("waitid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int waitid(idtype_t, id_t, siginfo_t *, int)
     * }
     */
    public static FunctionDescriptor waitid$descriptor() {
        return waitid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int waitid(idtype_t, id_t, siginfo_t *, int)
     * }
     */
    public static MethodHandle waitid$handle() {
        return waitid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int waitid(idtype_t, id_t, siginfo_t *, int)
     * }
     */
    public static MemorySegment waitid$address() {
        return waitid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int waitid(idtype_t, id_t, siginfo_t *, int)
     * }
     */
    public static int waitid(int x0, int x1, MemorySegment x2, int x3) {
        var mh$ = waitid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waitid", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wait3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wait3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t wait3(int *, int, struct rusage *)
     * }
     */
    public static FunctionDescriptor wait3$descriptor() {
        return wait3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t wait3(int *, int, struct rusage *)
     * }
     */
    public static MethodHandle wait3$handle() {
        return wait3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t wait3(int *, int, struct rusage *)
     * }
     */
    public static MemorySegment wait3$address() {
        return wait3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t wait3(int *, int, struct rusage *)
     * }
     */
    public static int wait3(MemorySegment x0, int x1, MemorySegment x2) {
        var mh$ = wait3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wait3", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wait4 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wait4");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t wait4(pid_t, int *, int, struct rusage *)
     * }
     */
    public static FunctionDescriptor wait4$descriptor() {
        return wait4.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t wait4(pid_t, int *, int, struct rusage *)
     * }
     */
    public static MethodHandle wait4$handle() {
        return wait4.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t wait4(pid_t, int *, int, struct rusage *)
     * }
     */
    public static MemorySegment wait4$address() {
        return wait4.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t wait4(pid_t, int *, int, struct rusage *)
     * }
     */
    public static int wait4(int x0, MemorySegment x1, int x2, MemorySegment x3) {
        var mh$ = wait4.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wait4", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class alloca {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("alloca");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *alloca(size_t)
     * }
     */
    public static FunctionDescriptor alloca$descriptor() {
        return alloca.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *alloca(size_t)
     * }
     */
    public static MethodHandle alloca$handle() {
        return alloca.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *alloca(size_t)
     * }
     */
    public static MemorySegment alloca$address() {
        return alloca.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *alloca(size_t)
     * }
     */
    public static MemorySegment alloca(long x0) {
        var mh$ = alloca.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("alloca", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_ct_rune_t ct_rune_t
     * }
     */
    public static final OfInt ct_rune_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_rune_t rune_t
     * }
     */
    public static final OfInt rune_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_wchar_t wchar_t
     * }
     */
    public static final OfInt wchar_t = Python_h.C_INT;

    private static class __mb_cur_max$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("__mb_cur_max").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int __mb_cur_max
     * }
     */
    public static OfInt __mb_cur_max$layout() {
        return __mb_cur_max$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int __mb_cur_max
     * }
     */
    public static MemorySegment __mb_cur_max$segment() {
        return __mb_cur_max$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int __mb_cur_max
     * }
     */
    public static int __mb_cur_max() {
        return __mb_cur_max$constants.SEGMENT.get(__mb_cur_max$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int __mb_cur_max
     * }
     */
    public static void __mb_cur_max(int varValue) {
        __mb_cur_max$constants.SEGMENT.set(__mb_cur_max$constants.LAYOUT, 0L, varValue);
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned long long malloc_type_id_t
     * }
     */
    public static final OfLong malloc_type_id_t = Python_h.C_LONG_LONG;

    private static class malloc_type_malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("malloc_type_malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_malloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_malloc$descriptor() {
        return malloc_type_malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_malloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_malloc$handle() {
        return malloc_type_malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_malloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_malloc$address() {
        return malloc_type_malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_malloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_malloc(long size, long type_id) {
        var mh$ = malloc_type_malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_malloc", size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("malloc_type_calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_calloc$descriptor() {
        return malloc_type_calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_calloc$handle() {
        return malloc_type_calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_calloc$address() {
        return malloc_type_calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_calloc(long count, long size, long type_id) {
        var mh$ = malloc_type_calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_calloc", count, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(count, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("malloc_type_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void malloc_type_free(void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_free$descriptor() {
        return malloc_type_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void malloc_type_free(void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_free$handle() {
        return malloc_type_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void malloc_type_free(void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_free$address() {
        return malloc_type_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void malloc_type_free(void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static void malloc_type_free(MemorySegment ptr, long type_id) {
        var mh$ = malloc_type_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_free", ptr, type_id);
            }
            mh$.invokeExact(ptr, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("malloc_type_realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_realloc$descriptor() {
        return malloc_type_realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_realloc$handle() {
        return malloc_type_realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_realloc$address() {
        return malloc_type_realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_realloc(MemorySegment ptr, long size, long type_id) {
        var mh$ = malloc_type_realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_realloc", ptr, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(ptr, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_valloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("malloc_type_valloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_valloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_valloc$descriptor() {
        return malloc_type_valloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_valloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_valloc$handle() {
        return malloc_type_valloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_valloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_valloc$address() {
        return malloc_type_valloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_valloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_valloc(long size, long type_id) {
        var mh$ = malloc_type_valloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_valloc", size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_aligned_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("malloc_type_aligned_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_aligned_alloc(size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_aligned_alloc$descriptor() {
        return malloc_type_aligned_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_aligned_alloc(size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_aligned_alloc$handle() {
        return malloc_type_aligned_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_aligned_alloc(size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_aligned_alloc$address() {
        return malloc_type_aligned_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_aligned_alloc(size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_aligned_alloc(long alignment, long size, long type_id) {
        var mh$ = malloc_type_aligned_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_aligned_alloc", alignment, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(alignment, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_posix_memalign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("malloc_type_posix_memalign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_posix_memalign$descriptor() {
        return malloc_type_posix_memalign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_posix_memalign$handle() {
        return malloc_type_posix_memalign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_posix_memalign$address() {
        return malloc_type_posix_memalign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static int malloc_type_posix_memalign(MemorySegment memptr, long alignment, long size, long type_id) {
        var mh$ = malloc_type_posix_memalign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_posix_memalign", memptr, alignment, size, type_id);
            }
            return (int)mh$.invokeExact(memptr, alignment, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("malloc_type_zone_malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_zone_malloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_malloc$descriptor() {
        return malloc_type_zone_malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_zone_malloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_malloc$handle() {
        return malloc_type_zone_malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_zone_malloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_malloc$address() {
        return malloc_type_zone_malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_zone_malloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_malloc(MemorySegment zone, long size, long type_id) {
        var mh$ = malloc_type_zone_malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_malloc", zone, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(zone, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("malloc_type_zone_calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_zone_calloc(malloc_zone_t *zone, size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_calloc$descriptor() {
        return malloc_type_zone_calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_zone_calloc(malloc_zone_t *zone, size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_calloc$handle() {
        return malloc_type_zone_calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_zone_calloc(malloc_zone_t *zone, size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_calloc$address() {
        return malloc_type_zone_calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_zone_calloc(malloc_zone_t *zone, size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_calloc(MemorySegment zone, long count, long size, long type_id) {
        var mh$ = malloc_type_zone_calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_calloc", zone, count, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(zone, count, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("malloc_type_zone_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void malloc_type_zone_free(malloc_zone_t *zone, void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_free$descriptor() {
        return malloc_type_zone_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void malloc_type_zone_free(malloc_zone_t *zone, void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_free$handle() {
        return malloc_type_zone_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void malloc_type_zone_free(malloc_zone_t *zone, void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_free$address() {
        return malloc_type_zone_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void malloc_type_zone_free(malloc_zone_t *zone, void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static void malloc_type_zone_free(MemorySegment zone, MemorySegment ptr, long type_id) {
        var mh$ = malloc_type_zone_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_free", zone, ptr, type_id);
            }
            mh$.invokeExact(zone, ptr, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("malloc_type_zone_realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_zone_realloc(malloc_zone_t *zone, void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_realloc$descriptor() {
        return malloc_type_zone_realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_zone_realloc(malloc_zone_t *zone, void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_realloc$handle() {
        return malloc_type_zone_realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_zone_realloc(malloc_zone_t *zone, void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_realloc$address() {
        return malloc_type_zone_realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_zone_realloc(malloc_zone_t *zone, void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_realloc(MemorySegment zone, MemorySegment ptr, long size, long type_id) {
        var mh$ = malloc_type_zone_realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_realloc", zone, ptr, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(zone, ptr, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_valloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("malloc_type_zone_valloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_zone_valloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_valloc$descriptor() {
        return malloc_type_zone_valloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_zone_valloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_valloc$handle() {
        return malloc_type_zone_valloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_zone_valloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_valloc$address() {
        return malloc_type_zone_valloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_zone_valloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_valloc(MemorySegment zone, long size, long type_id) {
        var mh$ = malloc_type_zone_valloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_valloc", zone, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(zone, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_memalign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("malloc_type_zone_memalign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_memalign$descriptor() {
        return malloc_type_zone_memalign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_memalign$handle() {
        return malloc_type_zone_memalign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_memalign$address() {
        return malloc_type_zone_memalign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_memalign(MemorySegment zone, long alignment, long size, long type_id) {
        var mh$ = malloc_type_zone_memalign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_memalign", zone, alignment, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(zone, alignment, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc(size_t __size)
     * }
     */
    public static FunctionDescriptor malloc$descriptor() {
        return malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc(size_t __size)
     * }
     */
    public static MethodHandle malloc$handle() {
        return malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc(size_t __size)
     * }
     */
    public static MemorySegment malloc$address() {
        return malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc(size_t __size)
     * }
     */
    public static MemorySegment malloc(long __size) {
        var mh$ = malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *calloc(size_t __count, size_t __size)
     * }
     */
    public static FunctionDescriptor calloc$descriptor() {
        return calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *calloc(size_t __count, size_t __size)
     * }
     */
    public static MethodHandle calloc$handle() {
        return calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *calloc(size_t __count, size_t __size)
     * }
     */
    public static MemorySegment calloc$address() {
        return calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *calloc(size_t __count, size_t __size)
     * }
     */
    public static MemorySegment calloc(long __count, long __size) {
        var mh$ = calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("calloc", __count, __size);
            }
            return (MemorySegment)mh$.invokeExact(__count, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void free(void *)
     * }
     */
    public static FunctionDescriptor free$descriptor() {
        return free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void free(void *)
     * }
     */
    public static MethodHandle free$handle() {
        return free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void free(void *)
     * }
     */
    public static MemorySegment free$address() {
        return free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void free(void *)
     * }
     */
    public static void free(MemorySegment x0) {
        var mh$ = free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("free", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static FunctionDescriptor realloc$descriptor() {
        return realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MethodHandle realloc$handle() {
        return realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment realloc$address() {
        return realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment realloc(MemorySegment __ptr, long __size) {
        var mh$ = realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realloc", __ptr, __size);
            }
            return (MemorySegment)mh$.invokeExact(__ptr, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class reallocf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("reallocf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *reallocf(void *__ptr, size_t __size)
     * }
     */
    public static FunctionDescriptor reallocf$descriptor() {
        return reallocf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *reallocf(void *__ptr, size_t __size)
     * }
     */
    public static MethodHandle reallocf$handle() {
        return reallocf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *reallocf(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment reallocf$address() {
        return reallocf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *reallocf(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment reallocf(MemorySegment __ptr, long __size) {
        var mh$ = reallocf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("reallocf", __ptr, __size);
            }
            return (MemorySegment)mh$.invokeExact(__ptr, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class valloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("valloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *valloc(size_t)
     * }
     */
    public static FunctionDescriptor valloc$descriptor() {
        return valloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *valloc(size_t)
     * }
     */
    public static MethodHandle valloc$handle() {
        return valloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *valloc(size_t)
     * }
     */
    public static MemorySegment valloc$address() {
        return valloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *valloc(size_t)
     * }
     */
    public static MemorySegment valloc(long x0) {
        var mh$ = valloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("valloc", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class aligned_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("aligned_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static FunctionDescriptor aligned_alloc$descriptor() {
        return aligned_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MethodHandle aligned_alloc$handle() {
        return aligned_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment aligned_alloc$address() {
        return aligned_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment aligned_alloc(long __alignment, long __size) {
        var mh$ = aligned_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("aligned_alloc", __alignment, __size);
            }
            return (MemorySegment)mh$.invokeExact(__alignment, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class posix_memalign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("posix_memalign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static FunctionDescriptor posix_memalign$descriptor() {
        return posix_memalign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static MethodHandle posix_memalign$handle() {
        return posix_memalign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment posix_memalign$address() {
        return posix_memalign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static int posix_memalign(MemorySegment __memptr, long __alignment, long __size) {
        var mh$ = posix_memalign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("posix_memalign", __memptr, __alignment, __size);
            }
            return (int)mh$.invokeExact(__memptr, __alignment, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("abort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static FunctionDescriptor abort$descriptor() {
        return abort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static MethodHandle abort$handle() {
        return abort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static MemorySegment abort$address() {
        return abort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static void abort() {
        var mh$ = abort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abort");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("abs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int abs(int)
     * }
     */
    public static FunctionDescriptor abs$descriptor() {
        return abs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int abs(int)
     * }
     */
    public static MethodHandle abs$handle() {
        return abs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int abs(int)
     * }
     */
    public static MemorySegment abs$address() {
        return abs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int abs(int)
     * }
     */
    public static int abs(int x0) {
        var mh$ = abs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abs", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atexit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("atexit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int atexit(void (* _Nonnull)(void))
     * }
     */
    public static FunctionDescriptor atexit$descriptor() {
        return atexit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int atexit(void (* _Nonnull)(void))
     * }
     */
    public static MethodHandle atexit$handle() {
        return atexit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int atexit(void (* _Nonnull)(void))
     * }
     */
    public static MemorySegment atexit$address() {
        return atexit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int atexit(void (* _Nonnull)(void))
     * }
     */
    public static int atexit(MemorySegment x0) {
        var mh$ = atexit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atexit", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("atof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double atof(const char *)
     * }
     */
    public static FunctionDescriptor atof$descriptor() {
        return atof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double atof(const char *)
     * }
     */
    public static MethodHandle atof$handle() {
        return atof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double atof(const char *)
     * }
     */
    public static MemorySegment atof$address() {
        return atof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double atof(const char *)
     * }
     */
    public static double atof(MemorySegment x0) {
        var mh$ = atof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atof", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("atoi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int atoi(const char *)
     * }
     */
    public static FunctionDescriptor atoi$descriptor() {
        return atoi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int atoi(const char *)
     * }
     */
    public static MethodHandle atoi$handle() {
        return atoi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int atoi(const char *)
     * }
     */
    public static MemorySegment atoi$address() {
        return atoi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int atoi(const char *)
     * }
     */
    public static int atoi(MemorySegment x0) {
        var mh$ = atoi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoi", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("atol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long atol(const char *)
     * }
     */
    public static FunctionDescriptor atol$descriptor() {
        return atol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long atol(const char *)
     * }
     */
    public static MethodHandle atol$handle() {
        return atol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long atol(const char *)
     * }
     */
    public static MemorySegment atol$address() {
        return atol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long atol(const char *)
     * }
     */
    public static long atol(MemorySegment x0) {
        var mh$ = atol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atol", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("atoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long atoll(const char *)
     * }
     */
    public static FunctionDescriptor atoll$descriptor() {
        return atoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long atoll(const char *)
     * }
     */
    public static MethodHandle atoll$handle() {
        return atoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long atoll(const char *)
     * }
     */
    public static MemorySegment atoll$address() {
        return atoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long atoll(const char *)
     * }
     */
    public static long atoll(MemorySegment x0) {
        var mh$ = atoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoll", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bsearch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("bsearch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor bsearch$descriptor() {
        return bsearch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle bsearch$handle() {
        return bsearch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment bsearch$address() {
        return bsearch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment bsearch(MemorySegment __key, MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = bsearch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bsearch", __key, __base, __nel, __width, __compar);
            }
            return (MemorySegment)mh$.invokeExact(__key, __base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class div {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            div_t.layout(),
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("div");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * div_t div(int, int)
     * }
     */
    public static FunctionDescriptor div$descriptor() {
        return div.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * div_t div(int, int)
     * }
     */
    public static MethodHandle div$handle() {
        return div.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * div_t div(int, int)
     * }
     */
    public static MemorySegment div$address() {
        return div.ADDR;
    }

    /**
     * {@snippet lang=c :
     * div_t div(int, int)
     * }
     */
    public static MemorySegment div(SegmentAllocator allocator, int x0, int x1) {
        var mh$ = div.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("div", allocator, x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void exit(int)
     * }
     */
    public static FunctionDescriptor exit$descriptor() {
        return exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void exit(int)
     * }
     */
    public static MethodHandle exit$handle() {
        return exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void exit(int)
     * }
     */
    public static MemorySegment exit$address() {
        return exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void exit(int)
     * }
     */
    public static void exit(int x0) {
        var mh$ = exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exit", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getenv(const char *)
     * }
     */
    public static FunctionDescriptor getenv$descriptor() {
        return getenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getenv(const char *)
     * }
     */
    public static MethodHandle getenv$handle() {
        return getenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getenv(const char *)
     * }
     */
    public static MemorySegment getenv$address() {
        return getenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getenv(const char *)
     * }
     */
    public static MemorySegment getenv(MemorySegment x0) {
        var mh$ = getenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getenv", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class labs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("labs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long labs(long)
     * }
     */
    public static FunctionDescriptor labs$descriptor() {
        return labs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long labs(long)
     * }
     */
    public static MethodHandle labs$handle() {
        return labs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long labs(long)
     * }
     */
    public static MemorySegment labs$address() {
        return labs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long labs(long)
     * }
     */
    public static long labs(long x0) {
        var mh$ = labs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("labs", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ldiv_t.layout(),
            Python_h.C_LONG,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ldiv_t ldiv(long, long)
     * }
     */
    public static FunctionDescriptor ldiv$descriptor() {
        return ldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ldiv_t ldiv(long, long)
     * }
     */
    public static MethodHandle ldiv$handle() {
        return ldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ldiv_t ldiv(long, long)
     * }
     */
    public static MemorySegment ldiv$address() {
        return ldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ldiv_t ldiv(long, long)
     * }
     */
    public static MemorySegment ldiv(SegmentAllocator allocator, long x0, long x1) {
        var mh$ = ldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldiv", allocator, x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("llabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long llabs(long long)
     * }
     */
    public static FunctionDescriptor llabs$descriptor() {
        return llabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long llabs(long long)
     * }
     */
    public static MethodHandle llabs$handle() {
        return llabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long llabs(long long)
     * }
     */
    public static MemorySegment llabs$address() {
        return llabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long llabs(long long)
     * }
     */
    public static long llabs(long x0) {
        var mh$ = llabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llabs", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lldiv_t.layout(),
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lldiv_t lldiv(long long, long long)
     * }
     */
    public static FunctionDescriptor lldiv$descriptor() {
        return lldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lldiv_t lldiv(long long, long long)
     * }
     */
    public static MethodHandle lldiv$handle() {
        return lldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lldiv_t lldiv(long long, long long)
     * }
     */
    public static MemorySegment lldiv$address() {
        return lldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lldiv_t lldiv(long long, long long)
     * }
     */
    public static MemorySegment lldiv(SegmentAllocator allocator, long x0, long x1) {
        var mh$ = lldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lldiv", allocator, x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mblen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mblen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mblen(const char *__s, size_t __n)
     * }
     */
    public static FunctionDescriptor mblen$descriptor() {
        return mblen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mblen(const char *__s, size_t __n)
     * }
     */
    public static MethodHandle mblen$handle() {
        return mblen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mblen(const char *__s, size_t __n)
     * }
     */
    public static MemorySegment mblen$address() {
        return mblen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mblen(const char *__s, size_t __n)
     * }
     */
    public static int mblen(MemorySegment __s, long __n) {
        var mh$ = mblen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mblen", __s, __n);
            }
            return (int)mh$.invokeExact(__s, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbstowcs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mbstowcs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static FunctionDescriptor mbstowcs$descriptor() {
        return mbstowcs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static MethodHandle mbstowcs$handle() {
        return mbstowcs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static MemorySegment mbstowcs$address() {
        return mbstowcs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static long mbstowcs(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = mbstowcs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbstowcs", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbtowc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mbtowc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static FunctionDescriptor mbtowc$descriptor() {
        return mbtowc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static MethodHandle mbtowc$handle() {
        return mbtowc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static MemorySegment mbtowc$address() {
        return mbtowc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mbtowc(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static int mbtowc(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = mbtowc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbtowc", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("qsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor qsort$descriptor() {
        return qsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle qsort$handle() {
        return qsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment qsort$address() {
        return qsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static void qsort(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = qsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort", __base, __nel, __width, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("rand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static FunctionDescriptor rand$descriptor() {
        return rand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static MethodHandle rand$handle() {
        return rand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static MemorySegment rand$address() {
        return rand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static int rand() {
        var mh$ = rand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("srand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srand(unsigned int)
     * }
     */
    public static FunctionDescriptor srand$descriptor() {
        return srand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srand(unsigned int)
     * }
     */
    public static MethodHandle srand$handle() {
        return srand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srand(unsigned int)
     * }
     */
    public static MemorySegment srand$address() {
        return srand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srand(unsigned int)
     * }
     */
    public static void srand(int x0) {
        var mh$ = srand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strtod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double strtod(const char *, char **)
     * }
     */
    public static FunctionDescriptor strtod$descriptor() {
        return strtod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double strtod(const char *, char **)
     * }
     */
    public static MethodHandle strtod$handle() {
        return strtod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double strtod(const char *, char **)
     * }
     */
    public static MemorySegment strtod$address() {
        return strtod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double strtod(const char *, char **)
     * }
     */
    public static double strtod(MemorySegment x0, MemorySegment x1) {
        var mh$ = strtod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtod", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_FLOAT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strtof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float strtof(const char *, char **)
     * }
     */
    public static FunctionDescriptor strtof$descriptor() {
        return strtof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float strtof(const char *, char **)
     * }
     */
    public static MethodHandle strtof$handle() {
        return strtof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float strtof(const char *, char **)
     * }
     */
    public static MemorySegment strtof$address() {
        return strtof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float strtof(const char *, char **)
     * }
     */
    public static float strtof(MemorySegment x0, MemorySegment x1) {
        var mh$ = strtof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtof", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strtol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long strtol(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtol$descriptor() {
        return strtol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long strtol(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtol$handle() {
        return strtol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long strtol(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtol$address() {
        return strtol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long strtol(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtol(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtol", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strtoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long strtoll(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoll$descriptor() {
        return strtoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long strtoll(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtoll$handle() {
        return strtoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long strtoll(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtoll$address() {
        return strtoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long strtoll(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtoll(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoll", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strtoul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strtoul(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoul$descriptor() {
        return strtoul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strtoul(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtoul$handle() {
        return strtoul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strtoul(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtoul$address() {
        return strtoul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strtoul(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtoul(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtoul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoul", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strtoull");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoull$descriptor() {
        return strtoull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtoull$handle() {
        return strtoull.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtoull$address() {
        return strtoull.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtoull(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtoull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoull", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class system {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("system");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int system(const char *)
     * }
     */
    public static FunctionDescriptor system$descriptor() {
        return system.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int system(const char *)
     * }
     */
    public static MethodHandle system$handle() {
        return system.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int system(const char *)
     * }
     */
    public static MemorySegment system$address() {
        return system.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int system(const char *)
     * }
     */
    public static int system(MemorySegment x0) {
        var mh$ = system.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("system", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstombs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wcstombs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcstombs(char *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static FunctionDescriptor wcstombs$descriptor() {
        return wcstombs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcstombs(char *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static MethodHandle wcstombs$handle() {
        return wcstombs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcstombs(char *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static MemorySegment wcstombs$address() {
        return wcstombs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcstombs(char *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static long wcstombs(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = wcstombs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstombs", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wctomb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("wctomb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wctomb(char *, wchar_t)
     * }
     */
    public static FunctionDescriptor wctomb$descriptor() {
        return wctomb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wctomb(char *, wchar_t)
     * }
     */
    public static MethodHandle wctomb$handle() {
        return wctomb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wctomb(char *, wchar_t)
     * }
     */
    public static MemorySegment wctomb$address() {
        return wctomb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wctomb(char *, wchar_t)
     * }
     */
    public static int wctomb(MemorySegment x0, int x1) {
        var mh$ = wctomb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wctomb", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("_Exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static FunctionDescriptor _Exit$descriptor() {
        return _Exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static MethodHandle _Exit$handle() {
        return _Exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static MemorySegment _Exit$address() {
        return _Exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static void _Exit(int x0) {
        var mh$ = _Exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Exit", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class a64l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("a64l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long a64l(const char *)
     * }
     */
    public static FunctionDescriptor a64l$descriptor() {
        return a64l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long a64l(const char *)
     * }
     */
    public static MethodHandle a64l$handle() {
        return a64l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long a64l(const char *)
     * }
     */
    public static MemorySegment a64l$address() {
        return a64l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long a64l(const char *)
     * }
     */
    public static long a64l(MemorySegment x0) {
        var mh$ = a64l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("a64l", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class drand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("drand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double drand48()
     * }
     */
    public static FunctionDescriptor drand48$descriptor() {
        return drand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double drand48()
     * }
     */
    public static MethodHandle drand48$handle() {
        return drand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double drand48()
     * }
     */
    public static MemorySegment drand48$address() {
        return drand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double drand48()
     * }
     */
    public static double drand48() {
        var mh$ = drand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("drand48");
            }
            return (double)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_DOUBLE,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ecvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static FunctionDescriptor ecvt$descriptor() {
        return ecvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MethodHandle ecvt$handle() {
        return ecvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MemorySegment ecvt$address() {
        return ecvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MemorySegment ecvt(double x0, int x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ecvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecvt", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_DOUBLE,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("erand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double erand48(unsigned short [3])
     * }
     */
    public static FunctionDescriptor erand48$descriptor() {
        return erand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double erand48(unsigned short [3])
     * }
     */
    public static MethodHandle erand48$handle() {
        return erand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double erand48(unsigned short [3])
     * }
     */
    public static MemorySegment erand48$address() {
        return erand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double erand48(unsigned short [3])
     * }
     */
    public static double erand48(MemorySegment x0) {
        var mh$ = erand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erand48", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_DOUBLE,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *fcvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static FunctionDescriptor fcvt$descriptor() {
        return fcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *fcvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MethodHandle fcvt$handle() {
        return fcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *fcvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MemorySegment fcvt$address() {
        return fcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *fcvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MemorySegment fcvt(double x0, int x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = fcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcvt", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_DOUBLE,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("gcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *gcvt(double, int, char *)
     * }
     */
    public static FunctionDescriptor gcvt$descriptor() {
        return gcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *gcvt(double, int, char *)
     * }
     */
    public static MethodHandle gcvt$handle() {
        return gcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *gcvt(double, int, char *)
     * }
     */
    public static MemorySegment gcvt$address() {
        return gcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *gcvt(double, int, char *)
     * }
     */
    public static MemorySegment gcvt(double x0, int x1, MemorySegment x2) {
        var mh$ = gcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcvt", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsubopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getsubopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static FunctionDescriptor getsubopt$descriptor() {
        return getsubopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static MethodHandle getsubopt$handle() {
        return getsubopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static MemorySegment getsubopt$address() {
        return getsubopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static int getsubopt(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = getsubopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsubopt", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class grantpt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("grantpt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int grantpt(int)
     * }
     */
    public static FunctionDescriptor grantpt$descriptor() {
        return grantpt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int grantpt(int)
     * }
     */
    public static MethodHandle grantpt$handle() {
        return grantpt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int grantpt(int)
     * }
     */
    public static MemorySegment grantpt$address() {
        return grantpt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int grantpt(int)
     * }
     */
    public static int grantpt(int x0) {
        var mh$ = grantpt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("grantpt", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class initstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("initstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *initstate(unsigned int, char *, size_t)
     * }
     */
    public static FunctionDescriptor initstate$descriptor() {
        return initstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *initstate(unsigned int, char *, size_t)
     * }
     */
    public static MethodHandle initstate$handle() {
        return initstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *initstate(unsigned int, char *, size_t)
     * }
     */
    public static MemorySegment initstate$address() {
        return initstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *initstate(unsigned int, char *, size_t)
     * }
     */
    public static MemorySegment initstate(int x0, MemorySegment x1, long x2) {
        var mh$ = initstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initstate", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("jrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long jrand48(unsigned short [3])
     * }
     */
    public static FunctionDescriptor jrand48$descriptor() {
        return jrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long jrand48(unsigned short [3])
     * }
     */
    public static MethodHandle jrand48$handle() {
        return jrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long jrand48(unsigned short [3])
     * }
     */
    public static MemorySegment jrand48$address() {
        return jrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long jrand48(unsigned short [3])
     * }
     */
    public static long jrand48(MemorySegment x0) {
        var mh$ = jrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jrand48", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class l64a {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("l64a");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *l64a(long)
     * }
     */
    public static FunctionDescriptor l64a$descriptor() {
        return l64a.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *l64a(long)
     * }
     */
    public static MethodHandle l64a$handle() {
        return l64a.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *l64a(long)
     * }
     */
    public static MemorySegment l64a$address() {
        return l64a.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *l64a(long)
     * }
     */
    public static MemorySegment l64a(long x0) {
        var mh$ = l64a.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("l64a", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lcong48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lcong48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void lcong48(unsigned short [7])
     * }
     */
    public static FunctionDescriptor lcong48$descriptor() {
        return lcong48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void lcong48(unsigned short [7])
     * }
     */
    public static MethodHandle lcong48$handle() {
        return lcong48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void lcong48(unsigned short [7])
     * }
     */
    public static MemorySegment lcong48$address() {
        return lcong48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void lcong48(unsigned short [7])
     * }
     */
    public static void lcong48(MemorySegment x0) {
        var mh$ = lcong48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lcong48", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("lrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long lrand48()
     * }
     */
    public static FunctionDescriptor lrand48$descriptor() {
        return lrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long lrand48()
     * }
     */
    public static MethodHandle lrand48$handle() {
        return lrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long lrand48()
     * }
     */
    public static MemorySegment lrand48$address() {
        return lrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long lrand48()
     * }
     */
    public static long lrand48() {
        var mh$ = lrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrand48");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mktemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mktemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static FunctionDescriptor mktemp$descriptor() {
        return mktemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static MethodHandle mktemp$handle() {
        return mktemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static MemorySegment mktemp$address() {
        return mktemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static MemorySegment mktemp(MemorySegment x0) {
        var mh$ = mktemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mktemp", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mkstemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static FunctionDescriptor mkstemp$descriptor() {
        return mkstemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static MethodHandle mkstemp$handle() {
        return mkstemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static MemorySegment mkstemp$address() {
        return mkstemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static int mkstemp(MemorySegment x0) {
        var mh$ = mkstemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstemp", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long mrand48()
     * }
     */
    public static FunctionDescriptor mrand48$descriptor() {
        return mrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long mrand48()
     * }
     */
    public static MethodHandle mrand48$handle() {
        return mrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long mrand48()
     * }
     */
    public static MemorySegment mrand48$address() {
        return mrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long mrand48()
     * }
     */
    public static long mrand48() {
        var mh$ = mrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mrand48");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("nrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long nrand48(unsigned short [3])
     * }
     */
    public static FunctionDescriptor nrand48$descriptor() {
        return nrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long nrand48(unsigned short [3])
     * }
     */
    public static MethodHandle nrand48$handle() {
        return nrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long nrand48(unsigned short [3])
     * }
     */
    public static MemorySegment nrand48$address() {
        return nrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long nrand48(unsigned short [3])
     * }
     */
    public static long nrand48(MemorySegment x0) {
        var mh$ = nrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nrand48", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class posix_openpt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("posix_openpt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int posix_openpt(int)
     * }
     */
    public static FunctionDescriptor posix_openpt$descriptor() {
        return posix_openpt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int posix_openpt(int)
     * }
     */
    public static MethodHandle posix_openpt$handle() {
        return posix_openpt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int posix_openpt(int)
     * }
     */
    public static MemorySegment posix_openpt$address() {
        return posix_openpt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int posix_openpt(int)
     * }
     */
    public static int posix_openpt(int x0) {
        var mh$ = posix_openpt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("posix_openpt", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ptsname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ptsname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ptsname(int)
     * }
     */
    public static FunctionDescriptor ptsname$descriptor() {
        return ptsname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ptsname(int)
     * }
     */
    public static MethodHandle ptsname$handle() {
        return ptsname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ptsname(int)
     * }
     */
    public static MemorySegment ptsname$address() {
        return ptsname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ptsname(int)
     * }
     */
    public static MemorySegment ptsname(int x0) {
        var mh$ = ptsname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ptsname", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ptsname_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ptsname_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ptsname_r(int fildes, char *buffer, size_t buflen)
     * }
     */
    public static FunctionDescriptor ptsname_r$descriptor() {
        return ptsname_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ptsname_r(int fildes, char *buffer, size_t buflen)
     * }
     */
    public static MethodHandle ptsname_r$handle() {
        return ptsname_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ptsname_r(int fildes, char *buffer, size_t buflen)
     * }
     */
    public static MemorySegment ptsname_r$address() {
        return ptsname_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ptsname_r(int fildes, char *buffer, size_t buflen)
     * }
     */
    public static int ptsname_r(int fildes, MemorySegment buffer, long buflen) {
        var mh$ = ptsname_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ptsname_r", fildes, buffer, buflen);
            }
            return (int)mh$.invokeExact(fildes, buffer, buflen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("putenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putenv(char *)
     * }
     */
    public static FunctionDescriptor putenv$descriptor() {
        return putenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putenv(char *)
     * }
     */
    public static MethodHandle putenv$handle() {
        return putenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putenv(char *)
     * }
     */
    public static MemorySegment putenv$address() {
        return putenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putenv(char *)
     * }
     */
    public static int putenv(MemorySegment x0) {
        var mh$ = putenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putenv", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class random {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("random");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long random()
     * }
     */
    public static FunctionDescriptor random$descriptor() {
        return random.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long random()
     * }
     */
    public static MethodHandle random$handle() {
        return random.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long random()
     * }
     */
    public static MemorySegment random$address() {
        return random.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long random()
     * }
     */
    public static long random() {
        var mh$ = random.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("random");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("rand_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rand_r(unsigned int *)
     * }
     */
    public static FunctionDescriptor rand_r$descriptor() {
        return rand_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rand_r(unsigned int *)
     * }
     */
    public static MethodHandle rand_r$handle() {
        return rand_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rand_r(unsigned int *)
     * }
     */
    public static MemorySegment rand_r$address() {
        return rand_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rand_r(unsigned int *)
     * }
     */
    public static int rand_r(MemorySegment x0) {
        var mh$ = rand_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand_r", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realpath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("realpath$DARWIN_EXTSN");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *realpath(const char *restrict, char *restrict)
     * }
     */
    public static FunctionDescriptor realpath$descriptor() {
        return realpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *realpath(const char *restrict, char *restrict)
     * }
     */
    public static MethodHandle realpath$handle() {
        return realpath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *realpath(const char *restrict, char *restrict)
     * }
     */
    public static MemorySegment realpath$address() {
        return realpath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *realpath(const char *restrict, char *restrict)
     * }
     */
    public static MemorySegment realpath(MemorySegment x0, MemorySegment x1) {
        var mh$ = realpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realpath", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class seed48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("seed48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned short *seed48(unsigned short [3])
     * }
     */
    public static FunctionDescriptor seed48$descriptor() {
        return seed48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned short *seed48(unsigned short [3])
     * }
     */
    public static MethodHandle seed48$handle() {
        return seed48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned short *seed48(unsigned short [3])
     * }
     */
    public static MemorySegment seed48$address() {
        return seed48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned short *seed48(unsigned short [3])
     * }
     */
    public static MemorySegment seed48(MemorySegment x0) {
        var mh$ = seed48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("seed48", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setenv(const char *__name, const char *__value, int __overwrite)
     * }
     */
    public static FunctionDescriptor setenv$descriptor() {
        return setenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setenv(const char *__name, const char *__value, int __overwrite)
     * }
     */
    public static MethodHandle setenv$handle() {
        return setenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setenv(const char *__name, const char *__value, int __overwrite)
     * }
     */
    public static MemorySegment setenv$address() {
        return setenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setenv(const char *__name, const char *__value, int __overwrite)
     * }
     */
    public static int setenv(MemorySegment __name, MemorySegment __value, int __overwrite) {
        var mh$ = setenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setenv", __name, __value, __overwrite);
            }
            return (int)mh$.invokeExact(__name, __value, __overwrite);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setkey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setkey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setkey(const char *)
     * }
     */
    public static FunctionDescriptor setkey$descriptor() {
        return setkey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setkey(const char *)
     * }
     */
    public static MethodHandle setkey$handle() {
        return setkey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setkey(const char *)
     * }
     */
    public static MemorySegment setkey$address() {
        return setkey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setkey(const char *)
     * }
     */
    public static void setkey(MemorySegment x0) {
        var mh$ = setkey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setkey", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *setstate(const char *)
     * }
     */
    public static FunctionDescriptor setstate$descriptor() {
        return setstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *setstate(const char *)
     * }
     */
    public static MethodHandle setstate$handle() {
        return setstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *setstate(const char *)
     * }
     */
    public static MemorySegment setstate$address() {
        return setstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *setstate(const char *)
     * }
     */
    public static MemorySegment setstate(MemorySegment x0) {
        var mh$ = setstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setstate", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("srand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srand48(long)
     * }
     */
    public static FunctionDescriptor srand48$descriptor() {
        return srand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srand48(long)
     * }
     */
    public static MethodHandle srand48$handle() {
        return srand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srand48(long)
     * }
     */
    public static MemorySegment srand48$address() {
        return srand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srand48(long)
     * }
     */
    public static void srand48(long x0) {
        var mh$ = srand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand48", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srandom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("srandom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srandom(unsigned int)
     * }
     */
    public static FunctionDescriptor srandom$descriptor() {
        return srandom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srandom(unsigned int)
     * }
     */
    public static MethodHandle srandom$handle() {
        return srandom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srandom(unsigned int)
     * }
     */
    public static MemorySegment srandom$address() {
        return srandom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srandom(unsigned int)
     * }
     */
    public static void srandom(int x0) {
        var mh$ = srandom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srandom", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unlockpt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("unlockpt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int unlockpt(int)
     * }
     */
    public static FunctionDescriptor unlockpt$descriptor() {
        return unlockpt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int unlockpt(int)
     * }
     */
    public static MethodHandle unlockpt$handle() {
        return unlockpt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int unlockpt(int)
     * }
     */
    public static MemorySegment unlockpt$address() {
        return unlockpt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int unlockpt(int)
     * }
     */
    public static int unlockpt(int x0) {
        var mh$ = unlockpt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unlockpt", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unsetenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("unsetenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int unsetenv(const char *)
     * }
     */
    public static FunctionDescriptor unsetenv$descriptor() {
        return unsetenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int unsetenv(const char *)
     * }
     */
    public static MethodHandle unsetenv$handle() {
        return unsetenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int unsetenv(const char *)
     * }
     */
    public static MemorySegment unsetenv$address() {
        return unsetenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int unsetenv(const char *)
     * }
     */
    public static int unsetenv(MemorySegment x0) {
        var mh$ = unsetenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unsetenv", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_dev_t dev_t
     * }
     */
    public static final OfInt dev_t = Python_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_mode_t mode_t
     * }
     */
    public static final OfShort mode_t = Python_h.C_SHORT;

    private static class arc4random {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("arc4random");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t arc4random()
     * }
     */
    public static FunctionDescriptor arc4random$descriptor() {
        return arc4random.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t arc4random()
     * }
     */
    public static MethodHandle arc4random$handle() {
        return arc4random.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t arc4random()
     * }
     */
    public static MemorySegment arc4random$address() {
        return arc4random.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t arc4random()
     * }
     */
    public static int arc4random() {
        var mh$ = arc4random.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_addrandom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("arc4random_addrandom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void arc4random_addrandom(unsigned char *, int)
     * }
     */
    public static FunctionDescriptor arc4random_addrandom$descriptor() {
        return arc4random_addrandom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void arc4random_addrandom(unsigned char *, int)
     * }
     */
    public static MethodHandle arc4random_addrandom$handle() {
        return arc4random_addrandom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void arc4random_addrandom(unsigned char *, int)
     * }
     */
    public static MemorySegment arc4random_addrandom$address() {
        return arc4random_addrandom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void arc4random_addrandom(unsigned char *, int)
     * }
     */
    public static void arc4random_addrandom(MemorySegment x0, int x1) {
        var mh$ = arc4random_addrandom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_addrandom", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_buf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("arc4random_buf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void arc4random_buf(void *__buf, size_t __nbytes)
     * }
     */
    public static FunctionDescriptor arc4random_buf$descriptor() {
        return arc4random_buf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void arc4random_buf(void *__buf, size_t __nbytes)
     * }
     */
    public static MethodHandle arc4random_buf$handle() {
        return arc4random_buf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void arc4random_buf(void *__buf, size_t __nbytes)
     * }
     */
    public static MemorySegment arc4random_buf$address() {
        return arc4random_buf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void arc4random_buf(void *__buf, size_t __nbytes)
     * }
     */
    public static void arc4random_buf(MemorySegment __buf, long __nbytes) {
        var mh$ = arc4random_buf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_buf", __buf, __nbytes);
            }
            mh$.invokeExact(__buf, __nbytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_stir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("arc4random_stir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void arc4random_stir()
     * }
     */
    public static FunctionDescriptor arc4random_stir$descriptor() {
        return arc4random_stir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void arc4random_stir()
     * }
     */
    public static MethodHandle arc4random_stir$handle() {
        return arc4random_stir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void arc4random_stir()
     * }
     */
    public static MemorySegment arc4random_stir$address() {
        return arc4random_stir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void arc4random_stir()
     * }
     */
    public static void arc4random_stir() {
        var mh$ = arc4random_stir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_stir");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_uniform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("arc4random_uniform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t arc4random_uniform(uint32_t __upper_bound)
     * }
     */
    public static FunctionDescriptor arc4random_uniform$descriptor() {
        return arc4random_uniform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t arc4random_uniform(uint32_t __upper_bound)
     * }
     */
    public static MethodHandle arc4random_uniform$handle() {
        return arc4random_uniform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t arc4random_uniform(uint32_t __upper_bound)
     * }
     */
    public static MemorySegment arc4random_uniform$address() {
        return arc4random_uniform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t arc4random_uniform(uint32_t __upper_bound)
     * }
     */
    public static int arc4random_uniform(int __upper_bound) {
        var mh$ = arc4random_uniform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_uniform", __upper_bound);
            }
            return (int)mh$.invokeExact(__upper_bound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atexit_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("atexit_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int atexit_b(void (^ _Nonnull)(void))
     * }
     */
    public static FunctionDescriptor atexit_b$descriptor() {
        return atexit_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int atexit_b(void (^ _Nonnull)(void))
     * }
     */
    public static MethodHandle atexit_b$handle() {
        return atexit_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int atexit_b(void (^ _Nonnull)(void))
     * }
     */
    public static MemorySegment atexit_b$address() {
        return atexit_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int atexit_b(void (^ _Nonnull)(void))
     * }
     */
    public static int atexit_b(MemorySegment x0) {
        var mh$ = atexit_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atexit_b", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bsearch_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("bsearch_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, __bsearch_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor bsearch_b$descriptor() {
        return bsearch_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, __bsearch_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle bsearch_b$handle() {
        return bsearch_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, __bsearch_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment bsearch_b$address() {
        return bsearch_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, __bsearch_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment bsearch_b(MemorySegment __key, MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = bsearch_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bsearch_b", __key, __base, __nel, __width, __compar);
            }
            return (MemorySegment)mh$.invokeExact(__key, __base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetcap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("cgetcap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *cgetcap(char *, const char *, int)
     * }
     */
    public static FunctionDescriptor cgetcap$descriptor() {
        return cgetcap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *cgetcap(char *, const char *, int)
     * }
     */
    public static MethodHandle cgetcap$handle() {
        return cgetcap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *cgetcap(char *, const char *, int)
     * }
     */
    public static MemorySegment cgetcap$address() {
        return cgetcap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *cgetcap(char *, const char *, int)
     * }
     */
    public static MemorySegment cgetcap(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = cgetcap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetcap", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("cgetclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetclose()
     * }
     */
    public static FunctionDescriptor cgetclose$descriptor() {
        return cgetclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetclose()
     * }
     */
    public static MethodHandle cgetclose$handle() {
        return cgetclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetclose()
     * }
     */
    public static MemorySegment cgetclose$address() {
        return cgetclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetclose()
     * }
     */
    public static int cgetclose() {
        var mh$ = cgetclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetclose");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("cgetent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetent(char **, char **, const char *)
     * }
     */
    public static FunctionDescriptor cgetent$descriptor() {
        return cgetent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetent(char **, char **, const char *)
     * }
     */
    public static MethodHandle cgetent$handle() {
        return cgetent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetent(char **, char **, const char *)
     * }
     */
    public static MemorySegment cgetent$address() {
        return cgetent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetent(char **, char **, const char *)
     * }
     */
    public static int cgetent(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = cgetent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetent", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetfirst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("cgetfirst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetfirst(char **, char **)
     * }
     */
    public static FunctionDescriptor cgetfirst$descriptor() {
        return cgetfirst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetfirst(char **, char **)
     * }
     */
    public static MethodHandle cgetfirst$handle() {
        return cgetfirst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetfirst(char **, char **)
     * }
     */
    public static MemorySegment cgetfirst$address() {
        return cgetfirst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetfirst(char **, char **)
     * }
     */
    public static int cgetfirst(MemorySegment x0, MemorySegment x1) {
        var mh$ = cgetfirst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetfirst", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetmatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("cgetmatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetmatch(const char *, const char *)
     * }
     */
    public static FunctionDescriptor cgetmatch$descriptor() {
        return cgetmatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetmatch(const char *, const char *)
     * }
     */
    public static MethodHandle cgetmatch$handle() {
        return cgetmatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetmatch(const char *, const char *)
     * }
     */
    public static MemorySegment cgetmatch$address() {
        return cgetmatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetmatch(const char *, const char *)
     * }
     */
    public static int cgetmatch(MemorySegment x0, MemorySegment x1) {
        var mh$ = cgetmatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetmatch", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetnext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("cgetnext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetnext(char **, char **)
     * }
     */
    public static FunctionDescriptor cgetnext$descriptor() {
        return cgetnext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetnext(char **, char **)
     * }
     */
    public static MethodHandle cgetnext$handle() {
        return cgetnext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetnext(char **, char **)
     * }
     */
    public static MemorySegment cgetnext$address() {
        return cgetnext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetnext(char **, char **)
     * }
     */
    public static int cgetnext(MemorySegment x0, MemorySegment x1) {
        var mh$ = cgetnext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetnext", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetnum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("cgetnum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetnum(char *, const char *, long *)
     * }
     */
    public static FunctionDescriptor cgetnum$descriptor() {
        return cgetnum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetnum(char *, const char *, long *)
     * }
     */
    public static MethodHandle cgetnum$handle() {
        return cgetnum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetnum(char *, const char *, long *)
     * }
     */
    public static MemorySegment cgetnum$address() {
        return cgetnum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetnum(char *, const char *, long *)
     * }
     */
    public static int cgetnum(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = cgetnum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetnum", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("cgetset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetset(const char *)
     * }
     */
    public static FunctionDescriptor cgetset$descriptor() {
        return cgetset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetset(const char *)
     * }
     */
    public static MethodHandle cgetset$handle() {
        return cgetset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetset(const char *)
     * }
     */
    public static MemorySegment cgetset$address() {
        return cgetset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetset(const char *)
     * }
     */
    public static int cgetset(MemorySegment x0) {
        var mh$ = cgetset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetset", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("cgetstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetstr(char *, const char *, char **)
     * }
     */
    public static FunctionDescriptor cgetstr$descriptor() {
        return cgetstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetstr(char *, const char *, char **)
     * }
     */
    public static MethodHandle cgetstr$handle() {
        return cgetstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetstr(char *, const char *, char **)
     * }
     */
    public static MemorySegment cgetstr$address() {
        return cgetstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetstr(char *, const char *, char **)
     * }
     */
    public static int cgetstr(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = cgetstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetstr", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetustr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("cgetustr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetustr(char *, const char *, char **)
     * }
     */
    public static FunctionDescriptor cgetustr$descriptor() {
        return cgetustr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetustr(char *, const char *, char **)
     * }
     */
    public static MethodHandle cgetustr$handle() {
        return cgetustr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetustr(char *, const char *, char **)
     * }
     */
    public static MemorySegment cgetustr$address() {
        return cgetustr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetustr(char *, const char *, char **)
     * }
     */
    public static int cgetustr(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = cgetustr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetustr", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class daemon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("daemon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int daemon(int, int)
     * }
     */
    public static FunctionDescriptor daemon$descriptor() {
        return daemon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int daemon(int, int)
     * }
     */
    public static MethodHandle daemon$handle() {
        return daemon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int daemon(int, int)
     * }
     */
    public static MemorySegment daemon$address() {
        return daemon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int daemon(int, int)
     * }
     */
    public static int daemon(int x0, int x1) {
        var mh$ = daemon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("daemon", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class devname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_SHORT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("devname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *devname(dev_t, mode_t)
     * }
     */
    public static FunctionDescriptor devname$descriptor() {
        return devname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *devname(dev_t, mode_t)
     * }
     */
    public static MethodHandle devname$handle() {
        return devname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *devname(dev_t, mode_t)
     * }
     */
    public static MemorySegment devname$address() {
        return devname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *devname(dev_t, mode_t)
     * }
     */
    public static MemorySegment devname(int x0, short x1) {
        var mh$ = devname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("devname", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class devname_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_SHORT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("devname_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *devname_r(dev_t, mode_t, char *buf, int len)
     * }
     */
    public static FunctionDescriptor devname_r$descriptor() {
        return devname_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *devname_r(dev_t, mode_t, char *buf, int len)
     * }
     */
    public static MethodHandle devname_r$handle() {
        return devname_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *devname_r(dev_t, mode_t, char *buf, int len)
     * }
     */
    public static MemorySegment devname_r$address() {
        return devname_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *devname_r(dev_t, mode_t, char *buf, int len)
     * }
     */
    public static MemorySegment devname_r(int x0, short x1, MemorySegment buf, int len) {
        var mh$ = devname_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("devname_r", x0, x1, buf, len);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, buf, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getbsize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getbsize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getbsize(int *, long *)
     * }
     */
    public static FunctionDescriptor getbsize$descriptor() {
        return getbsize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getbsize(int *, long *)
     * }
     */
    public static MethodHandle getbsize$handle() {
        return getbsize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getbsize(int *, long *)
     * }
     */
    public static MemorySegment getbsize$address() {
        return getbsize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getbsize(int *, long *)
     * }
     */
    public static MemorySegment getbsize(MemorySegment x0, MemorySegment x1) {
        var mh$ = getbsize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getbsize", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getloadavg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getloadavg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getloadavg(double [], int)
     * }
     */
    public static FunctionDescriptor getloadavg$descriptor() {
        return getloadavg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getloadavg(double [], int)
     * }
     */
    public static MethodHandle getloadavg$handle() {
        return getloadavg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getloadavg(double [], int)
     * }
     */
    public static MemorySegment getloadavg$address() {
        return getloadavg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getloadavg(double [], int)
     * }
     */
    public static int getloadavg(MemorySegment x0, int x1) {
        var mh$ = getloadavg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getloadavg", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getprogname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getprogname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *getprogname()
     * }
     */
    public static FunctionDescriptor getprogname$descriptor() {
        return getprogname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *getprogname()
     * }
     */
    public static MethodHandle getprogname$handle() {
        return getprogname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *getprogname()
     * }
     */
    public static MemorySegment getprogname$address() {
        return getprogname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *getprogname()
     * }
     */
    public static MemorySegment getprogname() {
        var mh$ = getprogname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getprogname");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setprogname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setprogname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setprogname(const char *)
     * }
     */
    public static FunctionDescriptor setprogname$descriptor() {
        return setprogname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setprogname(const char *)
     * }
     */
    public static MethodHandle setprogname$handle() {
        return setprogname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setprogname(const char *)
     * }
     */
    public static MemorySegment setprogname$address() {
        return setprogname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setprogname(const char *)
     * }
     */
    public static void setprogname(MemorySegment x0) {
        var mh$ = setprogname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setprogname", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heapsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("heapsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heapsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor heapsort$descriptor() {
        return heapsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heapsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle heapsort$handle() {
        return heapsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heapsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment heapsort$address() {
        return heapsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heapsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static int heapsort(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = heapsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heapsort", __base, __nel, __width, __compar);
            }
            return (int)mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heapsort_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("heapsort_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heapsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor heapsort_b$descriptor() {
        return heapsort_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heapsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle heapsort_b$handle() {
        return heapsort_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heapsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment heapsort_b$address() {
        return heapsort_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heapsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static int heapsort_b(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = heapsort_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heapsort_b", __base, __nel, __width, __compar);
            }
            return (int)mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mergesort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mergesort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mergesort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor mergesort$descriptor() {
        return mergesort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mergesort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle mergesort$handle() {
        return mergesort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mergesort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment mergesort$address() {
        return mergesort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mergesort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static int mergesort(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = mergesort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mergesort", __base, __nel, __width, __compar);
            }
            return (int)mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mergesort_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("mergesort_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mergesort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor mergesort_b$descriptor() {
        return mergesort_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mergesort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle mergesort_b$handle() {
        return mergesort_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mergesort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment mergesort_b$address() {
        return mergesort_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mergesort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static int mergesort_b(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = mergesort_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mergesort_b", __base, __nel, __width, __compar);
            }
            return (int)mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class psort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("psort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void psort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor psort$descriptor() {
        return psort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void psort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle psort$handle() {
        return psort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void psort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment psort$address() {
        return psort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void psort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static void psort(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = psort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("psort", __base, __nel, __width, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class psort_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("psort_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void psort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor psort_b$descriptor() {
        return psort_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void psort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle psort_b$handle() {
        return psort_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void psort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment psort_b$address() {
        return psort_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void psort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static void psort_b(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = psort_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("psort_b", __base, __nel, __width, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class psort_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("psort_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void psort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static FunctionDescriptor psort_r$descriptor() {
        return psort_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void psort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static MethodHandle psort_r$handle() {
        return psort_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void psort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static MemorySegment psort_r$address() {
        return psort_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void psort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static void psort_r(MemorySegment __base, long __nel, long __width, MemorySegment x3, MemorySegment __compar) {
        var mh$ = psort_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("psort_r", __base, __nel, __width, x3, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, x3, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("qsort_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor qsort_b$descriptor() {
        return qsort_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle qsort_b$handle() {
        return qsort_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment qsort_b$address() {
        return qsort_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static void qsort_b(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = qsort_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort_b", __base, __nel, __width, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("qsort_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static FunctionDescriptor qsort_r$descriptor() {
        return qsort_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static MethodHandle qsort_r$handle() {
        return qsort_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static MemorySegment qsort_r$address() {
        return qsort_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static void qsort_r(MemorySegment __base, long __nel, long __width, MemorySegment x3, MemorySegment __compar) {
        var mh$ = qsort_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort_r", __base, __nel, __width, x3, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, x3, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class radixsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("radixsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static FunctionDescriptor radixsort$descriptor() {
        return radixsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static MethodHandle radixsort$handle() {
        return radixsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static MemorySegment radixsort$address() {
        return radixsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static int radixsort(MemorySegment __base, int __nel, MemorySegment __table, int __endbyte) {
        var mh$ = radixsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("radixsort", __base, __nel, __table, __endbyte);
            }
            return (int)mh$.invokeExact(__base, __nel, __table, __endbyte);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rpmatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("rpmatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rpmatch(const char *)
     * }
     */
    public static FunctionDescriptor rpmatch$descriptor() {
        return rpmatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rpmatch(const char *)
     * }
     */
    public static MethodHandle rpmatch$handle() {
        return rpmatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rpmatch(const char *)
     * }
     */
    public static MemorySegment rpmatch$address() {
        return rpmatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rpmatch(const char *)
     * }
     */
    public static int rpmatch(MemorySegment x0) {
        var mh$ = rpmatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rpmatch", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sradixsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sradixsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static FunctionDescriptor sradixsort$descriptor() {
        return sradixsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static MethodHandle sradixsort$handle() {
        return sradixsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static MemorySegment sradixsort$address() {
        return sradixsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static int sradixsort(MemorySegment __base, int __nel, MemorySegment __table, int __endbyte) {
        var mh$ = sradixsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sradixsort", __base, __nel, __table, __endbyte);
            }
            return (int)mh$.invokeExact(__base, __nel, __table, __endbyte);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sranddev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("sranddev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sranddev()
     * }
     */
    public static FunctionDescriptor sranddev$descriptor() {
        return sranddev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sranddev()
     * }
     */
    public static MethodHandle sranddev$handle() {
        return sranddev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sranddev()
     * }
     */
    public static MemorySegment sranddev$address() {
        return sranddev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sranddev()
     * }
     */
    public static void sranddev() {
        var mh$ = sranddev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sranddev");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srandomdev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("srandomdev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srandomdev()
     * }
     */
    public static FunctionDescriptor srandomdev$descriptor() {
        return srandomdev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srandomdev()
     * }
     */
    public static MethodHandle srandomdev$handle() {
        return srandomdev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srandomdev()
     * }
     */
    public static MemorySegment srandomdev$address() {
        return srandomdev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srandomdev()
     * }
     */
    public static void srandomdev() {
        var mh$ = srandomdev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srandomdev");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtonum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strtonum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
     * }
     */
    public static FunctionDescriptor strtonum$descriptor() {
        return strtonum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
     * }
     */
    public static MethodHandle strtonum$handle() {
        return strtonum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
     * }
     */
    public static MemorySegment strtonum$address() {
        return strtonum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
     * }
     */
    public static long strtonum(MemorySegment __numstr, long __minval, long __maxval, MemorySegment __errstrp) {
        var mh$ = strtonum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtonum", __numstr, __minval, __maxval, __errstrp);
            }
            return (long)mh$.invokeExact(__numstr, __minval, __maxval, __errstrp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strtoq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long strtoq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoq$descriptor() {
        return strtoq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long strtoq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtoq$handle() {
        return strtoq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long strtoq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtoq$address() {
        return strtoq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long strtoq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtoq(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtoq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoq", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtouq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strtouq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long strtouq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtouq$descriptor() {
        return strtouq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long strtouq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtouq$handle() {
        return strtouq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long strtouq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtouq$address() {
        return strtouq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long strtouq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtouq(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtouq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtouq", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class suboptarg$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("suboptarg").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static AddressLayout suboptarg$layout() {
        return suboptarg$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static MemorySegment suboptarg$segment() {
        return suboptarg$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static MemorySegment suboptarg() {
        return suboptarg$constants.SEGMENT.get(suboptarg$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static void suboptarg(MemorySegment varValue) {
        suboptarg$constants.SEGMENT.set(suboptarg$constants.LAYOUT, 0L, varValue);
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_va_list va_list
     * }
     */
    public static final AddressLayout va_list = Python_h.C_POINTER;

    private static class renameat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("renameat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int renameat(int, const char *, int, const char *)
     * }
     */
    public static FunctionDescriptor renameat$descriptor() {
        return renameat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int renameat(int, const char *, int, const char *)
     * }
     */
    public static MethodHandle renameat$handle() {
        return renameat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int renameat(int, const char *, int, const char *)
     * }
     */
    public static MemorySegment renameat$address() {
        return renameat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int renameat(int, const char *, int, const char *)
     * }
     */
    public static int renameat(int x0, MemorySegment x1, int x2, MemorySegment x3) {
        var mh$ = renameat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("renameat", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class renamex_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("renamex_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int renamex_np(const char *, const char *, unsigned int)
     * }
     */
    public static FunctionDescriptor renamex_np$descriptor() {
        return renamex_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int renamex_np(const char *, const char *, unsigned int)
     * }
     */
    public static MethodHandle renamex_np$handle() {
        return renamex_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int renamex_np(const char *, const char *, unsigned int)
     * }
     */
    public static MemorySegment renamex_np$address() {
        return renamex_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int renamex_np(const char *, const char *, unsigned int)
     * }
     */
    public static int renamex_np(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = renamex_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("renamex_np", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class renameatx_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("renameatx_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int renameatx_np(int, const char *, int, const char *, unsigned int)
     * }
     */
    public static FunctionDescriptor renameatx_np$descriptor() {
        return renameatx_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int renameatx_np(int, const char *, int, const char *, unsigned int)
     * }
     */
    public static MethodHandle renameatx_np$handle() {
        return renameatx_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int renameatx_np(int, const char *, int, const char *, unsigned int)
     * }
     */
    public static MemorySegment renameatx_np$address() {
        return renameatx_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int renameatx_np(int, const char *, int, const char *, unsigned int)
     * }
     */
    public static int renameatx_np(int x0, MemorySegment x1, int x2, MemorySegment x3, int x4) {
        var mh$ = renameatx_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("renameatx_np", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_off_t fpos_t
     * }
     */
    public static final OfLong fpos_t = Python_h.C_LONG_LONG;

    private static class __stdinp$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("__stdinp").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *__stdinp
     * }
     */
    public static AddressLayout __stdinp$layout() {
        return __stdinp$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *__stdinp
     * }
     */
    public static MemorySegment __stdinp$segment() {
        return __stdinp$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *__stdinp
     * }
     */
    public static MemorySegment __stdinp() {
        return __stdinp$constants.SEGMENT.get(__stdinp$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *__stdinp
     * }
     */
    public static void __stdinp(MemorySegment varValue) {
        __stdinp$constants.SEGMENT.set(__stdinp$constants.LAYOUT, 0L, varValue);
    }

    private static class __stdoutp$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("__stdoutp").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *__stdoutp
     * }
     */
    public static AddressLayout __stdoutp$layout() {
        return __stdoutp$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *__stdoutp
     * }
     */
    public static MemorySegment __stdoutp$segment() {
        return __stdoutp$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *__stdoutp
     * }
     */
    public static MemorySegment __stdoutp() {
        return __stdoutp$constants.SEGMENT.get(__stdoutp$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *__stdoutp
     * }
     */
    public static void __stdoutp(MemorySegment varValue) {
        __stdoutp$constants.SEGMENT.set(__stdoutp$constants.LAYOUT, 0L, varValue);
    }

    private static class __stderrp$constants {
        public static final AddressLayout LAYOUT = Python_h.C_POINTER;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("__stderrp").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *__stderrp
     * }
     */
    public static AddressLayout __stderrp$layout() {
        return __stderrp$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *__stderrp
     * }
     */
    public static MemorySegment __stderrp$segment() {
        return __stderrp$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *__stderrp
     * }
     */
    public static MemorySegment __stderrp() {
        return __stderrp$constants.SEGMENT.get(__stderrp$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *__stderrp
     * }
     */
    public static void __stderrp(MemorySegment varValue) {
        __stderrp$constants.SEGMENT.set(__stderrp$constants.LAYOUT, 0L, varValue);
    }

    private static class clearerr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("clearerr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clearerr(FILE *)
     * }
     */
    public static FunctionDescriptor clearerr$descriptor() {
        return clearerr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clearerr(FILE *)
     * }
     */
    public static MethodHandle clearerr$handle() {
        return clearerr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clearerr(FILE *)
     * }
     */
    public static MemorySegment clearerr$address() {
        return clearerr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clearerr(FILE *)
     * }
     */
    public static void clearerr(MemorySegment x0) {
        var mh$ = clearerr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearerr", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fclose(FILE *)
     * }
     */
    public static FunctionDescriptor fclose$descriptor() {
        return fclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fclose(FILE *)
     * }
     */
    public static MethodHandle fclose$handle() {
        return fclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fclose(FILE *)
     * }
     */
    public static MemorySegment fclose$address() {
        return fclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fclose(FILE *)
     * }
     */
    public static int fclose(MemorySegment x0) {
        var mh$ = fclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fclose", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class feof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("feof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int feof(FILE *)
     * }
     */
    public static FunctionDescriptor feof$descriptor() {
        return feof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int feof(FILE *)
     * }
     */
    public static MethodHandle feof$handle() {
        return feof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int feof(FILE *)
     * }
     */
    public static MemorySegment feof$address() {
        return feof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int feof(FILE *)
     * }
     */
    public static int feof(MemorySegment x0) {
        var mh$ = feof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("feof", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ferror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ferror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ferror(FILE *)
     * }
     */
    public static FunctionDescriptor ferror$descriptor() {
        return ferror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ferror(FILE *)
     * }
     */
    public static MethodHandle ferror$handle() {
        return ferror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ferror(FILE *)
     * }
     */
    public static MemorySegment ferror$address() {
        return ferror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ferror(FILE *)
     * }
     */
    public static int ferror(MemorySegment x0) {
        var mh$ = ferror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ferror", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fflush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fflush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fflush(FILE *)
     * }
     */
    public static FunctionDescriptor fflush$descriptor() {
        return fflush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fflush(FILE *)
     * }
     */
    public static MethodHandle fflush$handle() {
        return fflush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fflush(FILE *)
     * }
     */
    public static MemorySegment fflush$address() {
        return fflush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fflush(FILE *)
     * }
     */
    public static int fflush(MemorySegment x0) {
        var mh$ = fflush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fflush", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fgetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fgetc(FILE *)
     * }
     */
    public static FunctionDescriptor fgetc$descriptor() {
        return fgetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fgetc(FILE *)
     * }
     */
    public static MethodHandle fgetc$handle() {
        return fgetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fgetc(FILE *)
     * }
     */
    public static MemorySegment fgetc$address() {
        return fgetc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fgetc(FILE *)
     * }
     */
    public static int fgetc(MemorySegment x0) {
        var mh$ = fgetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetc", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fgetpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fgetpos(FILE *restrict, fpos_t *)
     * }
     */
    public static FunctionDescriptor fgetpos$descriptor() {
        return fgetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fgetpos(FILE *restrict, fpos_t *)
     * }
     */
    public static MethodHandle fgetpos$handle() {
        return fgetpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fgetpos(FILE *restrict, fpos_t *)
     * }
     */
    public static MemorySegment fgetpos$address() {
        return fgetpos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fgetpos(FILE *restrict, fpos_t *)
     * }
     */
    public static int fgetpos(MemorySegment x0, MemorySegment x1) {
        var mh$ = fgetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetpos", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fgets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *fgets(char *restrict, int, FILE *)
     * }
     */
    public static FunctionDescriptor fgets$descriptor() {
        return fgets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *fgets(char *restrict, int, FILE *)
     * }
     */
    public static MethodHandle fgets$handle() {
        return fgets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *fgets(char *restrict, int, FILE *)
     * }
     */
    public static MemorySegment fgets$address() {
        return fgets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *fgets(char *restrict, int, FILE *)
     * }
     */
    public static MemorySegment fgets(MemorySegment x0, int x1, MemorySegment x2) {
        var mh$ = fgets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgets", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fopen$DARWIN_EXTSN");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *fopen(const char *restrict __filename, const char *restrict __mode)
     * }
     */
    public static FunctionDescriptor fopen$descriptor() {
        return fopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *fopen(const char *restrict __filename, const char *restrict __mode)
     * }
     */
    public static MethodHandle fopen$handle() {
        return fopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *fopen(const char *restrict __filename, const char *restrict __mode)
     * }
     */
    public static MemorySegment fopen$address() {
        return fopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *fopen(const char *restrict __filename, const char *restrict __mode)
     * }
     */
    public static MemorySegment fopen(MemorySegment __filename, MemorySegment __mode) {
        var mh$ = fopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fopen", __filename, __mode);
            }
            return (MemorySegment)mh$.invokeExact(__filename, __mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int fprintf(FILE *restrict, const char *restrict, ...)
     * }
     */
    public static class fprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("fprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int fprintf(FILE *restrict, const char *restrict, ...)
         * }
         */
        public static fprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fprintf", x0, x1, x2);
                }
                return (int)spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class fputc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fputc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fputc(int, FILE *)
     * }
     */
    public static FunctionDescriptor fputc$descriptor() {
        return fputc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fputc(int, FILE *)
     * }
     */
    public static MethodHandle fputc$handle() {
        return fputc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fputc(int, FILE *)
     * }
     */
    public static MemorySegment fputc$address() {
        return fputc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fputc(int, FILE *)
     * }
     */
    public static int fputc(int x0, MemorySegment x1) {
        var mh$ = fputc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputc", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fputs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fputs(const char *restrict, FILE *restrict)
     * }
     */
    public static FunctionDescriptor fputs$descriptor() {
        return fputs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fputs(const char *restrict, FILE *restrict)
     * }
     */
    public static MethodHandle fputs$handle() {
        return fputs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fputs(const char *restrict, FILE *restrict)
     * }
     */
    public static MemorySegment fputs$address() {
        return fputs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fputs(const char *restrict, FILE *restrict)
     * }
     */
    public static int fputs(MemorySegment x0, MemorySegment x1) {
        var mh$ = fputs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputs", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long fread(void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fread$descriptor() {
        return fread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long fread(void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fread$handle() {
        return fread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long fread(void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fread$address() {
        return fread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long fread(void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream)
     * }
     */
    public static long fread(MemorySegment __ptr, long __size, long __nitems, MemorySegment __stream) {
        var mh$ = fread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fread", __ptr, __size, __nitems, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __nitems, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class freopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("freopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *freopen(const char *restrict, const char *restrict, FILE *restrict)
     * }
     */
    public static FunctionDescriptor freopen$descriptor() {
        return freopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *freopen(const char *restrict, const char *restrict, FILE *restrict)
     * }
     */
    public static MethodHandle freopen$handle() {
        return freopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *freopen(const char *restrict, const char *restrict, FILE *restrict)
     * }
     */
    public static MemorySegment freopen$address() {
        return freopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *freopen(const char *restrict, const char *restrict, FILE *restrict)
     * }
     */
    public static MemorySegment freopen(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = freopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("freopen", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int fscanf(FILE *restrict, const char *restrict, ...)
     * }
     */
    public static class fscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("fscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int fscanf(FILE *restrict, const char *restrict, ...)
         * }
         */
        public static fscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fscanf", x0, x1, x2);
                }
                return (int)spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class fseek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fseek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fseek(FILE *, long, int)
     * }
     */
    public static FunctionDescriptor fseek$descriptor() {
        return fseek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fseek(FILE *, long, int)
     * }
     */
    public static MethodHandle fseek$handle() {
        return fseek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fseek(FILE *, long, int)
     * }
     */
    public static MemorySegment fseek$address() {
        return fseek.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fseek(FILE *, long, int)
     * }
     */
    public static int fseek(MemorySegment x0, long x1, int x2) {
        var mh$ = fseek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseek", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fsetpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fsetpos(FILE *, const fpos_t *)
     * }
     */
    public static FunctionDescriptor fsetpos$descriptor() {
        return fsetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fsetpos(FILE *, const fpos_t *)
     * }
     */
    public static MethodHandle fsetpos$handle() {
        return fsetpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fsetpos(FILE *, const fpos_t *)
     * }
     */
    public static MemorySegment fsetpos$address() {
        return fsetpos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fsetpos(FILE *, const fpos_t *)
     * }
     */
    public static int fsetpos(MemorySegment x0, MemorySegment x1) {
        var mh$ = fsetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsetpos", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ftell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long ftell(FILE *)
     * }
     */
    public static FunctionDescriptor ftell$descriptor() {
        return ftell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long ftell(FILE *)
     * }
     */
    public static MethodHandle ftell$handle() {
        return ftell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long ftell(FILE *)
     * }
     */
    public static MemorySegment ftell$address() {
        return ftell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long ftell(FILE *)
     * }
     */
    public static long ftell(MemorySegment x0) {
        var mh$ = ftell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftell", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fwrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fwrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fwrite$descriptor() {
        return fwrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fwrite$handle() {
        return fwrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fwrite$address() {
        return fwrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream)
     * }
     */
    public static long fwrite(MemorySegment __ptr, long __size, long __nitems, MemorySegment __stream) {
        var mh$ = fwrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fwrite", __ptr, __size, __nitems, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __nitems, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getc(FILE *)
     * }
     */
    public static FunctionDescriptor getc$descriptor() {
        return getc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getc(FILE *)
     * }
     */
    public static MethodHandle getc$handle() {
        return getc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getc(FILE *)
     * }
     */
    public static MemorySegment getc$address() {
        return getc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getc(FILE *)
     * }
     */
    public static int getc(MemorySegment x0) {
        var mh$ = getc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getchar()
     * }
     */
    public static FunctionDescriptor getchar$descriptor() {
        return getchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getchar()
     * }
     */
    public static MethodHandle getchar$handle() {
        return getchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getchar()
     * }
     */
    public static MemorySegment getchar$address() {
        return getchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getchar()
     * }
     */
    public static int getchar() {
        var mh$ = getchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("gets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *gets(char *)
     * }
     */
    public static FunctionDescriptor gets$descriptor() {
        return gets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *gets(char *)
     * }
     */
    public static MethodHandle gets$handle() {
        return gets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *gets(char *)
     * }
     */
    public static MemorySegment gets$address() {
        return gets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *gets(char *)
     * }
     */
    public static MemorySegment gets(MemorySegment x0) {
        var mh$ = gets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gets", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class perror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("perror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void perror(const char *)
     * }
     */
    public static FunctionDescriptor perror$descriptor() {
        return perror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void perror(const char *)
     * }
     */
    public static MethodHandle perror$handle() {
        return perror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void perror(const char *)
     * }
     */
    public static MemorySegment perror$address() {
        return perror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void perror(const char *)
     * }
     */
    public static void perror(MemorySegment x0) {
        var mh$ = perror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("perror", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int printf(const char *restrict, ...)
     * }
     */
    public static class printf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("printf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private printf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int printf(const char *restrict, ...)
         * }
         */
        public static printf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new printf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("printf", x0, x1);
                }
                return (int)spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class putc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("putc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putc(int, FILE *)
     * }
     */
    public static FunctionDescriptor putc$descriptor() {
        return putc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putc(int, FILE *)
     * }
     */
    public static MethodHandle putc$handle() {
        return putc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putc(int, FILE *)
     * }
     */
    public static MemorySegment putc$address() {
        return putc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putc(int, FILE *)
     * }
     */
    public static int putc(int x0, MemorySegment x1) {
        var mh$ = putc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("putchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putchar(int)
     * }
     */
    public static FunctionDescriptor putchar$descriptor() {
        return putchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putchar(int)
     * }
     */
    public static MethodHandle putchar$handle() {
        return putchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putchar(int)
     * }
     */
    public static MemorySegment putchar$address() {
        return putchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putchar(int)
     * }
     */
    public static int putchar(int x0) {
        var mh$ = putchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class puts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("puts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int puts(const char *)
     * }
     */
    public static FunctionDescriptor puts$descriptor() {
        return puts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int puts(const char *)
     * }
     */
    public static MethodHandle puts$handle() {
        return puts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int puts(const char *)
     * }
     */
    public static MemorySegment puts$address() {
        return puts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int puts(const char *)
     * }
     */
    public static int puts(MemorySegment x0) {
        var mh$ = puts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("puts", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int remove(const char *)
     * }
     */
    public static FunctionDescriptor remove$descriptor() {
        return remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int remove(const char *)
     * }
     */
    public static MethodHandle remove$handle() {
        return remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int remove(const char *)
     * }
     */
    public static MemorySegment remove$address() {
        return remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int remove(const char *)
     * }
     */
    public static int remove(MemorySegment x0) {
        var mh$ = remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remove", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("rename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rename(const char *__old, const char *__new)
     * }
     */
    public static FunctionDescriptor rename$descriptor() {
        return rename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rename(const char *__old, const char *__new)
     * }
     */
    public static MethodHandle rename$handle() {
        return rename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rename(const char *__old, const char *__new)
     * }
     */
    public static MemorySegment rename$address() {
        return rename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rename(const char *__old, const char *__new)
     * }
     */
    public static int rename(MemorySegment __old, MemorySegment __new) {
        var mh$ = rename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rename", __old, __new);
            }
            return (int)mh$.invokeExact(__old, __new);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rewind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("rewind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rewind(FILE *)
     * }
     */
    public static FunctionDescriptor rewind$descriptor() {
        return rewind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rewind(FILE *)
     * }
     */
    public static MethodHandle rewind$handle() {
        return rewind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rewind(FILE *)
     * }
     */
    public static MemorySegment rewind$address() {
        return rewind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rewind(FILE *)
     * }
     */
    public static void rewind(MemorySegment x0) {
        var mh$ = rewind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rewind", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int scanf(const char *restrict, ...)
     * }
     */
    public static class scanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("scanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private scanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int scanf(const char *restrict, ...)
         * }
         */
        public static scanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new scanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("scanf", x0, x1);
                }
                return (int)spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class setbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setbuf(FILE *restrict, char *restrict)
     * }
     */
    public static FunctionDescriptor setbuf$descriptor() {
        return setbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setbuf(FILE *restrict, char *restrict)
     * }
     */
    public static MethodHandle setbuf$handle() {
        return setbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setbuf(FILE *restrict, char *restrict)
     * }
     */
    public static MemorySegment setbuf$address() {
        return setbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setbuf(FILE *restrict, char *restrict)
     * }
     */
    public static void setbuf(MemorySegment x0, MemorySegment x1) {
        var mh$ = setbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuf", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setvbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setvbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setvbuf(FILE *restrict, char *restrict, int, size_t)
     * }
     */
    public static FunctionDescriptor setvbuf$descriptor() {
        return setvbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setvbuf(FILE *restrict, char *restrict, int, size_t)
     * }
     */
    public static MethodHandle setvbuf$handle() {
        return setvbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setvbuf(FILE *restrict, char *restrict, int, size_t)
     * }
     */
    public static MemorySegment setvbuf$address() {
        return setvbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setvbuf(FILE *restrict, char *restrict, int, size_t)
     * }
     */
    public static int setvbuf(MemorySegment x0, MemorySegment x1, int x2, long x3) {
        var mh$ = setvbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setvbuf", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int sprintf(char *restrict, const char *restrict, ...)
     * }
     */
    public static class sprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("sprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private sprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int sprintf(char *restrict, const char *restrict, ...)
         * }
         */
        public static sprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new sprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("sprintf", x0, x1, x2);
                }
                return (int)spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int sscanf(const char *restrict, const char *restrict, ...)
     * }
     */
    public static class sscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("sscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private sscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int sscanf(const char *restrict, const char *restrict, ...)
         * }
         */
        public static sscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new sscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("sscanf", x0, x1, x2);
                }
                return (int)spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class tmpfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tmpfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *tmpfile()
     * }
     */
    public static FunctionDescriptor tmpfile$descriptor() {
        return tmpfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *tmpfile()
     * }
     */
    public static MethodHandle tmpfile$handle() {
        return tmpfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile$address() {
        return tmpfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile() {
        var mh$ = tmpfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpfile");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tmpnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *tmpnam(char *)
     * }
     */
    public static FunctionDescriptor tmpnam$descriptor() {
        return tmpnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *tmpnam(char *)
     * }
     */
    public static MethodHandle tmpnam$handle() {
        return tmpnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *tmpnam(char *)
     * }
     */
    public static MemorySegment tmpnam$address() {
        return tmpnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *tmpnam(char *)
     * }
     */
    public static MemorySegment tmpnam(MemorySegment x0) {
        var mh$ = tmpnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpnam", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ungetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ungetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ungetc(int, FILE *)
     * }
     */
    public static FunctionDescriptor ungetc$descriptor() {
        return ungetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ungetc(int, FILE *)
     * }
     */
    public static MethodHandle ungetc$handle() {
        return ungetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ungetc(int, FILE *)
     * }
     */
    public static MemorySegment ungetc$address() {
        return ungetc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ungetc(int, FILE *)
     * }
     */
    public static int ungetc(int x0, MemorySegment x1) {
        var mh$ = ungetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ungetc", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vfprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("vfprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vfprintf(FILE *restrict, const char *restrict, va_list)
     * }
     */
    public static FunctionDescriptor vfprintf$descriptor() {
        return vfprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vfprintf(FILE *restrict, const char *restrict, va_list)
     * }
     */
    public static MethodHandle vfprintf$handle() {
        return vfprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vfprintf(FILE *restrict, const char *restrict, va_list)
     * }
     */
    public static MemorySegment vfprintf$address() {
        return vfprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vfprintf(FILE *restrict, const char *restrict, va_list)
     * }
     */
    public static int vfprintf(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = vfprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfprintf", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("vprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vprintf(const char *restrict, va_list)
     * }
     */
    public static FunctionDescriptor vprintf$descriptor() {
        return vprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vprintf(const char *restrict, va_list)
     * }
     */
    public static MethodHandle vprintf$handle() {
        return vprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vprintf(const char *restrict, va_list)
     * }
     */
    public static MemorySegment vprintf$address() {
        return vprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vprintf(const char *restrict, va_list)
     * }
     */
    public static int vprintf(MemorySegment x0, MemorySegment x1) {
        var mh$ = vprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vprintf", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vsprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("vsprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vsprintf(char *restrict, const char *restrict, va_list)
     * }
     */
    public static FunctionDescriptor vsprintf$descriptor() {
        return vsprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vsprintf(char *restrict, const char *restrict, va_list)
     * }
     */
    public static MethodHandle vsprintf$handle() {
        return vsprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vsprintf(char *restrict, const char *restrict, va_list)
     * }
     */
    public static MemorySegment vsprintf$address() {
        return vsprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vsprintf(char *restrict, const char *restrict, va_list)
     * }
     */
    public static int vsprintf(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = vsprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsprintf", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctermid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ctermid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ctermid(char *)
     * }
     */
    public static FunctionDescriptor ctermid$descriptor() {
        return ctermid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ctermid(char *)
     * }
     */
    public static MethodHandle ctermid$handle() {
        return ctermid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ctermid(char *)
     * }
     */
    public static MemorySegment ctermid$address() {
        return ctermid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ctermid(char *)
     * }
     */
    public static MemorySegment ctermid(MemorySegment x0) {
        var mh$ = ctermid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctermid", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fdopen$DARWIN_EXTSN");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *fdopen(int, const char *)
     * }
     */
    public static FunctionDescriptor fdopen$descriptor() {
        return fdopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *fdopen(int, const char *)
     * }
     */
    public static MethodHandle fdopen$handle() {
        return fdopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *fdopen(int, const char *)
     * }
     */
    public static MemorySegment fdopen$address() {
        return fdopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *fdopen(int, const char *)
     * }
     */
    public static MemorySegment fdopen(int x0, MemorySegment x1) {
        var mh$ = fdopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdopen", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fileno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fileno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fileno(FILE *)
     * }
     */
    public static FunctionDescriptor fileno$descriptor() {
        return fileno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fileno(FILE *)
     * }
     */
    public static MethodHandle fileno$handle() {
        return fileno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fileno(FILE *)
     * }
     */
    public static MemorySegment fileno$address() {
        return fileno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fileno(FILE *)
     * }
     */
    public static int fileno(MemorySegment x0) {
        var mh$ = fileno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fileno", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("pclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pclose(FILE *)
     * }
     */
    public static FunctionDescriptor pclose$descriptor() {
        return pclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pclose(FILE *)
     * }
     */
    public static MethodHandle pclose$handle() {
        return pclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pclose(FILE *)
     * }
     */
    public static MemorySegment pclose$address() {
        return pclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pclose(FILE *)
     * }
     */
    public static int pclose(MemorySegment x0) {
        var mh$ = pclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pclose", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class popen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("popen$DARWIN_EXTSN");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *popen(const char *, const char *)
     * }
     */
    public static FunctionDescriptor popen$descriptor() {
        return popen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *popen(const char *, const char *)
     * }
     */
    public static MethodHandle popen$handle() {
        return popen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *popen(const char *, const char *)
     * }
     */
    public static MemorySegment popen$address() {
        return popen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *popen(const char *, const char *)
     * }
     */
    public static MemorySegment popen(MemorySegment x0, MemorySegment x1) {
        var mh$ = popen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("popen", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __srget {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__srget");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __srget(FILE *)
     * }
     */
    public static FunctionDescriptor __srget$descriptor() {
        return __srget.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __srget(FILE *)
     * }
     */
    public static MethodHandle __srget$handle() {
        return __srget.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __srget(FILE *)
     * }
     */
    public static MemorySegment __srget$address() {
        return __srget.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __srget(FILE *)
     * }
     */
    public static int __srget(MemorySegment x0) {
        var mh$ = __srget.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__srget", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __svfscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__svfscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __svfscanf(FILE *, const char *, va_list)
     * }
     */
    public static FunctionDescriptor __svfscanf$descriptor() {
        return __svfscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __svfscanf(FILE *, const char *, va_list)
     * }
     */
    public static MethodHandle __svfscanf$handle() {
        return __svfscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __svfscanf(FILE *, const char *, va_list)
     * }
     */
    public static MemorySegment __svfscanf$address() {
        return __svfscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __svfscanf(FILE *, const char *, va_list)
     * }
     */
    public static int __svfscanf(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = __svfscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__svfscanf", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __swbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__swbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __swbuf(int, FILE *)
     * }
     */
    public static FunctionDescriptor __swbuf$descriptor() {
        return __swbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __swbuf(int, FILE *)
     * }
     */
    public static MethodHandle __swbuf$handle() {
        return __swbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __swbuf(int, FILE *)
     * }
     */
    public static MemorySegment __swbuf$address() {
        return __swbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __swbuf(int, FILE *)
     * }
     */
    public static int __swbuf(int x0, MemorySegment x1) {
        var mh$ = __swbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__swbuf", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("flockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flockfile(FILE *)
     * }
     */
    public static FunctionDescriptor flockfile$descriptor() {
        return flockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flockfile(FILE *)
     * }
     */
    public static MethodHandle flockfile$handle() {
        return flockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flockfile(FILE *)
     * }
     */
    public static MemorySegment flockfile$address() {
        return flockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flockfile(FILE *)
     * }
     */
    public static void flockfile(MemorySegment x0) {
        var mh$ = flockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flockfile", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftrylockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ftrylockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ftrylockfile(FILE *)
     * }
     */
    public static FunctionDescriptor ftrylockfile$descriptor() {
        return ftrylockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ftrylockfile(FILE *)
     * }
     */
    public static MethodHandle ftrylockfile$handle() {
        return ftrylockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ftrylockfile(FILE *)
     * }
     */
    public static MemorySegment ftrylockfile$address() {
        return ftrylockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ftrylockfile(FILE *)
     * }
     */
    public static int ftrylockfile(MemorySegment x0) {
        var mh$ = ftrylockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftrylockfile", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class funlockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("funlockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void funlockfile(FILE *)
     * }
     */
    public static FunctionDescriptor funlockfile$descriptor() {
        return funlockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void funlockfile(FILE *)
     * }
     */
    public static MethodHandle funlockfile$handle() {
        return funlockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void funlockfile(FILE *)
     * }
     */
    public static MemorySegment funlockfile$address() {
        return funlockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void funlockfile(FILE *)
     * }
     */
    public static void funlockfile(MemorySegment x0) {
        var mh$ = funlockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("funlockfile", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getc_unlocked(FILE *)
     * }
     */
    public static FunctionDescriptor getc_unlocked$descriptor() {
        return getc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getc_unlocked(FILE *)
     * }
     */
    public static MethodHandle getc_unlocked$handle() {
        return getc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getc_unlocked(FILE *)
     * }
     */
    public static MemorySegment getc_unlocked$address() {
        return getc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getc_unlocked(FILE *)
     * }
     */
    public static int getc_unlocked(MemorySegment x0) {
        var mh$ = getc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc_unlocked", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getchar_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getchar_unlocked()
     * }
     */
    public static FunctionDescriptor getchar_unlocked$descriptor() {
        return getchar_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getchar_unlocked()
     * }
     */
    public static MethodHandle getchar_unlocked$handle() {
        return getchar_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getchar_unlocked()
     * }
     */
    public static MemorySegment getchar_unlocked$address() {
        return getchar_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getchar_unlocked()
     * }
     */
    public static int getchar_unlocked() {
        var mh$ = getchar_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar_unlocked");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("putc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putc_unlocked(int, FILE *)
     * }
     */
    public static FunctionDescriptor putc_unlocked$descriptor() {
        return putc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putc_unlocked(int, FILE *)
     * }
     */
    public static MethodHandle putc_unlocked$handle() {
        return putc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putc_unlocked(int, FILE *)
     * }
     */
    public static MemorySegment putc_unlocked$address() {
        return putc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putc_unlocked(int, FILE *)
     * }
     */
    public static int putc_unlocked(int x0, MemorySegment x1) {
        var mh$ = putc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc_unlocked", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("putchar_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putchar_unlocked(int)
     * }
     */
    public static FunctionDescriptor putchar_unlocked$descriptor() {
        return putchar_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putchar_unlocked(int)
     * }
     */
    public static MethodHandle putchar_unlocked$handle() {
        return putchar_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putchar_unlocked(int)
     * }
     */
    public static MemorySegment putchar_unlocked$address() {
        return putchar_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putchar_unlocked(int)
     * }
     */
    public static int putchar_unlocked(int x0) {
        var mh$ = putchar_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar_unlocked", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getw(FILE *)
     * }
     */
    public static FunctionDescriptor getw$descriptor() {
        return getw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getw(FILE *)
     * }
     */
    public static MethodHandle getw$handle() {
        return getw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getw(FILE *)
     * }
     */
    public static MemorySegment getw$address() {
        return getw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getw(FILE *)
     * }
     */
    public static int getw(MemorySegment x0) {
        var mh$ = getw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getw", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("putw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putw(int, FILE *)
     * }
     */
    public static FunctionDescriptor putw$descriptor() {
        return putw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putw(int, FILE *)
     * }
     */
    public static MethodHandle putw$handle() {
        return putw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putw(int, FILE *)
     * }
     */
    public static MemorySegment putw$address() {
        return putw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putw(int, FILE *)
     * }
     */
    public static int putw(int x0, MemorySegment x1) {
        var mh$ = putw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putw", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tempnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("tempnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *tempnam(const char *__dir, const char *__prefix)
     * }
     */
    public static FunctionDescriptor tempnam$descriptor() {
        return tempnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *tempnam(const char *__dir, const char *__prefix)
     * }
     */
    public static MethodHandle tempnam$handle() {
        return tempnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *tempnam(const char *__dir, const char *__prefix)
     * }
     */
    public static MemorySegment tempnam$address() {
        return tempnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *tempnam(const char *__dir, const char *__prefix)
     * }
     */
    public static MemorySegment tempnam(MemorySegment __dir, MemorySegment __prefix) {
        var mh$ = tempnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tempnam", __dir, __prefix);
            }
            return (MemorySegment)mh$.invokeExact(__dir, __prefix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_off_t off_t
     * }
     */
    public static final OfLong off_t = Python_h.C_LONG_LONG;

    private static class fseeko {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG_LONG,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fseeko");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fseeko(FILE *__stream, off_t __offset, int __whence)
     * }
     */
    public static FunctionDescriptor fseeko$descriptor() {
        return fseeko.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fseeko(FILE *__stream, off_t __offset, int __whence)
     * }
     */
    public static MethodHandle fseeko$handle() {
        return fseeko.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fseeko(FILE *__stream, off_t __offset, int __whence)
     * }
     */
    public static MemorySegment fseeko$address() {
        return fseeko.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fseeko(FILE *__stream, off_t __offset, int __whence)
     * }
     */
    public static int fseeko(MemorySegment __stream, long __offset, int __whence) {
        var mh$ = fseeko.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseeko", __stream, __offset, __whence);
            }
            return (int)mh$.invokeExact(__stream, __offset, __whence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftello {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ftello");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * off_t ftello(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftello$descriptor() {
        return ftello.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * off_t ftello(FILE *__stream)
     * }
     */
    public static MethodHandle ftello$handle() {
        return ftello.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * off_t ftello(FILE *__stream)
     * }
     */
    public static MemorySegment ftello$address() {
        return ftello.ADDR;
    }

    /**
     * {@snippet lang=c :
     * off_t ftello(FILE *__stream)
     * }
     */
    public static long ftello(MemorySegment __stream) {
        var mh$ = ftello.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftello", __stream);
            }
            return (long)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int snprintf(char *restrict __str, size_t __size, const char *restrict __format, ...)
     * }
     */
    public static class snprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_LONG,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("snprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private snprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int snprintf(char *restrict __str, size_t __size, const char *restrict __format, ...)
         * }
         */
        public static snprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new snprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __str, long __size, MemorySegment __format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("snprintf", __str, __size, __format, x3);
                }
                return (int)spreader.invokeExact(__str, __size, __format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vfscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("vfscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vfscanf(FILE *restrict __stream, const char *restrict __format, va_list)
     * }
     */
    public static FunctionDescriptor vfscanf$descriptor() {
        return vfscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vfscanf(FILE *restrict __stream, const char *restrict __format, va_list)
     * }
     */
    public static MethodHandle vfscanf$handle() {
        return vfscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vfscanf(FILE *restrict __stream, const char *restrict __format, va_list)
     * }
     */
    public static MemorySegment vfscanf$address() {
        return vfscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vfscanf(FILE *restrict __stream, const char *restrict __format, va_list)
     * }
     */
    public static int vfscanf(MemorySegment __stream, MemorySegment __format, MemorySegment x2) {
        var mh$ = vfscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfscanf", __stream, __format, x2);
            }
            return (int)mh$.invokeExact(__stream, __format, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("vscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vscanf(const char *restrict __format, va_list)
     * }
     */
    public static FunctionDescriptor vscanf$descriptor() {
        return vscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vscanf(const char *restrict __format, va_list)
     * }
     */
    public static MethodHandle vscanf$handle() {
        return vscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vscanf(const char *restrict __format, va_list)
     * }
     */
    public static MemorySegment vscanf$address() {
        return vscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vscanf(const char *restrict __format, va_list)
     * }
     */
    public static int vscanf(MemorySegment __format, MemorySegment x1) {
        var mh$ = vscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vscanf", __format, x1);
            }
            return (int)mh$.invokeExact(__format, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vsnprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("vsnprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vsnprintf(char *restrict __str, size_t __size, const char *restrict __format, va_list)
     * }
     */
    public static FunctionDescriptor vsnprintf$descriptor() {
        return vsnprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vsnprintf(char *restrict __str, size_t __size, const char *restrict __format, va_list)
     * }
     */
    public static MethodHandle vsnprintf$handle() {
        return vsnprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vsnprintf(char *restrict __str, size_t __size, const char *restrict __format, va_list)
     * }
     */
    public static MemorySegment vsnprintf$address() {
        return vsnprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vsnprintf(char *restrict __str, size_t __size, const char *restrict __format, va_list)
     * }
     */
    public static int vsnprintf(MemorySegment __str, long __size, MemorySegment __format, MemorySegment x3) {
        var mh$ = vsnprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsnprintf", __str, __size, __format, x3);
            }
            return (int)mh$.invokeExact(__str, __size, __format, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vsscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("vsscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vsscanf(const char *restrict __str, const char *restrict __format, va_list)
     * }
     */
    public static FunctionDescriptor vsscanf$descriptor() {
        return vsscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vsscanf(const char *restrict __str, const char *restrict __format, va_list)
     * }
     */
    public static MethodHandle vsscanf$handle() {
        return vsscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vsscanf(const char *restrict __str, const char *restrict __format, va_list)
     * }
     */
    public static MemorySegment vsscanf$address() {
        return vsscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vsscanf(const char *restrict __str, const char *restrict __format, va_list)
     * }
     */
    public static int vsscanf(MemorySegment __str, MemorySegment __format, MemorySegment x2) {
        var mh$ = vsscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsscanf", __str, __format, x2);
            }
            return (int)mh$.invokeExact(__str, __format, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_ssize_t ssize_t
     * }
     */
    public static final OfLong ssize_t = Python_h.C_LONG;

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int dprintf(int, const char *restrict, ...)
     * }
     */
    public static class dprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_INT,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("dprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private dprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int dprintf(int, const char *restrict, ...)
         * }
         */
        public static dprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new dprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(int x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("dprintf", x0, x1, x2);
                }
                return (int)spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vdprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("vdprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vdprintf(int, const char *restrict, va_list)
     * }
     */
    public static FunctionDescriptor vdprintf$descriptor() {
        return vdprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vdprintf(int, const char *restrict, va_list)
     * }
     */
    public static MethodHandle vdprintf$handle() {
        return vdprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vdprintf(int, const char *restrict, va_list)
     * }
     */
    public static MemorySegment vdprintf$address() {
        return vdprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vdprintf(int, const char *restrict, va_list)
     * }
     */
    public static int vdprintf(int x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = vdprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vdprintf", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getdelim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getdelim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t getdelim(char **restrict __linep, size_t *restrict __linecapp, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor getdelim$descriptor() {
        return getdelim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t getdelim(char **restrict __linep, size_t *restrict __linecapp, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MethodHandle getdelim$handle() {
        return getdelim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t getdelim(char **restrict __linep, size_t *restrict __linecapp, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MemorySegment getdelim$address() {
        return getdelim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t getdelim(char **restrict __linep, size_t *restrict __linecapp, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static long getdelim(MemorySegment __linep, MemorySegment __linecapp, int __delimiter, MemorySegment __stream) {
        var mh$ = getdelim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getdelim", __linep, __linecapp, __delimiter, __stream);
            }
            return (long)mh$.invokeExact(__linep, __linecapp, __delimiter, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("getline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t getline(char **restrict __linep, size_t *restrict __linecapp, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor getline$descriptor() {
        return getline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t getline(char **restrict __linep, size_t *restrict __linecapp, FILE *restrict __stream)
     * }
     */
    public static MethodHandle getline$handle() {
        return getline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t getline(char **restrict __linep, size_t *restrict __linecapp, FILE *restrict __stream)
     * }
     */
    public static MemorySegment getline$address() {
        return getline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t getline(char **restrict __linep, size_t *restrict __linecapp, FILE *restrict __stream)
     * }
     */
    public static long getline(MemorySegment __linep, MemorySegment __linecapp, MemorySegment __stream) {
        var mh$ = getline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getline", __linep, __linecapp, __stream);
            }
            return (long)mh$.invokeExact(__linep, __linecapp, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmemopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fmemopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *fmemopen(void *restrict __buf, size_t __size, const char *restrict __mode)
     * }
     */
    public static FunctionDescriptor fmemopen$descriptor() {
        return fmemopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *fmemopen(void *restrict __buf, size_t __size, const char *restrict __mode)
     * }
     */
    public static MethodHandle fmemopen$handle() {
        return fmemopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *fmemopen(void *restrict __buf, size_t __size, const char *restrict __mode)
     * }
     */
    public static MemorySegment fmemopen$address() {
        return fmemopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *fmemopen(void *restrict __buf, size_t __size, const char *restrict __mode)
     * }
     */
    public static MemorySegment fmemopen(MemorySegment __buf, long __size, MemorySegment __mode) {
        var mh$ = fmemopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmemopen", __buf, __size, __mode);
            }
            return (MemorySegment)mh$.invokeExact(__buf, __size, __mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class open_memstream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("open_memstream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *open_memstream(char **__bufp, size_t *__sizep)
     * }
     */
    public static FunctionDescriptor open_memstream$descriptor() {
        return open_memstream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *open_memstream(char **__bufp, size_t *__sizep)
     * }
     */
    public static MethodHandle open_memstream$handle() {
        return open_memstream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *open_memstream(char **__bufp, size_t *__sizep)
     * }
     */
    public static MemorySegment open_memstream$address() {
        return open_memstream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *open_memstream(char **__bufp, size_t *__sizep)
     * }
     */
    public static MemorySegment open_memstream(MemorySegment __bufp, MemorySegment __sizep) {
        var mh$ = open_memstream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("open_memstream", __bufp, __sizep);
            }
            return (MemorySegment)mh$.invokeExact(__bufp, __sizep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sys_nerr$constants {
        public static final OfInt LAYOUT = Python_h.C_INT;
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("sys_nerr").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const int sys_nerr
     * }
     */
    public static OfInt sys_nerr$layout() {
        return sys_nerr$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const int sys_nerr
     * }
     */
    public static MemorySegment sys_nerr$segment() {
        return sys_nerr$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const int sys_nerr
     * }
     */
    public static int sys_nerr() {
        return sys_nerr$constants.SEGMENT.get(sys_nerr$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const int sys_nerr
     * }
     */
    public static void sys_nerr(int varValue) {
        sys_nerr$constants.SEGMENT.set(sys_nerr$constants.LAYOUT, 0L, varValue);
    }

    private static class sys_errlist$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(0, Python_h.C_POINTER);
        public static final MemorySegment SEGMENT = Python_h.findOrThrow("sys_errlist").reinterpret(LAYOUT.byteSize());
        public static final VarHandle HANDLE = LAYOUT.varHandle();

        public static final long[] DIMS = {  };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const char *const sys_errlist[]
     * }
     */
    public static SequenceLayout sys_errlist$layout() {
        return sys_errlist$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern const char *const sys_errlist[]
     * }
     */
    public static long[] sys_errlist$dimensions() {
        return sys_errlist$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const char *const sys_errlist[]
     * }
     */
    public static MemorySegment sys_errlist() {
        return sys_errlist$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const char *const sys_errlist[]
     * }
     */
    public static void sys_errlist(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, sys_errlist$constants.SEGMENT, 0L, sys_errlist$constants.LAYOUT.byteSize());
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int asprintf(char **restrict, const char *restrict, ...)
     * }
     */
    public static class asprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("asprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private asprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int asprintf(char **restrict, const char *restrict, ...)
         * }
         */
        public static asprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new asprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("asprintf", x0, x1, x2);
                }
                return (int)spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class ctermid_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("ctermid_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ctermid_r(char *)
     * }
     */
    public static FunctionDescriptor ctermid_r$descriptor() {
        return ctermid_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ctermid_r(char *)
     * }
     */
    public static MethodHandle ctermid_r$handle() {
        return ctermid_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ctermid_r(char *)
     * }
     */
    public static MemorySegment ctermid_r$address() {
        return ctermid_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ctermid_r(char *)
     * }
     */
    public static MemorySegment ctermid_r(MemorySegment x0) {
        var mh$ = ctermid_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctermid_r", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetln {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fgetln");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *fgetln(FILE *, size_t *)
     * }
     */
    public static FunctionDescriptor fgetln$descriptor() {
        return fgetln.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *fgetln(FILE *, size_t *)
     * }
     */
    public static MethodHandle fgetln$handle() {
        return fgetln.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *fgetln(FILE *, size_t *)
     * }
     */
    public static MemorySegment fgetln$address() {
        return fgetln.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *fgetln(FILE *, size_t *)
     * }
     */
    public static MemorySegment fgetln(MemorySegment x0, MemorySegment x1) {
        var mh$ = fgetln.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetln", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmtcheck {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fmtcheck");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *fmtcheck(const char *, const char *)
     * }
     */
    public static FunctionDescriptor fmtcheck$descriptor() {
        return fmtcheck.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *fmtcheck(const char *, const char *)
     * }
     */
    public static MethodHandle fmtcheck$handle() {
        return fmtcheck.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *fmtcheck(const char *, const char *)
     * }
     */
    public static MemorySegment fmtcheck$address() {
        return fmtcheck.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *fmtcheck(const char *, const char *)
     * }
     */
    public static MemorySegment fmtcheck(MemorySegment x0, MemorySegment x1) {
        var mh$ = fmtcheck.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmtcheck", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fpurge {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("fpurge");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fpurge(FILE *)
     * }
     */
    public static FunctionDescriptor fpurge$descriptor() {
        return fpurge.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fpurge(FILE *)
     * }
     */
    public static MethodHandle fpurge$handle() {
        return fpurge.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fpurge(FILE *)
     * }
     */
    public static MemorySegment fpurge$address() {
        return fpurge.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fpurge(FILE *)
     * }
     */
    public static int fpurge(MemorySegment x0) {
        var mh$ = fpurge.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fpurge", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setbuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setbuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setbuffer(FILE *, char *, int)
     * }
     */
    public static FunctionDescriptor setbuffer$descriptor() {
        return setbuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setbuffer(FILE *, char *, int)
     * }
     */
    public static MethodHandle setbuffer$handle() {
        return setbuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setbuffer(FILE *, char *, int)
     * }
     */
    public static MemorySegment setbuffer$address() {
        return setbuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setbuffer(FILE *, char *, int)
     * }
     */
    public static void setbuffer(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = setbuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuffer", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setlinebuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("setlinebuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setlinebuf(FILE *)
     * }
     */
    public static FunctionDescriptor setlinebuf$descriptor() {
        return setlinebuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setlinebuf(FILE *)
     * }
     */
    public static MethodHandle setlinebuf$handle() {
        return setlinebuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setlinebuf(FILE *)
     * }
     */
    public static MemorySegment setlinebuf$address() {
        return setlinebuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setlinebuf(FILE *)
     * }
     */
    public static int setlinebuf(MemorySegment x0) {
        var mh$ = setlinebuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setlinebuf", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vasprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("vasprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vasprintf(char **restrict, const char *restrict, va_list)
     * }
     */
    public static FunctionDescriptor vasprintf$descriptor() {
        return vasprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vasprintf(char **restrict, const char *restrict, va_list)
     * }
     */
    public static MethodHandle vasprintf$handle() {
        return vasprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vasprintf(char **restrict, const char *restrict, va_list)
     * }
     */
    public static MemorySegment vasprintf$address() {
        return vasprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vasprintf(char **restrict, const char *restrict, va_list)
     * }
     */
    public static int vasprintf(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = vasprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vasprintf", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class funopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("funopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *funopen(const void *, int (* _Nullable)(void *, char *, int), int (* _Nullable)(void *, const char *, int), fpos_t (* _Nullable)(void *, fpos_t, int), int (* _Nullable)(void *))
     * }
     */
    public static FunctionDescriptor funopen$descriptor() {
        return funopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *funopen(const void *, int (* _Nullable)(void *, char *, int), int (* _Nullable)(void *, const char *, int), fpos_t (* _Nullable)(void *, fpos_t, int), int (* _Nullable)(void *))
     * }
     */
    public static MethodHandle funopen$handle() {
        return funopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *funopen(const void *, int (* _Nullable)(void *, char *, int), int (* _Nullable)(void *, const char *, int), fpos_t (* _Nullable)(void *, fpos_t, int), int (* _Nullable)(void *))
     * }
     */
    public static MemorySegment funopen$address() {
        return funopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *funopen(const void *, int (* _Nullable)(void *, char *, int), int (* _Nullable)(void *, const char *, int), fpos_t (* _Nullable)(void *, fpos_t, int), int (* _Nullable)(void *))
     * }
     */
    public static MemorySegment funopen(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = funopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("funopen", x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int __sprintf_chk(char *restrict, int, size_t, const char *restrict, ...)
     * }
     */
    public static class __sprintf_chk {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_INT,
                Python_h.C_LONG,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("__sprintf_chk");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private __sprintf_chk(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int __sprintf_chk(char *restrict, int, size_t, const char *restrict, ...)
         * }
         */
        public static __sprintf_chk makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new __sprintf_chk(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, int x1, long x2, MemorySegment x3, Object... x4) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("__sprintf_chk", x0, x1, x2, x3, x4);
                }
                return (int)spreader.invokeExact(x0, x1, x2, x3, x4);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int __snprintf_chk(char *restrict, size_t, int, size_t, const char *restrict, ...)
     * }
     */
    public static class __snprintf_chk {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                Python_h.C_INT,
                Python_h.C_POINTER,
                Python_h.C_LONG,
                Python_h.C_INT,
                Python_h.C_LONG,
                Python_h.C_POINTER
            );
        private static final MemorySegment ADDR = Python_h.findOrThrow("__snprintf_chk");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private __snprintf_chk(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int __snprintf_chk(char *restrict, size_t, int, size_t, const char *restrict, ...)
         * }
         */
        public static __snprintf_chk makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new __snprintf_chk(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, long x1, int x2, long x3, MemorySegment x4, Object... x5) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("__snprintf_chk", x0, x1, x2, x3, x4, x5);
                }
                return (int)spreader.invokeExact(x0, x1, x2, x3, x4, x5);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class __vsprintf_chk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__vsprintf_chk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __vsprintf_chk(char *restrict, int, size_t, const char *restrict, va_list)
     * }
     */
    public static FunctionDescriptor __vsprintf_chk$descriptor() {
        return __vsprintf_chk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __vsprintf_chk(char *restrict, int, size_t, const char *restrict, va_list)
     * }
     */
    public static MethodHandle __vsprintf_chk$handle() {
        return __vsprintf_chk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __vsprintf_chk(char *restrict, int, size_t, const char *restrict, va_list)
     * }
     */
    public static MemorySegment __vsprintf_chk$address() {
        return __vsprintf_chk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __vsprintf_chk(char *restrict, int, size_t, const char *restrict, va_list)
     * }
     */
    public static int __vsprintf_chk(MemorySegment x0, int x1, long x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = __vsprintf_chk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__vsprintf_chk", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __vsnprintf_chk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_LONG,
            Python_h.C_INT,
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__vsnprintf_chk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __vsnprintf_chk(char *restrict, size_t, int, size_t, const char *restrict, va_list)
     * }
     */
    public static FunctionDescriptor __vsnprintf_chk$descriptor() {
        return __vsnprintf_chk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __vsnprintf_chk(char *restrict, size_t, int, size_t, const char *restrict, va_list)
     * }
     */
    public static MethodHandle __vsnprintf_chk$handle() {
        return __vsnprintf_chk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __vsnprintf_chk(char *restrict, size_t, int, size_t, const char *restrict, va_list)
     * }
     */
    public static MemorySegment __vsnprintf_chk$address() {
        return __vsnprintf_chk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __vsnprintf_chk(char *restrict, size_t, int, size_t, const char *restrict, va_list)
     * }
     */
    public static int __vsnprintf_chk(MemorySegment x0, long x1, int x2, long x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = __vsnprintf_chk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__vsnprintf_chk", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int errno_t
     * }
     */
    public static final OfInt errno_t = Python_h.C_INT;

    private static class __error {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER    );

        public static final MemorySegment ADDR = Python_h.findOrThrow("__error");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int *__error()
     * }
     */
    public static FunctionDescriptor __error$descriptor() {
        return __error.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int *__error()
     * }
     */
    public static MethodHandle __error$handle() {
        return __error.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int *__error()
     * }
     */
    public static MemorySegment __error$address() {
        return __error.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int *__error()
     * }
     */
    public static MemorySegment __error() {
        var mh$ = __error.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__error");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("memchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static FunctionDescriptor memchr$descriptor() {
        return memchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static MethodHandle memchr$handle() {
        return memchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static MemorySegment memchr$address() {
        return memchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static MemorySegment memchr(MemorySegment __s, int __c, long __n) {
        var mh$ = memchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memchr", __s, __c, __n);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("memcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor memcmp$descriptor() {
        return memcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MethodHandle memcmp$handle() {
        return memcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MemorySegment memcmp$address() {
        return memcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static int memcmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = memcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memcmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("memcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memcpy(void *__dst, const void *__src, size_t __n)
     * }
     */
    public static FunctionDescriptor memcpy$descriptor() {
        return memcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memcpy(void *__dst, const void *__src, size_t __n)
     * }
     */
    public static MethodHandle memcpy$handle() {
        return memcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memcpy(void *__dst, const void *__src, size_t __n)
     * }
     */
    public static MemorySegment memcpy$address() {
        return memcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memcpy(void *__dst, const void *__src, size_t __n)
     * }
     */
    public static MemorySegment memcpy(MemorySegment __dst, MemorySegment __src, long __n) {
        var mh$ = memcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memcpy", __dst, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memmove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("memmove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memmove(void *__dst, const void *__src, size_t __len)
     * }
     */
    public static FunctionDescriptor memmove$descriptor() {
        return memmove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memmove(void *__dst, const void *__src, size_t __len)
     * }
     */
    public static MethodHandle memmove$handle() {
        return memmove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memmove(void *__dst, const void *__src, size_t __len)
     * }
     */
    public static MemorySegment memmove$address() {
        return memmove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memmove(void *__dst, const void *__src, size_t __len)
     * }
     */
    public static MemorySegment memmove(MemorySegment __dst, MemorySegment __src, long __len) {
        var mh$ = memmove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memmove", __dst, __src, __len);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("memset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memset(void *__b, int __c, size_t __len)
     * }
     */
    public static FunctionDescriptor memset$descriptor() {
        return memset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memset(void *__b, int __c, size_t __len)
     * }
     */
    public static MethodHandle memset$handle() {
        return memset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memset(void *__b, int __c, size_t __len)
     * }
     */
    public static MemorySegment memset$address() {
        return memset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memset(void *__b, int __c, size_t __len)
     * }
     */
    public static MemorySegment memset(MemorySegment __b, int __c, long __len) {
        var mh$ = memset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset", __b, __c, __len);
            }
            return (MemorySegment)mh$.invokeExact(__b, __c, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strcat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strcat(char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcat$descriptor() {
        return strcat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strcat(char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcat$handle() {
        return strcat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strcat(char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcat$address() {
        return strcat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strcat(char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcat(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcat", __s1, __s2);
            }
            return (MemorySegment)mh$.invokeExact(__s1, __s2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strchr(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor strchr$descriptor() {
        return strchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strchr(const char *__s, int __c)
     * }
     */
    public static MethodHandle strchr$handle() {
        return strchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strchr$address() {
        return strchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strchr(MemorySegment __s, int __c) {
        var mh$ = strchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strchr", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcmp$descriptor() {
        return strcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcmp$handle() {
        return strcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcmp$address() {
        return strcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static int strcmp(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcmp", __s1, __s2);
            }
            return (int)mh$.invokeExact(__s1, __s2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_INT,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strcoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcoll$descriptor() {
        return strcoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcoll$handle() {
        return strcoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcoll$address() {
        return strcoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static int strcoll(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcoll", __s1, __s2);
            }
            return (int)mh$.invokeExact(__s1, __s2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strcpy(char *__dst, const char *__src)
     * }
     */
    public static FunctionDescriptor strcpy$descriptor() {
        return strcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strcpy(char *__dst, const char *__src)
     * }
     */
    public static MethodHandle strcpy$handle() {
        return strcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strcpy(char *__dst, const char *__src)
     * }
     */
    public static MemorySegment strcpy$address() {
        return strcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strcpy(char *__dst, const char *__src)
     * }
     */
    public static MemorySegment strcpy(MemorySegment __dst, MemorySegment __src) {
        var mh$ = strcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcpy", __dst, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strcspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strcspn(const char *__s, const char *__charset)
     * }
     */
    public static FunctionDescriptor strcspn$descriptor() {
        return strcspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strcspn(const char *__s, const char *__charset)
     * }
     */
    public static MethodHandle strcspn$handle() {
        return strcspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strcspn(const char *__s, const char *__charset)
     * }
     */
    public static MemorySegment strcspn$address() {
        return strcspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strcspn(const char *__s, const char *__charset)
     * }
     */
    public static long strcspn(MemorySegment __s, MemorySegment __charset) {
        var mh$ = strcspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcspn", __s, __charset);
            }
            return (long)mh$.invokeExact(__s, __charset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_INT
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strerror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strerror(int __errnum)
     * }
     */
    public static FunctionDescriptor strerror$descriptor() {
        return strerror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strerror(int __errnum)
     * }
     */
    public static MethodHandle strerror$handle() {
        return strerror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strerror(int __errnum)
     * }
     */
    public static MemorySegment strerror$address() {
        return strerror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strerror(int __errnum)
     * }
     */
    public static MemorySegment strerror(int __errnum) {
        var mh$ = strerror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror", __errnum);
            }
            return (MemorySegment)mh$.invokeExact(__errnum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_LONG,
            Python_h.C_POINTER
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strlen(const char *__s)
     * }
     */
    public static FunctionDescriptor strlen$descriptor() {
        return strlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strlen(const char *__s)
     * }
     */
    public static MethodHandle strlen$handle() {
        return strlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strlen(const char *__s)
     * }
     */
    public static MemorySegment strlen$address() {
        return strlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strlen(const char *__s)
     * }
     */
    public static long strlen(MemorySegment __s) {
        var mh$ = strlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlen", __s);
            }
            return (long)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_POINTER,
            Python_h.C_LONG
        );

        public static final MemorySegment ADDR = Python_h.findOrThrow("strncat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strncat(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor strncat$descriptor() {
        return strncat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strncat(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MethodHandle strncat$handle() {
        return strncat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strncat(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MemorySegment strncat$address() {
        return strncat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strncat(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MemorySegment strncat(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = strncat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncat", __s1, __s2, __n);
            }
            return (MemorySegment)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

