// Generated by jextract

package org.freeglut;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class freeglut_h_1 extends freeglut_h_2 {

    freeglut_h_1() {
        // Should not be called directly
    }
    /**
     * {@snippet lang=c :
     * typedef float GLclampf
     * }
     */
    public static final OfFloat GLclampf = freeglut_h.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t GLenum
     * }
     */
    public static final OfInt GLenum = freeglut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef float GLfloat
     * }
     */
    public static final OfFloat GLfloat = freeglut_h.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef int32_t GLint
     * }
     */
    public static final OfInt GLint = freeglut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int16_t GLshort
     * }
     */
    public static final OfShort GLshort = freeglut_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int32_t GLsizei
     * }
     */
    public static final OfInt GLsizei = freeglut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint8_t GLubyte
     * }
     */
    public static final OfByte GLubyte = freeglut_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint32_t GLuint
     * }
     */
    public static final OfInt GLuint = freeglut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint16_t GLushort
     * }
     */
    public static final OfShort GLushort = freeglut_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef char GLchar
     * }
     */
    public static final OfByte GLchar = freeglut_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef char GLcharARB
     * }
     */
    public static final OfByte GLcharARB = freeglut_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef void *GLhandleARB
     * }
     */
    public static final AddressLayout GLhandleARB = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef double GLdouble
     * }
     */
    public static final OfDouble GLdouble = freeglut_h.C_DOUBLE;
    /**
     * {@snippet lang=c :
     * typedef double GLclampd
     * }
     */
    public static final OfDouble GLclampd = freeglut_h.C_DOUBLE;
    /**
     * {@snippet lang=c :
     * typedef int32_t GLfixed
     * }
     */
    public static final OfInt GLfixed = freeglut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint16_t GLhalf
     * }
     */
    public static final OfShort GLhalf = freeglut_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint16_t GLhalfARB
     * }
     */
    public static final OfShort GLhalfARB = freeglut_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int64_t GLint64
     * }
     */
    public static final OfLong GLint64 = freeglut_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct __GLsync *GLsync
     * }
     */
    public static final AddressLayout GLsync = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef uint64_t GLuint64
     * }
     */
    public static final OfLong GLuint64 = freeglut_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t GLint64EXT
     * }
     */
    public static final OfLong GLint64EXT = freeglut_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint64_t GLuint64EXT
     * }
     */
    public static final OfLong GLuint64EXT = freeglut_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef intptr_t GLintptr
     * }
     */
    public static final OfLong GLintptr = freeglut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef intptr_t GLsizeiptr
     * }
     */
    public static final OfLong GLsizeiptr = freeglut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef intptr_t GLintptrARB
     * }
     */
    public static final OfLong GLintptrARB = freeglut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef intptr_t GLsizeiptrARB
     * }
     */
    public static final OfLong GLsizeiptrARB = freeglut_h.C_LONG;

    private static class glClampColorARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glClampColorARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glClampColorARB(GLenum target, GLenum clamp)
     * }
     */
    public static FunctionDescriptor glClampColorARB$descriptor() {
        return glClampColorARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glClampColorARB(GLenum target, GLenum clamp)
     * }
     */
    public static MethodHandle glClampColorARB$handle() {
        return glClampColorARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glClampColorARB(GLenum target, GLenum clamp)
     * }
     */
    public static MemorySegment glClampColorARB$address() {
        return glClampColorARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glClampColorARB(GLenum target, GLenum clamp)
     * }
     */
    public static void glClampColorARB(int target, int clamp) {
        var mh$ = glClampColorARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClampColorARB", target, clamp);
            }
            mh$.invokeExact(target, clamp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDrawBuffersARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDrawBuffersARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glDrawBuffersARB(GLsizei n, const GLenum *bufs)
     * }
     */
    public static FunctionDescriptor glDrawBuffersARB$descriptor() {
        return glDrawBuffersARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glDrawBuffersARB(GLsizei n, const GLenum *bufs)
     * }
     */
    public static MethodHandle glDrawBuffersARB$handle() {
        return glDrawBuffersARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glDrawBuffersARB(GLsizei n, const GLenum *bufs)
     * }
     */
    public static MemorySegment glDrawBuffersARB$address() {
        return glDrawBuffersARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glDrawBuffersARB(GLsizei n, const GLenum *bufs)
     * }
     */
    public static void glDrawBuffersARB(int n, MemorySegment bufs) {
        var mh$ = glDrawBuffersARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDrawBuffersARB", n, bufs);
            }
            mh$.invokeExact(n, bufs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDrawElementsBaseVertex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDrawElementsBaseVertex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glDrawElementsBaseVertex(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLint base_vertex)
     * }
     */
    public static FunctionDescriptor glDrawElementsBaseVertex$descriptor() {
        return glDrawElementsBaseVertex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glDrawElementsBaseVertex(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLint base_vertex)
     * }
     */
    public static MethodHandle glDrawElementsBaseVertex$handle() {
        return glDrawElementsBaseVertex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glDrawElementsBaseVertex(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLint base_vertex)
     * }
     */
    public static MemorySegment glDrawElementsBaseVertex$address() {
        return glDrawElementsBaseVertex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glDrawElementsBaseVertex(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLint base_vertex)
     * }
     */
    public static void glDrawElementsBaseVertex(int mode, int count, int type, MemorySegment indices, int base_vertex) {
        var mh$ = glDrawElementsBaseVertex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDrawElementsBaseVertex", mode, count, type, indices, base_vertex);
            }
            mh$.invokeExact(mode, count, type, indices, base_vertex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDrawRangeElementsBaseVertex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDrawRangeElementsBaseVertex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glDrawRangeElementsBaseVertex(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices, GLint base_vertex)
     * }
     */
    public static FunctionDescriptor glDrawRangeElementsBaseVertex$descriptor() {
        return glDrawRangeElementsBaseVertex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glDrawRangeElementsBaseVertex(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices, GLint base_vertex)
     * }
     */
    public static MethodHandle glDrawRangeElementsBaseVertex$handle() {
        return glDrawRangeElementsBaseVertex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glDrawRangeElementsBaseVertex(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices, GLint base_vertex)
     * }
     */
    public static MemorySegment glDrawRangeElementsBaseVertex$address() {
        return glDrawRangeElementsBaseVertex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glDrawRangeElementsBaseVertex(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices, GLint base_vertex)
     * }
     */
    public static void glDrawRangeElementsBaseVertex(int mode, int start, int end, int count, int type, MemorySegment indices, int base_vertex) {
        var mh$ = glDrawRangeElementsBaseVertex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDrawRangeElementsBaseVertex", mode, start, end, count, type, indices, base_vertex);
            }
            mh$.invokeExact(mode, start, end, count, type, indices, base_vertex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDrawElementsInstancedBaseVertex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDrawElementsInstancedBaseVertex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glDrawElementsInstancedBaseVertex(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount, GLint base_vertex)
     * }
     */
    public static FunctionDescriptor glDrawElementsInstancedBaseVertex$descriptor() {
        return glDrawElementsInstancedBaseVertex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glDrawElementsInstancedBaseVertex(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount, GLint base_vertex)
     * }
     */
    public static MethodHandle glDrawElementsInstancedBaseVertex$handle() {
        return glDrawElementsInstancedBaseVertex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glDrawElementsInstancedBaseVertex(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount, GLint base_vertex)
     * }
     */
    public static MemorySegment glDrawElementsInstancedBaseVertex$address() {
        return glDrawElementsInstancedBaseVertex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glDrawElementsInstancedBaseVertex(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount, GLint base_vertex)
     * }
     */
    public static void glDrawElementsInstancedBaseVertex(int mode, int count, int type, MemorySegment indices, int primcount, int base_vertex) {
        var mh$ = glDrawElementsInstancedBaseVertex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDrawElementsInstancedBaseVertex", mode, count, type, indices, primcount, base_vertex);
            }
            mh$.invokeExact(mode, count, type, indices, primcount, base_vertex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiDrawElementsBaseVertex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiDrawElementsBaseVertex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiDrawElementsBaseVertex(GLenum mode, const GLsizei *count, GLenum type, const GLvoid *const *indices, GLsizei primcount, const GLint *base_vertex)
     * }
     */
    public static FunctionDescriptor glMultiDrawElementsBaseVertex$descriptor() {
        return glMultiDrawElementsBaseVertex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiDrawElementsBaseVertex(GLenum mode, const GLsizei *count, GLenum type, const GLvoid *const *indices, GLsizei primcount, const GLint *base_vertex)
     * }
     */
    public static MethodHandle glMultiDrawElementsBaseVertex$handle() {
        return glMultiDrawElementsBaseVertex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiDrawElementsBaseVertex(GLenum mode, const GLsizei *count, GLenum type, const GLvoid *const *indices, GLsizei primcount, const GLint *base_vertex)
     * }
     */
    public static MemorySegment glMultiDrawElementsBaseVertex$address() {
        return glMultiDrawElementsBaseVertex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiDrawElementsBaseVertex(GLenum mode, const GLsizei *count, GLenum type, const GLvoid *const *indices, GLsizei primcount, const GLint *base_vertex)
     * }
     */
    public static void glMultiDrawElementsBaseVertex(int mode, MemorySegment count, int type, MemorySegment indices, int primcount, MemorySegment base_vertex) {
        var mh$ = glMultiDrawElementsBaseVertex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiDrawElementsBaseVertex", mode, count, type, indices, primcount, base_vertex);
            }
            mh$.invokeExact(mode, count, type, indices, primcount, base_vertex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDrawArraysInstancedARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDrawArraysInstancedARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glDrawArraysInstancedARB(GLenum mode, GLint first, GLsizei count, GLsizei primcount)
     * }
     */
    public static FunctionDescriptor glDrawArraysInstancedARB$descriptor() {
        return glDrawArraysInstancedARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glDrawArraysInstancedARB(GLenum mode, GLint first, GLsizei count, GLsizei primcount)
     * }
     */
    public static MethodHandle glDrawArraysInstancedARB$handle() {
        return glDrawArraysInstancedARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glDrawArraysInstancedARB(GLenum mode, GLint first, GLsizei count, GLsizei primcount)
     * }
     */
    public static MemorySegment glDrawArraysInstancedARB$address() {
        return glDrawArraysInstancedARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glDrawArraysInstancedARB(GLenum mode, GLint first, GLsizei count, GLsizei primcount)
     * }
     */
    public static void glDrawArraysInstancedARB(int mode, int first, int count, int primcount) {
        var mh$ = glDrawArraysInstancedARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDrawArraysInstancedARB", mode, first, count, primcount);
            }
            mh$.invokeExact(mode, first, count, primcount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDrawElementsInstancedARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDrawElementsInstancedARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glDrawElementsInstancedARB(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount)
     * }
     */
    public static FunctionDescriptor glDrawElementsInstancedARB$descriptor() {
        return glDrawElementsInstancedARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glDrawElementsInstancedARB(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount)
     * }
     */
    public static MethodHandle glDrawElementsInstancedARB$handle() {
        return glDrawElementsInstancedARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glDrawElementsInstancedARB(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount)
     * }
     */
    public static MemorySegment glDrawElementsInstancedARB$address() {
        return glDrawElementsInstancedARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glDrawElementsInstancedARB(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount)
     * }
     */
    public static void glDrawElementsInstancedARB(int mode, int count, int type, MemorySegment indices, int primcount) {
        var mh$ = glDrawElementsInstancedARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDrawElementsInstancedARB", mode, count, type, indices, primcount);
            }
            mh$.invokeExact(mode, count, type, indices, primcount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIsRenderbuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glIsRenderbuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLboolean glIsRenderbuffer(GLuint renderbuffer)
     * }
     */
    public static FunctionDescriptor glIsRenderbuffer$descriptor() {
        return glIsRenderbuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLboolean glIsRenderbuffer(GLuint renderbuffer)
     * }
     */
    public static MethodHandle glIsRenderbuffer$handle() {
        return glIsRenderbuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLboolean glIsRenderbuffer(GLuint renderbuffer)
     * }
     */
    public static MemorySegment glIsRenderbuffer$address() {
        return glIsRenderbuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLboolean glIsRenderbuffer(GLuint renderbuffer)
     * }
     */
    public static byte glIsRenderbuffer(int renderbuffer) {
        var mh$ = glIsRenderbuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIsRenderbuffer", renderbuffer);
            }
            return (byte)mh$.invokeExact(renderbuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBindRenderbuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glBindRenderbuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glBindRenderbuffer(GLenum target, GLuint renderbuffer)
     * }
     */
    public static FunctionDescriptor glBindRenderbuffer$descriptor() {
        return glBindRenderbuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glBindRenderbuffer(GLenum target, GLuint renderbuffer)
     * }
     */
    public static MethodHandle glBindRenderbuffer$handle() {
        return glBindRenderbuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glBindRenderbuffer(GLenum target, GLuint renderbuffer)
     * }
     */
    public static MemorySegment glBindRenderbuffer$address() {
        return glBindRenderbuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glBindRenderbuffer(GLenum target, GLuint renderbuffer)
     * }
     */
    public static void glBindRenderbuffer(int target, int renderbuffer) {
        var mh$ = glBindRenderbuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBindRenderbuffer", target, renderbuffer);
            }
            mh$.invokeExact(target, renderbuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDeleteRenderbuffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDeleteRenderbuffers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glDeleteRenderbuffers(GLsizei n, const GLuint *renderbuffers)
     * }
     */
    public static FunctionDescriptor glDeleteRenderbuffers$descriptor() {
        return glDeleteRenderbuffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glDeleteRenderbuffers(GLsizei n, const GLuint *renderbuffers)
     * }
     */
    public static MethodHandle glDeleteRenderbuffers$handle() {
        return glDeleteRenderbuffers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glDeleteRenderbuffers(GLsizei n, const GLuint *renderbuffers)
     * }
     */
    public static MemorySegment glDeleteRenderbuffers$address() {
        return glDeleteRenderbuffers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glDeleteRenderbuffers(GLsizei n, const GLuint *renderbuffers)
     * }
     */
    public static void glDeleteRenderbuffers(int n, MemorySegment renderbuffers) {
        var mh$ = glDeleteRenderbuffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDeleteRenderbuffers", n, renderbuffers);
            }
            mh$.invokeExact(n, renderbuffers);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGenRenderbuffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGenRenderbuffers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGenRenderbuffers(GLsizei n, GLuint *renderbuffers)
     * }
     */
    public static FunctionDescriptor glGenRenderbuffers$descriptor() {
        return glGenRenderbuffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGenRenderbuffers(GLsizei n, GLuint *renderbuffers)
     * }
     */
    public static MethodHandle glGenRenderbuffers$handle() {
        return glGenRenderbuffers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGenRenderbuffers(GLsizei n, GLuint *renderbuffers)
     * }
     */
    public static MemorySegment glGenRenderbuffers$address() {
        return glGenRenderbuffers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGenRenderbuffers(GLsizei n, GLuint *renderbuffers)
     * }
     */
    public static void glGenRenderbuffers(int n, MemorySegment renderbuffers) {
        var mh$ = glGenRenderbuffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGenRenderbuffers", n, renderbuffers);
            }
            mh$.invokeExact(n, renderbuffers);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRenderbufferStorage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRenderbufferStorage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
     * }
     */
    public static FunctionDescriptor glRenderbufferStorage$descriptor() {
        return glRenderbufferStorage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
     * }
     */
    public static MethodHandle glRenderbufferStorage$handle() {
        return glRenderbufferStorage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
     * }
     */
    public static MemorySegment glRenderbufferStorage$address() {
        return glRenderbufferStorage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
     * }
     */
    public static void glRenderbufferStorage(int target, int internalformat, int width, int height) {
        var mh$ = glRenderbufferStorage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRenderbufferStorage", target, internalformat, width, height);
            }
            mh$.invokeExact(target, internalformat, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetRenderbufferParameteriv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetRenderbufferParameteriv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetRenderbufferParameteriv$descriptor() {
        return glGetRenderbufferParameteriv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetRenderbufferParameteriv$handle() {
        return glGetRenderbufferParameteriv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetRenderbufferParameteriv$address() {
        return glGetRenderbufferParameteriv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static void glGetRenderbufferParameteriv(int target, int pname, MemorySegment params) {
        var mh$ = glGetRenderbufferParameteriv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetRenderbufferParameteriv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIsFramebuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glIsFramebuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLboolean glIsFramebuffer(GLuint framebuffer)
     * }
     */
    public static FunctionDescriptor glIsFramebuffer$descriptor() {
        return glIsFramebuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLboolean glIsFramebuffer(GLuint framebuffer)
     * }
     */
    public static MethodHandle glIsFramebuffer$handle() {
        return glIsFramebuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLboolean glIsFramebuffer(GLuint framebuffer)
     * }
     */
    public static MemorySegment glIsFramebuffer$address() {
        return glIsFramebuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLboolean glIsFramebuffer(GLuint framebuffer)
     * }
     */
    public static byte glIsFramebuffer(int framebuffer) {
        var mh$ = glIsFramebuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIsFramebuffer", framebuffer);
            }
            return (byte)mh$.invokeExact(framebuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBindFramebuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glBindFramebuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glBindFramebuffer(GLenum target, GLuint framebuffer)
     * }
     */
    public static FunctionDescriptor glBindFramebuffer$descriptor() {
        return glBindFramebuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glBindFramebuffer(GLenum target, GLuint framebuffer)
     * }
     */
    public static MethodHandle glBindFramebuffer$handle() {
        return glBindFramebuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glBindFramebuffer(GLenum target, GLuint framebuffer)
     * }
     */
    public static MemorySegment glBindFramebuffer$address() {
        return glBindFramebuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glBindFramebuffer(GLenum target, GLuint framebuffer)
     * }
     */
    public static void glBindFramebuffer(int target, int framebuffer) {
        var mh$ = glBindFramebuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBindFramebuffer", target, framebuffer);
            }
            mh$.invokeExact(target, framebuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDeleteFramebuffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDeleteFramebuffers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glDeleteFramebuffers(GLsizei n, const GLuint *framebuffers)
     * }
     */
    public static FunctionDescriptor glDeleteFramebuffers$descriptor() {
        return glDeleteFramebuffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glDeleteFramebuffers(GLsizei n, const GLuint *framebuffers)
     * }
     */
    public static MethodHandle glDeleteFramebuffers$handle() {
        return glDeleteFramebuffers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glDeleteFramebuffers(GLsizei n, const GLuint *framebuffers)
     * }
     */
    public static MemorySegment glDeleteFramebuffers$address() {
        return glDeleteFramebuffers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glDeleteFramebuffers(GLsizei n, const GLuint *framebuffers)
     * }
     */
    public static void glDeleteFramebuffers(int n, MemorySegment framebuffers) {
        var mh$ = glDeleteFramebuffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDeleteFramebuffers", n, framebuffers);
            }
            mh$.invokeExact(n, framebuffers);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGenFramebuffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGenFramebuffers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGenFramebuffers(GLsizei n, GLuint *framebuffers)
     * }
     */
    public static FunctionDescriptor glGenFramebuffers$descriptor() {
        return glGenFramebuffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGenFramebuffers(GLsizei n, GLuint *framebuffers)
     * }
     */
    public static MethodHandle glGenFramebuffers$handle() {
        return glGenFramebuffers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGenFramebuffers(GLsizei n, GLuint *framebuffers)
     * }
     */
    public static MemorySegment glGenFramebuffers$address() {
        return glGenFramebuffers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGenFramebuffers(GLsizei n, GLuint *framebuffers)
     * }
     */
    public static void glGenFramebuffers(int n, MemorySegment framebuffers) {
        var mh$ = glGenFramebuffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGenFramebuffers", n, framebuffers);
            }
            mh$.invokeExact(n, framebuffers);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCheckFramebufferStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glCheckFramebufferStatus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLenum glCheckFramebufferStatus(GLenum target)
     * }
     */
    public static FunctionDescriptor glCheckFramebufferStatus$descriptor() {
        return glCheckFramebufferStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLenum glCheckFramebufferStatus(GLenum target)
     * }
     */
    public static MethodHandle glCheckFramebufferStatus$handle() {
        return glCheckFramebufferStatus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLenum glCheckFramebufferStatus(GLenum target)
     * }
     */
    public static MemorySegment glCheckFramebufferStatus$address() {
        return glCheckFramebufferStatus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLenum glCheckFramebufferStatus(GLenum target)
     * }
     */
    public static int glCheckFramebufferStatus(int target) {
        var mh$ = glCheckFramebufferStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCheckFramebufferStatus", target);
            }
            return (int)mh$.invokeExact(target);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFramebufferTexture1D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFramebufferTexture1D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glFramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
     * }
     */
    public static FunctionDescriptor glFramebufferTexture1D$descriptor() {
        return glFramebufferTexture1D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glFramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
     * }
     */
    public static MethodHandle glFramebufferTexture1D$handle() {
        return glFramebufferTexture1D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glFramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
     * }
     */
    public static MemorySegment glFramebufferTexture1D$address() {
        return glFramebufferTexture1D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glFramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
     * }
     */
    public static void glFramebufferTexture1D(int target, int attachment, int textarget, int texture, int level) {
        var mh$ = glFramebufferTexture1D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFramebufferTexture1D", target, attachment, textarget, texture, level);
            }
            mh$.invokeExact(target, attachment, textarget, texture, level);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFramebufferTexture2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFramebufferTexture2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
     * }
     */
    public static FunctionDescriptor glFramebufferTexture2D$descriptor() {
        return glFramebufferTexture2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
     * }
     */
    public static MethodHandle glFramebufferTexture2D$handle() {
        return glFramebufferTexture2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
     * }
     */
    public static MemorySegment glFramebufferTexture2D$address() {
        return glFramebufferTexture2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
     * }
     */
    public static void glFramebufferTexture2D(int target, int attachment, int textarget, int texture, int level) {
        var mh$ = glFramebufferTexture2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFramebufferTexture2D", target, attachment, textarget, texture, level);
            }
            mh$.invokeExact(target, attachment, textarget, texture, level);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFramebufferTexture3D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFramebufferTexture3D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glFramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
     * }
     */
    public static FunctionDescriptor glFramebufferTexture3D$descriptor() {
        return glFramebufferTexture3D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glFramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
     * }
     */
    public static MethodHandle glFramebufferTexture3D$handle() {
        return glFramebufferTexture3D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glFramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
     * }
     */
    public static MemorySegment glFramebufferTexture3D$address() {
        return glFramebufferTexture3D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glFramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
     * }
     */
    public static void glFramebufferTexture3D(int target, int attachment, int textarget, int texture, int level, int zoffset) {
        var mh$ = glFramebufferTexture3D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFramebufferTexture3D", target, attachment, textarget, texture, level, zoffset);
            }
            mh$.invokeExact(target, attachment, textarget, texture, level, zoffset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFramebufferRenderbuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFramebufferRenderbuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
     * }
     */
    public static FunctionDescriptor glFramebufferRenderbuffer$descriptor() {
        return glFramebufferRenderbuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
     * }
     */
    public static MethodHandle glFramebufferRenderbuffer$handle() {
        return glFramebufferRenderbuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
     * }
     */
    public static MemorySegment glFramebufferRenderbuffer$address() {
        return glFramebufferRenderbuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
     * }
     */
    public static void glFramebufferRenderbuffer(int target, int attachment, int renderbuffertarget, int renderbuffer) {
        var mh$ = glFramebufferRenderbuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFramebufferRenderbuffer", target, attachment, renderbuffertarget, renderbuffer);
            }
            mh$.invokeExact(target, attachment, renderbuffertarget, renderbuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetFramebufferAttachmentParameteriv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetFramebufferAttachmentParameteriv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetFramebufferAttachmentParameteriv$descriptor() {
        return glGetFramebufferAttachmentParameteriv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetFramebufferAttachmentParameteriv$handle() {
        return glGetFramebufferAttachmentParameteriv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetFramebufferAttachmentParameteriv$address() {
        return glGetFramebufferAttachmentParameteriv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint *params)
     * }
     */
    public static void glGetFramebufferAttachmentParameteriv(int target, int attachment, int pname, MemorySegment params) {
        var mh$ = glGetFramebufferAttachmentParameteriv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetFramebufferAttachmentParameteriv", target, attachment, pname, params);
            }
            mh$.invokeExact(target, attachment, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGenerateMipmap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGenerateMipmap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGenerateMipmap(GLenum target)
     * }
     */
    public static FunctionDescriptor glGenerateMipmap$descriptor() {
        return glGenerateMipmap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGenerateMipmap(GLenum target)
     * }
     */
    public static MethodHandle glGenerateMipmap$handle() {
        return glGenerateMipmap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGenerateMipmap(GLenum target)
     * }
     */
    public static MemorySegment glGenerateMipmap$address() {
        return glGenerateMipmap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGenerateMipmap(GLenum target)
     * }
     */
    public static void glGenerateMipmap(int target) {
        var mh$ = glGenerateMipmap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGenerateMipmap", target);
            }
            mh$.invokeExact(target);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBlitFramebuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glBlitFramebuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
     * }
     */
    public static FunctionDescriptor glBlitFramebuffer$descriptor() {
        return glBlitFramebuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
     * }
     */
    public static MethodHandle glBlitFramebuffer$handle() {
        return glBlitFramebuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
     * }
     */
    public static MemorySegment glBlitFramebuffer$address() {
        return glBlitFramebuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
     * }
     */
    public static void glBlitFramebuffer(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, int mask, int filter) {
        var mh$ = glBlitFramebuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBlitFramebuffer", srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
            }
            mh$.invokeExact(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRenderbufferStorageMultisample {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRenderbufferStorageMultisample");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
     * }
     */
    public static FunctionDescriptor glRenderbufferStorageMultisample$descriptor() {
        return glRenderbufferStorageMultisample.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
     * }
     */
    public static MethodHandle glRenderbufferStorageMultisample$handle() {
        return glRenderbufferStorageMultisample.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
     * }
     */
    public static MemorySegment glRenderbufferStorageMultisample$address() {
        return glRenderbufferStorageMultisample.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
     * }
     */
    public static void glRenderbufferStorageMultisample(int target, int samples, int internalformat, int width, int height) {
        var mh$ = glRenderbufferStorageMultisample.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRenderbufferStorageMultisample", target, samples, internalformat, width, height);
            }
            mh$.invokeExact(target, samples, internalformat, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFramebufferTextureLayer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFramebufferTextureLayer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
     * }
     */
    public static FunctionDescriptor glFramebufferTextureLayer$descriptor() {
        return glFramebufferTextureLayer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
     * }
     */
    public static MethodHandle glFramebufferTextureLayer$handle() {
        return glFramebufferTextureLayer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
     * }
     */
    public static MemorySegment glFramebufferTextureLayer$address() {
        return glFramebufferTextureLayer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
     * }
     */
    public static void glFramebufferTextureLayer(int target, int attachment, int texture, int level, int layer) {
        var mh$ = glFramebufferTextureLayer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFramebufferTextureLayer", target, attachment, texture, level, layer);
            }
            mh$.invokeExact(target, attachment, texture, level, layer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttribDivisorARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttribDivisorARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttribDivisorARB(GLuint index, GLuint divisor)
     * }
     */
    public static FunctionDescriptor glVertexAttribDivisorARB$descriptor() {
        return glVertexAttribDivisorARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttribDivisorARB(GLuint index, GLuint divisor)
     * }
     */
    public static MethodHandle glVertexAttribDivisorARB$handle() {
        return glVertexAttribDivisorARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttribDivisorARB(GLuint index, GLuint divisor)
     * }
     */
    public static MemorySegment glVertexAttribDivisorARB$address() {
        return glVertexAttribDivisorARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttribDivisorARB(GLuint index, GLuint divisor)
     * }
     */
    public static void glVertexAttribDivisorARB(int index, int divisor) {
        var mh$ = glVertexAttribDivisorARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttribDivisorARB", index, divisor);
            }
            mh$.invokeExact(index, divisor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSampleCoverageARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glSampleCoverageARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glSampleCoverageARB(GLclampf value, GLboolean invert)
     * }
     */
    public static FunctionDescriptor glSampleCoverageARB$descriptor() {
        return glSampleCoverageARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glSampleCoverageARB(GLclampf value, GLboolean invert)
     * }
     */
    public static MethodHandle glSampleCoverageARB$handle() {
        return glSampleCoverageARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glSampleCoverageARB(GLclampf value, GLboolean invert)
     * }
     */
    public static MemorySegment glSampleCoverageARB$address() {
        return glSampleCoverageARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glSampleCoverageARB(GLclampf value, GLboolean invert)
     * }
     */
    public static void glSampleCoverageARB(float value, byte invert) {
        var mh$ = glSampleCoverageARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSampleCoverageARB", value, invert);
            }
            mh$.invokeExact(value, invert);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glActiveTextureARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glActiveTextureARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glActiveTextureARB(GLenum texture)
     * }
     */
    public static FunctionDescriptor glActiveTextureARB$descriptor() {
        return glActiveTextureARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glActiveTextureARB(GLenum texture)
     * }
     */
    public static MethodHandle glActiveTextureARB$handle() {
        return glActiveTextureARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glActiveTextureARB(GLenum texture)
     * }
     */
    public static MemorySegment glActiveTextureARB$address() {
        return glActiveTextureARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glActiveTextureARB(GLenum texture)
     * }
     */
    public static void glActiveTextureARB(int texture) {
        var mh$ = glActiveTextureARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glActiveTextureARB", texture);
            }
            mh$.invokeExact(texture);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glClientActiveTextureARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glClientActiveTextureARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glClientActiveTextureARB(GLenum texture)
     * }
     */
    public static FunctionDescriptor glClientActiveTextureARB$descriptor() {
        return glClientActiveTextureARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glClientActiveTextureARB(GLenum texture)
     * }
     */
    public static MethodHandle glClientActiveTextureARB$handle() {
        return glClientActiveTextureARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glClientActiveTextureARB(GLenum texture)
     * }
     */
    public static MemorySegment glClientActiveTextureARB$address() {
        return glClientActiveTextureARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glClientActiveTextureARB(GLenum texture)
     * }
     */
    public static void glClientActiveTextureARB(int texture) {
        var mh$ = glClientActiveTextureARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClientActiveTextureARB", texture);
            }
            mh$.invokeExact(texture);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1dARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord1dARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1dARB(GLenum target, GLdouble s)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1dARB$descriptor() {
        return glMultiTexCoord1dARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1dARB(GLenum target, GLdouble s)
     * }
     */
    public static MethodHandle glMultiTexCoord1dARB$handle() {
        return glMultiTexCoord1dARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1dARB(GLenum target, GLdouble s)
     * }
     */
    public static MemorySegment glMultiTexCoord1dARB$address() {
        return glMultiTexCoord1dARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord1dARB(GLenum target, GLdouble s)
     * }
     */
    public static void glMultiTexCoord1dARB(int target, double s) {
        var mh$ = glMultiTexCoord1dARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1dARB", target, s);
            }
            mh$.invokeExact(target, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1dvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord1dvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1dvARB$descriptor() {
        return glMultiTexCoord1dvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static MethodHandle glMultiTexCoord1dvARB$handle() {
        return glMultiTexCoord1dvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static MemorySegment glMultiTexCoord1dvARB$address() {
        return glMultiTexCoord1dvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord1dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static void glMultiTexCoord1dvARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord1dvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1dvARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1fARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord1fARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1fARB(GLenum target, GLfloat s)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1fARB$descriptor() {
        return glMultiTexCoord1fARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1fARB(GLenum target, GLfloat s)
     * }
     */
    public static MethodHandle glMultiTexCoord1fARB$handle() {
        return glMultiTexCoord1fARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1fARB(GLenum target, GLfloat s)
     * }
     */
    public static MemorySegment glMultiTexCoord1fARB$address() {
        return glMultiTexCoord1fARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord1fARB(GLenum target, GLfloat s)
     * }
     */
    public static void glMultiTexCoord1fARB(int target, float s) {
        var mh$ = glMultiTexCoord1fARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1fARB", target, s);
            }
            mh$.invokeExact(target, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1fvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord1fvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1fvARB$descriptor() {
        return glMultiTexCoord1fvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static MethodHandle glMultiTexCoord1fvARB$handle() {
        return glMultiTexCoord1fvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static MemorySegment glMultiTexCoord1fvARB$address() {
        return glMultiTexCoord1fvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord1fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static void glMultiTexCoord1fvARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord1fvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1fvARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1iARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord1iARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1iARB(GLenum target, GLint s)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1iARB$descriptor() {
        return glMultiTexCoord1iARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1iARB(GLenum target, GLint s)
     * }
     */
    public static MethodHandle glMultiTexCoord1iARB$handle() {
        return glMultiTexCoord1iARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1iARB(GLenum target, GLint s)
     * }
     */
    public static MemorySegment glMultiTexCoord1iARB$address() {
        return glMultiTexCoord1iARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord1iARB(GLenum target, GLint s)
     * }
     */
    public static void glMultiTexCoord1iARB(int target, int s) {
        var mh$ = glMultiTexCoord1iARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1iARB", target, s);
            }
            mh$.invokeExact(target, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1ivARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord1ivARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1ivARB(GLenum target, const GLint *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1ivARB$descriptor() {
        return glMultiTexCoord1ivARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1ivARB(GLenum target, const GLint *v)
     * }
     */
    public static MethodHandle glMultiTexCoord1ivARB$handle() {
        return glMultiTexCoord1ivARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1ivARB(GLenum target, const GLint *v)
     * }
     */
    public static MemorySegment glMultiTexCoord1ivARB$address() {
        return glMultiTexCoord1ivARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord1ivARB(GLenum target, const GLint *v)
     * }
     */
    public static void glMultiTexCoord1ivARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord1ivARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1ivARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1sARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord1sARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1sARB(GLenum target, GLshort s)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1sARB$descriptor() {
        return glMultiTexCoord1sARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1sARB(GLenum target, GLshort s)
     * }
     */
    public static MethodHandle glMultiTexCoord1sARB$handle() {
        return glMultiTexCoord1sARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1sARB(GLenum target, GLshort s)
     * }
     */
    public static MemorySegment glMultiTexCoord1sARB$address() {
        return glMultiTexCoord1sARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord1sARB(GLenum target, GLshort s)
     * }
     */
    public static void glMultiTexCoord1sARB(int target, short s) {
        var mh$ = glMultiTexCoord1sARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1sARB", target, s);
            }
            mh$.invokeExact(target, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1svARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord1svARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1svARB(GLenum target, const GLshort *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1svARB$descriptor() {
        return glMultiTexCoord1svARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1svARB(GLenum target, const GLshort *v)
     * }
     */
    public static MethodHandle glMultiTexCoord1svARB$handle() {
        return glMultiTexCoord1svARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1svARB(GLenum target, const GLshort *v)
     * }
     */
    public static MemorySegment glMultiTexCoord1svARB$address() {
        return glMultiTexCoord1svARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord1svARB(GLenum target, const GLshort *v)
     * }
     */
    public static void glMultiTexCoord1svARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord1svARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1svARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2dARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord2dARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2dARB(GLenum target, GLdouble s, GLdouble t)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2dARB$descriptor() {
        return glMultiTexCoord2dARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2dARB(GLenum target, GLdouble s, GLdouble t)
     * }
     */
    public static MethodHandle glMultiTexCoord2dARB$handle() {
        return glMultiTexCoord2dARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2dARB(GLenum target, GLdouble s, GLdouble t)
     * }
     */
    public static MemorySegment glMultiTexCoord2dARB$address() {
        return glMultiTexCoord2dARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord2dARB(GLenum target, GLdouble s, GLdouble t)
     * }
     */
    public static void glMultiTexCoord2dARB(int target, double s, double t) {
        var mh$ = glMultiTexCoord2dARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2dARB", target, s, t);
            }
            mh$.invokeExact(target, s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2dvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord2dvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2dvARB$descriptor() {
        return glMultiTexCoord2dvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static MethodHandle glMultiTexCoord2dvARB$handle() {
        return glMultiTexCoord2dvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static MemorySegment glMultiTexCoord2dvARB$address() {
        return glMultiTexCoord2dvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord2dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static void glMultiTexCoord2dvARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord2dvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2dvARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2fARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord2fARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2fARB(GLenum target, GLfloat s, GLfloat t)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2fARB$descriptor() {
        return glMultiTexCoord2fARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2fARB(GLenum target, GLfloat s, GLfloat t)
     * }
     */
    public static MethodHandle glMultiTexCoord2fARB$handle() {
        return glMultiTexCoord2fARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2fARB(GLenum target, GLfloat s, GLfloat t)
     * }
     */
    public static MemorySegment glMultiTexCoord2fARB$address() {
        return glMultiTexCoord2fARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord2fARB(GLenum target, GLfloat s, GLfloat t)
     * }
     */
    public static void glMultiTexCoord2fARB(int target, float s, float t) {
        var mh$ = glMultiTexCoord2fARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2fARB", target, s, t);
            }
            mh$.invokeExact(target, s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2fvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord2fvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2fvARB$descriptor() {
        return glMultiTexCoord2fvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static MethodHandle glMultiTexCoord2fvARB$handle() {
        return glMultiTexCoord2fvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static MemorySegment glMultiTexCoord2fvARB$address() {
        return glMultiTexCoord2fvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord2fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static void glMultiTexCoord2fvARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord2fvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2fvARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2iARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord2iARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2iARB(GLenum target, GLint s, GLint t)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2iARB$descriptor() {
        return glMultiTexCoord2iARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2iARB(GLenum target, GLint s, GLint t)
     * }
     */
    public static MethodHandle glMultiTexCoord2iARB$handle() {
        return glMultiTexCoord2iARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2iARB(GLenum target, GLint s, GLint t)
     * }
     */
    public static MemorySegment glMultiTexCoord2iARB$address() {
        return glMultiTexCoord2iARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord2iARB(GLenum target, GLint s, GLint t)
     * }
     */
    public static void glMultiTexCoord2iARB(int target, int s, int t) {
        var mh$ = glMultiTexCoord2iARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2iARB", target, s, t);
            }
            mh$.invokeExact(target, s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2ivARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord2ivARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2ivARB(GLenum target, const GLint *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2ivARB$descriptor() {
        return glMultiTexCoord2ivARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2ivARB(GLenum target, const GLint *v)
     * }
     */
    public static MethodHandle glMultiTexCoord2ivARB$handle() {
        return glMultiTexCoord2ivARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2ivARB(GLenum target, const GLint *v)
     * }
     */
    public static MemorySegment glMultiTexCoord2ivARB$address() {
        return glMultiTexCoord2ivARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord2ivARB(GLenum target, const GLint *v)
     * }
     */
    public static void glMultiTexCoord2ivARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord2ivARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2ivARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2sARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord2sARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2sARB(GLenum target, GLshort s, GLshort t)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2sARB$descriptor() {
        return glMultiTexCoord2sARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2sARB(GLenum target, GLshort s, GLshort t)
     * }
     */
    public static MethodHandle glMultiTexCoord2sARB$handle() {
        return glMultiTexCoord2sARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2sARB(GLenum target, GLshort s, GLshort t)
     * }
     */
    public static MemorySegment glMultiTexCoord2sARB$address() {
        return glMultiTexCoord2sARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord2sARB(GLenum target, GLshort s, GLshort t)
     * }
     */
    public static void glMultiTexCoord2sARB(int target, short s, short t) {
        var mh$ = glMultiTexCoord2sARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2sARB", target, s, t);
            }
            mh$.invokeExact(target, s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2svARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord2svARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2svARB(GLenum target, const GLshort *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2svARB$descriptor() {
        return glMultiTexCoord2svARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2svARB(GLenum target, const GLshort *v)
     * }
     */
    public static MethodHandle glMultiTexCoord2svARB$handle() {
        return glMultiTexCoord2svARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2svARB(GLenum target, const GLshort *v)
     * }
     */
    public static MemorySegment glMultiTexCoord2svARB$address() {
        return glMultiTexCoord2svARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord2svARB(GLenum target, const GLshort *v)
     * }
     */
    public static void glMultiTexCoord2svARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord2svARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2svARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3dARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord3dARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3dARB$descriptor() {
        return glMultiTexCoord3dARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static MethodHandle glMultiTexCoord3dARB$handle() {
        return glMultiTexCoord3dARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static MemorySegment glMultiTexCoord3dARB$address() {
        return glMultiTexCoord3dARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord3dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static void glMultiTexCoord3dARB(int target, double s, double t, double r) {
        var mh$ = glMultiTexCoord3dARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3dARB", target, s, t, r);
            }
            mh$.invokeExact(target, s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3dvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord3dvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3dvARB$descriptor() {
        return glMultiTexCoord3dvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static MethodHandle glMultiTexCoord3dvARB$handle() {
        return glMultiTexCoord3dvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static MemorySegment glMultiTexCoord3dvARB$address() {
        return glMultiTexCoord3dvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord3dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static void glMultiTexCoord3dvARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord3dvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3dvARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3fARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord3fARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3fARB$descriptor() {
        return glMultiTexCoord3fARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static MethodHandle glMultiTexCoord3fARB$handle() {
        return glMultiTexCoord3fARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static MemorySegment glMultiTexCoord3fARB$address() {
        return glMultiTexCoord3fARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord3fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static void glMultiTexCoord3fARB(int target, float s, float t, float r) {
        var mh$ = glMultiTexCoord3fARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3fARB", target, s, t, r);
            }
            mh$.invokeExact(target, s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3fvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord3fvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3fvARB$descriptor() {
        return glMultiTexCoord3fvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static MethodHandle glMultiTexCoord3fvARB$handle() {
        return glMultiTexCoord3fvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static MemorySegment glMultiTexCoord3fvARB$address() {
        return glMultiTexCoord3fvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord3fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static void glMultiTexCoord3fvARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord3fvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3fvARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3iARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord3iARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3iARB(GLenum target, GLint s, GLint t, GLint r)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3iARB$descriptor() {
        return glMultiTexCoord3iARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3iARB(GLenum target, GLint s, GLint t, GLint r)
     * }
     */
    public static MethodHandle glMultiTexCoord3iARB$handle() {
        return glMultiTexCoord3iARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3iARB(GLenum target, GLint s, GLint t, GLint r)
     * }
     */
    public static MemorySegment glMultiTexCoord3iARB$address() {
        return glMultiTexCoord3iARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord3iARB(GLenum target, GLint s, GLint t, GLint r)
     * }
     */
    public static void glMultiTexCoord3iARB(int target, int s, int t, int r) {
        var mh$ = glMultiTexCoord3iARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3iARB", target, s, t, r);
            }
            mh$.invokeExact(target, s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3ivARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord3ivARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3ivARB(GLenum target, const GLint *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3ivARB$descriptor() {
        return glMultiTexCoord3ivARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3ivARB(GLenum target, const GLint *v)
     * }
     */
    public static MethodHandle glMultiTexCoord3ivARB$handle() {
        return glMultiTexCoord3ivARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3ivARB(GLenum target, const GLint *v)
     * }
     */
    public static MemorySegment glMultiTexCoord3ivARB$address() {
        return glMultiTexCoord3ivARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord3ivARB(GLenum target, const GLint *v)
     * }
     */
    public static void glMultiTexCoord3ivARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord3ivARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3ivARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3sARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord3sARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3sARB(GLenum target, GLshort s, GLshort t, GLshort r)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3sARB$descriptor() {
        return glMultiTexCoord3sARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3sARB(GLenum target, GLshort s, GLshort t, GLshort r)
     * }
     */
    public static MethodHandle glMultiTexCoord3sARB$handle() {
        return glMultiTexCoord3sARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3sARB(GLenum target, GLshort s, GLshort t, GLshort r)
     * }
     */
    public static MemorySegment glMultiTexCoord3sARB$address() {
        return glMultiTexCoord3sARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord3sARB(GLenum target, GLshort s, GLshort t, GLshort r)
     * }
     */
    public static void glMultiTexCoord3sARB(int target, short s, short t, short r) {
        var mh$ = glMultiTexCoord3sARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3sARB", target, s, t, r);
            }
            mh$.invokeExact(target, s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3svARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord3svARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3svARB(GLenum target, const GLshort *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3svARB$descriptor() {
        return glMultiTexCoord3svARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3svARB(GLenum target, const GLshort *v)
     * }
     */
    public static MethodHandle glMultiTexCoord3svARB$handle() {
        return glMultiTexCoord3svARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3svARB(GLenum target, const GLshort *v)
     * }
     */
    public static MemorySegment glMultiTexCoord3svARB$address() {
        return glMultiTexCoord3svARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord3svARB(GLenum target, const GLshort *v)
     * }
     */
    public static void glMultiTexCoord3svARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord3svARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3svARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4dARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord4dARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4dARB$descriptor() {
        return glMultiTexCoord4dARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static MethodHandle glMultiTexCoord4dARB$handle() {
        return glMultiTexCoord4dARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static MemorySegment glMultiTexCoord4dARB$address() {
        return glMultiTexCoord4dARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord4dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static void glMultiTexCoord4dARB(int target, double s, double t, double r, double q) {
        var mh$ = glMultiTexCoord4dARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4dARB", target, s, t, r, q);
            }
            mh$.invokeExact(target, s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4dvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord4dvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4dvARB$descriptor() {
        return glMultiTexCoord4dvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static MethodHandle glMultiTexCoord4dvARB$handle() {
        return glMultiTexCoord4dvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static MemorySegment glMultiTexCoord4dvARB$address() {
        return glMultiTexCoord4dvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord4dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static void glMultiTexCoord4dvARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord4dvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4dvARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4fARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord4fARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4fARB$descriptor() {
        return glMultiTexCoord4fARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static MethodHandle glMultiTexCoord4fARB$handle() {
        return glMultiTexCoord4fARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static MemorySegment glMultiTexCoord4fARB$address() {
        return glMultiTexCoord4fARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord4fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static void glMultiTexCoord4fARB(int target, float s, float t, float r, float q) {
        var mh$ = glMultiTexCoord4fARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4fARB", target, s, t, r, q);
            }
            mh$.invokeExact(target, s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4fvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord4fvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4fvARB$descriptor() {
        return glMultiTexCoord4fvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static MethodHandle glMultiTexCoord4fvARB$handle() {
        return glMultiTexCoord4fvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static MemorySegment glMultiTexCoord4fvARB$address() {
        return glMultiTexCoord4fvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord4fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static void glMultiTexCoord4fvARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord4fvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4fvARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4iARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord4iARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4iARB(GLenum target, GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4iARB$descriptor() {
        return glMultiTexCoord4iARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4iARB(GLenum target, GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static MethodHandle glMultiTexCoord4iARB$handle() {
        return glMultiTexCoord4iARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4iARB(GLenum target, GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static MemorySegment glMultiTexCoord4iARB$address() {
        return glMultiTexCoord4iARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord4iARB(GLenum target, GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static void glMultiTexCoord4iARB(int target, int s, int t, int r, int q) {
        var mh$ = glMultiTexCoord4iARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4iARB", target, s, t, r, q);
            }
            mh$.invokeExact(target, s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4ivARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord4ivARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4ivARB(GLenum target, const GLint *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4ivARB$descriptor() {
        return glMultiTexCoord4ivARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4ivARB(GLenum target, const GLint *v)
     * }
     */
    public static MethodHandle glMultiTexCoord4ivARB$handle() {
        return glMultiTexCoord4ivARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4ivARB(GLenum target, const GLint *v)
     * }
     */
    public static MemorySegment glMultiTexCoord4ivARB$address() {
        return glMultiTexCoord4ivARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord4ivARB(GLenum target, const GLint *v)
     * }
     */
    public static void glMultiTexCoord4ivARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord4ivARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4ivARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4sARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord4sARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4sARB(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4sARB$descriptor() {
        return glMultiTexCoord4sARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4sARB(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static MethodHandle glMultiTexCoord4sARB$handle() {
        return glMultiTexCoord4sARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4sARB(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static MemorySegment glMultiTexCoord4sARB$address() {
        return glMultiTexCoord4sARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord4sARB(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static void glMultiTexCoord4sARB(int target, short s, short t, short r, short q) {
        var mh$ = glMultiTexCoord4sARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4sARB", target, s, t, r, q);
            }
            mh$.invokeExact(target, s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4svARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord4svARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4svARB(GLenum target, const GLshort *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4svARB$descriptor() {
        return glMultiTexCoord4svARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4svARB(GLenum target, const GLshort *v)
     * }
     */
    public static MethodHandle glMultiTexCoord4svARB$handle() {
        return glMultiTexCoord4svARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4svARB(GLenum target, const GLshort *v)
     * }
     */
    public static MemorySegment glMultiTexCoord4svARB$address() {
        return glMultiTexCoord4svARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord4svARB(GLenum target, const GLshort *v)
     * }
     */
    public static void glMultiTexCoord4svARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord4svARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4svARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGenQueriesARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGenQueriesARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGenQueriesARB(GLsizei n, GLuint *ids)
     * }
     */
    public static FunctionDescriptor glGenQueriesARB$descriptor() {
        return glGenQueriesARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGenQueriesARB(GLsizei n, GLuint *ids)
     * }
     */
    public static MethodHandle glGenQueriesARB$handle() {
        return glGenQueriesARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGenQueriesARB(GLsizei n, GLuint *ids)
     * }
     */
    public static MemorySegment glGenQueriesARB$address() {
        return glGenQueriesARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGenQueriesARB(GLsizei n, GLuint *ids)
     * }
     */
    public static void glGenQueriesARB(int n, MemorySegment ids) {
        var mh$ = glGenQueriesARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGenQueriesARB", n, ids);
            }
            mh$.invokeExact(n, ids);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDeleteQueriesARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDeleteQueriesARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glDeleteQueriesARB(GLsizei n, const GLuint *ids)
     * }
     */
    public static FunctionDescriptor glDeleteQueriesARB$descriptor() {
        return glDeleteQueriesARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glDeleteQueriesARB(GLsizei n, const GLuint *ids)
     * }
     */
    public static MethodHandle glDeleteQueriesARB$handle() {
        return glDeleteQueriesARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glDeleteQueriesARB(GLsizei n, const GLuint *ids)
     * }
     */
    public static MemorySegment glDeleteQueriesARB$address() {
        return glDeleteQueriesARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glDeleteQueriesARB(GLsizei n, const GLuint *ids)
     * }
     */
    public static void glDeleteQueriesARB(int n, MemorySegment ids) {
        var mh$ = glDeleteQueriesARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDeleteQueriesARB", n, ids);
            }
            mh$.invokeExact(n, ids);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIsQueryARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glIsQueryARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLboolean glIsQueryARB(GLuint id)
     * }
     */
    public static FunctionDescriptor glIsQueryARB$descriptor() {
        return glIsQueryARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLboolean glIsQueryARB(GLuint id)
     * }
     */
    public static MethodHandle glIsQueryARB$handle() {
        return glIsQueryARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLboolean glIsQueryARB(GLuint id)
     * }
     */
    public static MemorySegment glIsQueryARB$address() {
        return glIsQueryARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLboolean glIsQueryARB(GLuint id)
     * }
     */
    public static byte glIsQueryARB(int id) {
        var mh$ = glIsQueryARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIsQueryARB", id);
            }
            return (byte)mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBeginQueryARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glBeginQueryARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glBeginQueryARB(GLenum target, GLuint id)
     * }
     */
    public static FunctionDescriptor glBeginQueryARB$descriptor() {
        return glBeginQueryARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glBeginQueryARB(GLenum target, GLuint id)
     * }
     */
    public static MethodHandle glBeginQueryARB$handle() {
        return glBeginQueryARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glBeginQueryARB(GLenum target, GLuint id)
     * }
     */
    public static MemorySegment glBeginQueryARB$address() {
        return glBeginQueryARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glBeginQueryARB(GLenum target, GLuint id)
     * }
     */
    public static void glBeginQueryARB(int target, int id) {
        var mh$ = glBeginQueryARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBeginQueryARB", target, id);
            }
            mh$.invokeExact(target, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEndQueryARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glEndQueryARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glEndQueryARB(GLenum target)
     * }
     */
    public static FunctionDescriptor glEndQueryARB$descriptor() {
        return glEndQueryARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glEndQueryARB(GLenum target)
     * }
     */
    public static MethodHandle glEndQueryARB$handle() {
        return glEndQueryARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glEndQueryARB(GLenum target)
     * }
     */
    public static MemorySegment glEndQueryARB$address() {
        return glEndQueryARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glEndQueryARB(GLenum target)
     * }
     */
    public static void glEndQueryARB(int target) {
        var mh$ = glEndQueryARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEndQueryARB", target);
            }
            mh$.invokeExact(target);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetQueryivARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetQueryivARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetQueryivARB(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetQueryivARB$descriptor() {
        return glGetQueryivARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetQueryivARB(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetQueryivARB$handle() {
        return glGetQueryivARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetQueryivARB(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetQueryivARB$address() {
        return glGetQueryivARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetQueryivARB(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static void glGetQueryivARB(int target, int pname, MemorySegment params) {
        var mh$ = glGetQueryivARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetQueryivARB", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetQueryObjectivARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetQueryObjectivARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetQueryObjectivARB(GLuint id, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetQueryObjectivARB$descriptor() {
        return glGetQueryObjectivARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetQueryObjectivARB(GLuint id, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetQueryObjectivARB$handle() {
        return glGetQueryObjectivARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetQueryObjectivARB(GLuint id, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetQueryObjectivARB$address() {
        return glGetQueryObjectivARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetQueryObjectivARB(GLuint id, GLenum pname, GLint *params)
     * }
     */
    public static void glGetQueryObjectivARB(int id, int pname, MemorySegment params) {
        var mh$ = glGetQueryObjectivARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetQueryObjectivARB", id, pname, params);
            }
            mh$.invokeExact(id, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetQueryObjectuivARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetQueryObjectuivARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetQueryObjectuivARB(GLuint id, GLenum pname, GLuint *params)
     * }
     */
    public static FunctionDescriptor glGetQueryObjectuivARB$descriptor() {
        return glGetQueryObjectuivARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetQueryObjectuivARB(GLuint id, GLenum pname, GLuint *params)
     * }
     */
    public static MethodHandle glGetQueryObjectuivARB$handle() {
        return glGetQueryObjectuivARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetQueryObjectuivARB(GLuint id, GLenum pname, GLuint *params)
     * }
     */
    public static MemorySegment glGetQueryObjectuivARB$address() {
        return glGetQueryObjectuivARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetQueryObjectuivARB(GLuint id, GLenum pname, GLuint *params)
     * }
     */
    public static void glGetQueryObjectuivARB(int id, int pname, MemorySegment params) {
        var mh$ = glGetQueryObjectuivARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetQueryObjectuivARB", id, pname, params);
            }
            mh$.invokeExact(id, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPointParameterfARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPointParameterfARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glPointParameterfARB(GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glPointParameterfARB$descriptor() {
        return glPointParameterfARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glPointParameterfARB(GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glPointParameterfARB$handle() {
        return glPointParameterfARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glPointParameterfARB(GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glPointParameterfARB$address() {
        return glPointParameterfARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glPointParameterfARB(GLenum pname, GLfloat param)
     * }
     */
    public static void glPointParameterfARB(int pname, float param) {
        var mh$ = glPointParameterfARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPointParameterfARB", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPointParameterfvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPointParameterfvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glPointParameterfvARB(GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glPointParameterfvARB$descriptor() {
        return glPointParameterfvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glPointParameterfvARB(GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glPointParameterfvARB$handle() {
        return glPointParameterfvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glPointParameterfvARB(GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glPointParameterfvARB$address() {
        return glPointParameterfvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glPointParameterfvARB(GLenum pname, const GLfloat *params)
     * }
     */
    public static void glPointParameterfvARB(int pname, MemorySegment params) {
        var mh$ = glPointParameterfvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPointParameterfvARB", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glProvokingVertex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glProvokingVertex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glProvokingVertex(GLenum mode)
     * }
     */
    public static FunctionDescriptor glProvokingVertex$descriptor() {
        return glProvokingVertex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glProvokingVertex(GLenum mode)
     * }
     */
    public static MethodHandle glProvokingVertex$handle() {
        return glProvokingVertex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glProvokingVertex(GLenum mode)
     * }
     */
    public static MemorySegment glProvokingVertex$address() {
        return glProvokingVertex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glProvokingVertex(GLenum mode)
     * }
     */
    public static void glProvokingVertex(int mode) {
        var mh$ = glProvokingVertex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glProvokingVertex", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDeleteObjectARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDeleteObjectARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glDeleteObjectARB(GLhandleARB obj)
     * }
     */
    public static FunctionDescriptor glDeleteObjectARB$descriptor() {
        return glDeleteObjectARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glDeleteObjectARB(GLhandleARB obj)
     * }
     */
    public static MethodHandle glDeleteObjectARB$handle() {
        return glDeleteObjectARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glDeleteObjectARB(GLhandleARB obj)
     * }
     */
    public static MemorySegment glDeleteObjectARB$address() {
        return glDeleteObjectARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glDeleteObjectARB(GLhandleARB obj)
     * }
     */
    public static void glDeleteObjectARB(MemorySegment obj) {
        var mh$ = glDeleteObjectARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDeleteObjectARB", obj);
            }
            mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetHandleARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetHandleARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLhandleARB glGetHandleARB(GLenum pname)
     * }
     */
    public static FunctionDescriptor glGetHandleARB$descriptor() {
        return glGetHandleARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLhandleARB glGetHandleARB(GLenum pname)
     * }
     */
    public static MethodHandle glGetHandleARB$handle() {
        return glGetHandleARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLhandleARB glGetHandleARB(GLenum pname)
     * }
     */
    public static MemorySegment glGetHandleARB$address() {
        return glGetHandleARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLhandleARB glGetHandleARB(GLenum pname)
     * }
     */
    public static MemorySegment glGetHandleARB(int pname) {
        var mh$ = glGetHandleARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetHandleARB", pname);
            }
            return (MemorySegment)mh$.invokeExact(pname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDetachObjectARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDetachObjectARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glDetachObjectARB(GLhandleARB containerObj, GLhandleARB attachedObj)
     * }
     */
    public static FunctionDescriptor glDetachObjectARB$descriptor() {
        return glDetachObjectARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glDetachObjectARB(GLhandleARB containerObj, GLhandleARB attachedObj)
     * }
     */
    public static MethodHandle glDetachObjectARB$handle() {
        return glDetachObjectARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glDetachObjectARB(GLhandleARB containerObj, GLhandleARB attachedObj)
     * }
     */
    public static MemorySegment glDetachObjectARB$address() {
        return glDetachObjectARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glDetachObjectARB(GLhandleARB containerObj, GLhandleARB attachedObj)
     * }
     */
    public static void glDetachObjectARB(MemorySegment containerObj, MemorySegment attachedObj) {
        var mh$ = glDetachObjectARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDetachObjectARB", containerObj, attachedObj);
            }
            mh$.invokeExact(containerObj, attachedObj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCreateShaderObjectARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glCreateShaderObjectARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLhandleARB glCreateShaderObjectARB(GLenum shaderType)
     * }
     */
    public static FunctionDescriptor glCreateShaderObjectARB$descriptor() {
        return glCreateShaderObjectARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLhandleARB glCreateShaderObjectARB(GLenum shaderType)
     * }
     */
    public static MethodHandle glCreateShaderObjectARB$handle() {
        return glCreateShaderObjectARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLhandleARB glCreateShaderObjectARB(GLenum shaderType)
     * }
     */
    public static MemorySegment glCreateShaderObjectARB$address() {
        return glCreateShaderObjectARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLhandleARB glCreateShaderObjectARB(GLenum shaderType)
     * }
     */
    public static MemorySegment glCreateShaderObjectARB(int shaderType) {
        var mh$ = glCreateShaderObjectARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCreateShaderObjectARB", shaderType);
            }
            return (MemorySegment)mh$.invokeExact(shaderType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glShaderSourceARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glShaderSourceARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glShaderSourceARB(GLhandleARB shaderObj, GLsizei count, const GLcharARB *const *string, const GLint *length)
     * }
     */
    public static FunctionDescriptor glShaderSourceARB$descriptor() {
        return glShaderSourceARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glShaderSourceARB(GLhandleARB shaderObj, GLsizei count, const GLcharARB *const *string, const GLint *length)
     * }
     */
    public static MethodHandle glShaderSourceARB$handle() {
        return glShaderSourceARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glShaderSourceARB(GLhandleARB shaderObj, GLsizei count, const GLcharARB *const *string, const GLint *length)
     * }
     */
    public static MemorySegment glShaderSourceARB$address() {
        return glShaderSourceARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glShaderSourceARB(GLhandleARB shaderObj, GLsizei count, const GLcharARB *const *string, const GLint *length)
     * }
     */
    public static void glShaderSourceARB(MemorySegment shaderObj, int count, MemorySegment string, MemorySegment length) {
        var mh$ = glShaderSourceARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glShaderSourceARB", shaderObj, count, string, length);
            }
            mh$.invokeExact(shaderObj, count, string, length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCompileShaderARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glCompileShaderARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glCompileShaderARB(GLhandleARB shaderObj)
     * }
     */
    public static FunctionDescriptor glCompileShaderARB$descriptor() {
        return glCompileShaderARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glCompileShaderARB(GLhandleARB shaderObj)
     * }
     */
    public static MethodHandle glCompileShaderARB$handle() {
        return glCompileShaderARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glCompileShaderARB(GLhandleARB shaderObj)
     * }
     */
    public static MemorySegment glCompileShaderARB$address() {
        return glCompileShaderARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glCompileShaderARB(GLhandleARB shaderObj)
     * }
     */
    public static void glCompileShaderARB(MemorySegment shaderObj) {
        var mh$ = glCompileShaderARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCompileShaderARB", shaderObj);
            }
            mh$.invokeExact(shaderObj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCreateProgramObjectARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glCreateProgramObjectARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLhandleARB glCreateProgramObjectARB()
     * }
     */
    public static FunctionDescriptor glCreateProgramObjectARB$descriptor() {
        return glCreateProgramObjectARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLhandleARB glCreateProgramObjectARB()
     * }
     */
    public static MethodHandle glCreateProgramObjectARB$handle() {
        return glCreateProgramObjectARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLhandleARB glCreateProgramObjectARB()
     * }
     */
    public static MemorySegment glCreateProgramObjectARB$address() {
        return glCreateProgramObjectARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLhandleARB glCreateProgramObjectARB()
     * }
     */
    public static MemorySegment glCreateProgramObjectARB() {
        var mh$ = glCreateProgramObjectARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCreateProgramObjectARB");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glAttachObjectARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glAttachObjectARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glAttachObjectARB(GLhandleARB containerObj, GLhandleARB obj)
     * }
     */
    public static FunctionDescriptor glAttachObjectARB$descriptor() {
        return glAttachObjectARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glAttachObjectARB(GLhandleARB containerObj, GLhandleARB obj)
     * }
     */
    public static MethodHandle glAttachObjectARB$handle() {
        return glAttachObjectARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glAttachObjectARB(GLhandleARB containerObj, GLhandleARB obj)
     * }
     */
    public static MemorySegment glAttachObjectARB$address() {
        return glAttachObjectARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glAttachObjectARB(GLhandleARB containerObj, GLhandleARB obj)
     * }
     */
    public static void glAttachObjectARB(MemorySegment containerObj, MemorySegment obj) {
        var mh$ = glAttachObjectARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glAttachObjectARB", containerObj, obj);
            }
            mh$.invokeExact(containerObj, obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLinkProgramARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glLinkProgramARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glLinkProgramARB(GLhandleARB programObj)
     * }
     */
    public static FunctionDescriptor glLinkProgramARB$descriptor() {
        return glLinkProgramARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glLinkProgramARB(GLhandleARB programObj)
     * }
     */
    public static MethodHandle glLinkProgramARB$handle() {
        return glLinkProgramARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glLinkProgramARB(GLhandleARB programObj)
     * }
     */
    public static MemorySegment glLinkProgramARB$address() {
        return glLinkProgramARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glLinkProgramARB(GLhandleARB programObj)
     * }
     */
    public static void glLinkProgramARB(MemorySegment programObj) {
        var mh$ = glLinkProgramARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLinkProgramARB", programObj);
            }
            mh$.invokeExact(programObj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUseProgramObjectARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUseProgramObjectARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUseProgramObjectARB(GLhandleARB programObj)
     * }
     */
    public static FunctionDescriptor glUseProgramObjectARB$descriptor() {
        return glUseProgramObjectARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUseProgramObjectARB(GLhandleARB programObj)
     * }
     */
    public static MethodHandle glUseProgramObjectARB$handle() {
        return glUseProgramObjectARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUseProgramObjectARB(GLhandleARB programObj)
     * }
     */
    public static MemorySegment glUseProgramObjectARB$address() {
        return glUseProgramObjectARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUseProgramObjectARB(GLhandleARB programObj)
     * }
     */
    public static void glUseProgramObjectARB(MemorySegment programObj) {
        var mh$ = glUseProgramObjectARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUseProgramObjectARB", programObj);
            }
            mh$.invokeExact(programObj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glValidateProgramARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glValidateProgramARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glValidateProgramARB(GLhandleARB programObj)
     * }
     */
    public static FunctionDescriptor glValidateProgramARB$descriptor() {
        return glValidateProgramARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glValidateProgramARB(GLhandleARB programObj)
     * }
     */
    public static MethodHandle glValidateProgramARB$handle() {
        return glValidateProgramARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glValidateProgramARB(GLhandleARB programObj)
     * }
     */
    public static MemorySegment glValidateProgramARB$address() {
        return glValidateProgramARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glValidateProgramARB(GLhandleARB programObj)
     * }
     */
    public static void glValidateProgramARB(MemorySegment programObj) {
        var mh$ = glValidateProgramARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glValidateProgramARB", programObj);
            }
            mh$.invokeExact(programObj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniform1fARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniform1fARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniform1fARB(GLint location, GLfloat v0)
     * }
     */
    public static FunctionDescriptor glUniform1fARB$descriptor() {
        return glUniform1fARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniform1fARB(GLint location, GLfloat v0)
     * }
     */
    public static MethodHandle glUniform1fARB$handle() {
        return glUniform1fARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniform1fARB(GLint location, GLfloat v0)
     * }
     */
    public static MemorySegment glUniform1fARB$address() {
        return glUniform1fARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniform1fARB(GLint location, GLfloat v0)
     * }
     */
    public static void glUniform1fARB(int location, float v0) {
        var mh$ = glUniform1fARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniform1fARB", location, v0);
            }
            mh$.invokeExact(location, v0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniform2fARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniform2fARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniform2fARB(GLint location, GLfloat v0, GLfloat v1)
     * }
     */
    public static FunctionDescriptor glUniform2fARB$descriptor() {
        return glUniform2fARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniform2fARB(GLint location, GLfloat v0, GLfloat v1)
     * }
     */
    public static MethodHandle glUniform2fARB$handle() {
        return glUniform2fARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniform2fARB(GLint location, GLfloat v0, GLfloat v1)
     * }
     */
    public static MemorySegment glUniform2fARB$address() {
        return glUniform2fARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniform2fARB(GLint location, GLfloat v0, GLfloat v1)
     * }
     */
    public static void glUniform2fARB(int location, float v0, float v1) {
        var mh$ = glUniform2fARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniform2fARB", location, v0, v1);
            }
            mh$.invokeExact(location, v0, v1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniform3fARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniform3fARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniform3fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
     * }
     */
    public static FunctionDescriptor glUniform3fARB$descriptor() {
        return glUniform3fARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniform3fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
     * }
     */
    public static MethodHandle glUniform3fARB$handle() {
        return glUniform3fARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniform3fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
     * }
     */
    public static MemorySegment glUniform3fARB$address() {
        return glUniform3fARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniform3fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
     * }
     */
    public static void glUniform3fARB(int location, float v0, float v1, float v2) {
        var mh$ = glUniform3fARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniform3fARB", location, v0, v1, v2);
            }
            mh$.invokeExact(location, v0, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniform4fARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniform4fARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniform4fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
     * }
     */
    public static FunctionDescriptor glUniform4fARB$descriptor() {
        return glUniform4fARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniform4fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
     * }
     */
    public static MethodHandle glUniform4fARB$handle() {
        return glUniform4fARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniform4fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
     * }
     */
    public static MemorySegment glUniform4fARB$address() {
        return glUniform4fARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniform4fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
     * }
     */
    public static void glUniform4fARB(int location, float v0, float v1, float v2, float v3) {
        var mh$ = glUniform4fARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniform4fARB", location, v0, v1, v2, v3);
            }
            mh$.invokeExact(location, v0, v1, v2, v3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniform1iARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniform1iARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniform1iARB(GLint location, GLint v0)
     * }
     */
    public static FunctionDescriptor glUniform1iARB$descriptor() {
        return glUniform1iARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniform1iARB(GLint location, GLint v0)
     * }
     */
    public static MethodHandle glUniform1iARB$handle() {
        return glUniform1iARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniform1iARB(GLint location, GLint v0)
     * }
     */
    public static MemorySegment glUniform1iARB$address() {
        return glUniform1iARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniform1iARB(GLint location, GLint v0)
     * }
     */
    public static void glUniform1iARB(int location, int v0) {
        var mh$ = glUniform1iARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniform1iARB", location, v0);
            }
            mh$.invokeExact(location, v0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniform2iARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniform2iARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniform2iARB(GLint location, GLint v0, GLint v1)
     * }
     */
    public static FunctionDescriptor glUniform2iARB$descriptor() {
        return glUniform2iARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniform2iARB(GLint location, GLint v0, GLint v1)
     * }
     */
    public static MethodHandle glUniform2iARB$handle() {
        return glUniform2iARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniform2iARB(GLint location, GLint v0, GLint v1)
     * }
     */
    public static MemorySegment glUniform2iARB$address() {
        return glUniform2iARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniform2iARB(GLint location, GLint v0, GLint v1)
     * }
     */
    public static void glUniform2iARB(int location, int v0, int v1) {
        var mh$ = glUniform2iARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniform2iARB", location, v0, v1);
            }
            mh$.invokeExact(location, v0, v1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniform3iARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniform3iARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniform3iARB(GLint location, GLint v0, GLint v1, GLint v2)
     * }
     */
    public static FunctionDescriptor glUniform3iARB$descriptor() {
        return glUniform3iARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniform3iARB(GLint location, GLint v0, GLint v1, GLint v2)
     * }
     */
    public static MethodHandle glUniform3iARB$handle() {
        return glUniform3iARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniform3iARB(GLint location, GLint v0, GLint v1, GLint v2)
     * }
     */
    public static MemorySegment glUniform3iARB$address() {
        return glUniform3iARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniform3iARB(GLint location, GLint v0, GLint v1, GLint v2)
     * }
     */
    public static void glUniform3iARB(int location, int v0, int v1, int v2) {
        var mh$ = glUniform3iARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniform3iARB", location, v0, v1, v2);
            }
            mh$.invokeExact(location, v0, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniform4iARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniform4iARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniform4iARB(GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
     * }
     */
    public static FunctionDescriptor glUniform4iARB$descriptor() {
        return glUniform4iARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniform4iARB(GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
     * }
     */
    public static MethodHandle glUniform4iARB$handle() {
        return glUniform4iARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniform4iARB(GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
     * }
     */
    public static MemorySegment glUniform4iARB$address() {
        return glUniform4iARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniform4iARB(GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
     * }
     */
    public static void glUniform4iARB(int location, int v0, int v1, int v2, int v3) {
        var mh$ = glUniform4iARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniform4iARB", location, v0, v1, v2, v3);
            }
            mh$.invokeExact(location, v0, v1, v2, v3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniform1fvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniform1fvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniform1fvARB(GLint location, GLsizei count, const GLfloat *value)
     * }
     */
    public static FunctionDescriptor glUniform1fvARB$descriptor() {
        return glUniform1fvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniform1fvARB(GLint location, GLsizei count, const GLfloat *value)
     * }
     */
    public static MethodHandle glUniform1fvARB$handle() {
        return glUniform1fvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniform1fvARB(GLint location, GLsizei count, const GLfloat *value)
     * }
     */
    public static MemorySegment glUniform1fvARB$address() {
        return glUniform1fvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniform1fvARB(GLint location, GLsizei count, const GLfloat *value)
     * }
     */
    public static void glUniform1fvARB(int location, int count, MemorySegment value) {
        var mh$ = glUniform1fvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniform1fvARB", location, count, value);
            }
            mh$.invokeExact(location, count, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniform2fvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniform2fvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniform2fvARB(GLint location, GLsizei count, const GLfloat *value)
     * }
     */
    public static FunctionDescriptor glUniform2fvARB$descriptor() {
        return glUniform2fvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniform2fvARB(GLint location, GLsizei count, const GLfloat *value)
     * }
     */
    public static MethodHandle glUniform2fvARB$handle() {
        return glUniform2fvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniform2fvARB(GLint location, GLsizei count, const GLfloat *value)
     * }
     */
    public static MemorySegment glUniform2fvARB$address() {
        return glUniform2fvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniform2fvARB(GLint location, GLsizei count, const GLfloat *value)
     * }
     */
    public static void glUniform2fvARB(int location, int count, MemorySegment value) {
        var mh$ = glUniform2fvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniform2fvARB", location, count, value);
            }
            mh$.invokeExact(location, count, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniform3fvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniform3fvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniform3fvARB(GLint location, GLsizei count, const GLfloat *value)
     * }
     */
    public static FunctionDescriptor glUniform3fvARB$descriptor() {
        return glUniform3fvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniform3fvARB(GLint location, GLsizei count, const GLfloat *value)
     * }
     */
    public static MethodHandle glUniform3fvARB$handle() {
        return glUniform3fvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniform3fvARB(GLint location, GLsizei count, const GLfloat *value)
     * }
     */
    public static MemorySegment glUniform3fvARB$address() {
        return glUniform3fvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniform3fvARB(GLint location, GLsizei count, const GLfloat *value)
     * }
     */
    public static void glUniform3fvARB(int location, int count, MemorySegment value) {
        var mh$ = glUniform3fvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniform3fvARB", location, count, value);
            }
            mh$.invokeExact(location, count, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniform4fvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniform4fvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniform4fvARB(GLint location, GLsizei count, const GLfloat *value)
     * }
     */
    public static FunctionDescriptor glUniform4fvARB$descriptor() {
        return glUniform4fvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniform4fvARB(GLint location, GLsizei count, const GLfloat *value)
     * }
     */
    public static MethodHandle glUniform4fvARB$handle() {
        return glUniform4fvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniform4fvARB(GLint location, GLsizei count, const GLfloat *value)
     * }
     */
    public static MemorySegment glUniform4fvARB$address() {
        return glUniform4fvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniform4fvARB(GLint location, GLsizei count, const GLfloat *value)
     * }
     */
    public static void glUniform4fvARB(int location, int count, MemorySegment value) {
        var mh$ = glUniform4fvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniform4fvARB", location, count, value);
            }
            mh$.invokeExact(location, count, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniform1ivARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniform1ivARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniform1ivARB(GLint location, GLsizei count, const GLint *value)
     * }
     */
    public static FunctionDescriptor glUniform1ivARB$descriptor() {
        return glUniform1ivARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniform1ivARB(GLint location, GLsizei count, const GLint *value)
     * }
     */
    public static MethodHandle glUniform1ivARB$handle() {
        return glUniform1ivARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniform1ivARB(GLint location, GLsizei count, const GLint *value)
     * }
     */
    public static MemorySegment glUniform1ivARB$address() {
        return glUniform1ivARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniform1ivARB(GLint location, GLsizei count, const GLint *value)
     * }
     */
    public static void glUniform1ivARB(int location, int count, MemorySegment value) {
        var mh$ = glUniform1ivARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniform1ivARB", location, count, value);
            }
            mh$.invokeExact(location, count, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniform2ivARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniform2ivARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniform2ivARB(GLint location, GLsizei count, const GLint *value)
     * }
     */
    public static FunctionDescriptor glUniform2ivARB$descriptor() {
        return glUniform2ivARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniform2ivARB(GLint location, GLsizei count, const GLint *value)
     * }
     */
    public static MethodHandle glUniform2ivARB$handle() {
        return glUniform2ivARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniform2ivARB(GLint location, GLsizei count, const GLint *value)
     * }
     */
    public static MemorySegment glUniform2ivARB$address() {
        return glUniform2ivARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniform2ivARB(GLint location, GLsizei count, const GLint *value)
     * }
     */
    public static void glUniform2ivARB(int location, int count, MemorySegment value) {
        var mh$ = glUniform2ivARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniform2ivARB", location, count, value);
            }
            mh$.invokeExact(location, count, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniform3ivARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniform3ivARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniform3ivARB(GLint location, GLsizei count, const GLint *value)
     * }
     */
    public static FunctionDescriptor glUniform3ivARB$descriptor() {
        return glUniform3ivARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniform3ivARB(GLint location, GLsizei count, const GLint *value)
     * }
     */
    public static MethodHandle glUniform3ivARB$handle() {
        return glUniform3ivARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniform3ivARB(GLint location, GLsizei count, const GLint *value)
     * }
     */
    public static MemorySegment glUniform3ivARB$address() {
        return glUniform3ivARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniform3ivARB(GLint location, GLsizei count, const GLint *value)
     * }
     */
    public static void glUniform3ivARB(int location, int count, MemorySegment value) {
        var mh$ = glUniform3ivARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniform3ivARB", location, count, value);
            }
            mh$.invokeExact(location, count, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniform4ivARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniform4ivARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniform4ivARB(GLint location, GLsizei count, const GLint *value)
     * }
     */
    public static FunctionDescriptor glUniform4ivARB$descriptor() {
        return glUniform4ivARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniform4ivARB(GLint location, GLsizei count, const GLint *value)
     * }
     */
    public static MethodHandle glUniform4ivARB$handle() {
        return glUniform4ivARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniform4ivARB(GLint location, GLsizei count, const GLint *value)
     * }
     */
    public static MemorySegment glUniform4ivARB$address() {
        return glUniform4ivARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniform4ivARB(GLint location, GLsizei count, const GLint *value)
     * }
     */
    public static void glUniform4ivARB(int location, int count, MemorySegment value) {
        var mh$ = glUniform4ivARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniform4ivARB", location, count, value);
            }
            mh$.invokeExact(location, count, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniformMatrix2fvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniformMatrix2fvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniformMatrix2fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static FunctionDescriptor glUniformMatrix2fvARB$descriptor() {
        return glUniformMatrix2fvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniformMatrix2fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static MethodHandle glUniformMatrix2fvARB$handle() {
        return glUniformMatrix2fvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniformMatrix2fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static MemorySegment glUniformMatrix2fvARB$address() {
        return glUniformMatrix2fvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniformMatrix2fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static void glUniformMatrix2fvARB(int location, int count, byte transpose, MemorySegment value) {
        var mh$ = glUniformMatrix2fvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniformMatrix2fvARB", location, count, transpose, value);
            }
            mh$.invokeExact(location, count, transpose, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniformMatrix3fvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniformMatrix3fvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniformMatrix3fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static FunctionDescriptor glUniformMatrix3fvARB$descriptor() {
        return glUniformMatrix3fvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniformMatrix3fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static MethodHandle glUniformMatrix3fvARB$handle() {
        return glUniformMatrix3fvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniformMatrix3fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static MemorySegment glUniformMatrix3fvARB$address() {
        return glUniformMatrix3fvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniformMatrix3fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static void glUniformMatrix3fvARB(int location, int count, byte transpose, MemorySegment value) {
        var mh$ = glUniformMatrix3fvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniformMatrix3fvARB", location, count, transpose, value);
            }
            mh$.invokeExact(location, count, transpose, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniformMatrix4fvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniformMatrix4fvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniformMatrix4fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static FunctionDescriptor glUniformMatrix4fvARB$descriptor() {
        return glUniformMatrix4fvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniformMatrix4fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static MethodHandle glUniformMatrix4fvARB$handle() {
        return glUniformMatrix4fvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniformMatrix4fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static MemorySegment glUniformMatrix4fvARB$address() {
        return glUniformMatrix4fvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniformMatrix4fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static void glUniformMatrix4fvARB(int location, int count, byte transpose, MemorySegment value) {
        var mh$ = glUniformMatrix4fvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniformMatrix4fvARB", location, count, transpose, value);
            }
            mh$.invokeExact(location, count, transpose, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetObjectParameterfvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetObjectParameterfvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetObjectParameterfvARB(GLhandleARB obj, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetObjectParameterfvARB$descriptor() {
        return glGetObjectParameterfvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetObjectParameterfvARB(GLhandleARB obj, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetObjectParameterfvARB$handle() {
        return glGetObjectParameterfvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetObjectParameterfvARB(GLhandleARB obj, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetObjectParameterfvARB$address() {
        return glGetObjectParameterfvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetObjectParameterfvARB(GLhandleARB obj, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetObjectParameterfvARB(MemorySegment obj, int pname, MemorySegment params) {
        var mh$ = glGetObjectParameterfvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetObjectParameterfvARB", obj, pname, params);
            }
            mh$.invokeExact(obj, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetObjectParameterivARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetObjectParameterivARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetObjectParameterivARB(GLhandleARB obj, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetObjectParameterivARB$descriptor() {
        return glGetObjectParameterivARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetObjectParameterivARB(GLhandleARB obj, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetObjectParameterivARB$handle() {
        return glGetObjectParameterivARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetObjectParameterivARB(GLhandleARB obj, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetObjectParameterivARB$address() {
        return glGetObjectParameterivARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetObjectParameterivARB(GLhandleARB obj, GLenum pname, GLint *params)
     * }
     */
    public static void glGetObjectParameterivARB(MemorySegment obj, int pname, MemorySegment params) {
        var mh$ = glGetObjectParameterivARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetObjectParameterivARB", obj, pname, params);
            }
            mh$.invokeExact(obj, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetInfoLogARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetInfoLogARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetInfoLogARB(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *infoLog)
     * }
     */
    public static FunctionDescriptor glGetInfoLogARB$descriptor() {
        return glGetInfoLogARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetInfoLogARB(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *infoLog)
     * }
     */
    public static MethodHandle glGetInfoLogARB$handle() {
        return glGetInfoLogARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetInfoLogARB(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *infoLog)
     * }
     */
    public static MemorySegment glGetInfoLogARB$address() {
        return glGetInfoLogARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetInfoLogARB(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *infoLog)
     * }
     */
    public static void glGetInfoLogARB(MemorySegment obj, int maxLength, MemorySegment length, MemorySegment infoLog) {
        var mh$ = glGetInfoLogARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetInfoLogARB", obj, maxLength, length, infoLog);
            }
            mh$.invokeExact(obj, maxLength, length, infoLog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetAttachedObjectsARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetAttachedObjectsARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetAttachedObjectsARB(GLhandleARB containerObj, GLsizei maxCount, GLsizei *count, GLhandleARB *obj)
     * }
     */
    public static FunctionDescriptor glGetAttachedObjectsARB$descriptor() {
        return glGetAttachedObjectsARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetAttachedObjectsARB(GLhandleARB containerObj, GLsizei maxCount, GLsizei *count, GLhandleARB *obj)
     * }
     */
    public static MethodHandle glGetAttachedObjectsARB$handle() {
        return glGetAttachedObjectsARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetAttachedObjectsARB(GLhandleARB containerObj, GLsizei maxCount, GLsizei *count, GLhandleARB *obj)
     * }
     */
    public static MemorySegment glGetAttachedObjectsARB$address() {
        return glGetAttachedObjectsARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetAttachedObjectsARB(GLhandleARB containerObj, GLsizei maxCount, GLsizei *count, GLhandleARB *obj)
     * }
     */
    public static void glGetAttachedObjectsARB(MemorySegment containerObj, int maxCount, MemorySegment count, MemorySegment obj) {
        var mh$ = glGetAttachedObjectsARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetAttachedObjectsARB", containerObj, maxCount, count, obj);
            }
            mh$.invokeExact(containerObj, maxCount, count, obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetUniformLocationARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetUniformLocationARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLint glGetUniformLocationARB(GLhandleARB programObj, const GLcharARB *name)
     * }
     */
    public static FunctionDescriptor glGetUniformLocationARB$descriptor() {
        return glGetUniformLocationARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLint glGetUniformLocationARB(GLhandleARB programObj, const GLcharARB *name)
     * }
     */
    public static MethodHandle glGetUniformLocationARB$handle() {
        return glGetUniformLocationARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLint glGetUniformLocationARB(GLhandleARB programObj, const GLcharARB *name)
     * }
     */
    public static MemorySegment glGetUniformLocationARB$address() {
        return glGetUniformLocationARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLint glGetUniformLocationARB(GLhandleARB programObj, const GLcharARB *name)
     * }
     */
    public static int glGetUniformLocationARB(MemorySegment programObj, MemorySegment name) {
        var mh$ = glGetUniformLocationARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetUniformLocationARB", programObj, name);
            }
            return (int)mh$.invokeExact(programObj, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetActiveUniformARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetActiveUniformARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetActiveUniformARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name)
     * }
     */
    public static FunctionDescriptor glGetActiveUniformARB$descriptor() {
        return glGetActiveUniformARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetActiveUniformARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name)
     * }
     */
    public static MethodHandle glGetActiveUniformARB$handle() {
        return glGetActiveUniformARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetActiveUniformARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name)
     * }
     */
    public static MemorySegment glGetActiveUniformARB$address() {
        return glGetActiveUniformARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetActiveUniformARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name)
     * }
     */
    public static void glGetActiveUniformARB(MemorySegment programObj, int index, int maxLength, MemorySegment length, MemorySegment size, MemorySegment type, MemorySegment name) {
        var mh$ = glGetActiveUniformARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetActiveUniformARB", programObj, index, maxLength, length, size, type, name);
            }
            mh$.invokeExact(programObj, index, maxLength, length, size, type, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetUniformfvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetUniformfvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetUniformfvARB(GLhandleARB programObj, GLint location, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetUniformfvARB$descriptor() {
        return glGetUniformfvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetUniformfvARB(GLhandleARB programObj, GLint location, GLfloat *params)
     * }
     */
    public static MethodHandle glGetUniformfvARB$handle() {
        return glGetUniformfvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetUniformfvARB(GLhandleARB programObj, GLint location, GLfloat *params)
     * }
     */
    public static MemorySegment glGetUniformfvARB$address() {
        return glGetUniformfvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetUniformfvARB(GLhandleARB programObj, GLint location, GLfloat *params)
     * }
     */
    public static void glGetUniformfvARB(MemorySegment programObj, int location, MemorySegment params) {
        var mh$ = glGetUniformfvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetUniformfvARB", programObj, location, params);
            }
            mh$.invokeExact(programObj, location, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetUniformivARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetUniformivARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetUniformivARB(GLhandleARB programObj, GLint location, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetUniformivARB$descriptor() {
        return glGetUniformivARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetUniformivARB(GLhandleARB programObj, GLint location, GLint *params)
     * }
     */
    public static MethodHandle glGetUniformivARB$handle() {
        return glGetUniformivARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetUniformivARB(GLhandleARB programObj, GLint location, GLint *params)
     * }
     */
    public static MemorySegment glGetUniformivARB$address() {
        return glGetUniformivARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetUniformivARB(GLhandleARB programObj, GLint location, GLint *params)
     * }
     */
    public static void glGetUniformivARB(MemorySegment programObj, int location, MemorySegment params) {
        var mh$ = glGetUniformivARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetUniformivARB", programObj, location, params);
            }
            mh$.invokeExact(programObj, location, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetShaderSourceARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetShaderSourceARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetShaderSourceARB(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *source)
     * }
     */
    public static FunctionDescriptor glGetShaderSourceARB$descriptor() {
        return glGetShaderSourceARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetShaderSourceARB(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *source)
     * }
     */
    public static MethodHandle glGetShaderSourceARB$handle() {
        return glGetShaderSourceARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetShaderSourceARB(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *source)
     * }
     */
    public static MemorySegment glGetShaderSourceARB$address() {
        return glGetShaderSourceARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetShaderSourceARB(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *source)
     * }
     */
    public static void glGetShaderSourceARB(MemorySegment obj, int maxLength, MemorySegment length, MemorySegment source) {
        var mh$ = glGetShaderSourceARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetShaderSourceARB", obj, maxLength, length, source);
            }
            mh$.invokeExact(obj, maxLength, length, source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFenceSync {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFenceSync");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLsync glFenceSync(GLenum condition, GLbitfield flags)
     * }
     */
    public static FunctionDescriptor glFenceSync$descriptor() {
        return glFenceSync.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLsync glFenceSync(GLenum condition, GLbitfield flags)
     * }
     */
    public static MethodHandle glFenceSync$handle() {
        return glFenceSync.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLsync glFenceSync(GLenum condition, GLbitfield flags)
     * }
     */
    public static MemorySegment glFenceSync$address() {
        return glFenceSync.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLsync glFenceSync(GLenum condition, GLbitfield flags)
     * }
     */
    public static MemorySegment glFenceSync(int condition, int flags) {
        var mh$ = glFenceSync.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFenceSync", condition, flags);
            }
            return (MemorySegment)mh$.invokeExact(condition, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIsSync {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glIsSync");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLboolean glIsSync(GLsync sync)
     * }
     */
    public static FunctionDescriptor glIsSync$descriptor() {
        return glIsSync.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLboolean glIsSync(GLsync sync)
     * }
     */
    public static MethodHandle glIsSync$handle() {
        return glIsSync.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLboolean glIsSync(GLsync sync)
     * }
     */
    public static MemorySegment glIsSync$address() {
        return glIsSync.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLboolean glIsSync(GLsync sync)
     * }
     */
    public static byte glIsSync(MemorySegment sync) {
        var mh$ = glIsSync.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIsSync", sync);
            }
            return (byte)mh$.invokeExact(sync);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDeleteSync {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDeleteSync");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glDeleteSync(GLsync sync)
     * }
     */
    public static FunctionDescriptor glDeleteSync$descriptor() {
        return glDeleteSync.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glDeleteSync(GLsync sync)
     * }
     */
    public static MethodHandle glDeleteSync$handle() {
        return glDeleteSync.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glDeleteSync(GLsync sync)
     * }
     */
    public static MemorySegment glDeleteSync$address() {
        return glDeleteSync.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glDeleteSync(GLsync sync)
     * }
     */
    public static void glDeleteSync(MemorySegment sync) {
        var mh$ = glDeleteSync.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDeleteSync", sync);
            }
            mh$.invokeExact(sync);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glClientWaitSync {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glClientWaitSync");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLenum glClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)
     * }
     */
    public static FunctionDescriptor glClientWaitSync$descriptor() {
        return glClientWaitSync.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLenum glClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)
     * }
     */
    public static MethodHandle glClientWaitSync$handle() {
        return glClientWaitSync.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLenum glClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)
     * }
     */
    public static MemorySegment glClientWaitSync$address() {
        return glClientWaitSync.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLenum glClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)
     * }
     */
    public static int glClientWaitSync(MemorySegment sync, int flags, long timeout) {
        var mh$ = glClientWaitSync.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClientWaitSync", sync, flags, timeout);
            }
            return (int)mh$.invokeExact(sync, flags, timeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glWaitSync {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glWaitSync");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)
     * }
     */
    public static FunctionDescriptor glWaitSync$descriptor() {
        return glWaitSync.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)
     * }
     */
    public static MethodHandle glWaitSync$handle() {
        return glWaitSync.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)
     * }
     */
    public static MemorySegment glWaitSync$address() {
        return glWaitSync.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)
     * }
     */
    public static void glWaitSync(MemorySegment sync, int flags, long timeout) {
        var mh$ = glWaitSync.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glWaitSync", sync, flags, timeout);
            }
            mh$.invokeExact(sync, flags, timeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetInteger64v {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetInteger64v");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetInteger64v(GLenum pname, GLint64 *params)
     * }
     */
    public static FunctionDescriptor glGetInteger64v$descriptor() {
        return glGetInteger64v.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetInteger64v(GLenum pname, GLint64 *params)
     * }
     */
    public static MethodHandle glGetInteger64v$handle() {
        return glGetInteger64v.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetInteger64v(GLenum pname, GLint64 *params)
     * }
     */
    public static MemorySegment glGetInteger64v$address() {
        return glGetInteger64v.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetInteger64v(GLenum pname, GLint64 *params)
     * }
     */
    public static void glGetInteger64v(int pname, MemorySegment params) {
        var mh$ = glGetInteger64v.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetInteger64v", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetSynciv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetSynciv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values)
     * }
     */
    public static FunctionDescriptor glGetSynciv$descriptor() {
        return glGetSynciv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values)
     * }
     */
    public static MethodHandle glGetSynciv$handle() {
        return glGetSynciv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values)
     * }
     */
    public static MemorySegment glGetSynciv$address() {
        return glGetSynciv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values)
     * }
     */
    public static void glGetSynciv(MemorySegment sync, int pname, int bufSize, MemorySegment length, MemorySegment values) {
        var mh$ = glGetSynciv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetSynciv", sync, pname, bufSize, length, values);
            }
            mh$.invokeExact(sync, pname, bufSize, length, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCompressedTexImage3DARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glCompressedTexImage3DARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glCompressedTexImage3DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static FunctionDescriptor glCompressedTexImage3DARB$descriptor() {
        return glCompressedTexImage3DARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glCompressedTexImage3DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MethodHandle glCompressedTexImage3DARB$handle() {
        return glCompressedTexImage3DARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glCompressedTexImage3DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MemorySegment glCompressedTexImage3DARB$address() {
        return glCompressedTexImage3DARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glCompressedTexImage3DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static void glCompressedTexImage3DARB(int target, int level, int internalformat, int width, int height, int depth, int border, int imageSize, MemorySegment data) {
        var mh$ = glCompressedTexImage3DARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCompressedTexImage3DARB", target, level, internalformat, width, height, depth, border, imageSize, data);
            }
            mh$.invokeExact(target, level, internalformat, width, height, depth, border, imageSize, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCompressedTexImage2DARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glCompressedTexImage2DARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glCompressedTexImage2DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static FunctionDescriptor glCompressedTexImage2DARB$descriptor() {
        return glCompressedTexImage2DARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glCompressedTexImage2DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MethodHandle glCompressedTexImage2DARB$handle() {
        return glCompressedTexImage2DARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glCompressedTexImage2DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MemorySegment glCompressedTexImage2DARB$address() {
        return glCompressedTexImage2DARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glCompressedTexImage2DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static void glCompressedTexImage2DARB(int target, int level, int internalformat, int width, int height, int border, int imageSize, MemorySegment data) {
        var mh$ = glCompressedTexImage2DARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCompressedTexImage2DARB", target, level, internalformat, width, height, border, imageSize, data);
            }
            mh$.invokeExact(target, level, internalformat, width, height, border, imageSize, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCompressedTexImage1DARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glCompressedTexImage1DARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glCompressedTexImage1DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static FunctionDescriptor glCompressedTexImage1DARB$descriptor() {
        return glCompressedTexImage1DARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glCompressedTexImage1DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MethodHandle glCompressedTexImage1DARB$handle() {
        return glCompressedTexImage1DARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glCompressedTexImage1DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MemorySegment glCompressedTexImage1DARB$address() {
        return glCompressedTexImage1DARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glCompressedTexImage1DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static void glCompressedTexImage1DARB(int target, int level, int internalformat, int width, int border, int imageSize, MemorySegment data) {
        var mh$ = glCompressedTexImage1DARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCompressedTexImage1DARB", target, level, internalformat, width, border, imageSize, data);
            }
            mh$.invokeExact(target, level, internalformat, width, border, imageSize, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCompressedTexSubImage3DARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glCompressedTexSubImage3DARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glCompressedTexSubImage3DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static FunctionDescriptor glCompressedTexSubImage3DARB$descriptor() {
        return glCompressedTexSubImage3DARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glCompressedTexSubImage3DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MethodHandle glCompressedTexSubImage3DARB$handle() {
        return glCompressedTexSubImage3DARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glCompressedTexSubImage3DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MemorySegment glCompressedTexSubImage3DARB$address() {
        return glCompressedTexSubImage3DARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glCompressedTexSubImage3DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static void glCompressedTexSubImage3DARB(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, MemorySegment data) {
        var mh$ = glCompressedTexSubImage3DARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCompressedTexSubImage3DARB", target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
            }
            mh$.invokeExact(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCompressedTexSubImage2DARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glCompressedTexSubImage2DARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glCompressedTexSubImage2DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static FunctionDescriptor glCompressedTexSubImage2DARB$descriptor() {
        return glCompressedTexSubImage2DARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glCompressedTexSubImage2DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MethodHandle glCompressedTexSubImage2DARB$handle() {
        return glCompressedTexSubImage2DARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glCompressedTexSubImage2DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MemorySegment glCompressedTexSubImage2DARB$address() {
        return glCompressedTexSubImage2DARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glCompressedTexSubImage2DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static void glCompressedTexSubImage2DARB(int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, MemorySegment data) {
        var mh$ = glCompressedTexSubImage2DARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCompressedTexSubImage2DARB", target, level, xoffset, yoffset, width, height, format, imageSize, data);
            }
            mh$.invokeExact(target, level, xoffset, yoffset, width, height, format, imageSize, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCompressedTexSubImage1DARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glCompressedTexSubImage1DARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glCompressedTexSubImage1DARB(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static FunctionDescriptor glCompressedTexSubImage1DARB$descriptor() {
        return glCompressedTexSubImage1DARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glCompressedTexSubImage1DARB(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MethodHandle glCompressedTexSubImage1DARB$handle() {
        return glCompressedTexSubImage1DARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glCompressedTexSubImage1DARB(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MemorySegment glCompressedTexSubImage1DARB$address() {
        return glCompressedTexSubImage1DARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glCompressedTexSubImage1DARB(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static void glCompressedTexSubImage1DARB(int target, int level, int xoffset, int width, int format, int imageSize, MemorySegment data) {
        var mh$ = glCompressedTexSubImage1DARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCompressedTexSubImage1DARB", target, level, xoffset, width, format, imageSize, data);
            }
            mh$.invokeExact(target, level, xoffset, width, format, imageSize, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetCompressedTexImageARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetCompressedTexImageARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetCompressedTexImageARB(GLenum target, GLint level, GLvoid *data)
     * }
     */
    public static FunctionDescriptor glGetCompressedTexImageARB$descriptor() {
        return glGetCompressedTexImageARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetCompressedTexImageARB(GLenum target, GLint level, GLvoid *data)
     * }
     */
    public static MethodHandle glGetCompressedTexImageARB$handle() {
        return glGetCompressedTexImageARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetCompressedTexImageARB(GLenum target, GLint level, GLvoid *data)
     * }
     */
    public static MemorySegment glGetCompressedTexImageARB$address() {
        return glGetCompressedTexImageARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetCompressedTexImageARB(GLenum target, GLint level, GLvoid *data)
     * }
     */
    public static void glGetCompressedTexImageARB(int target, int level, MemorySegment data) {
        var mh$ = glGetCompressedTexImageARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetCompressedTexImageARB", target, level, data);
            }
            mh$.invokeExact(target, level, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLoadTransposeMatrixfARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glLoadTransposeMatrixfARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glLoadTransposeMatrixfARB(const GLfloat *m)
     * }
     */
    public static FunctionDescriptor glLoadTransposeMatrixfARB$descriptor() {
        return glLoadTransposeMatrixfARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glLoadTransposeMatrixfARB(const GLfloat *m)
     * }
     */
    public static MethodHandle glLoadTransposeMatrixfARB$handle() {
        return glLoadTransposeMatrixfARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glLoadTransposeMatrixfARB(const GLfloat *m)
     * }
     */
    public static MemorySegment glLoadTransposeMatrixfARB$address() {
        return glLoadTransposeMatrixfARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glLoadTransposeMatrixfARB(const GLfloat *m)
     * }
     */
    public static void glLoadTransposeMatrixfARB(MemorySegment m) {
        var mh$ = glLoadTransposeMatrixfARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLoadTransposeMatrixfARB", m);
            }
            mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLoadTransposeMatrixdARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glLoadTransposeMatrixdARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glLoadTransposeMatrixdARB(const GLdouble *m)
     * }
     */
    public static FunctionDescriptor glLoadTransposeMatrixdARB$descriptor() {
        return glLoadTransposeMatrixdARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glLoadTransposeMatrixdARB(const GLdouble *m)
     * }
     */
    public static MethodHandle glLoadTransposeMatrixdARB$handle() {
        return glLoadTransposeMatrixdARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glLoadTransposeMatrixdARB(const GLdouble *m)
     * }
     */
    public static MemorySegment glLoadTransposeMatrixdARB$address() {
        return glLoadTransposeMatrixdARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glLoadTransposeMatrixdARB(const GLdouble *m)
     * }
     */
    public static void glLoadTransposeMatrixdARB(MemorySegment m) {
        var mh$ = glLoadTransposeMatrixdARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLoadTransposeMatrixdARB", m);
            }
            mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultTransposeMatrixfARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultTransposeMatrixfARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultTransposeMatrixfARB(const GLfloat *m)
     * }
     */
    public static FunctionDescriptor glMultTransposeMatrixfARB$descriptor() {
        return glMultTransposeMatrixfARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultTransposeMatrixfARB(const GLfloat *m)
     * }
     */
    public static MethodHandle glMultTransposeMatrixfARB$handle() {
        return glMultTransposeMatrixfARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultTransposeMatrixfARB(const GLfloat *m)
     * }
     */
    public static MemorySegment glMultTransposeMatrixfARB$address() {
        return glMultTransposeMatrixfARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultTransposeMatrixfARB(const GLfloat *m)
     * }
     */
    public static void glMultTransposeMatrixfARB(MemorySegment m) {
        var mh$ = glMultTransposeMatrixfARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultTransposeMatrixfARB", m);
            }
            mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultTransposeMatrixdARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultTransposeMatrixdARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultTransposeMatrixdARB(const GLdouble *m)
     * }
     */
    public static FunctionDescriptor glMultTransposeMatrixdARB$descriptor() {
        return glMultTransposeMatrixdARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultTransposeMatrixdARB(const GLdouble *m)
     * }
     */
    public static MethodHandle glMultTransposeMatrixdARB$handle() {
        return glMultTransposeMatrixdARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultTransposeMatrixdARB(const GLdouble *m)
     * }
     */
    public static MemorySegment glMultTransposeMatrixdARB$address() {
        return glMultTransposeMatrixdARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultTransposeMatrixdARB(const GLdouble *m)
     * }
     */
    public static void glMultTransposeMatrixdARB(MemorySegment m) {
        var mh$ = glMultTransposeMatrixdARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultTransposeMatrixdARB", m);
            }
            mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glWeightbvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glWeightbvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glWeightbvARB(GLint size, const GLbyte *weights)
     * }
     */
    public static FunctionDescriptor glWeightbvARB$descriptor() {
        return glWeightbvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glWeightbvARB(GLint size, const GLbyte *weights)
     * }
     */
    public static MethodHandle glWeightbvARB$handle() {
        return glWeightbvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glWeightbvARB(GLint size, const GLbyte *weights)
     * }
     */
    public static MemorySegment glWeightbvARB$address() {
        return glWeightbvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glWeightbvARB(GLint size, const GLbyte *weights)
     * }
     */
    public static void glWeightbvARB(int size, MemorySegment weights) {
        var mh$ = glWeightbvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glWeightbvARB", size, weights);
            }
            mh$.invokeExact(size, weights);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glWeightsvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glWeightsvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glWeightsvARB(GLint size, const GLshort *weights)
     * }
     */
    public static FunctionDescriptor glWeightsvARB$descriptor() {
        return glWeightsvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glWeightsvARB(GLint size, const GLshort *weights)
     * }
     */
    public static MethodHandle glWeightsvARB$handle() {
        return glWeightsvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glWeightsvARB(GLint size, const GLshort *weights)
     * }
     */
    public static MemorySegment glWeightsvARB$address() {
        return glWeightsvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glWeightsvARB(GLint size, const GLshort *weights)
     * }
     */
    public static void glWeightsvARB(int size, MemorySegment weights) {
        var mh$ = glWeightsvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glWeightsvARB", size, weights);
            }
            mh$.invokeExact(size, weights);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glWeightivARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glWeightivARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glWeightivARB(GLint size, const GLint *weights)
     * }
     */
    public static FunctionDescriptor glWeightivARB$descriptor() {
        return glWeightivARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glWeightivARB(GLint size, const GLint *weights)
     * }
     */
    public static MethodHandle glWeightivARB$handle() {
        return glWeightivARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glWeightivARB(GLint size, const GLint *weights)
     * }
     */
    public static MemorySegment glWeightivARB$address() {
        return glWeightivARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glWeightivARB(GLint size, const GLint *weights)
     * }
     */
    public static void glWeightivARB(int size, MemorySegment weights) {
        var mh$ = glWeightivARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glWeightivARB", size, weights);
            }
            mh$.invokeExact(size, weights);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glWeightfvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glWeightfvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glWeightfvARB(GLint size, const GLfloat *weights)
     * }
     */
    public static FunctionDescriptor glWeightfvARB$descriptor() {
        return glWeightfvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glWeightfvARB(GLint size, const GLfloat *weights)
     * }
     */
    public static MethodHandle glWeightfvARB$handle() {
        return glWeightfvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glWeightfvARB(GLint size, const GLfloat *weights)
     * }
     */
    public static MemorySegment glWeightfvARB$address() {
        return glWeightfvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glWeightfvARB(GLint size, const GLfloat *weights)
     * }
     */
    public static void glWeightfvARB(int size, MemorySegment weights) {
        var mh$ = glWeightfvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glWeightfvARB", size, weights);
            }
            mh$.invokeExact(size, weights);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glWeightdvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glWeightdvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glWeightdvARB(GLint size, const GLdouble *weights)
     * }
     */
    public static FunctionDescriptor glWeightdvARB$descriptor() {
        return glWeightdvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glWeightdvARB(GLint size, const GLdouble *weights)
     * }
     */
    public static MethodHandle glWeightdvARB$handle() {
        return glWeightdvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glWeightdvARB(GLint size, const GLdouble *weights)
     * }
     */
    public static MemorySegment glWeightdvARB$address() {
        return glWeightdvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glWeightdvARB(GLint size, const GLdouble *weights)
     * }
     */
    public static void glWeightdvARB(int size, MemorySegment weights) {
        var mh$ = glWeightdvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glWeightdvARB", size, weights);
            }
            mh$.invokeExact(size, weights);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glWeightubvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glWeightubvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glWeightubvARB(GLint size, const GLubyte *weights)
     * }
     */
    public static FunctionDescriptor glWeightubvARB$descriptor() {
        return glWeightubvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glWeightubvARB(GLint size, const GLubyte *weights)
     * }
     */
    public static MethodHandle glWeightubvARB$handle() {
        return glWeightubvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glWeightubvARB(GLint size, const GLubyte *weights)
     * }
     */
    public static MemorySegment glWeightubvARB$address() {
        return glWeightubvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glWeightubvARB(GLint size, const GLubyte *weights)
     * }
     */
    public static void glWeightubvARB(int size, MemorySegment weights) {
        var mh$ = glWeightubvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glWeightubvARB", size, weights);
            }
            mh$.invokeExact(size, weights);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glWeightusvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glWeightusvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glWeightusvARB(GLint size, const GLushort *weights)
     * }
     */
    public static FunctionDescriptor glWeightusvARB$descriptor() {
        return glWeightusvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glWeightusvARB(GLint size, const GLushort *weights)
     * }
     */
    public static MethodHandle glWeightusvARB$handle() {
        return glWeightusvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glWeightusvARB(GLint size, const GLushort *weights)
     * }
     */
    public static MemorySegment glWeightusvARB$address() {
        return glWeightusvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glWeightusvARB(GLint size, const GLushort *weights)
     * }
     */
    public static void glWeightusvARB(int size, MemorySegment weights) {
        var mh$ = glWeightusvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glWeightusvARB", size, weights);
            }
            mh$.invokeExact(size, weights);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glWeightuivARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glWeightuivARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glWeightuivARB(GLint size, const GLuint *weights)
     * }
     */
    public static FunctionDescriptor glWeightuivARB$descriptor() {
        return glWeightuivARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glWeightuivARB(GLint size, const GLuint *weights)
     * }
     */
    public static MethodHandle glWeightuivARB$handle() {
        return glWeightuivARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glWeightuivARB(GLint size, const GLuint *weights)
     * }
     */
    public static MemorySegment glWeightuivARB$address() {
        return glWeightuivARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glWeightuivARB(GLint size, const GLuint *weights)
     * }
     */
    public static void glWeightuivARB(int size, MemorySegment weights) {
        var mh$ = glWeightuivARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glWeightuivARB", size, weights);
            }
            mh$.invokeExact(size, weights);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glWeightPointerARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glWeightPointerARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glWeightPointerARB(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static FunctionDescriptor glWeightPointerARB$descriptor() {
        return glWeightPointerARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glWeightPointerARB(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MethodHandle glWeightPointerARB$handle() {
        return glWeightPointerARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glWeightPointerARB(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MemorySegment glWeightPointerARB$address() {
        return glWeightPointerARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glWeightPointerARB(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static void glWeightPointerARB(int size, int type, int stride, MemorySegment pointer) {
        var mh$ = glWeightPointerARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glWeightPointerARB", size, type, stride, pointer);
            }
            mh$.invokeExact(size, type, stride, pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexBlendARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexBlendARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexBlendARB(GLint count)
     * }
     */
    public static FunctionDescriptor glVertexBlendARB$descriptor() {
        return glVertexBlendARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexBlendARB(GLint count)
     * }
     */
    public static MethodHandle glVertexBlendARB$handle() {
        return glVertexBlendARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexBlendARB(GLint count)
     * }
     */
    public static MemorySegment glVertexBlendARB$address() {
        return glVertexBlendARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexBlendARB(GLint count)
     * }
     */
    public static void glVertexBlendARB(int count) {
        var mh$ = glVertexBlendARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexBlendARB", count);
            }
            mh$.invokeExact(count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBindBufferARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glBindBufferARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glBindBufferARB(GLenum target, GLuint buffer)
     * }
     */
    public static FunctionDescriptor glBindBufferARB$descriptor() {
        return glBindBufferARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glBindBufferARB(GLenum target, GLuint buffer)
     * }
     */
    public static MethodHandle glBindBufferARB$handle() {
        return glBindBufferARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glBindBufferARB(GLenum target, GLuint buffer)
     * }
     */
    public static MemorySegment glBindBufferARB$address() {
        return glBindBufferARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glBindBufferARB(GLenum target, GLuint buffer)
     * }
     */
    public static void glBindBufferARB(int target, int buffer) {
        var mh$ = glBindBufferARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBindBufferARB", target, buffer);
            }
            mh$.invokeExact(target, buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDeleteBuffersARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDeleteBuffersARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glDeleteBuffersARB(GLsizei n, const GLuint *buffers)
     * }
     */
    public static FunctionDescriptor glDeleteBuffersARB$descriptor() {
        return glDeleteBuffersARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glDeleteBuffersARB(GLsizei n, const GLuint *buffers)
     * }
     */
    public static MethodHandle glDeleteBuffersARB$handle() {
        return glDeleteBuffersARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glDeleteBuffersARB(GLsizei n, const GLuint *buffers)
     * }
     */
    public static MemorySegment glDeleteBuffersARB$address() {
        return glDeleteBuffersARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glDeleteBuffersARB(GLsizei n, const GLuint *buffers)
     * }
     */
    public static void glDeleteBuffersARB(int n, MemorySegment buffers) {
        var mh$ = glDeleteBuffersARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDeleteBuffersARB", n, buffers);
            }
            mh$.invokeExact(n, buffers);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGenBuffersARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGenBuffersARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGenBuffersARB(GLsizei n, GLuint *buffers)
     * }
     */
    public static FunctionDescriptor glGenBuffersARB$descriptor() {
        return glGenBuffersARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGenBuffersARB(GLsizei n, GLuint *buffers)
     * }
     */
    public static MethodHandle glGenBuffersARB$handle() {
        return glGenBuffersARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGenBuffersARB(GLsizei n, GLuint *buffers)
     * }
     */
    public static MemorySegment glGenBuffersARB$address() {
        return glGenBuffersARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGenBuffersARB(GLsizei n, GLuint *buffers)
     * }
     */
    public static void glGenBuffersARB(int n, MemorySegment buffers) {
        var mh$ = glGenBuffersARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGenBuffersARB", n, buffers);
            }
            mh$.invokeExact(n, buffers);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIsBufferARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glIsBufferARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLboolean glIsBufferARB(GLuint buffer)
     * }
     */
    public static FunctionDescriptor glIsBufferARB$descriptor() {
        return glIsBufferARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLboolean glIsBufferARB(GLuint buffer)
     * }
     */
    public static MethodHandle glIsBufferARB$handle() {
        return glIsBufferARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLboolean glIsBufferARB(GLuint buffer)
     * }
     */
    public static MemorySegment glIsBufferARB$address() {
        return glIsBufferARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLboolean glIsBufferARB(GLuint buffer)
     * }
     */
    public static byte glIsBufferARB(int buffer) {
        var mh$ = glIsBufferARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIsBufferARB", buffer);
            }
            return (byte)mh$.invokeExact(buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBufferDataARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glBufferDataARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glBufferDataARB(GLenum target, GLsizeiptrARB size, const GLvoid *data, GLenum usage)
     * }
     */
    public static FunctionDescriptor glBufferDataARB$descriptor() {
        return glBufferDataARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glBufferDataARB(GLenum target, GLsizeiptrARB size, const GLvoid *data, GLenum usage)
     * }
     */
    public static MethodHandle glBufferDataARB$handle() {
        return glBufferDataARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glBufferDataARB(GLenum target, GLsizeiptrARB size, const GLvoid *data, GLenum usage)
     * }
     */
    public static MemorySegment glBufferDataARB$address() {
        return glBufferDataARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glBufferDataARB(GLenum target, GLsizeiptrARB size, const GLvoid *data, GLenum usage)
     * }
     */
    public static void glBufferDataARB(int target, long size, MemorySegment data, int usage) {
        var mh$ = glBufferDataARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBufferDataARB", target, size, data, usage);
            }
            mh$.invokeExact(target, size, data, usage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBufferSubDataARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glBufferSubDataARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid *data)
     * }
     */
    public static FunctionDescriptor glBufferSubDataARB$descriptor() {
        return glBufferSubDataARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid *data)
     * }
     */
    public static MethodHandle glBufferSubDataARB$handle() {
        return glBufferSubDataARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid *data)
     * }
     */
    public static MemorySegment glBufferSubDataARB$address() {
        return glBufferSubDataARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid *data)
     * }
     */
    public static void glBufferSubDataARB(int target, long offset, long size, MemorySegment data) {
        var mh$ = glBufferSubDataARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBufferSubDataARB", target, offset, size, data);
            }
            mh$.invokeExact(target, offset, size, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetBufferSubDataARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetBufferSubDataARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid *data)
     * }
     */
    public static FunctionDescriptor glGetBufferSubDataARB$descriptor() {
        return glGetBufferSubDataARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid *data)
     * }
     */
    public static MethodHandle glGetBufferSubDataARB$handle() {
        return glGetBufferSubDataARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid *data)
     * }
     */
    public static MemorySegment glGetBufferSubDataARB$address() {
        return glGetBufferSubDataARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid *data)
     * }
     */
    public static void glGetBufferSubDataARB(int target, long offset, long size, MemorySegment data) {
        var mh$ = glGetBufferSubDataARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetBufferSubDataARB", target, offset, size, data);
            }
            mh$.invokeExact(target, offset, size, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMapBufferARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMapBufferARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLvoid *glMapBufferARB(GLenum target, GLenum access)
     * }
     */
    public static FunctionDescriptor glMapBufferARB$descriptor() {
        return glMapBufferARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLvoid *glMapBufferARB(GLenum target, GLenum access)
     * }
     */
    public static MethodHandle glMapBufferARB$handle() {
        return glMapBufferARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLvoid *glMapBufferARB(GLenum target, GLenum access)
     * }
     */
    public static MemorySegment glMapBufferARB$address() {
        return glMapBufferARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLvoid *glMapBufferARB(GLenum target, GLenum access)
     * }
     */
    public static MemorySegment glMapBufferARB(int target, int access) {
        var mh$ = glMapBufferARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMapBufferARB", target, access);
            }
            return (MemorySegment)mh$.invokeExact(target, access);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUnmapBufferARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUnmapBufferARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLboolean glUnmapBufferARB(GLenum target)
     * }
     */
    public static FunctionDescriptor glUnmapBufferARB$descriptor() {
        return glUnmapBufferARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLboolean glUnmapBufferARB(GLenum target)
     * }
     */
    public static MethodHandle glUnmapBufferARB$handle() {
        return glUnmapBufferARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLboolean glUnmapBufferARB(GLenum target)
     * }
     */
    public static MemorySegment glUnmapBufferARB$address() {
        return glUnmapBufferARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLboolean glUnmapBufferARB(GLenum target)
     * }
     */
    public static byte glUnmapBufferARB(int target) {
        var mh$ = glUnmapBufferARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUnmapBufferARB", target);
            }
            return (byte)mh$.invokeExact(target);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetBufferParameterivARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetBufferParameterivARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetBufferParameterivARB(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetBufferParameterivARB$descriptor() {
        return glGetBufferParameterivARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetBufferParameterivARB(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetBufferParameterivARB$handle() {
        return glGetBufferParameterivARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetBufferParameterivARB(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetBufferParameterivARB$address() {
        return glGetBufferParameterivARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetBufferParameterivARB(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static void glGetBufferParameterivARB(int target, int pname, MemorySegment params) {
        var mh$ = glGetBufferParameterivARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetBufferParameterivARB", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetBufferPointervARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetBufferPointervARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetBufferPointervARB(GLenum target, GLenum pname, GLvoid **params)
     * }
     */
    public static FunctionDescriptor glGetBufferPointervARB$descriptor() {
        return glGetBufferPointervARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetBufferPointervARB(GLenum target, GLenum pname, GLvoid **params)
     * }
     */
    public static MethodHandle glGetBufferPointervARB$handle() {
        return glGetBufferPointervARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetBufferPointervARB(GLenum target, GLenum pname, GLvoid **params)
     * }
     */
    public static MemorySegment glGetBufferPointervARB$address() {
        return glGetBufferPointervARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetBufferPointervARB(GLenum target, GLenum pname, GLvoid **params)
     * }
     */
    public static void glGetBufferPointervARB(int target, int pname, MemorySegment params) {
        var mh$ = glGetBufferPointervARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetBufferPointervARB", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBindProgramARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glBindProgramARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glBindProgramARB(GLenum target, GLuint program)
     * }
     */
    public static FunctionDescriptor glBindProgramARB$descriptor() {
        return glBindProgramARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glBindProgramARB(GLenum target, GLuint program)
     * }
     */
    public static MethodHandle glBindProgramARB$handle() {
        return glBindProgramARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glBindProgramARB(GLenum target, GLuint program)
     * }
     */
    public static MemorySegment glBindProgramARB$address() {
        return glBindProgramARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glBindProgramARB(GLenum target, GLuint program)
     * }
     */
    public static void glBindProgramARB(int target, int program) {
        var mh$ = glBindProgramARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBindProgramARB", target, program);
            }
            mh$.invokeExact(target, program);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDeleteProgramsARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDeleteProgramsARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glDeleteProgramsARB(GLsizei n, const GLuint *programs)
     * }
     */
    public static FunctionDescriptor glDeleteProgramsARB$descriptor() {
        return glDeleteProgramsARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glDeleteProgramsARB(GLsizei n, const GLuint *programs)
     * }
     */
    public static MethodHandle glDeleteProgramsARB$handle() {
        return glDeleteProgramsARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glDeleteProgramsARB(GLsizei n, const GLuint *programs)
     * }
     */
    public static MemorySegment glDeleteProgramsARB$address() {
        return glDeleteProgramsARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glDeleteProgramsARB(GLsizei n, const GLuint *programs)
     * }
     */
    public static void glDeleteProgramsARB(int n, MemorySegment programs) {
        var mh$ = glDeleteProgramsARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDeleteProgramsARB", n, programs);
            }
            mh$.invokeExact(n, programs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGenProgramsARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGenProgramsARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGenProgramsARB(GLsizei n, GLuint *programs)
     * }
     */
    public static FunctionDescriptor glGenProgramsARB$descriptor() {
        return glGenProgramsARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGenProgramsARB(GLsizei n, GLuint *programs)
     * }
     */
    public static MethodHandle glGenProgramsARB$handle() {
        return glGenProgramsARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGenProgramsARB(GLsizei n, GLuint *programs)
     * }
     */
    public static MemorySegment glGenProgramsARB$address() {
        return glGenProgramsARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGenProgramsARB(GLsizei n, GLuint *programs)
     * }
     */
    public static void glGenProgramsARB(int n, MemorySegment programs) {
        var mh$ = glGenProgramsARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGenProgramsARB", n, programs);
            }
            mh$.invokeExact(n, programs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIsProgramARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glIsProgramARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLboolean glIsProgramARB(GLuint program)
     * }
     */
    public static FunctionDescriptor glIsProgramARB$descriptor() {
        return glIsProgramARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLboolean glIsProgramARB(GLuint program)
     * }
     */
    public static MethodHandle glIsProgramARB$handle() {
        return glIsProgramARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLboolean glIsProgramARB(GLuint program)
     * }
     */
    public static MemorySegment glIsProgramARB$address() {
        return glIsProgramARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLboolean glIsProgramARB(GLuint program)
     * }
     */
    public static byte glIsProgramARB(int program) {
        var mh$ = glIsProgramARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIsProgramARB", program);
            }
            return (byte)mh$.invokeExact(program);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glProgramEnvParameter4dARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glProgramEnvParameter4dARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glProgramEnvParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static FunctionDescriptor glProgramEnvParameter4dARB$descriptor() {
        return glProgramEnvParameter4dARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glProgramEnvParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static MethodHandle glProgramEnvParameter4dARB$handle() {
        return glProgramEnvParameter4dARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glProgramEnvParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static MemorySegment glProgramEnvParameter4dARB$address() {
        return glProgramEnvParameter4dARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glProgramEnvParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static void glProgramEnvParameter4dARB(int target, int index, double x, double y, double z, double w) {
        var mh$ = glProgramEnvParameter4dARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glProgramEnvParameter4dARB", target, index, x, y, z, w);
            }
            mh$.invokeExact(target, index, x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glProgramEnvParameter4dvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glProgramEnvParameter4dvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glProgramEnvParameter4dvARB(GLenum target, GLuint index, const GLdouble *params)
     * }
     */
    public static FunctionDescriptor glProgramEnvParameter4dvARB$descriptor() {
        return glProgramEnvParameter4dvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glProgramEnvParameter4dvARB(GLenum target, GLuint index, const GLdouble *params)
     * }
     */
    public static MethodHandle glProgramEnvParameter4dvARB$handle() {
        return glProgramEnvParameter4dvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glProgramEnvParameter4dvARB(GLenum target, GLuint index, const GLdouble *params)
     * }
     */
    public static MemorySegment glProgramEnvParameter4dvARB$address() {
        return glProgramEnvParameter4dvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glProgramEnvParameter4dvARB(GLenum target, GLuint index, const GLdouble *params)
     * }
     */
    public static void glProgramEnvParameter4dvARB(int target, int index, MemorySegment params) {
        var mh$ = glProgramEnvParameter4dvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glProgramEnvParameter4dvARB", target, index, params);
            }
            mh$.invokeExact(target, index, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glProgramEnvParameter4fARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glProgramEnvParameter4fARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glProgramEnvParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static FunctionDescriptor glProgramEnvParameter4fARB$descriptor() {
        return glProgramEnvParameter4fARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glProgramEnvParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static MethodHandle glProgramEnvParameter4fARB$handle() {
        return glProgramEnvParameter4fARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glProgramEnvParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static MemorySegment glProgramEnvParameter4fARB$address() {
        return glProgramEnvParameter4fARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glProgramEnvParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static void glProgramEnvParameter4fARB(int target, int index, float x, float y, float z, float w) {
        var mh$ = glProgramEnvParameter4fARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glProgramEnvParameter4fARB", target, index, x, y, z, w);
            }
            mh$.invokeExact(target, index, x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glProgramEnvParameter4fvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glProgramEnvParameter4fvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glProgramEnvParameter4fvARB(GLenum target, GLuint index, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glProgramEnvParameter4fvARB$descriptor() {
        return glProgramEnvParameter4fvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glProgramEnvParameter4fvARB(GLenum target, GLuint index, const GLfloat *params)
     * }
     */
    public static MethodHandle glProgramEnvParameter4fvARB$handle() {
        return glProgramEnvParameter4fvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glProgramEnvParameter4fvARB(GLenum target, GLuint index, const GLfloat *params)
     * }
     */
    public static MemorySegment glProgramEnvParameter4fvARB$address() {
        return glProgramEnvParameter4fvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glProgramEnvParameter4fvARB(GLenum target, GLuint index, const GLfloat *params)
     * }
     */
    public static void glProgramEnvParameter4fvARB(int target, int index, MemorySegment params) {
        var mh$ = glProgramEnvParameter4fvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glProgramEnvParameter4fvARB", target, index, params);
            }
            mh$.invokeExact(target, index, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glProgramLocalParameter4dARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glProgramLocalParameter4dARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glProgramLocalParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static FunctionDescriptor glProgramLocalParameter4dARB$descriptor() {
        return glProgramLocalParameter4dARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glProgramLocalParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static MethodHandle glProgramLocalParameter4dARB$handle() {
        return glProgramLocalParameter4dARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glProgramLocalParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static MemorySegment glProgramLocalParameter4dARB$address() {
        return glProgramLocalParameter4dARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glProgramLocalParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static void glProgramLocalParameter4dARB(int target, int index, double x, double y, double z, double w) {
        var mh$ = glProgramLocalParameter4dARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glProgramLocalParameter4dARB", target, index, x, y, z, w);
            }
            mh$.invokeExact(target, index, x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glProgramLocalParameter4dvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glProgramLocalParameter4dvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glProgramLocalParameter4dvARB(GLenum target, GLuint index, const GLdouble *params)
     * }
     */
    public static FunctionDescriptor glProgramLocalParameter4dvARB$descriptor() {
        return glProgramLocalParameter4dvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glProgramLocalParameter4dvARB(GLenum target, GLuint index, const GLdouble *params)
     * }
     */
    public static MethodHandle glProgramLocalParameter4dvARB$handle() {
        return glProgramLocalParameter4dvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glProgramLocalParameter4dvARB(GLenum target, GLuint index, const GLdouble *params)
     * }
     */
    public static MemorySegment glProgramLocalParameter4dvARB$address() {
        return glProgramLocalParameter4dvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glProgramLocalParameter4dvARB(GLenum target, GLuint index, const GLdouble *params)
     * }
     */
    public static void glProgramLocalParameter4dvARB(int target, int index, MemorySegment params) {
        var mh$ = glProgramLocalParameter4dvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glProgramLocalParameter4dvARB", target, index, params);
            }
            mh$.invokeExact(target, index, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glProgramLocalParameter4fARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glProgramLocalParameter4fARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glProgramLocalParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static FunctionDescriptor glProgramLocalParameter4fARB$descriptor() {
        return glProgramLocalParameter4fARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glProgramLocalParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static MethodHandle glProgramLocalParameter4fARB$handle() {
        return glProgramLocalParameter4fARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glProgramLocalParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static MemorySegment glProgramLocalParameter4fARB$address() {
        return glProgramLocalParameter4fARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glProgramLocalParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static void glProgramLocalParameter4fARB(int target, int index, float x, float y, float z, float w) {
        var mh$ = glProgramLocalParameter4fARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glProgramLocalParameter4fARB", target, index, x, y, z, w);
            }
            mh$.invokeExact(target, index, x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glProgramLocalParameter4fvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glProgramLocalParameter4fvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glProgramLocalParameter4fvARB(GLenum target, GLuint index, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glProgramLocalParameter4fvARB$descriptor() {
        return glProgramLocalParameter4fvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glProgramLocalParameter4fvARB(GLenum target, GLuint index, const GLfloat *params)
     * }
     */
    public static MethodHandle glProgramLocalParameter4fvARB$handle() {
        return glProgramLocalParameter4fvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glProgramLocalParameter4fvARB(GLenum target, GLuint index, const GLfloat *params)
     * }
     */
    public static MemorySegment glProgramLocalParameter4fvARB$address() {
        return glProgramLocalParameter4fvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glProgramLocalParameter4fvARB(GLenum target, GLuint index, const GLfloat *params)
     * }
     */
    public static void glProgramLocalParameter4fvARB(int target, int index, MemorySegment params) {
        var mh$ = glProgramLocalParameter4fvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glProgramLocalParameter4fvARB", target, index, params);
            }
            mh$.invokeExact(target, index, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetProgramEnvParameterdvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetProgramEnvParameterdvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetProgramEnvParameterdvARB(GLenum target, GLuint index, GLdouble *params)
     * }
     */
    public static FunctionDescriptor glGetProgramEnvParameterdvARB$descriptor() {
        return glGetProgramEnvParameterdvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetProgramEnvParameterdvARB(GLenum target, GLuint index, GLdouble *params)
     * }
     */
    public static MethodHandle glGetProgramEnvParameterdvARB$handle() {
        return glGetProgramEnvParameterdvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetProgramEnvParameterdvARB(GLenum target, GLuint index, GLdouble *params)
     * }
     */
    public static MemorySegment glGetProgramEnvParameterdvARB$address() {
        return glGetProgramEnvParameterdvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetProgramEnvParameterdvARB(GLenum target, GLuint index, GLdouble *params)
     * }
     */
    public static void glGetProgramEnvParameterdvARB(int target, int index, MemorySegment params) {
        var mh$ = glGetProgramEnvParameterdvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetProgramEnvParameterdvARB", target, index, params);
            }
            mh$.invokeExact(target, index, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetProgramEnvParameterfvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetProgramEnvParameterfvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetProgramEnvParameterfvARB(GLenum target, GLuint index, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetProgramEnvParameterfvARB$descriptor() {
        return glGetProgramEnvParameterfvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetProgramEnvParameterfvARB(GLenum target, GLuint index, GLfloat *params)
     * }
     */
    public static MethodHandle glGetProgramEnvParameterfvARB$handle() {
        return glGetProgramEnvParameterfvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetProgramEnvParameterfvARB(GLenum target, GLuint index, GLfloat *params)
     * }
     */
    public static MemorySegment glGetProgramEnvParameterfvARB$address() {
        return glGetProgramEnvParameterfvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetProgramEnvParameterfvARB(GLenum target, GLuint index, GLfloat *params)
     * }
     */
    public static void glGetProgramEnvParameterfvARB(int target, int index, MemorySegment params) {
        var mh$ = glGetProgramEnvParameterfvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetProgramEnvParameterfvARB", target, index, params);
            }
            mh$.invokeExact(target, index, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glProgramEnvParameters4fvEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glProgramEnvParameters4fvEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glProgramEnvParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glProgramEnvParameters4fvEXT$descriptor() {
        return glProgramEnvParameters4fvEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glProgramEnvParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat *params)
     * }
     */
    public static MethodHandle glProgramEnvParameters4fvEXT$handle() {
        return glProgramEnvParameters4fvEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glProgramEnvParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat *params)
     * }
     */
    public static MemorySegment glProgramEnvParameters4fvEXT$address() {
        return glProgramEnvParameters4fvEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glProgramEnvParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat *params)
     * }
     */
    public static void glProgramEnvParameters4fvEXT(int target, int index, int count, MemorySegment params) {
        var mh$ = glProgramEnvParameters4fvEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glProgramEnvParameters4fvEXT", target, index, count, params);
            }
            mh$.invokeExact(target, index, count, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glProgramLocalParameters4fvEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glProgramLocalParameters4fvEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glProgramLocalParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glProgramLocalParameters4fvEXT$descriptor() {
        return glProgramLocalParameters4fvEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glProgramLocalParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat *params)
     * }
     */
    public static MethodHandle glProgramLocalParameters4fvEXT$handle() {
        return glProgramLocalParameters4fvEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glProgramLocalParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat *params)
     * }
     */
    public static MemorySegment glProgramLocalParameters4fvEXT$address() {
        return glProgramLocalParameters4fvEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glProgramLocalParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat *params)
     * }
     */
    public static void glProgramLocalParameters4fvEXT(int target, int index, int count, MemorySegment params) {
        var mh$ = glProgramLocalParameters4fvEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glProgramLocalParameters4fvEXT", target, index, count, params);
            }
            mh$.invokeExact(target, index, count, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetProgramLocalParameterdvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetProgramLocalParameterdvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetProgramLocalParameterdvARB(GLenum target, GLuint index, GLdouble *params)
     * }
     */
    public static FunctionDescriptor glGetProgramLocalParameterdvARB$descriptor() {
        return glGetProgramLocalParameterdvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetProgramLocalParameterdvARB(GLenum target, GLuint index, GLdouble *params)
     * }
     */
    public static MethodHandle glGetProgramLocalParameterdvARB$handle() {
        return glGetProgramLocalParameterdvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetProgramLocalParameterdvARB(GLenum target, GLuint index, GLdouble *params)
     * }
     */
    public static MemorySegment glGetProgramLocalParameterdvARB$address() {
        return glGetProgramLocalParameterdvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetProgramLocalParameterdvARB(GLenum target, GLuint index, GLdouble *params)
     * }
     */
    public static void glGetProgramLocalParameterdvARB(int target, int index, MemorySegment params) {
        var mh$ = glGetProgramLocalParameterdvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetProgramLocalParameterdvARB", target, index, params);
            }
            mh$.invokeExact(target, index, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetProgramLocalParameterfvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetProgramLocalParameterfvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetProgramLocalParameterfvARB(GLenum target, GLuint index, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetProgramLocalParameterfvARB$descriptor() {
        return glGetProgramLocalParameterfvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetProgramLocalParameterfvARB(GLenum target, GLuint index, GLfloat *params)
     * }
     */
    public static MethodHandle glGetProgramLocalParameterfvARB$handle() {
        return glGetProgramLocalParameterfvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetProgramLocalParameterfvARB(GLenum target, GLuint index, GLfloat *params)
     * }
     */
    public static MemorySegment glGetProgramLocalParameterfvARB$address() {
        return glGetProgramLocalParameterfvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetProgramLocalParameterfvARB(GLenum target, GLuint index, GLfloat *params)
     * }
     */
    public static void glGetProgramLocalParameterfvARB(int target, int index, MemorySegment params) {
        var mh$ = glGetProgramLocalParameterfvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetProgramLocalParameterfvARB", target, index, params);
            }
            mh$.invokeExact(target, index, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glProgramStringARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glProgramStringARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glProgramStringARB(GLenum target, GLenum format, GLsizei len, const GLvoid *string)
     * }
     */
    public static FunctionDescriptor glProgramStringARB$descriptor() {
        return glProgramStringARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glProgramStringARB(GLenum target, GLenum format, GLsizei len, const GLvoid *string)
     * }
     */
    public static MethodHandle glProgramStringARB$handle() {
        return glProgramStringARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glProgramStringARB(GLenum target, GLenum format, GLsizei len, const GLvoid *string)
     * }
     */
    public static MemorySegment glProgramStringARB$address() {
        return glProgramStringARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glProgramStringARB(GLenum target, GLenum format, GLsizei len, const GLvoid *string)
     * }
     */
    public static void glProgramStringARB(int target, int format, int len, MemorySegment string) {
        var mh$ = glProgramStringARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glProgramStringARB", target, format, len, string);
            }
            mh$.invokeExact(target, format, len, string);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetProgramStringARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetProgramStringARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetProgramStringARB(GLenum target, GLenum pname, GLvoid *string)
     * }
     */
    public static FunctionDescriptor glGetProgramStringARB$descriptor() {
        return glGetProgramStringARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetProgramStringARB(GLenum target, GLenum pname, GLvoid *string)
     * }
     */
    public static MethodHandle glGetProgramStringARB$handle() {
        return glGetProgramStringARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetProgramStringARB(GLenum target, GLenum pname, GLvoid *string)
     * }
     */
    public static MemorySegment glGetProgramStringARB$address() {
        return glGetProgramStringARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetProgramStringARB(GLenum target, GLenum pname, GLvoid *string)
     * }
     */
    public static void glGetProgramStringARB(int target, int pname, MemorySegment string) {
        var mh$ = glGetProgramStringARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetProgramStringARB", target, pname, string);
            }
            mh$.invokeExact(target, pname, string);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetProgramivARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetProgramivARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetProgramivARB(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetProgramivARB$descriptor() {
        return glGetProgramivARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetProgramivARB(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetProgramivARB$handle() {
        return glGetProgramivARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetProgramivARB(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetProgramivARB$address() {
        return glGetProgramivARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetProgramivARB(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static void glGetProgramivARB(int target, int pname, MemorySegment params) {
        var mh$ = glGetProgramivARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetProgramivARB", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBindAttribLocationARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glBindAttribLocationARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glBindAttribLocationARB(GLhandleARB programObj, GLuint index, const GLcharARB *name)
     * }
     */
    public static FunctionDescriptor glBindAttribLocationARB$descriptor() {
        return glBindAttribLocationARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glBindAttribLocationARB(GLhandleARB programObj, GLuint index, const GLcharARB *name)
     * }
     */
    public static MethodHandle glBindAttribLocationARB$handle() {
        return glBindAttribLocationARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glBindAttribLocationARB(GLhandleARB programObj, GLuint index, const GLcharARB *name)
     * }
     */
    public static MemorySegment glBindAttribLocationARB$address() {
        return glBindAttribLocationARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glBindAttribLocationARB(GLhandleARB programObj, GLuint index, const GLcharARB *name)
     * }
     */
    public static void glBindAttribLocationARB(MemorySegment programObj, int index, MemorySegment name) {
        var mh$ = glBindAttribLocationARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBindAttribLocationARB", programObj, index, name);
            }
            mh$.invokeExact(programObj, index, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetActiveAttribARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetActiveAttribARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetActiveAttribARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name)
     * }
     */
    public static FunctionDescriptor glGetActiveAttribARB$descriptor() {
        return glGetActiveAttribARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetActiveAttribARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name)
     * }
     */
    public static MethodHandle glGetActiveAttribARB$handle() {
        return glGetActiveAttribARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetActiveAttribARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name)
     * }
     */
    public static MemorySegment glGetActiveAttribARB$address() {
        return glGetActiveAttribARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetActiveAttribARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name)
     * }
     */
    public static void glGetActiveAttribARB(MemorySegment programObj, int index, int maxLength, MemorySegment length, MemorySegment size, MemorySegment type, MemorySegment name) {
        var mh$ = glGetActiveAttribARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetActiveAttribARB", programObj, index, maxLength, length, size, type, name);
            }
            mh$.invokeExact(programObj, index, maxLength, length, size, type, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetAttribLocationARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetAttribLocationARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLint glGetAttribLocationARB(GLhandleARB programObj, const GLcharARB *name)
     * }
     */
    public static FunctionDescriptor glGetAttribLocationARB$descriptor() {
        return glGetAttribLocationARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLint glGetAttribLocationARB(GLhandleARB programObj, const GLcharARB *name)
     * }
     */
    public static MethodHandle glGetAttribLocationARB$handle() {
        return glGetAttribLocationARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLint glGetAttribLocationARB(GLhandleARB programObj, const GLcharARB *name)
     * }
     */
    public static MemorySegment glGetAttribLocationARB$address() {
        return glGetAttribLocationARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLint glGetAttribLocationARB(GLhandleARB programObj, const GLcharARB *name)
     * }
     */
    public static int glGetAttribLocationARB(MemorySegment programObj, MemorySegment name) {
        var mh$ = glGetAttribLocationARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetAttribLocationARB", programObj, name);
            }
            return (int)mh$.invokeExact(programObj, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib1dARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib1dARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib1dARB(GLuint index, GLdouble x)
     * }
     */
    public static FunctionDescriptor glVertexAttrib1dARB$descriptor() {
        return glVertexAttrib1dARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib1dARB(GLuint index, GLdouble x)
     * }
     */
    public static MethodHandle glVertexAttrib1dARB$handle() {
        return glVertexAttrib1dARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib1dARB(GLuint index, GLdouble x)
     * }
     */
    public static MemorySegment glVertexAttrib1dARB$address() {
        return glVertexAttrib1dARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib1dARB(GLuint index, GLdouble x)
     * }
     */
    public static void glVertexAttrib1dARB(int index, double x) {
        var mh$ = glVertexAttrib1dARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib1dARB", index, x);
            }
            mh$.invokeExact(index, x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib1dvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib1dvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib1dvARB(GLuint index, const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glVertexAttrib1dvARB$descriptor() {
        return glVertexAttrib1dvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib1dvARB(GLuint index, const GLdouble *v)
     * }
     */
    public static MethodHandle glVertexAttrib1dvARB$handle() {
        return glVertexAttrib1dvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib1dvARB(GLuint index, const GLdouble *v)
     * }
     */
    public static MemorySegment glVertexAttrib1dvARB$address() {
        return glVertexAttrib1dvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib1dvARB(GLuint index, const GLdouble *v)
     * }
     */
    public static void glVertexAttrib1dvARB(int index, MemorySegment v) {
        var mh$ = glVertexAttrib1dvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib1dvARB", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib1fARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib1fARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib1fARB(GLuint index, GLfloat x)
     * }
     */
    public static FunctionDescriptor glVertexAttrib1fARB$descriptor() {
        return glVertexAttrib1fARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib1fARB(GLuint index, GLfloat x)
     * }
     */
    public static MethodHandle glVertexAttrib1fARB$handle() {
        return glVertexAttrib1fARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib1fARB(GLuint index, GLfloat x)
     * }
     */
    public static MemorySegment glVertexAttrib1fARB$address() {
        return glVertexAttrib1fARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib1fARB(GLuint index, GLfloat x)
     * }
     */
    public static void glVertexAttrib1fARB(int index, float x) {
        var mh$ = glVertexAttrib1fARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib1fARB", index, x);
            }
            mh$.invokeExact(index, x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib1fvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib1fvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib1fvARB(GLuint index, const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glVertexAttrib1fvARB$descriptor() {
        return glVertexAttrib1fvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib1fvARB(GLuint index, const GLfloat *v)
     * }
     */
    public static MethodHandle glVertexAttrib1fvARB$handle() {
        return glVertexAttrib1fvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib1fvARB(GLuint index, const GLfloat *v)
     * }
     */
    public static MemorySegment glVertexAttrib1fvARB$address() {
        return glVertexAttrib1fvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib1fvARB(GLuint index, const GLfloat *v)
     * }
     */
    public static void glVertexAttrib1fvARB(int index, MemorySegment v) {
        var mh$ = glVertexAttrib1fvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib1fvARB", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib1sARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib1sARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib1sARB(GLuint index, GLshort x)
     * }
     */
    public static FunctionDescriptor glVertexAttrib1sARB$descriptor() {
        return glVertexAttrib1sARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib1sARB(GLuint index, GLshort x)
     * }
     */
    public static MethodHandle glVertexAttrib1sARB$handle() {
        return glVertexAttrib1sARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib1sARB(GLuint index, GLshort x)
     * }
     */
    public static MemorySegment glVertexAttrib1sARB$address() {
        return glVertexAttrib1sARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib1sARB(GLuint index, GLshort x)
     * }
     */
    public static void glVertexAttrib1sARB(int index, short x) {
        var mh$ = glVertexAttrib1sARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib1sARB", index, x);
            }
            mh$.invokeExact(index, x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib1svARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib1svARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib1svARB(GLuint index, const GLshort *v)
     * }
     */
    public static FunctionDescriptor glVertexAttrib1svARB$descriptor() {
        return glVertexAttrib1svARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib1svARB(GLuint index, const GLshort *v)
     * }
     */
    public static MethodHandle glVertexAttrib1svARB$handle() {
        return glVertexAttrib1svARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib1svARB(GLuint index, const GLshort *v)
     * }
     */
    public static MemorySegment glVertexAttrib1svARB$address() {
        return glVertexAttrib1svARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib1svARB(GLuint index, const GLshort *v)
     * }
     */
    public static void glVertexAttrib1svARB(int index, MemorySegment v) {
        var mh$ = glVertexAttrib1svARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib1svARB", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib2dARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib2dARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib2dARB(GLuint index, GLdouble x, GLdouble y)
     * }
     */
    public static FunctionDescriptor glVertexAttrib2dARB$descriptor() {
        return glVertexAttrib2dARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib2dARB(GLuint index, GLdouble x, GLdouble y)
     * }
     */
    public static MethodHandle glVertexAttrib2dARB$handle() {
        return glVertexAttrib2dARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib2dARB(GLuint index, GLdouble x, GLdouble y)
     * }
     */
    public static MemorySegment glVertexAttrib2dARB$address() {
        return glVertexAttrib2dARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib2dARB(GLuint index, GLdouble x, GLdouble y)
     * }
     */
    public static void glVertexAttrib2dARB(int index, double x, double y) {
        var mh$ = glVertexAttrib2dARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib2dARB", index, x, y);
            }
            mh$.invokeExact(index, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib2dvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib2dvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib2dvARB(GLuint index, const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glVertexAttrib2dvARB$descriptor() {
        return glVertexAttrib2dvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib2dvARB(GLuint index, const GLdouble *v)
     * }
     */
    public static MethodHandle glVertexAttrib2dvARB$handle() {
        return glVertexAttrib2dvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib2dvARB(GLuint index, const GLdouble *v)
     * }
     */
    public static MemorySegment glVertexAttrib2dvARB$address() {
        return glVertexAttrib2dvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib2dvARB(GLuint index, const GLdouble *v)
     * }
     */
    public static void glVertexAttrib2dvARB(int index, MemorySegment v) {
        var mh$ = glVertexAttrib2dvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib2dvARB", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib2fARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib2fARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib2fARB(GLuint index, GLfloat x, GLfloat y)
     * }
     */
    public static FunctionDescriptor glVertexAttrib2fARB$descriptor() {
        return glVertexAttrib2fARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib2fARB(GLuint index, GLfloat x, GLfloat y)
     * }
     */
    public static MethodHandle glVertexAttrib2fARB$handle() {
        return glVertexAttrib2fARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib2fARB(GLuint index, GLfloat x, GLfloat y)
     * }
     */
    public static MemorySegment glVertexAttrib2fARB$address() {
        return glVertexAttrib2fARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib2fARB(GLuint index, GLfloat x, GLfloat y)
     * }
     */
    public static void glVertexAttrib2fARB(int index, float x, float y) {
        var mh$ = glVertexAttrib2fARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib2fARB", index, x, y);
            }
            mh$.invokeExact(index, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib2fvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib2fvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib2fvARB(GLuint index, const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glVertexAttrib2fvARB$descriptor() {
        return glVertexAttrib2fvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib2fvARB(GLuint index, const GLfloat *v)
     * }
     */
    public static MethodHandle glVertexAttrib2fvARB$handle() {
        return glVertexAttrib2fvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib2fvARB(GLuint index, const GLfloat *v)
     * }
     */
    public static MemorySegment glVertexAttrib2fvARB$address() {
        return glVertexAttrib2fvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib2fvARB(GLuint index, const GLfloat *v)
     * }
     */
    public static void glVertexAttrib2fvARB(int index, MemorySegment v) {
        var mh$ = glVertexAttrib2fvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib2fvARB", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib2sARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib2sARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib2sARB(GLuint index, GLshort x, GLshort y)
     * }
     */
    public static FunctionDescriptor glVertexAttrib2sARB$descriptor() {
        return glVertexAttrib2sARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib2sARB(GLuint index, GLshort x, GLshort y)
     * }
     */
    public static MethodHandle glVertexAttrib2sARB$handle() {
        return glVertexAttrib2sARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib2sARB(GLuint index, GLshort x, GLshort y)
     * }
     */
    public static MemorySegment glVertexAttrib2sARB$address() {
        return glVertexAttrib2sARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib2sARB(GLuint index, GLshort x, GLshort y)
     * }
     */
    public static void glVertexAttrib2sARB(int index, short x, short y) {
        var mh$ = glVertexAttrib2sARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib2sARB", index, x, y);
            }
            mh$.invokeExact(index, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib2svARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib2svARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib2svARB(GLuint index, const GLshort *v)
     * }
     */
    public static FunctionDescriptor glVertexAttrib2svARB$descriptor() {
        return glVertexAttrib2svARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib2svARB(GLuint index, const GLshort *v)
     * }
     */
    public static MethodHandle glVertexAttrib2svARB$handle() {
        return glVertexAttrib2svARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib2svARB(GLuint index, const GLshort *v)
     * }
     */
    public static MemorySegment glVertexAttrib2svARB$address() {
        return glVertexAttrib2svARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib2svARB(GLuint index, const GLshort *v)
     * }
     */
    public static void glVertexAttrib2svARB(int index, MemorySegment v) {
        var mh$ = glVertexAttrib2svARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib2svARB", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib3dARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib3dARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib3dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static FunctionDescriptor glVertexAttrib3dARB$descriptor() {
        return glVertexAttrib3dARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib3dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MethodHandle glVertexAttrib3dARB$handle() {
        return glVertexAttrib3dARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib3dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MemorySegment glVertexAttrib3dARB$address() {
        return glVertexAttrib3dARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib3dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static void glVertexAttrib3dARB(int index, double x, double y, double z) {
        var mh$ = glVertexAttrib3dARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib3dARB", index, x, y, z);
            }
            mh$.invokeExact(index, x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib3dvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib3dvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib3dvARB(GLuint index, const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glVertexAttrib3dvARB$descriptor() {
        return glVertexAttrib3dvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib3dvARB(GLuint index, const GLdouble *v)
     * }
     */
    public static MethodHandle glVertexAttrib3dvARB$handle() {
        return glVertexAttrib3dvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib3dvARB(GLuint index, const GLdouble *v)
     * }
     */
    public static MemorySegment glVertexAttrib3dvARB$address() {
        return glVertexAttrib3dvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib3dvARB(GLuint index, const GLdouble *v)
     * }
     */
    public static void glVertexAttrib3dvARB(int index, MemorySegment v) {
        var mh$ = glVertexAttrib3dvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib3dvARB", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib3fARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib3fARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib3fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static FunctionDescriptor glVertexAttrib3fARB$descriptor() {
        return glVertexAttrib3fARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib3fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MethodHandle glVertexAttrib3fARB$handle() {
        return glVertexAttrib3fARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib3fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MemorySegment glVertexAttrib3fARB$address() {
        return glVertexAttrib3fARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib3fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static void glVertexAttrib3fARB(int index, float x, float y, float z) {
        var mh$ = glVertexAttrib3fARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib3fARB", index, x, y, z);
            }
            mh$.invokeExact(index, x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib3fvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib3fvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib3fvARB(GLuint index, const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glVertexAttrib3fvARB$descriptor() {
        return glVertexAttrib3fvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib3fvARB(GLuint index, const GLfloat *v)
     * }
     */
    public static MethodHandle glVertexAttrib3fvARB$handle() {
        return glVertexAttrib3fvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib3fvARB(GLuint index, const GLfloat *v)
     * }
     */
    public static MemorySegment glVertexAttrib3fvARB$address() {
        return glVertexAttrib3fvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib3fvARB(GLuint index, const GLfloat *v)
     * }
     */
    public static void glVertexAttrib3fvARB(int index, MemorySegment v) {
        var mh$ = glVertexAttrib3fvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib3fvARB", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib3sARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib3sARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib3sARB(GLuint index, GLshort x, GLshort y, GLshort z)
     * }
     */
    public static FunctionDescriptor glVertexAttrib3sARB$descriptor() {
        return glVertexAttrib3sARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib3sARB(GLuint index, GLshort x, GLshort y, GLshort z)
     * }
     */
    public static MethodHandle glVertexAttrib3sARB$handle() {
        return glVertexAttrib3sARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib3sARB(GLuint index, GLshort x, GLshort y, GLshort z)
     * }
     */
    public static MemorySegment glVertexAttrib3sARB$address() {
        return glVertexAttrib3sARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib3sARB(GLuint index, GLshort x, GLshort y, GLshort z)
     * }
     */
    public static void glVertexAttrib3sARB(int index, short x, short y, short z) {
        var mh$ = glVertexAttrib3sARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib3sARB", index, x, y, z);
            }
            mh$.invokeExact(index, x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib3svARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib3svARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib3svARB(GLuint index, const GLshort *v)
     * }
     */
    public static FunctionDescriptor glVertexAttrib3svARB$descriptor() {
        return glVertexAttrib3svARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib3svARB(GLuint index, const GLshort *v)
     * }
     */
    public static MethodHandle glVertexAttrib3svARB$handle() {
        return glVertexAttrib3svARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib3svARB(GLuint index, const GLshort *v)
     * }
     */
    public static MemorySegment glVertexAttrib3svARB$address() {
        return glVertexAttrib3svARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib3svARB(GLuint index, const GLshort *v)
     * }
     */
    public static void glVertexAttrib3svARB(int index, MemorySegment v) {
        var mh$ = glVertexAttrib3svARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib3svARB", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib4NbvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib4NbvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4NbvARB(GLuint index, const GLbyte *v)
     * }
     */
    public static FunctionDescriptor glVertexAttrib4NbvARB$descriptor() {
        return glVertexAttrib4NbvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4NbvARB(GLuint index, const GLbyte *v)
     * }
     */
    public static MethodHandle glVertexAttrib4NbvARB$handle() {
        return glVertexAttrib4NbvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4NbvARB(GLuint index, const GLbyte *v)
     * }
     */
    public static MemorySegment glVertexAttrib4NbvARB$address() {
        return glVertexAttrib4NbvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib4NbvARB(GLuint index, const GLbyte *v)
     * }
     */
    public static void glVertexAttrib4NbvARB(int index, MemorySegment v) {
        var mh$ = glVertexAttrib4NbvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib4NbvARB", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib4NivARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib4NivARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4NivARB(GLuint index, const GLint *v)
     * }
     */
    public static FunctionDescriptor glVertexAttrib4NivARB$descriptor() {
        return glVertexAttrib4NivARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4NivARB(GLuint index, const GLint *v)
     * }
     */
    public static MethodHandle glVertexAttrib4NivARB$handle() {
        return glVertexAttrib4NivARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4NivARB(GLuint index, const GLint *v)
     * }
     */
    public static MemorySegment glVertexAttrib4NivARB$address() {
        return glVertexAttrib4NivARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib4NivARB(GLuint index, const GLint *v)
     * }
     */
    public static void glVertexAttrib4NivARB(int index, MemorySegment v) {
        var mh$ = glVertexAttrib4NivARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib4NivARB", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib4NsvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib4NsvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4NsvARB(GLuint index, const GLshort *v)
     * }
     */
    public static FunctionDescriptor glVertexAttrib4NsvARB$descriptor() {
        return glVertexAttrib4NsvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4NsvARB(GLuint index, const GLshort *v)
     * }
     */
    public static MethodHandle glVertexAttrib4NsvARB$handle() {
        return glVertexAttrib4NsvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4NsvARB(GLuint index, const GLshort *v)
     * }
     */
    public static MemorySegment glVertexAttrib4NsvARB$address() {
        return glVertexAttrib4NsvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib4NsvARB(GLuint index, const GLshort *v)
     * }
     */
    public static void glVertexAttrib4NsvARB(int index, MemorySegment v) {
        var mh$ = glVertexAttrib4NsvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib4NsvARB", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib4NubARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib4NubARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4NubARB(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
     * }
     */
    public static FunctionDescriptor glVertexAttrib4NubARB$descriptor() {
        return glVertexAttrib4NubARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4NubARB(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
     * }
     */
    public static MethodHandle glVertexAttrib4NubARB$handle() {
        return glVertexAttrib4NubARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4NubARB(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
     * }
     */
    public static MemorySegment glVertexAttrib4NubARB$address() {
        return glVertexAttrib4NubARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib4NubARB(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
     * }
     */
    public static void glVertexAttrib4NubARB(int index, byte x, byte y, byte z, byte w) {
        var mh$ = glVertexAttrib4NubARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib4NubARB", index, x, y, z, w);
            }
            mh$.invokeExact(index, x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib4NubvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib4NubvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4NubvARB(GLuint index, const GLubyte *v)
     * }
     */
    public static FunctionDescriptor glVertexAttrib4NubvARB$descriptor() {
        return glVertexAttrib4NubvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4NubvARB(GLuint index, const GLubyte *v)
     * }
     */
    public static MethodHandle glVertexAttrib4NubvARB$handle() {
        return glVertexAttrib4NubvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4NubvARB(GLuint index, const GLubyte *v)
     * }
     */
    public static MemorySegment glVertexAttrib4NubvARB$address() {
        return glVertexAttrib4NubvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib4NubvARB(GLuint index, const GLubyte *v)
     * }
     */
    public static void glVertexAttrib4NubvARB(int index, MemorySegment v) {
        var mh$ = glVertexAttrib4NubvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib4NubvARB", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib4NuivARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib4NuivARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4NuivARB(GLuint index, const GLuint *v)
     * }
     */
    public static FunctionDescriptor glVertexAttrib4NuivARB$descriptor() {
        return glVertexAttrib4NuivARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4NuivARB(GLuint index, const GLuint *v)
     * }
     */
    public static MethodHandle glVertexAttrib4NuivARB$handle() {
        return glVertexAttrib4NuivARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4NuivARB(GLuint index, const GLuint *v)
     * }
     */
    public static MemorySegment glVertexAttrib4NuivARB$address() {
        return glVertexAttrib4NuivARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib4NuivARB(GLuint index, const GLuint *v)
     * }
     */
    public static void glVertexAttrib4NuivARB(int index, MemorySegment v) {
        var mh$ = glVertexAttrib4NuivARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib4NuivARB", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib4NusvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib4NusvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4NusvARB(GLuint index, const GLushort *v)
     * }
     */
    public static FunctionDescriptor glVertexAttrib4NusvARB$descriptor() {
        return glVertexAttrib4NusvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4NusvARB(GLuint index, const GLushort *v)
     * }
     */
    public static MethodHandle glVertexAttrib4NusvARB$handle() {
        return glVertexAttrib4NusvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4NusvARB(GLuint index, const GLushort *v)
     * }
     */
    public static MemorySegment glVertexAttrib4NusvARB$address() {
        return glVertexAttrib4NusvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib4NusvARB(GLuint index, const GLushort *v)
     * }
     */
    public static void glVertexAttrib4NusvARB(int index, MemorySegment v) {
        var mh$ = glVertexAttrib4NusvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib4NusvARB", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib4bvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib4bvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4bvARB(GLuint index, const GLbyte *v)
     * }
     */
    public static FunctionDescriptor glVertexAttrib4bvARB$descriptor() {
        return glVertexAttrib4bvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4bvARB(GLuint index, const GLbyte *v)
     * }
     */
    public static MethodHandle glVertexAttrib4bvARB$handle() {
        return glVertexAttrib4bvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4bvARB(GLuint index, const GLbyte *v)
     * }
     */
    public static MemorySegment glVertexAttrib4bvARB$address() {
        return glVertexAttrib4bvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib4bvARB(GLuint index, const GLbyte *v)
     * }
     */
    public static void glVertexAttrib4bvARB(int index, MemorySegment v) {
        var mh$ = glVertexAttrib4bvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib4bvARB", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib4dARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib4dARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static FunctionDescriptor glVertexAttrib4dARB$descriptor() {
        return glVertexAttrib4dARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static MethodHandle glVertexAttrib4dARB$handle() {
        return glVertexAttrib4dARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static MemorySegment glVertexAttrib4dARB$address() {
        return glVertexAttrib4dARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib4dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static void glVertexAttrib4dARB(int index, double x, double y, double z, double w) {
        var mh$ = glVertexAttrib4dARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib4dARB", index, x, y, z, w);
            }
            mh$.invokeExact(index, x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib4dvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib4dvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4dvARB(GLuint index, const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glVertexAttrib4dvARB$descriptor() {
        return glVertexAttrib4dvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4dvARB(GLuint index, const GLdouble *v)
     * }
     */
    public static MethodHandle glVertexAttrib4dvARB$handle() {
        return glVertexAttrib4dvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4dvARB(GLuint index, const GLdouble *v)
     * }
     */
    public static MemorySegment glVertexAttrib4dvARB$address() {
        return glVertexAttrib4dvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib4dvARB(GLuint index, const GLdouble *v)
     * }
     */
    public static void glVertexAttrib4dvARB(int index, MemorySegment v) {
        var mh$ = glVertexAttrib4dvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib4dvARB", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib4fARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib4fARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static FunctionDescriptor glVertexAttrib4fARB$descriptor() {
        return glVertexAttrib4fARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static MethodHandle glVertexAttrib4fARB$handle() {
        return glVertexAttrib4fARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static MemorySegment glVertexAttrib4fARB$address() {
        return glVertexAttrib4fARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib4fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static void glVertexAttrib4fARB(int index, float x, float y, float z, float w) {
        var mh$ = glVertexAttrib4fARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib4fARB", index, x, y, z, w);
            }
            mh$.invokeExact(index, x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib4fvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib4fvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4fvARB(GLuint index, const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glVertexAttrib4fvARB$descriptor() {
        return glVertexAttrib4fvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4fvARB(GLuint index, const GLfloat *v)
     * }
     */
    public static MethodHandle glVertexAttrib4fvARB$handle() {
        return glVertexAttrib4fvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4fvARB(GLuint index, const GLfloat *v)
     * }
     */
    public static MemorySegment glVertexAttrib4fvARB$address() {
        return glVertexAttrib4fvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib4fvARB(GLuint index, const GLfloat *v)
     * }
     */
    public static void glVertexAttrib4fvARB(int index, MemorySegment v) {
        var mh$ = glVertexAttrib4fvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib4fvARB", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib4ivARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib4ivARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4ivARB(GLuint index, const GLint *v)
     * }
     */
    public static FunctionDescriptor glVertexAttrib4ivARB$descriptor() {
        return glVertexAttrib4ivARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4ivARB(GLuint index, const GLint *v)
     * }
     */
    public static MethodHandle glVertexAttrib4ivARB$handle() {
        return glVertexAttrib4ivARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4ivARB(GLuint index, const GLint *v)
     * }
     */
    public static MemorySegment glVertexAttrib4ivARB$address() {
        return glVertexAttrib4ivARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib4ivARB(GLuint index, const GLint *v)
     * }
     */
    public static void glVertexAttrib4ivARB(int index, MemorySegment v) {
        var mh$ = glVertexAttrib4ivARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib4ivARB", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib4sARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib4sARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4sARB(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static FunctionDescriptor glVertexAttrib4sARB$descriptor() {
        return glVertexAttrib4sARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4sARB(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static MethodHandle glVertexAttrib4sARB$handle() {
        return glVertexAttrib4sARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4sARB(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static MemorySegment glVertexAttrib4sARB$address() {
        return glVertexAttrib4sARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib4sARB(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static void glVertexAttrib4sARB(int index, short x, short y, short z, short w) {
        var mh$ = glVertexAttrib4sARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib4sARB", index, x, y, z, w);
            }
            mh$.invokeExact(index, x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib4svARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib4svARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4svARB(GLuint index, const GLshort *v)
     * }
     */
    public static FunctionDescriptor glVertexAttrib4svARB$descriptor() {
        return glVertexAttrib4svARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4svARB(GLuint index, const GLshort *v)
     * }
     */
    public static MethodHandle glVertexAttrib4svARB$handle() {
        return glVertexAttrib4svARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4svARB(GLuint index, const GLshort *v)
     * }
     */
    public static MemorySegment glVertexAttrib4svARB$address() {
        return glVertexAttrib4svARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib4svARB(GLuint index, const GLshort *v)
     * }
     */
    public static void glVertexAttrib4svARB(int index, MemorySegment v) {
        var mh$ = glVertexAttrib4svARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib4svARB", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib4ubvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib4ubvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4ubvARB(GLuint index, const GLubyte *v)
     * }
     */
    public static FunctionDescriptor glVertexAttrib4ubvARB$descriptor() {
        return glVertexAttrib4ubvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4ubvARB(GLuint index, const GLubyte *v)
     * }
     */
    public static MethodHandle glVertexAttrib4ubvARB$handle() {
        return glVertexAttrib4ubvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4ubvARB(GLuint index, const GLubyte *v)
     * }
     */
    public static MemorySegment glVertexAttrib4ubvARB$address() {
        return glVertexAttrib4ubvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib4ubvARB(GLuint index, const GLubyte *v)
     * }
     */
    public static void glVertexAttrib4ubvARB(int index, MemorySegment v) {
        var mh$ = glVertexAttrib4ubvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib4ubvARB", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib4uivARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib4uivARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4uivARB(GLuint index, const GLuint *v)
     * }
     */
    public static FunctionDescriptor glVertexAttrib4uivARB$descriptor() {
        return glVertexAttrib4uivARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4uivARB(GLuint index, const GLuint *v)
     * }
     */
    public static MethodHandle glVertexAttrib4uivARB$handle() {
        return glVertexAttrib4uivARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4uivARB(GLuint index, const GLuint *v)
     * }
     */
    public static MemorySegment glVertexAttrib4uivARB$address() {
        return glVertexAttrib4uivARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib4uivARB(GLuint index, const GLuint *v)
     * }
     */
    public static void glVertexAttrib4uivARB(int index, MemorySegment v) {
        var mh$ = glVertexAttrib4uivARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib4uivARB", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib4usvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib4usvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4usvARB(GLuint index, const GLushort *v)
     * }
     */
    public static FunctionDescriptor glVertexAttrib4usvARB$descriptor() {
        return glVertexAttrib4usvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4usvARB(GLuint index, const GLushort *v)
     * }
     */
    public static MethodHandle glVertexAttrib4usvARB$handle() {
        return glVertexAttrib4usvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4usvARB(GLuint index, const GLushort *v)
     * }
     */
    public static MemorySegment glVertexAttrib4usvARB$address() {
        return glVertexAttrib4usvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib4usvARB(GLuint index, const GLushort *v)
     * }
     */
    public static void glVertexAttrib4usvARB(int index, MemorySegment v) {
        var mh$ = glVertexAttrib4usvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib4usvARB", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttribPointerARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_CHAR,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttribPointerARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttribPointerARB(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static FunctionDescriptor glVertexAttribPointerARB$descriptor() {
        return glVertexAttribPointerARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttribPointerARB(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MethodHandle glVertexAttribPointerARB$handle() {
        return glVertexAttribPointerARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttribPointerARB(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MemorySegment glVertexAttribPointerARB$address() {
        return glVertexAttribPointerARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttribPointerARB(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static void glVertexAttribPointerARB(int index, int size, int type, byte normalized, int stride, MemorySegment pointer) {
        var mh$ = glVertexAttribPointerARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttribPointerARB", index, size, type, normalized, stride, pointer);
            }
            mh$.invokeExact(index, size, type, normalized, stride, pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDisableVertexAttribArrayARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDisableVertexAttribArrayARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glDisableVertexAttribArrayARB(GLuint index)
     * }
     */
    public static FunctionDescriptor glDisableVertexAttribArrayARB$descriptor() {
        return glDisableVertexAttribArrayARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glDisableVertexAttribArrayARB(GLuint index)
     * }
     */
    public static MethodHandle glDisableVertexAttribArrayARB$handle() {
        return glDisableVertexAttribArrayARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glDisableVertexAttribArrayARB(GLuint index)
     * }
     */
    public static MemorySegment glDisableVertexAttribArrayARB$address() {
        return glDisableVertexAttribArrayARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glDisableVertexAttribArrayARB(GLuint index)
     * }
     */
    public static void glDisableVertexAttribArrayARB(int index) {
        var mh$ = glDisableVertexAttribArrayARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDisableVertexAttribArrayARB", index);
            }
            mh$.invokeExact(index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEnableVertexAttribArrayARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glEnableVertexAttribArrayARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glEnableVertexAttribArrayARB(GLuint index)
     * }
     */
    public static FunctionDescriptor glEnableVertexAttribArrayARB$descriptor() {
        return glEnableVertexAttribArrayARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glEnableVertexAttribArrayARB(GLuint index)
     * }
     */
    public static MethodHandle glEnableVertexAttribArrayARB$handle() {
        return glEnableVertexAttribArrayARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glEnableVertexAttribArrayARB(GLuint index)
     * }
     */
    public static MemorySegment glEnableVertexAttribArrayARB$address() {
        return glEnableVertexAttribArrayARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glEnableVertexAttribArrayARB(GLuint index)
     * }
     */
    public static void glEnableVertexAttribArrayARB(int index) {
        var mh$ = glEnableVertexAttribArrayARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEnableVertexAttribArrayARB", index);
            }
            mh$.invokeExact(index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetVertexAttribPointervARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetVertexAttribPointervARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetVertexAttribPointervARB(GLuint index, GLenum pname, GLvoid **pointer)
     * }
     */
    public static FunctionDescriptor glGetVertexAttribPointervARB$descriptor() {
        return glGetVertexAttribPointervARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetVertexAttribPointervARB(GLuint index, GLenum pname, GLvoid **pointer)
     * }
     */
    public static MethodHandle glGetVertexAttribPointervARB$handle() {
        return glGetVertexAttribPointervARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetVertexAttribPointervARB(GLuint index, GLenum pname, GLvoid **pointer)
     * }
     */
    public static MemorySegment glGetVertexAttribPointervARB$address() {
        return glGetVertexAttribPointervARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetVertexAttribPointervARB(GLuint index, GLenum pname, GLvoid **pointer)
     * }
     */
    public static void glGetVertexAttribPointervARB(int index, int pname, MemorySegment pointer) {
        var mh$ = glGetVertexAttribPointervARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetVertexAttribPointervARB", index, pname, pointer);
            }
            mh$.invokeExact(index, pname, pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetVertexAttribdvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetVertexAttribdvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetVertexAttribdvARB(GLuint index, GLenum pname, GLdouble *params)
     * }
     */
    public static FunctionDescriptor glGetVertexAttribdvARB$descriptor() {
        return glGetVertexAttribdvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetVertexAttribdvARB(GLuint index, GLenum pname, GLdouble *params)
     * }
     */
    public static MethodHandle glGetVertexAttribdvARB$handle() {
        return glGetVertexAttribdvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetVertexAttribdvARB(GLuint index, GLenum pname, GLdouble *params)
     * }
     */
    public static MemorySegment glGetVertexAttribdvARB$address() {
        return glGetVertexAttribdvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetVertexAttribdvARB(GLuint index, GLenum pname, GLdouble *params)
     * }
     */
    public static void glGetVertexAttribdvARB(int index, int pname, MemorySegment params) {
        var mh$ = glGetVertexAttribdvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetVertexAttribdvARB", index, pname, params);
            }
            mh$.invokeExact(index, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetVertexAttribfvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetVertexAttribfvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetVertexAttribfvARB(GLuint index, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetVertexAttribfvARB$descriptor() {
        return glGetVertexAttribfvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetVertexAttribfvARB(GLuint index, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetVertexAttribfvARB$handle() {
        return glGetVertexAttribfvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetVertexAttribfvARB(GLuint index, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetVertexAttribfvARB$address() {
        return glGetVertexAttribfvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetVertexAttribfvARB(GLuint index, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetVertexAttribfvARB(int index, int pname, MemorySegment params) {
        var mh$ = glGetVertexAttribfvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetVertexAttribfvARB", index, pname, params);
            }
            mh$.invokeExact(index, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetVertexAttribivARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetVertexAttribivARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetVertexAttribivARB(GLuint index, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetVertexAttribivARB$descriptor() {
        return glGetVertexAttribivARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetVertexAttribivARB(GLuint index, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetVertexAttribivARB$handle() {
        return glGetVertexAttribivARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetVertexAttribivARB(GLuint index, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetVertexAttribivARB$address() {
        return glGetVertexAttribivARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetVertexAttribivARB(GLuint index, GLenum pname, GLint *params)
     * }
     */
    public static void glGetVertexAttribivARB(int index, int pname, MemorySegment params) {
        var mh$ = glGetVertexAttribivARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetVertexAttribivARB", index, pname, params);
            }
            mh$.invokeExact(index, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glWindowPos2dARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glWindowPos2dARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glWindowPos2dARB(GLdouble x, GLdouble y)
     * }
     */
    public static FunctionDescriptor glWindowPos2dARB$descriptor() {
        return glWindowPos2dARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glWindowPos2dARB(GLdouble x, GLdouble y)
     * }
     */
    public static MethodHandle glWindowPos2dARB$handle() {
        return glWindowPos2dARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glWindowPos2dARB(GLdouble x, GLdouble y)
     * }
     */
    public static MemorySegment glWindowPos2dARB$address() {
        return glWindowPos2dARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glWindowPos2dARB(GLdouble x, GLdouble y)
     * }
     */
    public static void glWindowPos2dARB(double x, double y) {
        var mh$ = glWindowPos2dARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glWindowPos2dARB", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glWindowPos2dvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glWindowPos2dvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glWindowPos2dvARB(const GLdouble *p)
     * }
     */
    public static FunctionDescriptor glWindowPos2dvARB$descriptor() {
        return glWindowPos2dvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glWindowPos2dvARB(const GLdouble *p)
     * }
     */
    public static MethodHandle glWindowPos2dvARB$handle() {
        return glWindowPos2dvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glWindowPos2dvARB(const GLdouble *p)
     * }
     */
    public static MemorySegment glWindowPos2dvARB$address() {
        return glWindowPos2dvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glWindowPos2dvARB(const GLdouble *p)
     * }
     */
    public static void glWindowPos2dvARB(MemorySegment p) {
        var mh$ = glWindowPos2dvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glWindowPos2dvARB", p);
            }
            mh$.invokeExact(p);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glWindowPos2fARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glWindowPos2fARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glWindowPos2fARB(GLfloat x, GLfloat y)
     * }
     */
    public static FunctionDescriptor glWindowPos2fARB$descriptor() {
        return glWindowPos2fARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glWindowPos2fARB(GLfloat x, GLfloat y)
     * }
     */
    public static MethodHandle glWindowPos2fARB$handle() {
        return glWindowPos2fARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glWindowPos2fARB(GLfloat x, GLfloat y)
     * }
     */
    public static MemorySegment glWindowPos2fARB$address() {
        return glWindowPos2fARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glWindowPos2fARB(GLfloat x, GLfloat y)
     * }
     */
    public static void glWindowPos2fARB(float x, float y) {
        var mh$ = glWindowPos2fARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glWindowPos2fARB", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glWindowPos2fvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glWindowPos2fvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glWindowPos2fvARB(const GLfloat *p)
     * }
     */
    public static FunctionDescriptor glWindowPos2fvARB$descriptor() {
        return glWindowPos2fvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glWindowPos2fvARB(const GLfloat *p)
     * }
     */
    public static MethodHandle glWindowPos2fvARB$handle() {
        return glWindowPos2fvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glWindowPos2fvARB(const GLfloat *p)
     * }
     */
    public static MemorySegment glWindowPos2fvARB$address() {
        return glWindowPos2fvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glWindowPos2fvARB(const GLfloat *p)
     * }
     */
    public static void glWindowPos2fvARB(MemorySegment p) {
        var mh$ = glWindowPos2fvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glWindowPos2fvARB", p);
            }
            mh$.invokeExact(p);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glWindowPos2iARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glWindowPos2iARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glWindowPos2iARB(GLint x, GLint y)
     * }
     */
    public static FunctionDescriptor glWindowPos2iARB$descriptor() {
        return glWindowPos2iARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glWindowPos2iARB(GLint x, GLint y)
     * }
     */
    public static MethodHandle glWindowPos2iARB$handle() {
        return glWindowPos2iARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glWindowPos2iARB(GLint x, GLint y)
     * }
     */
    public static MemorySegment glWindowPos2iARB$address() {
        return glWindowPos2iARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glWindowPos2iARB(GLint x, GLint y)
     * }
     */
    public static void glWindowPos2iARB(int x, int y) {
        var mh$ = glWindowPos2iARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glWindowPos2iARB", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glWindowPos2ivARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glWindowPos2ivARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glWindowPos2ivARB(const GLint *p)
     * }
     */
    public static FunctionDescriptor glWindowPos2ivARB$descriptor() {
        return glWindowPos2ivARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glWindowPos2ivARB(const GLint *p)
     * }
     */
    public static MethodHandle glWindowPos2ivARB$handle() {
        return glWindowPos2ivARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glWindowPos2ivARB(const GLint *p)
     * }
     */
    public static MemorySegment glWindowPos2ivARB$address() {
        return glWindowPos2ivARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glWindowPos2ivARB(const GLint *p)
     * }
     */
    public static void glWindowPos2ivARB(MemorySegment p) {
        var mh$ = glWindowPos2ivARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glWindowPos2ivARB", p);
            }
            mh$.invokeExact(p);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glWindowPos2sARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glWindowPos2sARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glWindowPos2sARB(GLshort x, GLshort y)
     * }
     */
    public static FunctionDescriptor glWindowPos2sARB$descriptor() {
        return glWindowPos2sARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glWindowPos2sARB(GLshort x, GLshort y)
     * }
     */
    public static MethodHandle glWindowPos2sARB$handle() {
        return glWindowPos2sARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glWindowPos2sARB(GLshort x, GLshort y)
     * }
     */
    public static MemorySegment glWindowPos2sARB$address() {
        return glWindowPos2sARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glWindowPos2sARB(GLshort x, GLshort y)
     * }
     */
    public static void glWindowPos2sARB(short x, short y) {
        var mh$ = glWindowPos2sARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glWindowPos2sARB", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glWindowPos2svARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glWindowPos2svARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glWindowPos2svARB(const GLshort *p)
     * }
     */
    public static FunctionDescriptor glWindowPos2svARB$descriptor() {
        return glWindowPos2svARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glWindowPos2svARB(const GLshort *p)
     * }
     */
    public static MethodHandle glWindowPos2svARB$handle() {
        return glWindowPos2svARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glWindowPos2svARB(const GLshort *p)
     * }
     */
    public static MemorySegment glWindowPos2svARB$address() {
        return glWindowPos2svARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glWindowPos2svARB(const GLshort *p)
     * }
     */
    public static void glWindowPos2svARB(MemorySegment p) {
        var mh$ = glWindowPos2svARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glWindowPos2svARB", p);
            }
            mh$.invokeExact(p);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glWindowPos3dARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glWindowPos3dARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glWindowPos3dARB(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static FunctionDescriptor glWindowPos3dARB$descriptor() {
        return glWindowPos3dARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glWindowPos3dARB(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MethodHandle glWindowPos3dARB$handle() {
        return glWindowPos3dARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glWindowPos3dARB(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MemorySegment glWindowPos3dARB$address() {
        return glWindowPos3dARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glWindowPos3dARB(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static void glWindowPos3dARB(double x, double y, double z) {
        var mh$ = glWindowPos3dARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glWindowPos3dARB", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glWindowPos3dvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glWindowPos3dvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glWindowPos3dvARB(const GLdouble *p)
     * }
     */
    public static FunctionDescriptor glWindowPos3dvARB$descriptor() {
        return glWindowPos3dvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glWindowPos3dvARB(const GLdouble *p)
     * }
     */
    public static MethodHandle glWindowPos3dvARB$handle() {
        return glWindowPos3dvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glWindowPos3dvARB(const GLdouble *p)
     * }
     */
    public static MemorySegment glWindowPos3dvARB$address() {
        return glWindowPos3dvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glWindowPos3dvARB(const GLdouble *p)
     * }
     */
    public static void glWindowPos3dvARB(MemorySegment p) {
        var mh$ = glWindowPos3dvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glWindowPos3dvARB", p);
            }
            mh$.invokeExact(p);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glWindowPos3fARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glWindowPos3fARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glWindowPos3fARB(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static FunctionDescriptor glWindowPos3fARB$descriptor() {
        return glWindowPos3fARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glWindowPos3fARB(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MethodHandle glWindowPos3fARB$handle() {
        return glWindowPos3fARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glWindowPos3fARB(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MemorySegment glWindowPos3fARB$address() {
        return glWindowPos3fARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glWindowPos3fARB(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static void glWindowPos3fARB(float x, float y, float z) {
        var mh$ = glWindowPos3fARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glWindowPos3fARB", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glWindowPos3fvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glWindowPos3fvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glWindowPos3fvARB(const GLfloat *p)
     * }
     */
    public static FunctionDescriptor glWindowPos3fvARB$descriptor() {
        return glWindowPos3fvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glWindowPos3fvARB(const GLfloat *p)
     * }
     */
    public static MethodHandle glWindowPos3fvARB$handle() {
        return glWindowPos3fvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glWindowPos3fvARB(const GLfloat *p)
     * }
     */
    public static MemorySegment glWindowPos3fvARB$address() {
        return glWindowPos3fvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glWindowPos3fvARB(const GLfloat *p)
     * }
     */
    public static void glWindowPos3fvARB(MemorySegment p) {
        var mh$ = glWindowPos3fvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glWindowPos3fvARB", p);
            }
            mh$.invokeExact(p);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glWindowPos3iARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glWindowPos3iARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glWindowPos3iARB(GLint x, GLint y, GLint z)
     * }
     */
    public static FunctionDescriptor glWindowPos3iARB$descriptor() {
        return glWindowPos3iARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glWindowPos3iARB(GLint x, GLint y, GLint z)
     * }
     */
    public static MethodHandle glWindowPos3iARB$handle() {
        return glWindowPos3iARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glWindowPos3iARB(GLint x, GLint y, GLint z)
     * }
     */
    public static MemorySegment glWindowPos3iARB$address() {
        return glWindowPos3iARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glWindowPos3iARB(GLint x, GLint y, GLint z)
     * }
     */
    public static void glWindowPos3iARB(int x, int y, int z) {
        var mh$ = glWindowPos3iARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glWindowPos3iARB", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glWindowPos3ivARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glWindowPos3ivARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glWindowPos3ivARB(const GLint *p)
     * }
     */
    public static FunctionDescriptor glWindowPos3ivARB$descriptor() {
        return glWindowPos3ivARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glWindowPos3ivARB(const GLint *p)
     * }
     */
    public static MethodHandle glWindowPos3ivARB$handle() {
        return glWindowPos3ivARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glWindowPos3ivARB(const GLint *p)
     * }
     */
    public static MemorySegment glWindowPos3ivARB$address() {
        return glWindowPos3ivARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glWindowPos3ivARB(const GLint *p)
     * }
     */
    public static void glWindowPos3ivARB(MemorySegment p) {
        var mh$ = glWindowPos3ivARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glWindowPos3ivARB", p);
            }
            mh$.invokeExact(p);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glWindowPos3sARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glWindowPos3sARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glWindowPos3sARB(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static FunctionDescriptor glWindowPos3sARB$descriptor() {
        return glWindowPos3sARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glWindowPos3sARB(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static MethodHandle glWindowPos3sARB$handle() {
        return glWindowPos3sARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glWindowPos3sARB(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static MemorySegment glWindowPos3sARB$address() {
        return glWindowPos3sARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glWindowPos3sARB(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static void glWindowPos3sARB(short x, short y, short z) {
        var mh$ = glWindowPos3sARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glWindowPos3sARB", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glWindowPos3svARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glWindowPos3svARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glWindowPos3svARB(const GLshort *p)
     * }
     */
    public static FunctionDescriptor glWindowPos3svARB$descriptor() {
        return glWindowPos3svARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glWindowPos3svARB(const GLshort *p)
     * }
     */
    public static MethodHandle glWindowPos3svARB$handle() {
        return glWindowPos3svARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glWindowPos3svARB(const GLshort *p)
     * }
     */
    public static MemorySegment glWindowPos3svARB$address() {
        return glWindowPos3svARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glWindowPos3svARB(const GLshort *p)
     * }
     */
    public static void glWindowPos3svARB(MemorySegment p) {
        var mh$ = glWindowPos3svARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glWindowPos3svARB", p);
            }
            mh$.invokeExact(p);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniformBufferEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniformBufferEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniformBufferEXT(GLuint program, GLint location, GLuint buffer)
     * }
     */
    public static FunctionDescriptor glUniformBufferEXT$descriptor() {
        return glUniformBufferEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniformBufferEXT(GLuint program, GLint location, GLuint buffer)
     * }
     */
    public static MethodHandle glUniformBufferEXT$handle() {
        return glUniformBufferEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniformBufferEXT(GLuint program, GLint location, GLuint buffer)
     * }
     */
    public static MemorySegment glUniformBufferEXT$address() {
        return glUniformBufferEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniformBufferEXT(GLuint program, GLint location, GLuint buffer)
     * }
     */
    public static void glUniformBufferEXT(int program, int location, int buffer) {
        var mh$ = glUniformBufferEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniformBufferEXT", program, location, buffer);
            }
            mh$.invokeExact(program, location, buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetUniformBufferSizeEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetUniformBufferSizeEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLint glGetUniformBufferSizeEXT(GLuint program, GLint location)
     * }
     */
    public static FunctionDescriptor glGetUniformBufferSizeEXT$descriptor() {
        return glGetUniformBufferSizeEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLint glGetUniformBufferSizeEXT(GLuint program, GLint location)
     * }
     */
    public static MethodHandle glGetUniformBufferSizeEXT$handle() {
        return glGetUniformBufferSizeEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLint glGetUniformBufferSizeEXT(GLuint program, GLint location)
     * }
     */
    public static MemorySegment glGetUniformBufferSizeEXT$address() {
        return glGetUniformBufferSizeEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLint glGetUniformBufferSizeEXT(GLuint program, GLint location)
     * }
     */
    public static int glGetUniformBufferSizeEXT(int program, int location) {
        var mh$ = glGetUniformBufferSizeEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetUniformBufferSizeEXT", program, location);
            }
            return (int)mh$.invokeExact(program, location);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetUniformOffsetEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetUniformOffsetEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLintptr glGetUniformOffsetEXT(GLuint program, GLint location)
     * }
     */
    public static FunctionDescriptor glGetUniformOffsetEXT$descriptor() {
        return glGetUniformOffsetEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLintptr glGetUniformOffsetEXT(GLuint program, GLint location)
     * }
     */
    public static MethodHandle glGetUniformOffsetEXT$handle() {
        return glGetUniformOffsetEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLintptr glGetUniformOffsetEXT(GLuint program, GLint location)
     * }
     */
    public static MemorySegment glGetUniformOffsetEXT$address() {
        return glGetUniformOffsetEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLintptr glGetUniformOffsetEXT(GLuint program, GLint location)
     * }
     */
    public static long glGetUniformOffsetEXT(int program, int location) {
        var mh$ = glGetUniformOffsetEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetUniformOffsetEXT", program, location);
            }
            return (long)mh$.invokeExact(program, location);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBlendColorEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glBlendColorEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glBlendColorEXT(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
     * }
     */
    public static FunctionDescriptor glBlendColorEXT$descriptor() {
        return glBlendColorEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glBlendColorEXT(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
     * }
     */
    public static MethodHandle glBlendColorEXT$handle() {
        return glBlendColorEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glBlendColorEXT(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
     * }
     */
    public static MemorySegment glBlendColorEXT$address() {
        return glBlendColorEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glBlendColorEXT(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
     * }
     */
    public static void glBlendColorEXT(float red, float green, float blue, float alpha) {
        var mh$ = glBlendColorEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBlendColorEXT", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBlendEquationSeparateEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glBlendEquationSeparateEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glBlendEquationSeparateEXT(GLenum modeRGB, GLenum modeAlpha)
     * }
     */
    public static FunctionDescriptor glBlendEquationSeparateEXT$descriptor() {
        return glBlendEquationSeparateEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glBlendEquationSeparateEXT(GLenum modeRGB, GLenum modeAlpha)
     * }
     */
    public static MethodHandle glBlendEquationSeparateEXT$handle() {
        return glBlendEquationSeparateEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glBlendEquationSeparateEXT(GLenum modeRGB, GLenum modeAlpha)
     * }
     */
    public static MemorySegment glBlendEquationSeparateEXT$address() {
        return glBlendEquationSeparateEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glBlendEquationSeparateEXT(GLenum modeRGB, GLenum modeAlpha)
     * }
     */
    public static void glBlendEquationSeparateEXT(int modeRGB, int modeAlpha) {
        var mh$ = glBlendEquationSeparateEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBlendEquationSeparateEXT", modeRGB, modeAlpha);
            }
            mh$.invokeExact(modeRGB, modeAlpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBlendFuncSeparateEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glBlendFuncSeparateEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glBlendFuncSeparateEXT(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
     * }
     */
    public static FunctionDescriptor glBlendFuncSeparateEXT$descriptor() {
        return glBlendFuncSeparateEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glBlendFuncSeparateEXT(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
     * }
     */
    public static MethodHandle glBlendFuncSeparateEXT$handle() {
        return glBlendFuncSeparateEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glBlendFuncSeparateEXT(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
     * }
     */
    public static MemorySegment glBlendFuncSeparateEXT$address() {
        return glBlendFuncSeparateEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glBlendFuncSeparateEXT(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
     * }
     */
    public static void glBlendFuncSeparateEXT(int sfactorRGB, int dfactorRGB, int sfactorAlpha, int dfactorAlpha) {
        var mh$ = glBlendFuncSeparateEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBlendFuncSeparateEXT", sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
            }
            mh$.invokeExact(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBlendEquationEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glBlendEquationEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glBlendEquationEXT(GLenum mode)
     * }
     */
    public static FunctionDescriptor glBlendEquationEXT$descriptor() {
        return glBlendEquationEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glBlendEquationEXT(GLenum mode)
     * }
     */
    public static MethodHandle glBlendEquationEXT$handle() {
        return glBlendEquationEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glBlendEquationEXT(GLenum mode)
     * }
     */
    public static MemorySegment glBlendEquationEXT$address() {
        return glBlendEquationEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glBlendEquationEXT(GLenum mode)
     * }
     */
    public static void glBlendEquationEXT(int mode) {
        var mh$ = glBlendEquationEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBlendEquationEXT", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLabelObjectEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glLabelObjectEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glLabelObjectEXT(GLenum type, GLuint object, GLsizei length, const GLchar *label)
     * }
     */
    public static FunctionDescriptor glLabelObjectEXT$descriptor() {
        return glLabelObjectEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glLabelObjectEXT(GLenum type, GLuint object, GLsizei length, const GLchar *label)
     * }
     */
    public static MethodHandle glLabelObjectEXT$handle() {
        return glLabelObjectEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glLabelObjectEXT(GLenum type, GLuint object, GLsizei length, const GLchar *label)
     * }
     */
    public static MemorySegment glLabelObjectEXT$address() {
        return glLabelObjectEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glLabelObjectEXT(GLenum type, GLuint object, GLsizei length, const GLchar *label)
     * }
     */
    public static void glLabelObjectEXT(int type, int object, int length, MemorySegment label) {
        var mh$ = glLabelObjectEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLabelObjectEXT", type, object, length, label);
            }
            mh$.invokeExact(type, object, length, label);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetObjectLabelEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetObjectLabelEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetObjectLabelEXT(GLenum type, GLuint object, GLsizei bufSize, GLsizei *length, GLchar *label)
     * }
     */
    public static FunctionDescriptor glGetObjectLabelEXT$descriptor() {
        return glGetObjectLabelEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetObjectLabelEXT(GLenum type, GLuint object, GLsizei bufSize, GLsizei *length, GLchar *label)
     * }
     */
    public static MethodHandle glGetObjectLabelEXT$handle() {
        return glGetObjectLabelEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetObjectLabelEXT(GLenum type, GLuint object, GLsizei bufSize, GLsizei *length, GLchar *label)
     * }
     */
    public static MemorySegment glGetObjectLabelEXT$address() {
        return glGetObjectLabelEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetObjectLabelEXT(GLenum type, GLuint object, GLsizei bufSize, GLsizei *length, GLchar *label)
     * }
     */
    public static void glGetObjectLabelEXT(int type, int object, int bufSize, MemorySegment length, MemorySegment label) {
        var mh$ = glGetObjectLabelEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetObjectLabelEXT", type, object, bufSize, length, label);
            }
            mh$.invokeExact(type, object, bufSize, length, label);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glInsertEventMarkerEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glInsertEventMarkerEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glInsertEventMarkerEXT(GLsizei length, const char *marker)
     * }
     */
    public static FunctionDescriptor glInsertEventMarkerEXT$descriptor() {
        return glInsertEventMarkerEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glInsertEventMarkerEXT(GLsizei length, const char *marker)
     * }
     */
    public static MethodHandle glInsertEventMarkerEXT$handle() {
        return glInsertEventMarkerEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glInsertEventMarkerEXT(GLsizei length, const char *marker)
     * }
     */
    public static MemorySegment glInsertEventMarkerEXT$address() {
        return glInsertEventMarkerEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glInsertEventMarkerEXT(GLsizei length, const char *marker)
     * }
     */
    public static void glInsertEventMarkerEXT(int length, MemorySegment marker) {
        var mh$ = glInsertEventMarkerEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glInsertEventMarkerEXT", length, marker);
            }
            mh$.invokeExact(length, marker);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPushGroupMarkerEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPushGroupMarkerEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glPushGroupMarkerEXT(GLsizei length, const char *marker)
     * }
     */
    public static FunctionDescriptor glPushGroupMarkerEXT$descriptor() {
        return glPushGroupMarkerEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glPushGroupMarkerEXT(GLsizei length, const char *marker)
     * }
     */
    public static MethodHandle glPushGroupMarkerEXT$handle() {
        return glPushGroupMarkerEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glPushGroupMarkerEXT(GLsizei length, const char *marker)
     * }
     */
    public static MemorySegment glPushGroupMarkerEXT$address() {
        return glPushGroupMarkerEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glPushGroupMarkerEXT(GLsizei length, const char *marker)
     * }
     */
    public static void glPushGroupMarkerEXT(int length, MemorySegment marker) {
        var mh$ = glPushGroupMarkerEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPushGroupMarkerEXT", length, marker);
            }
            mh$.invokeExact(length, marker);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPopGroupMarkerEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPopGroupMarkerEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glPopGroupMarkerEXT()
     * }
     */
    public static FunctionDescriptor glPopGroupMarkerEXT$descriptor() {
        return glPopGroupMarkerEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glPopGroupMarkerEXT()
     * }
     */
    public static MethodHandle glPopGroupMarkerEXT$handle() {
        return glPopGroupMarkerEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glPopGroupMarkerEXT()
     * }
     */
    public static MemorySegment glPopGroupMarkerEXT$address() {
        return glPopGroupMarkerEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glPopGroupMarkerEXT()
     * }
     */
    public static void glPopGroupMarkerEXT() {
        var mh$ = glPopGroupMarkerEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPopGroupMarkerEXT");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDepthBoundsEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDepthBoundsEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glDepthBoundsEXT(GLclampd zmin, GLclampd zmax)
     * }
     */
    public static FunctionDescriptor glDepthBoundsEXT$descriptor() {
        return glDepthBoundsEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glDepthBoundsEXT(GLclampd zmin, GLclampd zmax)
     * }
     */
    public static MethodHandle glDepthBoundsEXT$handle() {
        return glDepthBoundsEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glDepthBoundsEXT(GLclampd zmin, GLclampd zmax)
     * }
     */
    public static MemorySegment glDepthBoundsEXT$address() {
        return glDepthBoundsEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glDepthBoundsEXT(GLclampd zmin, GLclampd zmax)
     * }
     */
    public static void glDepthBoundsEXT(double zmin, double zmax) {
        var mh$ = glDepthBoundsEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDepthBoundsEXT", zmin, zmax);
            }
            mh$.invokeExact(zmin, zmax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColorMaskIndexedEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColorMaskIndexedEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glColorMaskIndexedEXT(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a)
     * }
     */
    public static FunctionDescriptor glColorMaskIndexedEXT$descriptor() {
        return glColorMaskIndexedEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glColorMaskIndexedEXT(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a)
     * }
     */
    public static MethodHandle glColorMaskIndexedEXT$handle() {
        return glColorMaskIndexedEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glColorMaskIndexedEXT(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a)
     * }
     */
    public static MemorySegment glColorMaskIndexedEXT$address() {
        return glColorMaskIndexedEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glColorMaskIndexedEXT(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a)
     * }
     */
    public static void glColorMaskIndexedEXT(int index, byte r, byte g, byte b, byte a) {
        var mh$ = glColorMaskIndexedEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColorMaskIndexedEXT", index, r, g, b, a);
            }
            mh$.invokeExact(index, r, g, b, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEnableIndexedEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glEnableIndexedEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glEnableIndexedEXT(GLenum target, GLuint index)
     * }
     */
    public static FunctionDescriptor glEnableIndexedEXT$descriptor() {
        return glEnableIndexedEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glEnableIndexedEXT(GLenum target, GLuint index)
     * }
     */
    public static MethodHandle glEnableIndexedEXT$handle() {
        return glEnableIndexedEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glEnableIndexedEXT(GLenum target, GLuint index)
     * }
     */
    public static MemorySegment glEnableIndexedEXT$address() {
        return glEnableIndexedEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glEnableIndexedEXT(GLenum target, GLuint index)
     * }
     */
    public static void glEnableIndexedEXT(int target, int index) {
        var mh$ = glEnableIndexedEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEnableIndexedEXT", target, index);
            }
            mh$.invokeExact(target, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDisableIndexedEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDisableIndexedEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glDisableIndexedEXT(GLenum target, GLuint index)
     * }
     */
    public static FunctionDescriptor glDisableIndexedEXT$descriptor() {
        return glDisableIndexedEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glDisableIndexedEXT(GLenum target, GLuint index)
     * }
     */
    public static MethodHandle glDisableIndexedEXT$handle() {
        return glDisableIndexedEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glDisableIndexedEXT(GLenum target, GLuint index)
     * }
     */
    public static MemorySegment glDisableIndexedEXT$address() {
        return glDisableIndexedEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glDisableIndexedEXT(GLenum target, GLuint index)
     * }
     */
    public static void glDisableIndexedEXT(int target, int index) {
        var mh$ = glDisableIndexedEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDisableIndexedEXT", target, index);
            }
            mh$.invokeExact(target, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIsEnabledIndexedEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glIsEnabledIndexedEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLboolean glIsEnabledIndexedEXT(GLenum target, GLuint index)
     * }
     */
    public static FunctionDescriptor glIsEnabledIndexedEXT$descriptor() {
        return glIsEnabledIndexedEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLboolean glIsEnabledIndexedEXT(GLenum target, GLuint index)
     * }
     */
    public static MethodHandle glIsEnabledIndexedEXT$handle() {
        return glIsEnabledIndexedEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLboolean glIsEnabledIndexedEXT(GLenum target, GLuint index)
     * }
     */
    public static MemorySegment glIsEnabledIndexedEXT$address() {
        return glIsEnabledIndexedEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLboolean glIsEnabledIndexedEXT(GLenum target, GLuint index)
     * }
     */
    public static byte glIsEnabledIndexedEXT(int target, int index) {
        var mh$ = glIsEnabledIndexedEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIsEnabledIndexedEXT", target, index);
            }
            return (byte)mh$.invokeExact(target, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDrawRangeElementsEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDrawRangeElementsEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glDrawRangeElementsEXT(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)
     * }
     */
    public static FunctionDescriptor glDrawRangeElementsEXT$descriptor() {
        return glDrawRangeElementsEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glDrawRangeElementsEXT(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)
     * }
     */
    public static MethodHandle glDrawRangeElementsEXT$handle() {
        return glDrawRangeElementsEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glDrawRangeElementsEXT(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)
     * }
     */
    public static MemorySegment glDrawRangeElementsEXT$address() {
        return glDrawRangeElementsEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glDrawRangeElementsEXT(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)
     * }
     */
    public static void glDrawRangeElementsEXT(int mode, int start, int end, int count, int type, MemorySegment indices) {
        var mh$ = glDrawRangeElementsEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDrawRangeElementsEXT", mode, start, end, count, type, indices);
            }
            mh$.invokeExact(mode, start, end, count, type, indices);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFogCoordfEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFogCoordfEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glFogCoordfEXT(GLfloat coord)
     * }
     */
    public static FunctionDescriptor glFogCoordfEXT$descriptor() {
        return glFogCoordfEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glFogCoordfEXT(GLfloat coord)
     * }
     */
    public static MethodHandle glFogCoordfEXT$handle() {
        return glFogCoordfEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glFogCoordfEXT(GLfloat coord)
     * }
     */
    public static MemorySegment glFogCoordfEXT$address() {
        return glFogCoordfEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glFogCoordfEXT(GLfloat coord)
     * }
     */
    public static void glFogCoordfEXT(float coord) {
        var mh$ = glFogCoordfEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFogCoordfEXT", coord);
            }
            mh$.invokeExact(coord);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFogCoordfvEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFogCoordfvEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glFogCoordfvEXT(const GLfloat *coord)
     * }
     */
    public static FunctionDescriptor glFogCoordfvEXT$descriptor() {
        return glFogCoordfvEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glFogCoordfvEXT(const GLfloat *coord)
     * }
     */
    public static MethodHandle glFogCoordfvEXT$handle() {
        return glFogCoordfvEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glFogCoordfvEXT(const GLfloat *coord)
     * }
     */
    public static MemorySegment glFogCoordfvEXT$address() {
        return glFogCoordfvEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glFogCoordfvEXT(const GLfloat *coord)
     * }
     */
    public static void glFogCoordfvEXT(MemorySegment coord) {
        var mh$ = glFogCoordfvEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFogCoordfvEXT", coord);
            }
            mh$.invokeExact(coord);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFogCoorddEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFogCoorddEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glFogCoorddEXT(GLdouble coord)
     * }
     */
    public static FunctionDescriptor glFogCoorddEXT$descriptor() {
        return glFogCoorddEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glFogCoorddEXT(GLdouble coord)
     * }
     */
    public static MethodHandle glFogCoorddEXT$handle() {
        return glFogCoorddEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glFogCoorddEXT(GLdouble coord)
     * }
     */
    public static MemorySegment glFogCoorddEXT$address() {
        return glFogCoorddEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glFogCoorddEXT(GLdouble coord)
     * }
     */
    public static void glFogCoorddEXT(double coord) {
        var mh$ = glFogCoorddEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFogCoorddEXT", coord);
            }
            mh$.invokeExact(coord);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFogCoorddvEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFogCoorddvEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glFogCoorddvEXT(const GLdouble *coord)
     * }
     */
    public static FunctionDescriptor glFogCoorddvEXT$descriptor() {
        return glFogCoorddvEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glFogCoorddvEXT(const GLdouble *coord)
     * }
     */
    public static MethodHandle glFogCoorddvEXT$handle() {
        return glFogCoorddvEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glFogCoorddvEXT(const GLdouble *coord)
     * }
     */
    public static MemorySegment glFogCoorddvEXT$address() {
        return glFogCoorddvEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glFogCoorddvEXT(const GLdouble *coord)
     * }
     */
    public static void glFogCoorddvEXT(MemorySegment coord) {
        var mh$ = glFogCoorddvEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFogCoorddvEXT", coord);
            }
            mh$.invokeExact(coord);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFogCoordPointerEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFogCoordPointerEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glFogCoordPointerEXT(GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static FunctionDescriptor glFogCoordPointerEXT$descriptor() {
        return glFogCoordPointerEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glFogCoordPointerEXT(GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MethodHandle glFogCoordPointerEXT$handle() {
        return glFogCoordPointerEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glFogCoordPointerEXT(GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MemorySegment glFogCoordPointerEXT$address() {
        return glFogCoordPointerEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glFogCoordPointerEXT(GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static void glFogCoordPointerEXT(int type, int stride, MemorySegment pointer) {
        var mh$ = glFogCoordPointerEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFogCoordPointerEXT", type, stride, pointer);
            }
            mh$.invokeExact(type, stride, pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBlitFramebufferEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glBlitFramebufferEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glBlitFramebufferEXT(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
     * }
     */
    public static FunctionDescriptor glBlitFramebufferEXT$descriptor() {
        return glBlitFramebufferEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glBlitFramebufferEXT(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
     * }
     */
    public static MethodHandle glBlitFramebufferEXT$handle() {
        return glBlitFramebufferEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glBlitFramebufferEXT(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
     * }
     */
    public static MemorySegment glBlitFramebufferEXT$address() {
        return glBlitFramebufferEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glBlitFramebufferEXT(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
     * }
     */
    public static void glBlitFramebufferEXT(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, int mask, int filter) {
        var mh$ = glBlitFramebufferEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBlitFramebufferEXT", srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
            }
            mh$.invokeExact(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRenderbufferStorageMultisampleEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRenderbufferStorageMultisampleEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glRenderbufferStorageMultisampleEXT(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
     * }
     */
    public static FunctionDescriptor glRenderbufferStorageMultisampleEXT$descriptor() {
        return glRenderbufferStorageMultisampleEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glRenderbufferStorageMultisampleEXT(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
     * }
     */
    public static MethodHandle glRenderbufferStorageMultisampleEXT$handle() {
        return glRenderbufferStorageMultisampleEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glRenderbufferStorageMultisampleEXT(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
     * }
     */
    public static MemorySegment glRenderbufferStorageMultisampleEXT$address() {
        return glRenderbufferStorageMultisampleEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glRenderbufferStorageMultisampleEXT(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
     * }
     */
    public static void glRenderbufferStorageMultisampleEXT(int target, int samples, int internalformat, int width, int height) {
        var mh$ = glRenderbufferStorageMultisampleEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRenderbufferStorageMultisampleEXT", target, samples, internalformat, width, height);
            }
            mh$.invokeExact(target, samples, internalformat, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIsRenderbufferEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glIsRenderbufferEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLboolean glIsRenderbufferEXT(GLuint renderbuffer)
     * }
     */
    public static FunctionDescriptor glIsRenderbufferEXT$descriptor() {
        return glIsRenderbufferEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLboolean glIsRenderbufferEXT(GLuint renderbuffer)
     * }
     */
    public static MethodHandle glIsRenderbufferEXT$handle() {
        return glIsRenderbufferEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLboolean glIsRenderbufferEXT(GLuint renderbuffer)
     * }
     */
    public static MemorySegment glIsRenderbufferEXT$address() {
        return glIsRenderbufferEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLboolean glIsRenderbufferEXT(GLuint renderbuffer)
     * }
     */
    public static byte glIsRenderbufferEXT(int renderbuffer) {
        var mh$ = glIsRenderbufferEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIsRenderbufferEXT", renderbuffer);
            }
            return (byte)mh$.invokeExact(renderbuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBindRenderbufferEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glBindRenderbufferEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glBindRenderbufferEXT(GLenum target, GLuint renderbuffer)
     * }
     */
    public static FunctionDescriptor glBindRenderbufferEXT$descriptor() {
        return glBindRenderbufferEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glBindRenderbufferEXT(GLenum target, GLuint renderbuffer)
     * }
     */
    public static MethodHandle glBindRenderbufferEXT$handle() {
        return glBindRenderbufferEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glBindRenderbufferEXT(GLenum target, GLuint renderbuffer)
     * }
     */
    public static MemorySegment glBindRenderbufferEXT$address() {
        return glBindRenderbufferEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glBindRenderbufferEXT(GLenum target, GLuint renderbuffer)
     * }
     */
    public static void glBindRenderbufferEXT(int target, int renderbuffer) {
        var mh$ = glBindRenderbufferEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBindRenderbufferEXT", target, renderbuffer);
            }
            mh$.invokeExact(target, renderbuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDeleteRenderbuffersEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDeleteRenderbuffersEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glDeleteRenderbuffersEXT(GLsizei n, const GLuint *renderbuffers)
     * }
     */
    public static FunctionDescriptor glDeleteRenderbuffersEXT$descriptor() {
        return glDeleteRenderbuffersEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glDeleteRenderbuffersEXT(GLsizei n, const GLuint *renderbuffers)
     * }
     */
    public static MethodHandle glDeleteRenderbuffersEXT$handle() {
        return glDeleteRenderbuffersEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glDeleteRenderbuffersEXT(GLsizei n, const GLuint *renderbuffers)
     * }
     */
    public static MemorySegment glDeleteRenderbuffersEXT$address() {
        return glDeleteRenderbuffersEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glDeleteRenderbuffersEXT(GLsizei n, const GLuint *renderbuffers)
     * }
     */
    public static void glDeleteRenderbuffersEXT(int n, MemorySegment renderbuffers) {
        var mh$ = glDeleteRenderbuffersEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDeleteRenderbuffersEXT", n, renderbuffers);
            }
            mh$.invokeExact(n, renderbuffers);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGenRenderbuffersEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGenRenderbuffersEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGenRenderbuffersEXT(GLsizei n, GLuint *renderbuffers)
     * }
     */
    public static FunctionDescriptor glGenRenderbuffersEXT$descriptor() {
        return glGenRenderbuffersEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGenRenderbuffersEXT(GLsizei n, GLuint *renderbuffers)
     * }
     */
    public static MethodHandle glGenRenderbuffersEXT$handle() {
        return glGenRenderbuffersEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGenRenderbuffersEXT(GLsizei n, GLuint *renderbuffers)
     * }
     */
    public static MemorySegment glGenRenderbuffersEXT$address() {
        return glGenRenderbuffersEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGenRenderbuffersEXT(GLsizei n, GLuint *renderbuffers)
     * }
     */
    public static void glGenRenderbuffersEXT(int n, MemorySegment renderbuffers) {
        var mh$ = glGenRenderbuffersEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGenRenderbuffersEXT", n, renderbuffers);
            }
            mh$.invokeExact(n, renderbuffers);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRenderbufferStorageEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRenderbufferStorageEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glRenderbufferStorageEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
     * }
     */
    public static FunctionDescriptor glRenderbufferStorageEXT$descriptor() {
        return glRenderbufferStorageEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glRenderbufferStorageEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
     * }
     */
    public static MethodHandle glRenderbufferStorageEXT$handle() {
        return glRenderbufferStorageEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glRenderbufferStorageEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
     * }
     */
    public static MemorySegment glRenderbufferStorageEXT$address() {
        return glRenderbufferStorageEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glRenderbufferStorageEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
     * }
     */
    public static void glRenderbufferStorageEXT(int target, int internalformat, int width, int height) {
        var mh$ = glRenderbufferStorageEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRenderbufferStorageEXT", target, internalformat, width, height);
            }
            mh$.invokeExact(target, internalformat, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetRenderbufferParameterivEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetRenderbufferParameterivEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetRenderbufferParameterivEXT(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetRenderbufferParameterivEXT$descriptor() {
        return glGetRenderbufferParameterivEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetRenderbufferParameterivEXT(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetRenderbufferParameterivEXT$handle() {
        return glGetRenderbufferParameterivEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetRenderbufferParameterivEXT(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetRenderbufferParameterivEXT$address() {
        return glGetRenderbufferParameterivEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetRenderbufferParameterivEXT(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static void glGetRenderbufferParameterivEXT(int target, int pname, MemorySegment params) {
        var mh$ = glGetRenderbufferParameterivEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetRenderbufferParameterivEXT", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIsFramebufferEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glIsFramebufferEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLboolean glIsFramebufferEXT(GLuint framebuffer)
     * }
     */
    public static FunctionDescriptor glIsFramebufferEXT$descriptor() {
        return glIsFramebufferEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLboolean glIsFramebufferEXT(GLuint framebuffer)
     * }
     */
    public static MethodHandle glIsFramebufferEXT$handle() {
        return glIsFramebufferEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLboolean glIsFramebufferEXT(GLuint framebuffer)
     * }
     */
    public static MemorySegment glIsFramebufferEXT$address() {
        return glIsFramebufferEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLboolean glIsFramebufferEXT(GLuint framebuffer)
     * }
     */
    public static byte glIsFramebufferEXT(int framebuffer) {
        var mh$ = glIsFramebufferEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIsFramebufferEXT", framebuffer);
            }
            return (byte)mh$.invokeExact(framebuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBindFramebufferEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glBindFramebufferEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glBindFramebufferEXT(GLenum target, GLuint framebuffer)
     * }
     */
    public static FunctionDescriptor glBindFramebufferEXT$descriptor() {
        return glBindFramebufferEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glBindFramebufferEXT(GLenum target, GLuint framebuffer)
     * }
     */
    public static MethodHandle glBindFramebufferEXT$handle() {
        return glBindFramebufferEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glBindFramebufferEXT(GLenum target, GLuint framebuffer)
     * }
     */
    public static MemorySegment glBindFramebufferEXT$address() {
        return glBindFramebufferEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glBindFramebufferEXT(GLenum target, GLuint framebuffer)
     * }
     */
    public static void glBindFramebufferEXT(int target, int framebuffer) {
        var mh$ = glBindFramebufferEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBindFramebufferEXT", target, framebuffer);
            }
            mh$.invokeExact(target, framebuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDeleteFramebuffersEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDeleteFramebuffersEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glDeleteFramebuffersEXT(GLsizei n, const GLuint *framebuffers)
     * }
     */
    public static FunctionDescriptor glDeleteFramebuffersEXT$descriptor() {
        return glDeleteFramebuffersEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glDeleteFramebuffersEXT(GLsizei n, const GLuint *framebuffers)
     * }
     */
    public static MethodHandle glDeleteFramebuffersEXT$handle() {
        return glDeleteFramebuffersEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glDeleteFramebuffersEXT(GLsizei n, const GLuint *framebuffers)
     * }
     */
    public static MemorySegment glDeleteFramebuffersEXT$address() {
        return glDeleteFramebuffersEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glDeleteFramebuffersEXT(GLsizei n, const GLuint *framebuffers)
     * }
     */
    public static void glDeleteFramebuffersEXT(int n, MemorySegment framebuffers) {
        var mh$ = glDeleteFramebuffersEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDeleteFramebuffersEXT", n, framebuffers);
            }
            mh$.invokeExact(n, framebuffers);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGenFramebuffersEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGenFramebuffersEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGenFramebuffersEXT(GLsizei n, GLuint *framebuffers)
     * }
     */
    public static FunctionDescriptor glGenFramebuffersEXT$descriptor() {
        return glGenFramebuffersEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGenFramebuffersEXT(GLsizei n, GLuint *framebuffers)
     * }
     */
    public static MethodHandle glGenFramebuffersEXT$handle() {
        return glGenFramebuffersEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGenFramebuffersEXT(GLsizei n, GLuint *framebuffers)
     * }
     */
    public static MemorySegment glGenFramebuffersEXT$address() {
        return glGenFramebuffersEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGenFramebuffersEXT(GLsizei n, GLuint *framebuffers)
     * }
     */
    public static void glGenFramebuffersEXT(int n, MemorySegment framebuffers) {
        var mh$ = glGenFramebuffersEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGenFramebuffersEXT", n, framebuffers);
            }
            mh$.invokeExact(n, framebuffers);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCheckFramebufferStatusEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glCheckFramebufferStatusEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLenum glCheckFramebufferStatusEXT(GLenum target)
     * }
     */
    public static FunctionDescriptor glCheckFramebufferStatusEXT$descriptor() {
        return glCheckFramebufferStatusEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLenum glCheckFramebufferStatusEXT(GLenum target)
     * }
     */
    public static MethodHandle glCheckFramebufferStatusEXT$handle() {
        return glCheckFramebufferStatusEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLenum glCheckFramebufferStatusEXT(GLenum target)
     * }
     */
    public static MemorySegment glCheckFramebufferStatusEXT$address() {
        return glCheckFramebufferStatusEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLenum glCheckFramebufferStatusEXT(GLenum target)
     * }
     */
    public static int glCheckFramebufferStatusEXT(int target) {
        var mh$ = glCheckFramebufferStatusEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCheckFramebufferStatusEXT", target);
            }
            return (int)mh$.invokeExact(target);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFramebufferTexture1DEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFramebufferTexture1DEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glFramebufferTexture1DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
     * }
     */
    public static FunctionDescriptor glFramebufferTexture1DEXT$descriptor() {
        return glFramebufferTexture1DEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glFramebufferTexture1DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
     * }
     */
    public static MethodHandle glFramebufferTexture1DEXT$handle() {
        return glFramebufferTexture1DEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glFramebufferTexture1DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
     * }
     */
    public static MemorySegment glFramebufferTexture1DEXT$address() {
        return glFramebufferTexture1DEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glFramebufferTexture1DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
     * }
     */
    public static void glFramebufferTexture1DEXT(int target, int attachment, int textarget, int texture, int level) {
        var mh$ = glFramebufferTexture1DEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFramebufferTexture1DEXT", target, attachment, textarget, texture, level);
            }
            mh$.invokeExact(target, attachment, textarget, texture, level);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFramebufferTexture2DEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFramebufferTexture2DEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glFramebufferTexture2DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
     * }
     */
    public static FunctionDescriptor glFramebufferTexture2DEXT$descriptor() {
        return glFramebufferTexture2DEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glFramebufferTexture2DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
     * }
     */
    public static MethodHandle glFramebufferTexture2DEXT$handle() {
        return glFramebufferTexture2DEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glFramebufferTexture2DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
     * }
     */
    public static MemorySegment glFramebufferTexture2DEXT$address() {
        return glFramebufferTexture2DEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glFramebufferTexture2DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
     * }
     */
    public static void glFramebufferTexture2DEXT(int target, int attachment, int textarget, int texture, int level) {
        var mh$ = glFramebufferTexture2DEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFramebufferTexture2DEXT", target, attachment, textarget, texture, level);
            }
            mh$.invokeExact(target, attachment, textarget, texture, level);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFramebufferTexture3DEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFramebufferTexture3DEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glFramebufferTexture3DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
     * }
     */
    public static FunctionDescriptor glFramebufferTexture3DEXT$descriptor() {
        return glFramebufferTexture3DEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glFramebufferTexture3DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
     * }
     */
    public static MethodHandle glFramebufferTexture3DEXT$handle() {
        return glFramebufferTexture3DEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glFramebufferTexture3DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
     * }
     */
    public static MemorySegment glFramebufferTexture3DEXT$address() {
        return glFramebufferTexture3DEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glFramebufferTexture3DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
     * }
     */
    public static void glFramebufferTexture3DEXT(int target, int attachment, int textarget, int texture, int level, int zoffset) {
        var mh$ = glFramebufferTexture3DEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFramebufferTexture3DEXT", target, attachment, textarget, texture, level, zoffset);
            }
            mh$.invokeExact(target, attachment, textarget, texture, level, zoffset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFramebufferRenderbufferEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFramebufferRenderbufferEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glFramebufferRenderbufferEXT(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
     * }
     */
    public static FunctionDescriptor glFramebufferRenderbufferEXT$descriptor() {
        return glFramebufferRenderbufferEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glFramebufferRenderbufferEXT(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
     * }
     */
    public static MethodHandle glFramebufferRenderbufferEXT$handle() {
        return glFramebufferRenderbufferEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glFramebufferRenderbufferEXT(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
     * }
     */
    public static MemorySegment glFramebufferRenderbufferEXT$address() {
        return glFramebufferRenderbufferEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glFramebufferRenderbufferEXT(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
     * }
     */
    public static void glFramebufferRenderbufferEXT(int target, int attachment, int renderbuffertarget, int renderbuffer) {
        var mh$ = glFramebufferRenderbufferEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFramebufferRenderbufferEXT", target, attachment, renderbuffertarget, renderbuffer);
            }
            mh$.invokeExact(target, attachment, renderbuffertarget, renderbuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetFramebufferAttachmentParameterivEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetFramebufferAttachmentParameterivEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetFramebufferAttachmentParameterivEXT(GLenum target, GLenum attachment, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetFramebufferAttachmentParameterivEXT$descriptor() {
        return glGetFramebufferAttachmentParameterivEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetFramebufferAttachmentParameterivEXT(GLenum target, GLenum attachment, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetFramebufferAttachmentParameterivEXT$handle() {
        return glGetFramebufferAttachmentParameterivEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetFramebufferAttachmentParameterivEXT(GLenum target, GLenum attachment, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetFramebufferAttachmentParameterivEXT$address() {
        return glGetFramebufferAttachmentParameterivEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetFramebufferAttachmentParameterivEXT(GLenum target, GLenum attachment, GLenum pname, GLint *params)
     * }
     */
    public static void glGetFramebufferAttachmentParameterivEXT(int target, int attachment, int pname, MemorySegment params) {
        var mh$ = glGetFramebufferAttachmentParameterivEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetFramebufferAttachmentParameterivEXT", target, attachment, pname, params);
            }
            mh$.invokeExact(target, attachment, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGenerateMipmapEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGenerateMipmapEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGenerateMipmapEXT(GLenum target)
     * }
     */
    public static FunctionDescriptor glGenerateMipmapEXT$descriptor() {
        return glGenerateMipmapEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGenerateMipmapEXT(GLenum target)
     * }
     */
    public static MethodHandle glGenerateMipmapEXT$handle() {
        return glGenerateMipmapEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGenerateMipmapEXT(GLenum target)
     * }
     */
    public static MemorySegment glGenerateMipmapEXT$address() {
        return glGenerateMipmapEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGenerateMipmapEXT(GLenum target)
     * }
     */
    public static void glGenerateMipmapEXT(int target) {
        var mh$ = glGenerateMipmapEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGenerateMipmapEXT", target);
            }
            mh$.invokeExact(target);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glProgramParameteriEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glProgramParameteriEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glProgramParameteriEXT(GLuint program, GLenum pname, GLint value)
     * }
     */
    public static FunctionDescriptor glProgramParameteriEXT$descriptor() {
        return glProgramParameteriEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glProgramParameteriEXT(GLuint program, GLenum pname, GLint value)
     * }
     */
    public static MethodHandle glProgramParameteriEXT$handle() {
        return glProgramParameteriEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glProgramParameteriEXT(GLuint program, GLenum pname, GLint value)
     * }
     */
    public static MemorySegment glProgramParameteriEXT$address() {
        return glProgramParameteriEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glProgramParameteriEXT(GLuint program, GLenum pname, GLint value)
     * }
     */
    public static void glProgramParameteriEXT(int program, int pname, int value) {
        var mh$ = glProgramParameteriEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glProgramParameteriEXT", program, pname, value);
            }
            mh$.invokeExact(program, pname, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFramebufferTextureEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFramebufferTextureEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glFramebufferTextureEXT(GLenum target, GLenum attachment, GLuint texture, GLint level)
     * }
     */
    public static FunctionDescriptor glFramebufferTextureEXT$descriptor() {
        return glFramebufferTextureEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glFramebufferTextureEXT(GLenum target, GLenum attachment, GLuint texture, GLint level)
     * }
     */
    public static MethodHandle glFramebufferTextureEXT$handle() {
        return glFramebufferTextureEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glFramebufferTextureEXT(GLenum target, GLenum attachment, GLuint texture, GLint level)
     * }
     */
    public static MemorySegment glFramebufferTextureEXT$address() {
        return glFramebufferTextureEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glFramebufferTextureEXT(GLenum target, GLenum attachment, GLuint texture, GLint level)
     * }
     */
    public static void glFramebufferTextureEXT(int target, int attachment, int texture, int level) {
        var mh$ = glFramebufferTextureEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFramebufferTextureEXT", target, attachment, texture, level);
            }
            mh$.invokeExact(target, attachment, texture, level);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFramebufferTextureFaceEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFramebufferTextureFaceEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glFramebufferTextureFaceEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face)
     * }
     */
    public static FunctionDescriptor glFramebufferTextureFaceEXT$descriptor() {
        return glFramebufferTextureFaceEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glFramebufferTextureFaceEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face)
     * }
     */
    public static MethodHandle glFramebufferTextureFaceEXT$handle() {
        return glFramebufferTextureFaceEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glFramebufferTextureFaceEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face)
     * }
     */
    public static MemorySegment glFramebufferTextureFaceEXT$address() {
        return glFramebufferTextureFaceEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glFramebufferTextureFaceEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face)
     * }
     */
    public static void glFramebufferTextureFaceEXT(int target, int attachment, int texture, int level, int face) {
        var mh$ = glFramebufferTextureFaceEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFramebufferTextureFaceEXT", target, attachment, texture, level, face);
            }
            mh$.invokeExact(target, attachment, texture, level, face);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFramebufferTextureLayerEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFramebufferTextureLayerEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glFramebufferTextureLayerEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
     * }
     */
    public static FunctionDescriptor glFramebufferTextureLayerEXT$descriptor() {
        return glFramebufferTextureLayerEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glFramebufferTextureLayerEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
     * }
     */
    public static MethodHandle glFramebufferTextureLayerEXT$handle() {
        return glFramebufferTextureLayerEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glFramebufferTextureLayerEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
     * }
     */
    public static MemorySegment glFramebufferTextureLayerEXT$address() {
        return glFramebufferTextureLayerEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glFramebufferTextureLayerEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
     * }
     */
    public static void glFramebufferTextureLayerEXT(int target, int attachment, int texture, int level, int layer) {
        var mh$ = glFramebufferTextureLayerEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFramebufferTextureLayerEXT", target, attachment, texture, level, layer);
            }
            mh$.invokeExact(target, attachment, texture, level, layer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttribI1iEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttribI1iEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttribI1iEXT(GLuint index, GLint x)
     * }
     */
    public static FunctionDescriptor glVertexAttribI1iEXT$descriptor() {
        return glVertexAttribI1iEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttribI1iEXT(GLuint index, GLint x)
     * }
     */
    public static MethodHandle glVertexAttribI1iEXT$handle() {
        return glVertexAttribI1iEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttribI1iEXT(GLuint index, GLint x)
     * }
     */
    public static MemorySegment glVertexAttribI1iEXT$address() {
        return glVertexAttribI1iEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttribI1iEXT(GLuint index, GLint x)
     * }
     */
    public static void glVertexAttribI1iEXT(int index, int x) {
        var mh$ = glVertexAttribI1iEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttribI1iEXT", index, x);
            }
            mh$.invokeExact(index, x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttribI2iEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttribI2iEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttribI2iEXT(GLuint index, GLint x, GLint y)
     * }
     */
    public static FunctionDescriptor glVertexAttribI2iEXT$descriptor() {
        return glVertexAttribI2iEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttribI2iEXT(GLuint index, GLint x, GLint y)
     * }
     */
    public static MethodHandle glVertexAttribI2iEXT$handle() {
        return glVertexAttribI2iEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttribI2iEXT(GLuint index, GLint x, GLint y)
     * }
     */
    public static MemorySegment glVertexAttribI2iEXT$address() {
        return glVertexAttribI2iEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttribI2iEXT(GLuint index, GLint x, GLint y)
     * }
     */
    public static void glVertexAttribI2iEXT(int index, int x, int y) {
        var mh$ = glVertexAttribI2iEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttribI2iEXT", index, x, y);
            }
            mh$.invokeExact(index, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttribI3iEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttribI3iEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttribI3iEXT(GLuint index, GLint x, GLint y, GLint z)
     * }
     */
    public static FunctionDescriptor glVertexAttribI3iEXT$descriptor() {
        return glVertexAttribI3iEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttribI3iEXT(GLuint index, GLint x, GLint y, GLint z)
     * }
     */
    public static MethodHandle glVertexAttribI3iEXT$handle() {
        return glVertexAttribI3iEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttribI3iEXT(GLuint index, GLint x, GLint y, GLint z)
     * }
     */
    public static MemorySegment glVertexAttribI3iEXT$address() {
        return glVertexAttribI3iEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttribI3iEXT(GLuint index, GLint x, GLint y, GLint z)
     * }
     */
    public static void glVertexAttribI3iEXT(int index, int x, int y, int z) {
        var mh$ = glVertexAttribI3iEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttribI3iEXT", index, x, y, z);
            }
            mh$.invokeExact(index, x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttribI4iEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttribI4iEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttribI4iEXT(GLuint index, GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static FunctionDescriptor glVertexAttribI4iEXT$descriptor() {
        return glVertexAttribI4iEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttribI4iEXT(GLuint index, GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static MethodHandle glVertexAttribI4iEXT$handle() {
        return glVertexAttribI4iEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttribI4iEXT(GLuint index, GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static MemorySegment glVertexAttribI4iEXT$address() {
        return glVertexAttribI4iEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttribI4iEXT(GLuint index, GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static void glVertexAttribI4iEXT(int index, int x, int y, int z, int w) {
        var mh$ = glVertexAttribI4iEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttribI4iEXT", index, x, y, z, w);
            }
            mh$.invokeExact(index, x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttribI1uiEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttribI1uiEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttribI1uiEXT(GLuint index, GLuint x)
     * }
     */
    public static FunctionDescriptor glVertexAttribI1uiEXT$descriptor() {
        return glVertexAttribI1uiEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttribI1uiEXT(GLuint index, GLuint x)
     * }
     */
    public static MethodHandle glVertexAttribI1uiEXT$handle() {
        return glVertexAttribI1uiEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttribI1uiEXT(GLuint index, GLuint x)
     * }
     */
    public static MemorySegment glVertexAttribI1uiEXT$address() {
        return glVertexAttribI1uiEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttribI1uiEXT(GLuint index, GLuint x)
     * }
     */
    public static void glVertexAttribI1uiEXT(int index, int x) {
        var mh$ = glVertexAttribI1uiEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttribI1uiEXT", index, x);
            }
            mh$.invokeExact(index, x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttribI2uiEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttribI2uiEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttribI2uiEXT(GLuint index, GLuint x, GLuint y)
     * }
     */
    public static FunctionDescriptor glVertexAttribI2uiEXT$descriptor() {
        return glVertexAttribI2uiEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttribI2uiEXT(GLuint index, GLuint x, GLuint y)
     * }
     */
    public static MethodHandle glVertexAttribI2uiEXT$handle() {
        return glVertexAttribI2uiEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttribI2uiEXT(GLuint index, GLuint x, GLuint y)
     * }
     */
    public static MemorySegment glVertexAttribI2uiEXT$address() {
        return glVertexAttribI2uiEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttribI2uiEXT(GLuint index, GLuint x, GLuint y)
     * }
     */
    public static void glVertexAttribI2uiEXT(int index, int x, int y) {
        var mh$ = glVertexAttribI2uiEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttribI2uiEXT", index, x, y);
            }
            mh$.invokeExact(index, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttribI3uiEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttribI3uiEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttribI3uiEXT(GLuint index, GLuint x, GLuint y, GLuint z)
     * }
     */
    public static FunctionDescriptor glVertexAttribI3uiEXT$descriptor() {
        return glVertexAttribI3uiEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttribI3uiEXT(GLuint index, GLuint x, GLuint y, GLuint z)
     * }
     */
    public static MethodHandle glVertexAttribI3uiEXT$handle() {
        return glVertexAttribI3uiEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttribI3uiEXT(GLuint index, GLuint x, GLuint y, GLuint z)
     * }
     */
    public static MemorySegment glVertexAttribI3uiEXT$address() {
        return glVertexAttribI3uiEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttribI3uiEXT(GLuint index, GLuint x, GLuint y, GLuint z)
     * }
     */
    public static void glVertexAttribI3uiEXT(int index, int x, int y, int z) {
        var mh$ = glVertexAttribI3uiEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttribI3uiEXT", index, x, y, z);
            }
            mh$.invokeExact(index, x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttribI4uiEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttribI4uiEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttribI4uiEXT(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
     * }
     */
    public static FunctionDescriptor glVertexAttribI4uiEXT$descriptor() {
        return glVertexAttribI4uiEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttribI4uiEXT(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
     * }
     */
    public static MethodHandle glVertexAttribI4uiEXT$handle() {
        return glVertexAttribI4uiEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttribI4uiEXT(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
     * }
     */
    public static MemorySegment glVertexAttribI4uiEXT$address() {
        return glVertexAttribI4uiEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttribI4uiEXT(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
     * }
     */
    public static void glVertexAttribI4uiEXT(int index, int x, int y, int z, int w) {
        var mh$ = glVertexAttribI4uiEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttribI4uiEXT", index, x, y, z, w);
            }
            mh$.invokeExact(index, x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttribI1ivEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttribI1ivEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttribI1ivEXT(GLuint index, const GLint *v)
     * }
     */
    public static FunctionDescriptor glVertexAttribI1ivEXT$descriptor() {
        return glVertexAttribI1ivEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttribI1ivEXT(GLuint index, const GLint *v)
     * }
     */
    public static MethodHandle glVertexAttribI1ivEXT$handle() {
        return glVertexAttribI1ivEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttribI1ivEXT(GLuint index, const GLint *v)
     * }
     */
    public static MemorySegment glVertexAttribI1ivEXT$address() {
        return glVertexAttribI1ivEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttribI1ivEXT(GLuint index, const GLint *v)
     * }
     */
    public static void glVertexAttribI1ivEXT(int index, MemorySegment v) {
        var mh$ = glVertexAttribI1ivEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttribI1ivEXT", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttribI2ivEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttribI2ivEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttribI2ivEXT(GLuint index, const GLint *v)
     * }
     */
    public static FunctionDescriptor glVertexAttribI2ivEXT$descriptor() {
        return glVertexAttribI2ivEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttribI2ivEXT(GLuint index, const GLint *v)
     * }
     */
    public static MethodHandle glVertexAttribI2ivEXT$handle() {
        return glVertexAttribI2ivEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttribI2ivEXT(GLuint index, const GLint *v)
     * }
     */
    public static MemorySegment glVertexAttribI2ivEXT$address() {
        return glVertexAttribI2ivEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttribI2ivEXT(GLuint index, const GLint *v)
     * }
     */
    public static void glVertexAttribI2ivEXT(int index, MemorySegment v) {
        var mh$ = glVertexAttribI2ivEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttribI2ivEXT", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttribI3ivEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttribI3ivEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttribI3ivEXT(GLuint index, const GLint *v)
     * }
     */
    public static FunctionDescriptor glVertexAttribI3ivEXT$descriptor() {
        return glVertexAttribI3ivEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttribI3ivEXT(GLuint index, const GLint *v)
     * }
     */
    public static MethodHandle glVertexAttribI3ivEXT$handle() {
        return glVertexAttribI3ivEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttribI3ivEXT(GLuint index, const GLint *v)
     * }
     */
    public static MemorySegment glVertexAttribI3ivEXT$address() {
        return glVertexAttribI3ivEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttribI3ivEXT(GLuint index, const GLint *v)
     * }
     */
    public static void glVertexAttribI3ivEXT(int index, MemorySegment v) {
        var mh$ = glVertexAttribI3ivEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttribI3ivEXT", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttribI4ivEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttribI4ivEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttribI4ivEXT(GLuint index, const GLint *v)
     * }
     */
    public static FunctionDescriptor glVertexAttribI4ivEXT$descriptor() {
        return glVertexAttribI4ivEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttribI4ivEXT(GLuint index, const GLint *v)
     * }
     */
    public static MethodHandle glVertexAttribI4ivEXT$handle() {
        return glVertexAttribI4ivEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttribI4ivEXT(GLuint index, const GLint *v)
     * }
     */
    public static MemorySegment glVertexAttribI4ivEXT$address() {
        return glVertexAttribI4ivEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttribI4ivEXT(GLuint index, const GLint *v)
     * }
     */
    public static void glVertexAttribI4ivEXT(int index, MemorySegment v) {
        var mh$ = glVertexAttribI4ivEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttribI4ivEXT", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttribI1uivEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttribI1uivEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttribI1uivEXT(GLuint index, const GLuint *v)
     * }
     */
    public static FunctionDescriptor glVertexAttribI1uivEXT$descriptor() {
        return glVertexAttribI1uivEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttribI1uivEXT(GLuint index, const GLuint *v)
     * }
     */
    public static MethodHandle glVertexAttribI1uivEXT$handle() {
        return glVertexAttribI1uivEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttribI1uivEXT(GLuint index, const GLuint *v)
     * }
     */
    public static MemorySegment glVertexAttribI1uivEXT$address() {
        return glVertexAttribI1uivEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttribI1uivEXT(GLuint index, const GLuint *v)
     * }
     */
    public static void glVertexAttribI1uivEXT(int index, MemorySegment v) {
        var mh$ = glVertexAttribI1uivEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttribI1uivEXT", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttribI2uivEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttribI2uivEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttribI2uivEXT(GLuint index, const GLuint *v)
     * }
     */
    public static FunctionDescriptor glVertexAttribI2uivEXT$descriptor() {
        return glVertexAttribI2uivEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttribI2uivEXT(GLuint index, const GLuint *v)
     * }
     */
    public static MethodHandle glVertexAttribI2uivEXT$handle() {
        return glVertexAttribI2uivEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttribI2uivEXT(GLuint index, const GLuint *v)
     * }
     */
    public static MemorySegment glVertexAttribI2uivEXT$address() {
        return glVertexAttribI2uivEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttribI2uivEXT(GLuint index, const GLuint *v)
     * }
     */
    public static void glVertexAttribI2uivEXT(int index, MemorySegment v) {
        var mh$ = glVertexAttribI2uivEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttribI2uivEXT", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttribI3uivEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttribI3uivEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttribI3uivEXT(GLuint index, const GLuint *v)
     * }
     */
    public static FunctionDescriptor glVertexAttribI3uivEXT$descriptor() {
        return glVertexAttribI3uivEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttribI3uivEXT(GLuint index, const GLuint *v)
     * }
     */
    public static MethodHandle glVertexAttribI3uivEXT$handle() {
        return glVertexAttribI3uivEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttribI3uivEXT(GLuint index, const GLuint *v)
     * }
     */
    public static MemorySegment glVertexAttribI3uivEXT$address() {
        return glVertexAttribI3uivEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttribI3uivEXT(GLuint index, const GLuint *v)
     * }
     */
    public static void glVertexAttribI3uivEXT(int index, MemorySegment v) {
        var mh$ = glVertexAttribI3uivEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttribI3uivEXT", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttribI4uivEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttribI4uivEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttribI4uivEXT(GLuint index, const GLuint *v)
     * }
     */
    public static FunctionDescriptor glVertexAttribI4uivEXT$descriptor() {
        return glVertexAttribI4uivEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttribI4uivEXT(GLuint index, const GLuint *v)
     * }
     */
    public static MethodHandle glVertexAttribI4uivEXT$handle() {
        return glVertexAttribI4uivEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttribI4uivEXT(GLuint index, const GLuint *v)
     * }
     */
    public static MemorySegment glVertexAttribI4uivEXT$address() {
        return glVertexAttribI4uivEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttribI4uivEXT(GLuint index, const GLuint *v)
     * }
     */
    public static void glVertexAttribI4uivEXT(int index, MemorySegment v) {
        var mh$ = glVertexAttribI4uivEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttribI4uivEXT", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttribI4bvEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttribI4bvEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttribI4bvEXT(GLuint index, const GLbyte *v)
     * }
     */
    public static FunctionDescriptor glVertexAttribI4bvEXT$descriptor() {
        return glVertexAttribI4bvEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttribI4bvEXT(GLuint index, const GLbyte *v)
     * }
     */
    public static MethodHandle glVertexAttribI4bvEXT$handle() {
        return glVertexAttribI4bvEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttribI4bvEXT(GLuint index, const GLbyte *v)
     * }
     */
    public static MemorySegment glVertexAttribI4bvEXT$address() {
        return glVertexAttribI4bvEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttribI4bvEXT(GLuint index, const GLbyte *v)
     * }
     */
    public static void glVertexAttribI4bvEXT(int index, MemorySegment v) {
        var mh$ = glVertexAttribI4bvEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttribI4bvEXT", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttribI4svEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttribI4svEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttribI4svEXT(GLuint index, const GLshort *v)
     * }
     */
    public static FunctionDescriptor glVertexAttribI4svEXT$descriptor() {
        return glVertexAttribI4svEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttribI4svEXT(GLuint index, const GLshort *v)
     * }
     */
    public static MethodHandle glVertexAttribI4svEXT$handle() {
        return glVertexAttribI4svEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttribI4svEXT(GLuint index, const GLshort *v)
     * }
     */
    public static MemorySegment glVertexAttribI4svEXT$address() {
        return glVertexAttribI4svEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttribI4svEXT(GLuint index, const GLshort *v)
     * }
     */
    public static void glVertexAttribI4svEXT(int index, MemorySegment v) {
        var mh$ = glVertexAttribI4svEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttribI4svEXT", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttribI4ubvEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttribI4ubvEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttribI4ubvEXT(GLuint index, const GLubyte *v)
     * }
     */
    public static FunctionDescriptor glVertexAttribI4ubvEXT$descriptor() {
        return glVertexAttribI4ubvEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttribI4ubvEXT(GLuint index, const GLubyte *v)
     * }
     */
    public static MethodHandle glVertexAttribI4ubvEXT$handle() {
        return glVertexAttribI4ubvEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttribI4ubvEXT(GLuint index, const GLubyte *v)
     * }
     */
    public static MemorySegment glVertexAttribI4ubvEXT$address() {
        return glVertexAttribI4ubvEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttribI4ubvEXT(GLuint index, const GLubyte *v)
     * }
     */
    public static void glVertexAttribI4ubvEXT(int index, MemorySegment v) {
        var mh$ = glVertexAttribI4ubvEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttribI4ubvEXT", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttribI4usvEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttribI4usvEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttribI4usvEXT(GLuint index, const GLushort *v)
     * }
     */
    public static FunctionDescriptor glVertexAttribI4usvEXT$descriptor() {
        return glVertexAttribI4usvEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttribI4usvEXT(GLuint index, const GLushort *v)
     * }
     */
    public static MethodHandle glVertexAttribI4usvEXT$handle() {
        return glVertexAttribI4usvEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttribI4usvEXT(GLuint index, const GLushort *v)
     * }
     */
    public static MemorySegment glVertexAttribI4usvEXT$address() {
        return glVertexAttribI4usvEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttribI4usvEXT(GLuint index, const GLushort *v)
     * }
     */
    public static void glVertexAttribI4usvEXT(int index, MemorySegment v) {
        var mh$ = glVertexAttribI4usvEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttribI4usvEXT", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttribIPointerEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttribIPointerEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttribIPointerEXT(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static FunctionDescriptor glVertexAttribIPointerEXT$descriptor() {
        return glVertexAttribIPointerEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttribIPointerEXT(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MethodHandle glVertexAttribIPointerEXT$handle() {
        return glVertexAttribIPointerEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttribIPointerEXT(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MemorySegment glVertexAttribIPointerEXT$address() {
        return glVertexAttribIPointerEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttribIPointerEXT(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static void glVertexAttribIPointerEXT(int index, int size, int type, int stride, MemorySegment pointer) {
        var mh$ = glVertexAttribIPointerEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttribIPointerEXT", index, size, type, stride, pointer);
            }
            mh$.invokeExact(index, size, type, stride, pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetVertexAttribIivEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetVertexAttribIivEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetVertexAttribIivEXT(GLuint index, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetVertexAttribIivEXT$descriptor() {
        return glGetVertexAttribIivEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetVertexAttribIivEXT(GLuint index, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetVertexAttribIivEXT$handle() {
        return glGetVertexAttribIivEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetVertexAttribIivEXT(GLuint index, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetVertexAttribIivEXT$address() {
        return glGetVertexAttribIivEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetVertexAttribIivEXT(GLuint index, GLenum pname, GLint *params)
     * }
     */
    public static void glGetVertexAttribIivEXT(int index, int pname, MemorySegment params) {
        var mh$ = glGetVertexAttribIivEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetVertexAttribIivEXT", index, pname, params);
            }
            mh$.invokeExact(index, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetVertexAttribIuivEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetVertexAttribIuivEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetVertexAttribIuivEXT(GLuint index, GLenum pname, GLuint *params)
     * }
     */
    public static FunctionDescriptor glGetVertexAttribIuivEXT$descriptor() {
        return glGetVertexAttribIuivEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetVertexAttribIuivEXT(GLuint index, GLenum pname, GLuint *params)
     * }
     */
    public static MethodHandle glGetVertexAttribIuivEXT$handle() {
        return glGetVertexAttribIuivEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetVertexAttribIuivEXT(GLuint index, GLenum pname, GLuint *params)
     * }
     */
    public static MemorySegment glGetVertexAttribIuivEXT$address() {
        return glGetVertexAttribIuivEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetVertexAttribIuivEXT(GLuint index, GLenum pname, GLuint *params)
     * }
     */
    public static void glGetVertexAttribIuivEXT(int index, int pname, MemorySegment params) {
        var mh$ = glGetVertexAttribIuivEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetVertexAttribIuivEXT", index, pname, params);
            }
            mh$.invokeExact(index, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniform1uiEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniform1uiEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniform1uiEXT(GLint location, GLuint v0)
     * }
     */
    public static FunctionDescriptor glUniform1uiEXT$descriptor() {
        return glUniform1uiEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniform1uiEXT(GLint location, GLuint v0)
     * }
     */
    public static MethodHandle glUniform1uiEXT$handle() {
        return glUniform1uiEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniform1uiEXT(GLint location, GLuint v0)
     * }
     */
    public static MemorySegment glUniform1uiEXT$address() {
        return glUniform1uiEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniform1uiEXT(GLint location, GLuint v0)
     * }
     */
    public static void glUniform1uiEXT(int location, int v0) {
        var mh$ = glUniform1uiEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniform1uiEXT", location, v0);
            }
            mh$.invokeExact(location, v0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniform2uiEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniform2uiEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniform2uiEXT(GLint location, GLuint v0, GLuint v1)
     * }
     */
    public static FunctionDescriptor glUniform2uiEXT$descriptor() {
        return glUniform2uiEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniform2uiEXT(GLint location, GLuint v0, GLuint v1)
     * }
     */
    public static MethodHandle glUniform2uiEXT$handle() {
        return glUniform2uiEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniform2uiEXT(GLint location, GLuint v0, GLuint v1)
     * }
     */
    public static MemorySegment glUniform2uiEXT$address() {
        return glUniform2uiEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniform2uiEXT(GLint location, GLuint v0, GLuint v1)
     * }
     */
    public static void glUniform2uiEXT(int location, int v0, int v1) {
        var mh$ = glUniform2uiEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniform2uiEXT", location, v0, v1);
            }
            mh$.invokeExact(location, v0, v1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniform3uiEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniform3uiEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniform3uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2)
     * }
     */
    public static FunctionDescriptor glUniform3uiEXT$descriptor() {
        return glUniform3uiEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniform3uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2)
     * }
     */
    public static MethodHandle glUniform3uiEXT$handle() {
        return glUniform3uiEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniform3uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2)
     * }
     */
    public static MemorySegment glUniform3uiEXT$address() {
        return glUniform3uiEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniform3uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2)
     * }
     */
    public static void glUniform3uiEXT(int location, int v0, int v1, int v2) {
        var mh$ = glUniform3uiEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniform3uiEXT", location, v0, v1, v2);
            }
            mh$.invokeExact(location, v0, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniform4uiEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniform4uiEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniform4uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
     * }
     */
    public static FunctionDescriptor glUniform4uiEXT$descriptor() {
        return glUniform4uiEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniform4uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
     * }
     */
    public static MethodHandle glUniform4uiEXT$handle() {
        return glUniform4uiEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniform4uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
     * }
     */
    public static MemorySegment glUniform4uiEXT$address() {
        return glUniform4uiEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniform4uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
     * }
     */
    public static void glUniform4uiEXT(int location, int v0, int v1, int v2, int v3) {
        var mh$ = glUniform4uiEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniform4uiEXT", location, v0, v1, v2, v3);
            }
            mh$.invokeExact(location, v0, v1, v2, v3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniform1uivEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniform1uivEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniform1uivEXT(GLint location, GLsizei count, const GLuint *value)
     * }
     */
    public static FunctionDescriptor glUniform1uivEXT$descriptor() {
        return glUniform1uivEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniform1uivEXT(GLint location, GLsizei count, const GLuint *value)
     * }
     */
    public static MethodHandle glUniform1uivEXT$handle() {
        return glUniform1uivEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniform1uivEXT(GLint location, GLsizei count, const GLuint *value)
     * }
     */
    public static MemorySegment glUniform1uivEXT$address() {
        return glUniform1uivEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniform1uivEXT(GLint location, GLsizei count, const GLuint *value)
     * }
     */
    public static void glUniform1uivEXT(int location, int count, MemorySegment value) {
        var mh$ = glUniform1uivEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniform1uivEXT", location, count, value);
            }
            mh$.invokeExact(location, count, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniform2uivEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniform2uivEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniform2uivEXT(GLint location, GLsizei count, const GLuint *value)
     * }
     */
    public static FunctionDescriptor glUniform2uivEXT$descriptor() {
        return glUniform2uivEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniform2uivEXT(GLint location, GLsizei count, const GLuint *value)
     * }
     */
    public static MethodHandle glUniform2uivEXT$handle() {
        return glUniform2uivEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniform2uivEXT(GLint location, GLsizei count, const GLuint *value)
     * }
     */
    public static MemorySegment glUniform2uivEXT$address() {
        return glUniform2uivEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniform2uivEXT(GLint location, GLsizei count, const GLuint *value)
     * }
     */
    public static void glUniform2uivEXT(int location, int count, MemorySegment value) {
        var mh$ = glUniform2uivEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniform2uivEXT", location, count, value);
            }
            mh$.invokeExact(location, count, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniform3uivEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniform3uivEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniform3uivEXT(GLint location, GLsizei count, const GLuint *value)
     * }
     */
    public static FunctionDescriptor glUniform3uivEXT$descriptor() {
        return glUniform3uivEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniform3uivEXT(GLint location, GLsizei count, const GLuint *value)
     * }
     */
    public static MethodHandle glUniform3uivEXT$handle() {
        return glUniform3uivEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniform3uivEXT(GLint location, GLsizei count, const GLuint *value)
     * }
     */
    public static MemorySegment glUniform3uivEXT$address() {
        return glUniform3uivEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniform3uivEXT(GLint location, GLsizei count, const GLuint *value)
     * }
     */
    public static void glUniform3uivEXT(int location, int count, MemorySegment value) {
        var mh$ = glUniform3uivEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniform3uivEXT", location, count, value);
            }
            mh$.invokeExact(location, count, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniform4uivEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniform4uivEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniform4uivEXT(GLint location, GLsizei count, const GLuint *value)
     * }
     */
    public static FunctionDescriptor glUniform4uivEXT$descriptor() {
        return glUniform4uivEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniform4uivEXT(GLint location, GLsizei count, const GLuint *value)
     * }
     */
    public static MethodHandle glUniform4uivEXT$handle() {
        return glUniform4uivEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniform4uivEXT(GLint location, GLsizei count, const GLuint *value)
     * }
     */
    public static MemorySegment glUniform4uivEXT$address() {
        return glUniform4uivEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniform4uivEXT(GLint location, GLsizei count, const GLuint *value)
     * }
     */
    public static void glUniform4uivEXT(int location, int count, MemorySegment value) {
        var mh$ = glUniform4uivEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniform4uivEXT", location, count, value);
            }
            mh$.invokeExact(location, count, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetUniformuivEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetUniformuivEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetUniformuivEXT(GLuint program, GLint location, GLuint *params)
     * }
     */
    public static FunctionDescriptor glGetUniformuivEXT$descriptor() {
        return glGetUniformuivEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetUniformuivEXT(GLuint program, GLint location, GLuint *params)
     * }
     */
    public static MethodHandle glGetUniformuivEXT$handle() {
        return glGetUniformuivEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetUniformuivEXT(GLuint program, GLint location, GLuint *params)
     * }
     */
    public static MemorySegment glGetUniformuivEXT$address() {
        return glGetUniformuivEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetUniformuivEXT(GLuint program, GLint location, GLuint *params)
     * }
     */
    public static void glGetUniformuivEXT(int program, int location, MemorySegment params) {
        var mh$ = glGetUniformuivEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetUniformuivEXT", program, location, params);
            }
            mh$.invokeExact(program, location, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBindFragDataLocationEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glBindFragDataLocationEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glBindFragDataLocationEXT(GLuint program, GLuint colorNumber, const GLchar *name)
     * }
     */
    public static FunctionDescriptor glBindFragDataLocationEXT$descriptor() {
        return glBindFragDataLocationEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glBindFragDataLocationEXT(GLuint program, GLuint colorNumber, const GLchar *name)
     * }
     */
    public static MethodHandle glBindFragDataLocationEXT$handle() {
        return glBindFragDataLocationEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glBindFragDataLocationEXT(GLuint program, GLuint colorNumber, const GLchar *name)
     * }
     */
    public static MemorySegment glBindFragDataLocationEXT$address() {
        return glBindFragDataLocationEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glBindFragDataLocationEXT(GLuint program, GLuint colorNumber, const GLchar *name)
     * }
     */
    public static void glBindFragDataLocationEXT(int program, int colorNumber, MemorySegment name) {
        var mh$ = glBindFragDataLocationEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBindFragDataLocationEXT", program, colorNumber, name);
            }
            mh$.invokeExact(program, colorNumber, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetFragDataLocationEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetFragDataLocationEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLint glGetFragDataLocationEXT(GLuint program, const GLchar *name)
     * }
     */
    public static FunctionDescriptor glGetFragDataLocationEXT$descriptor() {
        return glGetFragDataLocationEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLint glGetFragDataLocationEXT(GLuint program, const GLchar *name)
     * }
     */
    public static MethodHandle glGetFragDataLocationEXT$handle() {
        return glGetFragDataLocationEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLint glGetFragDataLocationEXT(GLuint program, const GLchar *name)
     * }
     */
    public static MemorySegment glGetFragDataLocationEXT$address() {
        return glGetFragDataLocationEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLint glGetFragDataLocationEXT(GLuint program, const GLchar *name)
     * }
     */
    public static int glGetFragDataLocationEXT(int program, MemorySegment name) {
        var mh$ = glGetFragDataLocationEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetFragDataLocationEXT", program, name);
            }
            return (int)mh$.invokeExact(program, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiDrawArraysEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiDrawArraysEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiDrawArraysEXT(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount)
     * }
     */
    public static FunctionDescriptor glMultiDrawArraysEXT$descriptor() {
        return glMultiDrawArraysEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiDrawArraysEXT(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount)
     * }
     */
    public static MethodHandle glMultiDrawArraysEXT$handle() {
        return glMultiDrawArraysEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiDrawArraysEXT(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount)
     * }
     */
    public static MemorySegment glMultiDrawArraysEXT$address() {
        return glMultiDrawArraysEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiDrawArraysEXT(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount)
     * }
     */
    public static void glMultiDrawArraysEXT(int mode, MemorySegment first, MemorySegment count, int primcount) {
        var mh$ = glMultiDrawArraysEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiDrawArraysEXT", mode, first, count, primcount);
            }
            mh$.invokeExact(mode, first, count, primcount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiDrawElementsEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiDrawElementsEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiDrawElementsEXT(GLenum mode, const GLsizei *count, GLenum type, const GLvoid *const *indices, GLsizei primcount)
     * }
     */
    public static FunctionDescriptor glMultiDrawElementsEXT$descriptor() {
        return glMultiDrawElementsEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiDrawElementsEXT(GLenum mode, const GLsizei *count, GLenum type, const GLvoid *const *indices, GLsizei primcount)
     * }
     */
    public static MethodHandle glMultiDrawElementsEXT$handle() {
        return glMultiDrawElementsEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiDrawElementsEXT(GLenum mode, const GLsizei *count, GLenum type, const GLvoid *const *indices, GLsizei primcount)
     * }
     */
    public static MemorySegment glMultiDrawElementsEXT$address() {
        return glMultiDrawElementsEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiDrawElementsEXT(GLenum mode, const GLsizei *count, GLenum type, const GLvoid *const *indices, GLsizei primcount)
     * }
     */
    public static void glMultiDrawElementsEXT(int mode, MemorySegment count, int type, MemorySegment indices, int primcount) {
        var mh$ = glMultiDrawElementsEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiDrawElementsEXT", mode, count, type, indices, primcount);
            }
            mh$.invokeExact(mode, count, type, indices, primcount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glProvokingVertexEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glProvokingVertexEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glProvokingVertexEXT(GLenum mode)
     * }
     */
    public static FunctionDescriptor glProvokingVertexEXT$descriptor() {
        return glProvokingVertexEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glProvokingVertexEXT(GLenum mode)
     * }
     */
    public static MethodHandle glProvokingVertexEXT$handle() {
        return glProvokingVertexEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glProvokingVertexEXT(GLenum mode)
     * }
     */
    public static MemorySegment glProvokingVertexEXT$address() {
        return glProvokingVertexEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glProvokingVertexEXT(GLenum mode)
     * }
     */
    public static void glProvokingVertexEXT(int mode) {
        var mh$ = glProvokingVertexEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glProvokingVertexEXT", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSecondaryColor3bEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glSecondaryColor3bEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3bEXT(GLbyte red, GLbyte green, GLbyte blue)
     * }
     */
    public static FunctionDescriptor glSecondaryColor3bEXT$descriptor() {
        return glSecondaryColor3bEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3bEXT(GLbyte red, GLbyte green, GLbyte blue)
     * }
     */
    public static MethodHandle glSecondaryColor3bEXT$handle() {
        return glSecondaryColor3bEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3bEXT(GLbyte red, GLbyte green, GLbyte blue)
     * }
     */
    public static MemorySegment glSecondaryColor3bEXT$address() {
        return glSecondaryColor3bEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glSecondaryColor3bEXT(GLbyte red, GLbyte green, GLbyte blue)
     * }
     */
    public static void glSecondaryColor3bEXT(byte red, byte green, byte blue) {
        var mh$ = glSecondaryColor3bEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSecondaryColor3bEXT", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSecondaryColor3bvEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glSecondaryColor3bvEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3bvEXT(const GLbyte *v)
     * }
     */
    public static FunctionDescriptor glSecondaryColor3bvEXT$descriptor() {
        return glSecondaryColor3bvEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3bvEXT(const GLbyte *v)
     * }
     */
    public static MethodHandle glSecondaryColor3bvEXT$handle() {
        return glSecondaryColor3bvEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3bvEXT(const GLbyte *v)
     * }
     */
    public static MemorySegment glSecondaryColor3bvEXT$address() {
        return glSecondaryColor3bvEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glSecondaryColor3bvEXT(const GLbyte *v)
     * }
     */
    public static void glSecondaryColor3bvEXT(MemorySegment v) {
        var mh$ = glSecondaryColor3bvEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSecondaryColor3bvEXT", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSecondaryColor3dEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glSecondaryColor3dEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3dEXT(GLdouble red, GLdouble green, GLdouble blue)
     * }
     */
    public static FunctionDescriptor glSecondaryColor3dEXT$descriptor() {
        return glSecondaryColor3dEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3dEXT(GLdouble red, GLdouble green, GLdouble blue)
     * }
     */
    public static MethodHandle glSecondaryColor3dEXT$handle() {
        return glSecondaryColor3dEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3dEXT(GLdouble red, GLdouble green, GLdouble blue)
     * }
     */
    public static MemorySegment glSecondaryColor3dEXT$address() {
        return glSecondaryColor3dEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glSecondaryColor3dEXT(GLdouble red, GLdouble green, GLdouble blue)
     * }
     */
    public static void glSecondaryColor3dEXT(double red, double green, double blue) {
        var mh$ = glSecondaryColor3dEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSecondaryColor3dEXT", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSecondaryColor3dvEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glSecondaryColor3dvEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3dvEXT(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glSecondaryColor3dvEXT$descriptor() {
        return glSecondaryColor3dvEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3dvEXT(const GLdouble *v)
     * }
     */
    public static MethodHandle glSecondaryColor3dvEXT$handle() {
        return glSecondaryColor3dvEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3dvEXT(const GLdouble *v)
     * }
     */
    public static MemorySegment glSecondaryColor3dvEXT$address() {
        return glSecondaryColor3dvEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glSecondaryColor3dvEXT(const GLdouble *v)
     * }
     */
    public static void glSecondaryColor3dvEXT(MemorySegment v) {
        var mh$ = glSecondaryColor3dvEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSecondaryColor3dvEXT", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSecondaryColor3fEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glSecondaryColor3fEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3fEXT(GLfloat red, GLfloat green, GLfloat blue)
     * }
     */
    public static FunctionDescriptor glSecondaryColor3fEXT$descriptor() {
        return glSecondaryColor3fEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3fEXT(GLfloat red, GLfloat green, GLfloat blue)
     * }
     */
    public static MethodHandle glSecondaryColor3fEXT$handle() {
        return glSecondaryColor3fEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3fEXT(GLfloat red, GLfloat green, GLfloat blue)
     * }
     */
    public static MemorySegment glSecondaryColor3fEXT$address() {
        return glSecondaryColor3fEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glSecondaryColor3fEXT(GLfloat red, GLfloat green, GLfloat blue)
     * }
     */
    public static void glSecondaryColor3fEXT(float red, float green, float blue) {
        var mh$ = glSecondaryColor3fEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSecondaryColor3fEXT", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSecondaryColor3fvEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glSecondaryColor3fvEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3fvEXT(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glSecondaryColor3fvEXT$descriptor() {
        return glSecondaryColor3fvEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3fvEXT(const GLfloat *v)
     * }
     */
    public static MethodHandle glSecondaryColor3fvEXT$handle() {
        return glSecondaryColor3fvEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3fvEXT(const GLfloat *v)
     * }
     */
    public static MemorySegment glSecondaryColor3fvEXT$address() {
        return glSecondaryColor3fvEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glSecondaryColor3fvEXT(const GLfloat *v)
     * }
     */
    public static void glSecondaryColor3fvEXT(MemorySegment v) {
        var mh$ = glSecondaryColor3fvEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSecondaryColor3fvEXT", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSecondaryColor3iEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glSecondaryColor3iEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3iEXT(GLint red, GLint green, GLint blue)
     * }
     */
    public static FunctionDescriptor glSecondaryColor3iEXT$descriptor() {
        return glSecondaryColor3iEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3iEXT(GLint red, GLint green, GLint blue)
     * }
     */
    public static MethodHandle glSecondaryColor3iEXT$handle() {
        return glSecondaryColor3iEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3iEXT(GLint red, GLint green, GLint blue)
     * }
     */
    public static MemorySegment glSecondaryColor3iEXT$address() {
        return glSecondaryColor3iEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glSecondaryColor3iEXT(GLint red, GLint green, GLint blue)
     * }
     */
    public static void glSecondaryColor3iEXT(int red, int green, int blue) {
        var mh$ = glSecondaryColor3iEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSecondaryColor3iEXT", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSecondaryColor3ivEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glSecondaryColor3ivEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3ivEXT(const GLint *v)
     * }
     */
    public static FunctionDescriptor glSecondaryColor3ivEXT$descriptor() {
        return glSecondaryColor3ivEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3ivEXT(const GLint *v)
     * }
     */
    public static MethodHandle glSecondaryColor3ivEXT$handle() {
        return glSecondaryColor3ivEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3ivEXT(const GLint *v)
     * }
     */
    public static MemorySegment glSecondaryColor3ivEXT$address() {
        return glSecondaryColor3ivEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glSecondaryColor3ivEXT(const GLint *v)
     * }
     */
    public static void glSecondaryColor3ivEXT(MemorySegment v) {
        var mh$ = glSecondaryColor3ivEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSecondaryColor3ivEXT", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSecondaryColor3sEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glSecondaryColor3sEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3sEXT(GLshort red, GLshort green, GLshort blue)
     * }
     */
    public static FunctionDescriptor glSecondaryColor3sEXT$descriptor() {
        return glSecondaryColor3sEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3sEXT(GLshort red, GLshort green, GLshort blue)
     * }
     */
    public static MethodHandle glSecondaryColor3sEXT$handle() {
        return glSecondaryColor3sEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3sEXT(GLshort red, GLshort green, GLshort blue)
     * }
     */
    public static MemorySegment glSecondaryColor3sEXT$address() {
        return glSecondaryColor3sEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glSecondaryColor3sEXT(GLshort red, GLshort green, GLshort blue)
     * }
     */
    public static void glSecondaryColor3sEXT(short red, short green, short blue) {
        var mh$ = glSecondaryColor3sEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSecondaryColor3sEXT", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSecondaryColor3svEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glSecondaryColor3svEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3svEXT(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glSecondaryColor3svEXT$descriptor() {
        return glSecondaryColor3svEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3svEXT(const GLshort *v)
     * }
     */
    public static MethodHandle glSecondaryColor3svEXT$handle() {
        return glSecondaryColor3svEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3svEXT(const GLshort *v)
     * }
     */
    public static MemorySegment glSecondaryColor3svEXT$address() {
        return glSecondaryColor3svEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glSecondaryColor3svEXT(const GLshort *v)
     * }
     */
    public static void glSecondaryColor3svEXT(MemorySegment v) {
        var mh$ = glSecondaryColor3svEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSecondaryColor3svEXT", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSecondaryColor3ubEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glSecondaryColor3ubEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3ubEXT(GLubyte red, GLubyte green, GLubyte blue)
     * }
     */
    public static FunctionDescriptor glSecondaryColor3ubEXT$descriptor() {
        return glSecondaryColor3ubEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3ubEXT(GLubyte red, GLubyte green, GLubyte blue)
     * }
     */
    public static MethodHandle glSecondaryColor3ubEXT$handle() {
        return glSecondaryColor3ubEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3ubEXT(GLubyte red, GLubyte green, GLubyte blue)
     * }
     */
    public static MemorySegment glSecondaryColor3ubEXT$address() {
        return glSecondaryColor3ubEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glSecondaryColor3ubEXT(GLubyte red, GLubyte green, GLubyte blue)
     * }
     */
    public static void glSecondaryColor3ubEXT(byte red, byte green, byte blue) {
        var mh$ = glSecondaryColor3ubEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSecondaryColor3ubEXT", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSecondaryColor3ubvEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glSecondaryColor3ubvEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3ubvEXT(const GLubyte *v)
     * }
     */
    public static FunctionDescriptor glSecondaryColor3ubvEXT$descriptor() {
        return glSecondaryColor3ubvEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3ubvEXT(const GLubyte *v)
     * }
     */
    public static MethodHandle glSecondaryColor3ubvEXT$handle() {
        return glSecondaryColor3ubvEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3ubvEXT(const GLubyte *v)
     * }
     */
    public static MemorySegment glSecondaryColor3ubvEXT$address() {
        return glSecondaryColor3ubvEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glSecondaryColor3ubvEXT(const GLubyte *v)
     * }
     */
    public static void glSecondaryColor3ubvEXT(MemorySegment v) {
        var mh$ = glSecondaryColor3ubvEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSecondaryColor3ubvEXT", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSecondaryColor3uiEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glSecondaryColor3uiEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3uiEXT(GLuint red, GLuint green, GLuint blue)
     * }
     */
    public static FunctionDescriptor glSecondaryColor3uiEXT$descriptor() {
        return glSecondaryColor3uiEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3uiEXT(GLuint red, GLuint green, GLuint blue)
     * }
     */
    public static MethodHandle glSecondaryColor3uiEXT$handle() {
        return glSecondaryColor3uiEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3uiEXT(GLuint red, GLuint green, GLuint blue)
     * }
     */
    public static MemorySegment glSecondaryColor3uiEXT$address() {
        return glSecondaryColor3uiEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glSecondaryColor3uiEXT(GLuint red, GLuint green, GLuint blue)
     * }
     */
    public static void glSecondaryColor3uiEXT(int red, int green, int blue) {
        var mh$ = glSecondaryColor3uiEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSecondaryColor3uiEXT", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSecondaryColor3uivEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glSecondaryColor3uivEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3uivEXT(const GLuint *v)
     * }
     */
    public static FunctionDescriptor glSecondaryColor3uivEXT$descriptor() {
        return glSecondaryColor3uivEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3uivEXT(const GLuint *v)
     * }
     */
    public static MethodHandle glSecondaryColor3uivEXT$handle() {
        return glSecondaryColor3uivEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3uivEXT(const GLuint *v)
     * }
     */
    public static MemorySegment glSecondaryColor3uivEXT$address() {
        return glSecondaryColor3uivEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glSecondaryColor3uivEXT(const GLuint *v)
     * }
     */
    public static void glSecondaryColor3uivEXT(MemorySegment v) {
        var mh$ = glSecondaryColor3uivEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSecondaryColor3uivEXT", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSecondaryColor3usEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glSecondaryColor3usEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3usEXT(GLushort red, GLushort green, GLushort blue)
     * }
     */
    public static FunctionDescriptor glSecondaryColor3usEXT$descriptor() {
        return glSecondaryColor3usEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3usEXT(GLushort red, GLushort green, GLushort blue)
     * }
     */
    public static MethodHandle glSecondaryColor3usEXT$handle() {
        return glSecondaryColor3usEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3usEXT(GLushort red, GLushort green, GLushort blue)
     * }
     */
    public static MemorySegment glSecondaryColor3usEXT$address() {
        return glSecondaryColor3usEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glSecondaryColor3usEXT(GLushort red, GLushort green, GLushort blue)
     * }
     */
    public static void glSecondaryColor3usEXT(short red, short green, short blue) {
        var mh$ = glSecondaryColor3usEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSecondaryColor3usEXT", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSecondaryColor3usvEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glSecondaryColor3usvEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3usvEXT(const GLushort *v)
     * }
     */
    public static FunctionDescriptor glSecondaryColor3usvEXT$descriptor() {
        return glSecondaryColor3usvEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3usvEXT(const GLushort *v)
     * }
     */
    public static MethodHandle glSecondaryColor3usvEXT$handle() {
        return glSecondaryColor3usvEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3usvEXT(const GLushort *v)
     * }
     */
    public static MemorySegment glSecondaryColor3usvEXT$address() {
        return glSecondaryColor3usvEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glSecondaryColor3usvEXT(const GLushort *v)
     * }
     */
    public static void glSecondaryColor3usvEXT(MemorySegment v) {
        var mh$ = glSecondaryColor3usvEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSecondaryColor3usvEXT", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSecondaryColorPointerEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glSecondaryColorPointerEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glSecondaryColorPointerEXT(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static FunctionDescriptor glSecondaryColorPointerEXT$descriptor() {
        return glSecondaryColorPointerEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glSecondaryColorPointerEXT(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MethodHandle glSecondaryColorPointerEXT$handle() {
        return glSecondaryColorPointerEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glSecondaryColorPointerEXT(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MemorySegment glSecondaryColorPointerEXT$address() {
        return glSecondaryColorPointerEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glSecondaryColorPointerEXT(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static void glSecondaryColorPointerEXT(int size, int type, int stride, MemorySegment pointer) {
        var mh$ = glSecondaryColorPointerEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSecondaryColorPointerEXT", size, type, stride, pointer);
            }
            mh$.invokeExact(size, type, stride, pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glActiveStencilFaceEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glActiveStencilFaceEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glActiveStencilFaceEXT(GLenum face)
     * }
     */
    public static FunctionDescriptor glActiveStencilFaceEXT$descriptor() {
        return glActiveStencilFaceEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glActiveStencilFaceEXT(GLenum face)
     * }
     */
    public static MethodHandle glActiveStencilFaceEXT$handle() {
        return glActiveStencilFaceEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glActiveStencilFaceEXT(GLenum face)
     * }
     */
    public static MemorySegment glActiveStencilFaceEXT$address() {
        return glActiveStencilFaceEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glActiveStencilFaceEXT(GLenum face)
     * }
     */
    public static void glActiveStencilFaceEXT(int face) {
        var mh$ = glActiveStencilFaceEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glActiveStencilFaceEXT", face);
            }
            mh$.invokeExact(face);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glClearColorIiEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glClearColorIiEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glClearColorIiEXT(GLint r, GLint g, GLint b, GLint a)
     * }
     */
    public static FunctionDescriptor glClearColorIiEXT$descriptor() {
        return glClearColorIiEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glClearColorIiEXT(GLint r, GLint g, GLint b, GLint a)
     * }
     */
    public static MethodHandle glClearColorIiEXT$handle() {
        return glClearColorIiEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glClearColorIiEXT(GLint r, GLint g, GLint b, GLint a)
     * }
     */
    public static MemorySegment glClearColorIiEXT$address() {
        return glClearColorIiEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glClearColorIiEXT(GLint r, GLint g, GLint b, GLint a)
     * }
     */
    public static void glClearColorIiEXT(int r, int g, int b, int a) {
        var mh$ = glClearColorIiEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClearColorIiEXT", r, g, b, a);
            }
            mh$.invokeExact(r, g, b, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glClearColorIuiEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glClearColorIuiEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glClearColorIuiEXT(GLuint r, GLuint g, GLuint b, GLuint a)
     * }
     */
    public static FunctionDescriptor glClearColorIuiEXT$descriptor() {
        return glClearColorIuiEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glClearColorIuiEXT(GLuint r, GLuint g, GLuint b, GLuint a)
     * }
     */
    public static MethodHandle glClearColorIuiEXT$handle() {
        return glClearColorIuiEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glClearColorIuiEXT(GLuint r, GLuint g, GLuint b, GLuint a)
     * }
     */
    public static MemorySegment glClearColorIuiEXT$address() {
        return glClearColorIuiEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glClearColorIuiEXT(GLuint r, GLuint g, GLuint b, GLuint a)
     * }
     */
    public static void glClearColorIuiEXT(int r, int g, int b, int a) {
        var mh$ = glClearColorIuiEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClearColorIuiEXT", r, g, b, a);
            }
            mh$.invokeExact(r, g, b, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexParameterIivEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexParameterIivEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexParameterIivEXT(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glTexParameterIivEXT$descriptor() {
        return glTexParameterIivEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexParameterIivEXT(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glTexParameterIivEXT$handle() {
        return glTexParameterIivEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexParameterIivEXT(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glTexParameterIivEXT$address() {
        return glTexParameterIivEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexParameterIivEXT(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static void glTexParameterIivEXT(int target, int pname, MemorySegment params) {
        var mh$ = glTexParameterIivEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexParameterIivEXT", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexParameterIuivEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexParameterIuivEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexParameterIuivEXT(GLenum target, GLenum pname, GLuint *params)
     * }
     */
    public static FunctionDescriptor glTexParameterIuivEXT$descriptor() {
        return glTexParameterIuivEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexParameterIuivEXT(GLenum target, GLenum pname, GLuint *params)
     * }
     */
    public static MethodHandle glTexParameterIuivEXT$handle() {
        return glTexParameterIuivEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexParameterIuivEXT(GLenum target, GLenum pname, GLuint *params)
     * }
     */
    public static MemorySegment glTexParameterIuivEXT$address() {
        return glTexParameterIuivEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexParameterIuivEXT(GLenum target, GLenum pname, GLuint *params)
     * }
     */
    public static void glTexParameterIuivEXT(int target, int pname, MemorySegment params) {
        var mh$ = glTexParameterIuivEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexParameterIuivEXT", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexParameterIivEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetTexParameterIivEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetTexParameterIivEXT(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetTexParameterIivEXT$descriptor() {
        return glGetTexParameterIivEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetTexParameterIivEXT(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetTexParameterIivEXT$handle() {
        return glGetTexParameterIivEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetTexParameterIivEXT(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetTexParameterIivEXT$address() {
        return glGetTexParameterIivEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetTexParameterIivEXT(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static void glGetTexParameterIivEXT(int target, int pname, MemorySegment params) {
        var mh$ = glGetTexParameterIivEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexParameterIivEXT", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexParameterIuivEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetTexParameterIuivEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetTexParameterIuivEXT(GLenum target, GLenum pname, GLuint *params)
     * }
     */
    public static FunctionDescriptor glGetTexParameterIuivEXT$descriptor() {
        return glGetTexParameterIuivEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetTexParameterIuivEXT(GLenum target, GLenum pname, GLuint *params)
     * }
     */
    public static MethodHandle glGetTexParameterIuivEXT$handle() {
        return glGetTexParameterIuivEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetTexParameterIuivEXT(GLenum target, GLenum pname, GLuint *params)
     * }
     */
    public static MemorySegment glGetTexParameterIuivEXT$address() {
        return glGetTexParameterIuivEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetTexParameterIuivEXT(GLenum target, GLenum pname, GLuint *params)
     * }
     */
    public static void glGetTexParameterIuivEXT(int target, int pname, MemorySegment params) {
        var mh$ = glGetTexParameterIuivEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexParameterIuivEXT", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetQueryObjecti64vEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetQueryObjecti64vEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetQueryObjecti64vEXT(GLuint id, GLenum pname, GLint64EXT *params)
     * }
     */
    public static FunctionDescriptor glGetQueryObjecti64vEXT$descriptor() {
        return glGetQueryObjecti64vEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetQueryObjecti64vEXT(GLuint id, GLenum pname, GLint64EXT *params)
     * }
     */
    public static MethodHandle glGetQueryObjecti64vEXT$handle() {
        return glGetQueryObjecti64vEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetQueryObjecti64vEXT(GLuint id, GLenum pname, GLint64EXT *params)
     * }
     */
    public static MemorySegment glGetQueryObjecti64vEXT$address() {
        return glGetQueryObjecti64vEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetQueryObjecti64vEXT(GLuint id, GLenum pname, GLint64EXT *params)
     * }
     */
    public static void glGetQueryObjecti64vEXT(int id, int pname, MemorySegment params) {
        var mh$ = glGetQueryObjecti64vEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetQueryObjecti64vEXT", id, pname, params);
            }
            mh$.invokeExact(id, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetQueryObjectui64vEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetQueryObjectui64vEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetQueryObjectui64vEXT(GLuint id, GLenum pname, GLuint64EXT *params)
     * }
     */
    public static FunctionDescriptor glGetQueryObjectui64vEXT$descriptor() {
        return glGetQueryObjectui64vEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetQueryObjectui64vEXT(GLuint id, GLenum pname, GLuint64EXT *params)
     * }
     */
    public static MethodHandle glGetQueryObjectui64vEXT$handle() {
        return glGetQueryObjectui64vEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetQueryObjectui64vEXT(GLuint id, GLenum pname, GLuint64EXT *params)
     * }
     */
    public static MemorySegment glGetQueryObjectui64vEXT$address() {
        return glGetQueryObjectui64vEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetQueryObjectui64vEXT(GLuint id, GLenum pname, GLuint64EXT *params)
     * }
     */
    public static void glGetQueryObjectui64vEXT(int id, int pname, MemorySegment params) {
        var mh$ = glGetQueryObjectui64vEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetQueryObjectui64vEXT", id, pname, params);
            }
            mh$.invokeExact(id, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBindBufferRangeEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glBindBufferRangeEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glBindBufferRangeEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)
     * }
     */
    public static FunctionDescriptor glBindBufferRangeEXT$descriptor() {
        return glBindBufferRangeEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glBindBufferRangeEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)
     * }
     */
    public static MethodHandle glBindBufferRangeEXT$handle() {
        return glBindBufferRangeEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glBindBufferRangeEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)
     * }
     */
    public static MemorySegment glBindBufferRangeEXT$address() {
        return glBindBufferRangeEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glBindBufferRangeEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)
     * }
     */
    public static void glBindBufferRangeEXT(int target, int index, int buffer, long offset, long size) {
        var mh$ = glBindBufferRangeEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBindBufferRangeEXT", target, index, buffer, offset, size);
            }
            mh$.invokeExact(target, index, buffer, offset, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBindBufferOffsetEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glBindBufferOffsetEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glBindBufferOffsetEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset)
     * }
     */
    public static FunctionDescriptor glBindBufferOffsetEXT$descriptor() {
        return glBindBufferOffsetEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glBindBufferOffsetEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset)
     * }
     */
    public static MethodHandle glBindBufferOffsetEXT$handle() {
        return glBindBufferOffsetEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glBindBufferOffsetEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset)
     * }
     */
    public static MemorySegment glBindBufferOffsetEXT$address() {
        return glBindBufferOffsetEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glBindBufferOffsetEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset)
     * }
     */
    public static void glBindBufferOffsetEXT(int target, int index, int buffer, long offset) {
        var mh$ = glBindBufferOffsetEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBindBufferOffsetEXT", target, index, buffer, offset);
            }
            mh$.invokeExact(target, index, buffer, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBindBufferBaseEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glBindBufferBaseEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glBindBufferBaseEXT(GLenum target, GLuint index, GLuint buffer)
     * }
     */
    public static FunctionDescriptor glBindBufferBaseEXT$descriptor() {
        return glBindBufferBaseEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glBindBufferBaseEXT(GLenum target, GLuint index, GLuint buffer)
     * }
     */
    public static MethodHandle glBindBufferBaseEXT$handle() {
        return glBindBufferBaseEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glBindBufferBaseEXT(GLenum target, GLuint index, GLuint buffer)
     * }
     */
    public static MemorySegment glBindBufferBaseEXT$address() {
        return glBindBufferBaseEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glBindBufferBaseEXT(GLenum target, GLuint index, GLuint buffer)
     * }
     */
    public static void glBindBufferBaseEXT(int target, int index, int buffer) {
        var mh$ = glBindBufferBaseEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBindBufferBaseEXT", target, index, buffer);
            }
            mh$.invokeExact(target, index, buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBeginTransformFeedbackEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glBeginTransformFeedbackEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glBeginTransformFeedbackEXT(GLenum primitiveMode)
     * }
     */
    public static FunctionDescriptor glBeginTransformFeedbackEXT$descriptor() {
        return glBeginTransformFeedbackEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glBeginTransformFeedbackEXT(GLenum primitiveMode)
     * }
     */
    public static MethodHandle glBeginTransformFeedbackEXT$handle() {
        return glBeginTransformFeedbackEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glBeginTransformFeedbackEXT(GLenum primitiveMode)
     * }
     */
    public static MemorySegment glBeginTransformFeedbackEXT$address() {
        return glBeginTransformFeedbackEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glBeginTransformFeedbackEXT(GLenum primitiveMode)
     * }
     */
    public static void glBeginTransformFeedbackEXT(int primitiveMode) {
        var mh$ = glBeginTransformFeedbackEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBeginTransformFeedbackEXT", primitiveMode);
            }
            mh$.invokeExact(primitiveMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEndTransformFeedbackEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glEndTransformFeedbackEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glEndTransformFeedbackEXT()
     * }
     */
    public static FunctionDescriptor glEndTransformFeedbackEXT$descriptor() {
        return glEndTransformFeedbackEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glEndTransformFeedbackEXT()
     * }
     */
    public static MethodHandle glEndTransformFeedbackEXT$handle() {
        return glEndTransformFeedbackEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glEndTransformFeedbackEXT()
     * }
     */
    public static MemorySegment glEndTransformFeedbackEXT$address() {
        return glEndTransformFeedbackEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glEndTransformFeedbackEXT()
     * }
     */
    public static void glEndTransformFeedbackEXT() {
        var mh$ = glEndTransformFeedbackEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEndTransformFeedbackEXT");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTransformFeedbackVaryingsEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTransformFeedbackVaryingsEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTransformFeedbackVaryingsEXT(GLuint program, GLsizei count, const GLchar *const *varyings, GLenum bufferMode)
     * }
     */
    public static FunctionDescriptor glTransformFeedbackVaryingsEXT$descriptor() {
        return glTransformFeedbackVaryingsEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTransformFeedbackVaryingsEXT(GLuint program, GLsizei count, const GLchar *const *varyings, GLenum bufferMode)
     * }
     */
    public static MethodHandle glTransformFeedbackVaryingsEXT$handle() {
        return glTransformFeedbackVaryingsEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTransformFeedbackVaryingsEXT(GLuint program, GLsizei count, const GLchar *const *varyings, GLenum bufferMode)
     * }
     */
    public static MemorySegment glTransformFeedbackVaryingsEXT$address() {
        return glTransformFeedbackVaryingsEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTransformFeedbackVaryingsEXT(GLuint program, GLsizei count, const GLchar *const *varyings, GLenum bufferMode)
     * }
     */
    public static void glTransformFeedbackVaryingsEXT(int program, int count, MemorySegment varyings, int bufferMode) {
        var mh$ = glTransformFeedbackVaryingsEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTransformFeedbackVaryingsEXT", program, count, varyings, bufferMode);
            }
            mh$.invokeExact(program, count, varyings, bufferMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTransformFeedbackVaryingEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetTransformFeedbackVaryingEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetTransformFeedbackVaryingEXT(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name)
     * }
     */
    public static FunctionDescriptor glGetTransformFeedbackVaryingEXT$descriptor() {
        return glGetTransformFeedbackVaryingEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetTransformFeedbackVaryingEXT(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name)
     * }
     */
    public static MethodHandle glGetTransformFeedbackVaryingEXT$handle() {
        return glGetTransformFeedbackVaryingEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetTransformFeedbackVaryingEXT(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name)
     * }
     */
    public static MemorySegment glGetTransformFeedbackVaryingEXT$address() {
        return glGetTransformFeedbackVaryingEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetTransformFeedbackVaryingEXT(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name)
     * }
     */
    public static void glGetTransformFeedbackVaryingEXT(int program, int index, int bufSize, MemorySegment length, MemorySegment size, MemorySegment type, MemorySegment name) {
        var mh$ = glGetTransformFeedbackVaryingEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTransformFeedbackVaryingEXT", program, index, bufSize, length, size, type, name);
            }
            mh$.invokeExact(program, index, bufSize, length, size, type, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetIntegerIndexedvEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetIntegerIndexedvEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetIntegerIndexedvEXT(GLenum param, GLuint index, GLint *values)
     * }
     */
    public static FunctionDescriptor glGetIntegerIndexedvEXT$descriptor() {
        return glGetIntegerIndexedvEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetIntegerIndexedvEXT(GLenum param, GLuint index, GLint *values)
     * }
     */
    public static MethodHandle glGetIntegerIndexedvEXT$handle() {
        return glGetIntegerIndexedvEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetIntegerIndexedvEXT(GLenum param, GLuint index, GLint *values)
     * }
     */
    public static MemorySegment glGetIntegerIndexedvEXT$address() {
        return glGetIntegerIndexedvEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetIntegerIndexedvEXT(GLenum param, GLuint index, GLint *values)
     * }
     */
    public static void glGetIntegerIndexedvEXT(int param, int index, MemorySegment values) {
        var mh$ = glGetIntegerIndexedvEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetIntegerIndexedvEXT", param, index, values);
            }
            mh$.invokeExact(param, index, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetBooleanIndexedvEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetBooleanIndexedvEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetBooleanIndexedvEXT(GLenum param, GLuint index, GLboolean *values)
     * }
     */
    public static FunctionDescriptor glGetBooleanIndexedvEXT$descriptor() {
        return glGetBooleanIndexedvEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetBooleanIndexedvEXT(GLenum param, GLuint index, GLboolean *values)
     * }
     */
    public static MethodHandle glGetBooleanIndexedvEXT$handle() {
        return glGetBooleanIndexedvEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetBooleanIndexedvEXT(GLenum param, GLuint index, GLboolean *values)
     * }
     */
    public static MemorySegment glGetBooleanIndexedvEXT$address() {
        return glGetBooleanIndexedvEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetBooleanIndexedvEXT(GLenum param, GLuint index, GLboolean *values)
     * }
     */
    public static void glGetBooleanIndexedvEXT(int param, int index, MemorySegment values) {
        var mh$ = glGetBooleanIndexedvEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetBooleanIndexedvEXT", param, index, values);
            }
            mh$.invokeExact(param, index, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glElementPointerAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glElementPointerAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glElementPointerAPPLE(GLenum type, const GLvoid *pointer)
     * }
     */
    public static FunctionDescriptor glElementPointerAPPLE$descriptor() {
        return glElementPointerAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glElementPointerAPPLE(GLenum type, const GLvoid *pointer)
     * }
     */
    public static MethodHandle glElementPointerAPPLE$handle() {
        return glElementPointerAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glElementPointerAPPLE(GLenum type, const GLvoid *pointer)
     * }
     */
    public static MemorySegment glElementPointerAPPLE$address() {
        return glElementPointerAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glElementPointerAPPLE(GLenum type, const GLvoid *pointer)
     * }
     */
    public static void glElementPointerAPPLE(int type, MemorySegment pointer) {
        var mh$ = glElementPointerAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glElementPointerAPPLE", type, pointer);
            }
            mh$.invokeExact(type, pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDrawElementArrayAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDrawElementArrayAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glDrawElementArrayAPPLE(GLenum mode, GLint first, GLsizei count)
     * }
     */
    public static FunctionDescriptor glDrawElementArrayAPPLE$descriptor() {
        return glDrawElementArrayAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glDrawElementArrayAPPLE(GLenum mode, GLint first, GLsizei count)
     * }
     */
    public static MethodHandle glDrawElementArrayAPPLE$handle() {
        return glDrawElementArrayAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glDrawElementArrayAPPLE(GLenum mode, GLint first, GLsizei count)
     * }
     */
    public static MemorySegment glDrawElementArrayAPPLE$address() {
        return glDrawElementArrayAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glDrawElementArrayAPPLE(GLenum mode, GLint first, GLsizei count)
     * }
     */
    public static void glDrawElementArrayAPPLE(int mode, int first, int count) {
        var mh$ = glDrawElementArrayAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDrawElementArrayAPPLE", mode, first, count);
            }
            mh$.invokeExact(mode, first, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDrawRangeElementArrayAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDrawRangeElementArrayAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count)
     * }
     */
    public static FunctionDescriptor glDrawRangeElementArrayAPPLE$descriptor() {
        return glDrawRangeElementArrayAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count)
     * }
     */
    public static MethodHandle glDrawRangeElementArrayAPPLE$handle() {
        return glDrawRangeElementArrayAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count)
     * }
     */
    public static MemorySegment glDrawRangeElementArrayAPPLE$address() {
        return glDrawRangeElementArrayAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count)
     * }
     */
    public static void glDrawRangeElementArrayAPPLE(int mode, int start, int end, int first, int count) {
        var mh$ = glDrawRangeElementArrayAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDrawRangeElementArrayAPPLE", mode, start, end, first, count);
            }
            mh$.invokeExact(mode, start, end, first, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiDrawElementArrayAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiDrawElementArrayAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiDrawElementArrayAPPLE(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount)
     * }
     */
    public static FunctionDescriptor glMultiDrawElementArrayAPPLE$descriptor() {
        return glMultiDrawElementArrayAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiDrawElementArrayAPPLE(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount)
     * }
     */
    public static MethodHandle glMultiDrawElementArrayAPPLE$handle() {
        return glMultiDrawElementArrayAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiDrawElementArrayAPPLE(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount)
     * }
     */
    public static MemorySegment glMultiDrawElementArrayAPPLE$address() {
        return glMultiDrawElementArrayAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiDrawElementArrayAPPLE(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount)
     * }
     */
    public static void glMultiDrawElementArrayAPPLE(int mode, MemorySegment first, MemorySegment count, int primcount) {
        var mh$ = glMultiDrawElementArrayAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiDrawElementArrayAPPLE", mode, first, count, primcount);
            }
            mh$.invokeExact(mode, first, count, primcount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiDrawRangeElementArrayAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiDrawRangeElementArrayAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, const GLint *first, const GLsizei *count, GLsizei primcount)
     * }
     */
    public static FunctionDescriptor glMultiDrawRangeElementArrayAPPLE$descriptor() {
        return glMultiDrawRangeElementArrayAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, const GLint *first, const GLsizei *count, GLsizei primcount)
     * }
     */
    public static MethodHandle glMultiDrawRangeElementArrayAPPLE$handle() {
        return glMultiDrawRangeElementArrayAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, const GLint *first, const GLsizei *count, GLsizei primcount)
     * }
     */
    public static MemorySegment glMultiDrawRangeElementArrayAPPLE$address() {
        return glMultiDrawRangeElementArrayAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, const GLint *first, const GLsizei *count, GLsizei primcount)
     * }
     */
    public static void glMultiDrawRangeElementArrayAPPLE(int mode, int start, int end, MemorySegment first, MemorySegment count, int primcount) {
        var mh$ = glMultiDrawRangeElementArrayAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiDrawRangeElementArrayAPPLE", mode, start, end, first, count, primcount);
            }
            mh$.invokeExact(mode, start, end, first, count, primcount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGenFencesAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGenFencesAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGenFencesAPPLE(GLsizei n, GLuint *fences)
     * }
     */
    public static FunctionDescriptor glGenFencesAPPLE$descriptor() {
        return glGenFencesAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGenFencesAPPLE(GLsizei n, GLuint *fences)
     * }
     */
    public static MethodHandle glGenFencesAPPLE$handle() {
        return glGenFencesAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGenFencesAPPLE(GLsizei n, GLuint *fences)
     * }
     */
    public static MemorySegment glGenFencesAPPLE$address() {
        return glGenFencesAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGenFencesAPPLE(GLsizei n, GLuint *fences)
     * }
     */
    public static void glGenFencesAPPLE(int n, MemorySegment fences) {
        var mh$ = glGenFencesAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGenFencesAPPLE", n, fences);
            }
            mh$.invokeExact(n, fences);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDeleteFencesAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDeleteFencesAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glDeleteFencesAPPLE(GLsizei n, const GLuint *fences)
     * }
     */
    public static FunctionDescriptor glDeleteFencesAPPLE$descriptor() {
        return glDeleteFencesAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glDeleteFencesAPPLE(GLsizei n, const GLuint *fences)
     * }
     */
    public static MethodHandle glDeleteFencesAPPLE$handle() {
        return glDeleteFencesAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glDeleteFencesAPPLE(GLsizei n, const GLuint *fences)
     * }
     */
    public static MemorySegment glDeleteFencesAPPLE$address() {
        return glDeleteFencesAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glDeleteFencesAPPLE(GLsizei n, const GLuint *fences)
     * }
     */
    public static void glDeleteFencesAPPLE(int n, MemorySegment fences) {
        var mh$ = glDeleteFencesAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDeleteFencesAPPLE", n, fences);
            }
            mh$.invokeExact(n, fences);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSetFenceAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glSetFenceAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glSetFenceAPPLE(GLuint fence)
     * }
     */
    public static FunctionDescriptor glSetFenceAPPLE$descriptor() {
        return glSetFenceAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glSetFenceAPPLE(GLuint fence)
     * }
     */
    public static MethodHandle glSetFenceAPPLE$handle() {
        return glSetFenceAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glSetFenceAPPLE(GLuint fence)
     * }
     */
    public static MemorySegment glSetFenceAPPLE$address() {
        return glSetFenceAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glSetFenceAPPLE(GLuint fence)
     * }
     */
    public static void glSetFenceAPPLE(int fence) {
        var mh$ = glSetFenceAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSetFenceAPPLE", fence);
            }
            mh$.invokeExact(fence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIsFenceAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glIsFenceAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLboolean glIsFenceAPPLE(GLuint fence)
     * }
     */
    public static FunctionDescriptor glIsFenceAPPLE$descriptor() {
        return glIsFenceAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLboolean glIsFenceAPPLE(GLuint fence)
     * }
     */
    public static MethodHandle glIsFenceAPPLE$handle() {
        return glIsFenceAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLboolean glIsFenceAPPLE(GLuint fence)
     * }
     */
    public static MemorySegment glIsFenceAPPLE$address() {
        return glIsFenceAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLboolean glIsFenceAPPLE(GLuint fence)
     * }
     */
    public static byte glIsFenceAPPLE(int fence) {
        var mh$ = glIsFenceAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIsFenceAPPLE", fence);
            }
            return (byte)mh$.invokeExact(fence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTestFenceAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTestFenceAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLboolean glTestFenceAPPLE(GLuint fence)
     * }
     */
    public static FunctionDescriptor glTestFenceAPPLE$descriptor() {
        return glTestFenceAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLboolean glTestFenceAPPLE(GLuint fence)
     * }
     */
    public static MethodHandle glTestFenceAPPLE$handle() {
        return glTestFenceAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLboolean glTestFenceAPPLE(GLuint fence)
     * }
     */
    public static MemorySegment glTestFenceAPPLE$address() {
        return glTestFenceAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLboolean glTestFenceAPPLE(GLuint fence)
     * }
     */
    public static byte glTestFenceAPPLE(int fence) {
        var mh$ = glTestFenceAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTestFenceAPPLE", fence);
            }
            return (byte)mh$.invokeExact(fence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFinishFenceAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFinishFenceAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glFinishFenceAPPLE(GLuint fence)
     * }
     */
    public static FunctionDescriptor glFinishFenceAPPLE$descriptor() {
        return glFinishFenceAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glFinishFenceAPPLE(GLuint fence)
     * }
     */
    public static MethodHandle glFinishFenceAPPLE$handle() {
        return glFinishFenceAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glFinishFenceAPPLE(GLuint fence)
     * }
     */
    public static MemorySegment glFinishFenceAPPLE$address() {
        return glFinishFenceAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glFinishFenceAPPLE(GLuint fence)
     * }
     */
    public static void glFinishFenceAPPLE(int fence) {
        var mh$ = glFinishFenceAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFinishFenceAPPLE", fence);
            }
            mh$.invokeExact(fence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTestObjectAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTestObjectAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLboolean glTestObjectAPPLE(GLenum object, GLuint name)
     * }
     */
    public static FunctionDescriptor glTestObjectAPPLE$descriptor() {
        return glTestObjectAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLboolean glTestObjectAPPLE(GLenum object, GLuint name)
     * }
     */
    public static MethodHandle glTestObjectAPPLE$handle() {
        return glTestObjectAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLboolean glTestObjectAPPLE(GLenum object, GLuint name)
     * }
     */
    public static MemorySegment glTestObjectAPPLE$address() {
        return glTestObjectAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLboolean glTestObjectAPPLE(GLenum object, GLuint name)
     * }
     */
    public static byte glTestObjectAPPLE(int object, int name) {
        var mh$ = glTestObjectAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTestObjectAPPLE", object, name);
            }
            return (byte)mh$.invokeExact(object, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFinishObjectAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFinishObjectAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glFinishObjectAPPLE(GLenum object, GLuint name)
     * }
     */
    public static FunctionDescriptor glFinishObjectAPPLE$descriptor() {
        return glFinishObjectAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glFinishObjectAPPLE(GLenum object, GLuint name)
     * }
     */
    public static MethodHandle glFinishObjectAPPLE$handle() {
        return glFinishObjectAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glFinishObjectAPPLE(GLenum object, GLuint name)
     * }
     */
    public static MemorySegment glFinishObjectAPPLE$address() {
        return glFinishObjectAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glFinishObjectAPPLE(GLenum object, GLuint name)
     * }
     */
    public static void glFinishObjectAPPLE(int object, int name) {
        var mh$ = glFinishObjectAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFinishObjectAPPLE", object, name);
            }
            mh$.invokeExact(object, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBufferParameteriAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glBufferParameteriAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glBufferParameteriAPPLE(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glBufferParameteriAPPLE$descriptor() {
        return glBufferParameteriAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glBufferParameteriAPPLE(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glBufferParameteriAPPLE$handle() {
        return glBufferParameteriAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glBufferParameteriAPPLE(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glBufferParameteriAPPLE$address() {
        return glBufferParameteriAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glBufferParameteriAPPLE(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static void glBufferParameteriAPPLE(int target, int pname, int param) {
        var mh$ = glBufferParameteriAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBufferParameteriAPPLE", target, pname, param);
            }
            mh$.invokeExact(target, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFlushMappedBufferRangeAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFlushMappedBufferRangeAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glFlushMappedBufferRangeAPPLE(GLenum target, GLintptr offset, GLsizeiptr size)
     * }
     */
    public static FunctionDescriptor glFlushMappedBufferRangeAPPLE$descriptor() {
        return glFlushMappedBufferRangeAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glFlushMappedBufferRangeAPPLE(GLenum target, GLintptr offset, GLsizeiptr size)
     * }
     */
    public static MethodHandle glFlushMappedBufferRangeAPPLE$handle() {
        return glFlushMappedBufferRangeAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glFlushMappedBufferRangeAPPLE(GLenum target, GLintptr offset, GLsizeiptr size)
     * }
     */
    public static MemorySegment glFlushMappedBufferRangeAPPLE$address() {
        return glFlushMappedBufferRangeAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glFlushMappedBufferRangeAPPLE(GLenum target, GLintptr offset, GLsizeiptr size)
     * }
     */
    public static void glFlushMappedBufferRangeAPPLE(int target, long offset, long size) {
        var mh$ = glFlushMappedBufferRangeAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFlushMappedBufferRangeAPPLE", target, offset, size);
            }
            mh$.invokeExact(target, offset, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFlushRenderAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFlushRenderAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glFlushRenderAPPLE()
     * }
     */
    public static FunctionDescriptor glFlushRenderAPPLE$descriptor() {
        return glFlushRenderAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glFlushRenderAPPLE()
     * }
     */
    public static MethodHandle glFlushRenderAPPLE$handle() {
        return glFlushRenderAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glFlushRenderAPPLE()
     * }
     */
    public static MemorySegment glFlushRenderAPPLE$address() {
        return glFlushRenderAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glFlushRenderAPPLE()
     * }
     */
    public static void glFlushRenderAPPLE() {
        var mh$ = glFlushRenderAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFlushRenderAPPLE");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFinishRenderAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFinishRenderAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glFinishRenderAPPLE()
     * }
     */
    public static FunctionDescriptor glFinishRenderAPPLE$descriptor() {
        return glFinishRenderAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glFinishRenderAPPLE()
     * }
     */
    public static MethodHandle glFinishRenderAPPLE$handle() {
        return glFinishRenderAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glFinishRenderAPPLE()
     * }
     */
    public static MemorySegment glFinishRenderAPPLE$address() {
        return glFinishRenderAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glFinishRenderAPPLE()
     * }
     */
    public static void glFinishRenderAPPLE() {
        var mh$ = glFinishRenderAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFinishRenderAPPLE");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSwapAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glSwapAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glSwapAPPLE()
     * }
     */
    public static FunctionDescriptor glSwapAPPLE$descriptor() {
        return glSwapAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glSwapAPPLE()
     * }
     */
    public static MethodHandle glSwapAPPLE$handle() {
        return glSwapAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glSwapAPPLE()
     * }
     */
    public static MemorySegment glSwapAPPLE$address() {
        return glSwapAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glSwapAPPLE()
     * }
     */
    public static void glSwapAPPLE() {
        var mh$ = glSwapAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSwapAPPLE");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glObjectPurgeableAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glObjectPurgeableAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLenum glObjectPurgeableAPPLE(GLenum objectType, GLuint name, GLenum option)
     * }
     */
    public static FunctionDescriptor glObjectPurgeableAPPLE$descriptor() {
        return glObjectPurgeableAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLenum glObjectPurgeableAPPLE(GLenum objectType, GLuint name, GLenum option)
     * }
     */
    public static MethodHandle glObjectPurgeableAPPLE$handle() {
        return glObjectPurgeableAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLenum glObjectPurgeableAPPLE(GLenum objectType, GLuint name, GLenum option)
     * }
     */
    public static MemorySegment glObjectPurgeableAPPLE$address() {
        return glObjectPurgeableAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLenum glObjectPurgeableAPPLE(GLenum objectType, GLuint name, GLenum option)
     * }
     */
    public static int glObjectPurgeableAPPLE(int objectType, int name, int option) {
        var mh$ = glObjectPurgeableAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glObjectPurgeableAPPLE", objectType, name, option);
            }
            return (int)mh$.invokeExact(objectType, name, option);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glObjectUnpurgeableAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glObjectUnpurgeableAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLenum glObjectUnpurgeableAPPLE(GLenum objectType, GLuint name, GLenum option)
     * }
     */
    public static FunctionDescriptor glObjectUnpurgeableAPPLE$descriptor() {
        return glObjectUnpurgeableAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLenum glObjectUnpurgeableAPPLE(GLenum objectType, GLuint name, GLenum option)
     * }
     */
    public static MethodHandle glObjectUnpurgeableAPPLE$handle() {
        return glObjectUnpurgeableAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLenum glObjectUnpurgeableAPPLE(GLenum objectType, GLuint name, GLenum option)
     * }
     */
    public static MemorySegment glObjectUnpurgeableAPPLE$address() {
        return glObjectUnpurgeableAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLenum glObjectUnpurgeableAPPLE(GLenum objectType, GLuint name, GLenum option)
     * }
     */
    public static int glObjectUnpurgeableAPPLE(int objectType, int name, int option) {
        var mh$ = glObjectUnpurgeableAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glObjectUnpurgeableAPPLE", objectType, name, option);
            }
            return (int)mh$.invokeExact(objectType, name, option);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetObjectParameterivAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetObjectParameterivAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetObjectParameterivAPPLE(GLenum objectType, GLuint name, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetObjectParameterivAPPLE$descriptor() {
        return glGetObjectParameterivAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetObjectParameterivAPPLE(GLenum objectType, GLuint name, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetObjectParameterivAPPLE$handle() {
        return glGetObjectParameterivAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetObjectParameterivAPPLE(GLenum objectType, GLuint name, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetObjectParameterivAPPLE$address() {
        return glGetObjectParameterivAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetObjectParameterivAPPLE(GLenum objectType, GLuint name, GLenum pname, GLint *params)
     * }
     */
    public static void glGetObjectParameterivAPPLE(int objectType, int name, int pname, MemorySegment params) {
        var mh$ = glGetObjectParameterivAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetObjectParameterivAPPLE", objectType, name, pname, params);
            }
            mh$.invokeExact(objectType, name, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTextureRangeAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTextureRangeAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTextureRangeAPPLE(GLenum target, GLsizei length, const GLvoid *pointer)
     * }
     */
    public static FunctionDescriptor glTextureRangeAPPLE$descriptor() {
        return glTextureRangeAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTextureRangeAPPLE(GLenum target, GLsizei length, const GLvoid *pointer)
     * }
     */
    public static MethodHandle glTextureRangeAPPLE$handle() {
        return glTextureRangeAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTextureRangeAPPLE(GLenum target, GLsizei length, const GLvoid *pointer)
     * }
     */
    public static MemorySegment glTextureRangeAPPLE$address() {
        return glTextureRangeAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTextureRangeAPPLE(GLenum target, GLsizei length, const GLvoid *pointer)
     * }
     */
    public static void glTextureRangeAPPLE(int target, int length, MemorySegment pointer) {
        var mh$ = glTextureRangeAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTextureRangeAPPLE", target, length, pointer);
            }
            mh$.invokeExact(target, length, pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexParameterPointervAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetTexParameterPointervAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetTexParameterPointervAPPLE(GLenum target, GLenum pname, GLvoid **params)
     * }
     */
    public static FunctionDescriptor glGetTexParameterPointervAPPLE$descriptor() {
        return glGetTexParameterPointervAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetTexParameterPointervAPPLE(GLenum target, GLenum pname, GLvoid **params)
     * }
     */
    public static MethodHandle glGetTexParameterPointervAPPLE$handle() {
        return glGetTexParameterPointervAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetTexParameterPointervAPPLE(GLenum target, GLenum pname, GLvoid **params)
     * }
     */
    public static MemorySegment glGetTexParameterPointervAPPLE$address() {
        return glGetTexParameterPointervAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetTexParameterPointervAPPLE(GLenum target, GLenum pname, GLvoid **params)
     * }
     */
    public static void glGetTexParameterPointervAPPLE(int target, int pname, MemorySegment params) {
        var mh$ = glGetTexParameterPointervAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexParameterPointervAPPLE", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBindVertexArrayAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glBindVertexArrayAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glBindVertexArrayAPPLE(GLuint id)
     * }
     */
    public static FunctionDescriptor glBindVertexArrayAPPLE$descriptor() {
        return glBindVertexArrayAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glBindVertexArrayAPPLE(GLuint id)
     * }
     */
    public static MethodHandle glBindVertexArrayAPPLE$handle() {
        return glBindVertexArrayAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glBindVertexArrayAPPLE(GLuint id)
     * }
     */
    public static MemorySegment glBindVertexArrayAPPLE$address() {
        return glBindVertexArrayAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glBindVertexArrayAPPLE(GLuint id)
     * }
     */
    public static void glBindVertexArrayAPPLE(int id) {
        var mh$ = glBindVertexArrayAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBindVertexArrayAPPLE", id);
            }
            mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDeleteVertexArraysAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDeleteVertexArraysAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glDeleteVertexArraysAPPLE(GLsizei n, const GLuint *ids)
     * }
     */
    public static FunctionDescriptor glDeleteVertexArraysAPPLE$descriptor() {
        return glDeleteVertexArraysAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glDeleteVertexArraysAPPLE(GLsizei n, const GLuint *ids)
     * }
     */
    public static MethodHandle glDeleteVertexArraysAPPLE$handle() {
        return glDeleteVertexArraysAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glDeleteVertexArraysAPPLE(GLsizei n, const GLuint *ids)
     * }
     */
    public static MemorySegment glDeleteVertexArraysAPPLE$address() {
        return glDeleteVertexArraysAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glDeleteVertexArraysAPPLE(GLsizei n, const GLuint *ids)
     * }
     */
    public static void glDeleteVertexArraysAPPLE(int n, MemorySegment ids) {
        var mh$ = glDeleteVertexArraysAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDeleteVertexArraysAPPLE", n, ids);
            }
            mh$.invokeExact(n, ids);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGenVertexArraysAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGenVertexArraysAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGenVertexArraysAPPLE(GLsizei n, GLuint *ids)
     * }
     */
    public static FunctionDescriptor glGenVertexArraysAPPLE$descriptor() {
        return glGenVertexArraysAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGenVertexArraysAPPLE(GLsizei n, GLuint *ids)
     * }
     */
    public static MethodHandle glGenVertexArraysAPPLE$handle() {
        return glGenVertexArraysAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGenVertexArraysAPPLE(GLsizei n, GLuint *ids)
     * }
     */
    public static MemorySegment glGenVertexArraysAPPLE$address() {
        return glGenVertexArraysAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGenVertexArraysAPPLE(GLsizei n, GLuint *ids)
     * }
     */
    public static void glGenVertexArraysAPPLE(int n, MemorySegment ids) {
        var mh$ = glGenVertexArraysAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGenVertexArraysAPPLE", n, ids);
            }
            mh$.invokeExact(n, ids);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIsVertexArrayAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glIsVertexArrayAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLboolean glIsVertexArrayAPPLE(GLuint id)
     * }
     */
    public static FunctionDescriptor glIsVertexArrayAPPLE$descriptor() {
        return glIsVertexArrayAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLboolean glIsVertexArrayAPPLE(GLuint id)
     * }
     */
    public static MethodHandle glIsVertexArrayAPPLE$handle() {
        return glIsVertexArrayAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLboolean glIsVertexArrayAPPLE(GLuint id)
     * }
     */
    public static MemorySegment glIsVertexArrayAPPLE$address() {
        return glIsVertexArrayAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLboolean glIsVertexArrayAPPLE(GLuint id)
     * }
     */
    public static byte glIsVertexArrayAPPLE(int id) {
        var mh$ = glIsVertexArrayAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIsVertexArrayAPPLE", id);
            }
            return (byte)mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexArrayRangeAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexArrayRangeAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexArrayRangeAPPLE(GLsizei length, const GLvoid *pointer)
     * }
     */
    public static FunctionDescriptor glVertexArrayRangeAPPLE$descriptor() {
        return glVertexArrayRangeAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexArrayRangeAPPLE(GLsizei length, const GLvoid *pointer)
     * }
     */
    public static MethodHandle glVertexArrayRangeAPPLE$handle() {
        return glVertexArrayRangeAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexArrayRangeAPPLE(GLsizei length, const GLvoid *pointer)
     * }
     */
    public static MemorySegment glVertexArrayRangeAPPLE$address() {
        return glVertexArrayRangeAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexArrayRangeAPPLE(GLsizei length, const GLvoid *pointer)
     * }
     */
    public static void glVertexArrayRangeAPPLE(int length, MemorySegment pointer) {
        var mh$ = glVertexArrayRangeAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexArrayRangeAPPLE", length, pointer);
            }
            mh$.invokeExact(length, pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFlushVertexArrayRangeAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFlushVertexArrayRangeAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glFlushVertexArrayRangeAPPLE(GLsizei length, const GLvoid *pointer)
     * }
     */
    public static FunctionDescriptor glFlushVertexArrayRangeAPPLE$descriptor() {
        return glFlushVertexArrayRangeAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glFlushVertexArrayRangeAPPLE(GLsizei length, const GLvoid *pointer)
     * }
     */
    public static MethodHandle glFlushVertexArrayRangeAPPLE$handle() {
        return glFlushVertexArrayRangeAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glFlushVertexArrayRangeAPPLE(GLsizei length, const GLvoid *pointer)
     * }
     */
    public static MemorySegment glFlushVertexArrayRangeAPPLE$address() {
        return glFlushVertexArrayRangeAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glFlushVertexArrayRangeAPPLE(GLsizei length, const GLvoid *pointer)
     * }
     */
    public static void glFlushVertexArrayRangeAPPLE(int length, MemorySegment pointer) {
        var mh$ = glFlushVertexArrayRangeAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFlushVertexArrayRangeAPPLE", length, pointer);
            }
            mh$.invokeExact(length, pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexArrayParameteriAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexArrayParameteriAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexArrayParameteriAPPLE(GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glVertexArrayParameteriAPPLE$descriptor() {
        return glVertexArrayParameteriAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexArrayParameteriAPPLE(GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glVertexArrayParameteriAPPLE$handle() {
        return glVertexArrayParameteriAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexArrayParameteriAPPLE(GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glVertexArrayParameteriAPPLE$address() {
        return glVertexArrayParameteriAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexArrayParameteriAPPLE(GLenum pname, GLint param)
     * }
     */
    public static void glVertexArrayParameteriAPPLE(int pname, int param) {
        var mh$ = glVertexArrayParameteriAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexArrayParameteriAPPLE", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPointSizePointerAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPointSizePointerAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glPointSizePointerAPPLE(GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static FunctionDescriptor glPointSizePointerAPPLE$descriptor() {
        return glPointSizePointerAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glPointSizePointerAPPLE(GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MethodHandle glPointSizePointerAPPLE$handle() {
        return glPointSizePointerAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glPointSizePointerAPPLE(GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MemorySegment glPointSizePointerAPPLE$address() {
        return glPointSizePointerAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glPointSizePointerAPPLE(GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static void glPointSizePointerAPPLE(int type, int stride, MemorySegment pointer) {
        var mh$ = glPointSizePointerAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPointSizePointerAPPLE", type, stride, pointer);
            }
            mh$.invokeExact(type, stride, pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexPointSizefAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexPointSizefAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexPointSizefAPPLE(GLfloat size)
     * }
     */
    public static FunctionDescriptor glVertexPointSizefAPPLE$descriptor() {
        return glVertexPointSizefAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexPointSizefAPPLE(GLfloat size)
     * }
     */
    public static MethodHandle glVertexPointSizefAPPLE$handle() {
        return glVertexPointSizefAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexPointSizefAPPLE(GLfloat size)
     * }
     */
    public static MemorySegment glVertexPointSizefAPPLE$address() {
        return glVertexPointSizefAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexPointSizefAPPLE(GLfloat size)
     * }
     */
    public static void glVertexPointSizefAPPLE(float size) {
        var mh$ = glVertexPointSizefAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexPointSizefAPPLE", size);
            }
            mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEnableVertexAttribAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glEnableVertexAttribAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glEnableVertexAttribAPPLE(GLuint index, GLenum pname)
     * }
     */
    public static FunctionDescriptor glEnableVertexAttribAPPLE$descriptor() {
        return glEnableVertexAttribAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glEnableVertexAttribAPPLE(GLuint index, GLenum pname)
     * }
     */
    public static MethodHandle glEnableVertexAttribAPPLE$handle() {
        return glEnableVertexAttribAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glEnableVertexAttribAPPLE(GLuint index, GLenum pname)
     * }
     */
    public static MemorySegment glEnableVertexAttribAPPLE$address() {
        return glEnableVertexAttribAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glEnableVertexAttribAPPLE(GLuint index, GLenum pname)
     * }
     */
    public static void glEnableVertexAttribAPPLE(int index, int pname) {
        var mh$ = glEnableVertexAttribAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEnableVertexAttribAPPLE", index, pname);
            }
            mh$.invokeExact(index, pname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDisableVertexAttribAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDisableVertexAttribAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glDisableVertexAttribAPPLE(GLuint index, GLenum pname)
     * }
     */
    public static FunctionDescriptor glDisableVertexAttribAPPLE$descriptor() {
        return glDisableVertexAttribAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glDisableVertexAttribAPPLE(GLuint index, GLenum pname)
     * }
     */
    public static MethodHandle glDisableVertexAttribAPPLE$handle() {
        return glDisableVertexAttribAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glDisableVertexAttribAPPLE(GLuint index, GLenum pname)
     * }
     */
    public static MemorySegment glDisableVertexAttribAPPLE$address() {
        return glDisableVertexAttribAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glDisableVertexAttribAPPLE(GLuint index, GLenum pname)
     * }
     */
    public static void glDisableVertexAttribAPPLE(int index, int pname) {
        var mh$ = glDisableVertexAttribAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDisableVertexAttribAPPLE", index, pname);
            }
            mh$.invokeExact(index, pname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIsVertexAttribEnabledAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glIsVertexAttribEnabledAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLboolean glIsVertexAttribEnabledAPPLE(GLuint index, GLenum pname)
     * }
     */
    public static FunctionDescriptor glIsVertexAttribEnabledAPPLE$descriptor() {
        return glIsVertexAttribEnabledAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLboolean glIsVertexAttribEnabledAPPLE(GLuint index, GLenum pname)
     * }
     */
    public static MethodHandle glIsVertexAttribEnabledAPPLE$handle() {
        return glIsVertexAttribEnabledAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLboolean glIsVertexAttribEnabledAPPLE(GLuint index, GLenum pname)
     * }
     */
    public static MemorySegment glIsVertexAttribEnabledAPPLE$address() {
        return glIsVertexAttribEnabledAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLboolean glIsVertexAttribEnabledAPPLE(GLuint index, GLenum pname)
     * }
     */
    public static byte glIsVertexAttribEnabledAPPLE(int index, int pname) {
        var mh$ = glIsVertexAttribEnabledAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIsVertexAttribEnabledAPPLE", index, pname);
            }
            return (byte)mh$.invokeExact(index, pname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMapVertexAttrib1dAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMapVertexAttrib1dAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMapVertexAttrib1dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
     * }
     */
    public static FunctionDescriptor glMapVertexAttrib1dAPPLE$descriptor() {
        return glMapVertexAttrib1dAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMapVertexAttrib1dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
     * }
     */
    public static MethodHandle glMapVertexAttrib1dAPPLE$handle() {
        return glMapVertexAttrib1dAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMapVertexAttrib1dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
     * }
     */
    public static MemorySegment glMapVertexAttrib1dAPPLE$address() {
        return glMapVertexAttrib1dAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMapVertexAttrib1dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
     * }
     */
    public static void glMapVertexAttrib1dAPPLE(int index, int size, double u1, double u2, int stride, int order, MemorySegment points) {
        var mh$ = glMapVertexAttrib1dAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMapVertexAttrib1dAPPLE", index, size, u1, u2, stride, order, points);
            }
            mh$.invokeExact(index, size, u1, u2, stride, order, points);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMapVertexAttrib1fAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMapVertexAttrib1fAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMapVertexAttrib1fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
     * }
     */
    public static FunctionDescriptor glMapVertexAttrib1fAPPLE$descriptor() {
        return glMapVertexAttrib1fAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMapVertexAttrib1fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
     * }
     */
    public static MethodHandle glMapVertexAttrib1fAPPLE$handle() {
        return glMapVertexAttrib1fAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMapVertexAttrib1fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
     * }
     */
    public static MemorySegment glMapVertexAttrib1fAPPLE$address() {
        return glMapVertexAttrib1fAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMapVertexAttrib1fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
     * }
     */
    public static void glMapVertexAttrib1fAPPLE(int index, int size, float u1, float u2, int stride, int order, MemorySegment points) {
        var mh$ = glMapVertexAttrib1fAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMapVertexAttrib1fAPPLE", index, size, u1, u2, stride, order, points);
            }
            mh$.invokeExact(index, size, u1, u2, stride, order, points);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMapVertexAttrib2dAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMapVertexAttrib2dAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMapVertexAttrib2dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
     * }
     */
    public static FunctionDescriptor glMapVertexAttrib2dAPPLE$descriptor() {
        return glMapVertexAttrib2dAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMapVertexAttrib2dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
     * }
     */
    public static MethodHandle glMapVertexAttrib2dAPPLE$handle() {
        return glMapVertexAttrib2dAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMapVertexAttrib2dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
     * }
     */
    public static MemorySegment glMapVertexAttrib2dAPPLE$address() {
        return glMapVertexAttrib2dAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMapVertexAttrib2dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
     * }
     */
    public static void glMapVertexAttrib2dAPPLE(int index, int size, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, MemorySegment points) {
        var mh$ = glMapVertexAttrib2dAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMapVertexAttrib2dAPPLE", index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
            }
            mh$.invokeExact(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMapVertexAttrib2fAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMapVertexAttrib2fAPPLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMapVertexAttrib2fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
     * }
     */
    public static FunctionDescriptor glMapVertexAttrib2fAPPLE$descriptor() {
        return glMapVertexAttrib2fAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMapVertexAttrib2fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
     * }
     */
    public static MethodHandle glMapVertexAttrib2fAPPLE$handle() {
        return glMapVertexAttrib2fAPPLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMapVertexAttrib2fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
     * }
     */
    public static MemorySegment glMapVertexAttrib2fAPPLE$address() {
        return glMapVertexAttrib2fAPPLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMapVertexAttrib2fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
     * }
     */
    public static void glMapVertexAttrib2fAPPLE(int index, int size, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, MemorySegment points) {
        var mh$ = glMapVertexAttrib2fAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMapVertexAttrib2fAPPLE", index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
            }
            mh$.invokeExact(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBlendEquationSeparateATI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glBlendEquationSeparateATI");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glBlendEquationSeparateATI(GLenum equationRGB, GLenum equationAlpha)
     * }
     */
    public static FunctionDescriptor glBlendEquationSeparateATI$descriptor() {
        return glBlendEquationSeparateATI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glBlendEquationSeparateATI(GLenum equationRGB, GLenum equationAlpha)
     * }
     */
    public static MethodHandle glBlendEquationSeparateATI$handle() {
        return glBlendEquationSeparateATI.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glBlendEquationSeparateATI(GLenum equationRGB, GLenum equationAlpha)
     * }
     */
    public static MemorySegment glBlendEquationSeparateATI$address() {
        return glBlendEquationSeparateATI.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glBlendEquationSeparateATI(GLenum equationRGB, GLenum equationAlpha)
     * }
     */
    public static void glBlendEquationSeparateATI(int equationRGB, int equationAlpha) {
        var mh$ = glBlendEquationSeparateATI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBlendEquationSeparateATI", equationRGB, equationAlpha);
            }
            mh$.invokeExact(equationRGB, equationAlpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glStencilOpSeparateATI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glStencilOpSeparateATI");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glStencilOpSeparateATI(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass)
     * }
     */
    public static FunctionDescriptor glStencilOpSeparateATI$descriptor() {
        return glStencilOpSeparateATI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glStencilOpSeparateATI(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass)
     * }
     */
    public static MethodHandle glStencilOpSeparateATI$handle() {
        return glStencilOpSeparateATI.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glStencilOpSeparateATI(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass)
     * }
     */
    public static MemorySegment glStencilOpSeparateATI$address() {
        return glStencilOpSeparateATI.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glStencilOpSeparateATI(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass)
     * }
     */
    public static void glStencilOpSeparateATI(int face, int sfail, int dpfail, int dppass) {
        var mh$ = glStencilOpSeparateATI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glStencilOpSeparateATI", face, sfail, dpfail, dppass);
            }
            mh$.invokeExact(face, sfail, dpfail, dppass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glStencilFuncSeparateATI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glStencilFuncSeparateATI");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glStencilFuncSeparateATI(GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask)
     * }
     */
    public static FunctionDescriptor glStencilFuncSeparateATI$descriptor() {
        return glStencilFuncSeparateATI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glStencilFuncSeparateATI(GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask)
     * }
     */
    public static MethodHandle glStencilFuncSeparateATI$handle() {
        return glStencilFuncSeparateATI.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glStencilFuncSeparateATI(GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask)
     * }
     */
    public static MemorySegment glStencilFuncSeparateATI$address() {
        return glStencilFuncSeparateATI.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glStencilFuncSeparateATI(GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask)
     * }
     */
    public static void glStencilFuncSeparateATI(int frontfunc, int backfunc, int ref, int mask) {
        var mh$ = glStencilFuncSeparateATI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glStencilFuncSeparateATI", frontfunc, backfunc, ref, mask);
            }
            mh$.invokeExact(frontfunc, backfunc, ref, mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBeginConditionalRenderNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glBeginConditionalRenderNV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glBeginConditionalRenderNV(GLuint id, GLenum mode)
     * }
     */
    public static FunctionDescriptor glBeginConditionalRenderNV$descriptor() {
        return glBeginConditionalRenderNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glBeginConditionalRenderNV(GLuint id, GLenum mode)
     * }
     */
    public static MethodHandle glBeginConditionalRenderNV$handle() {
        return glBeginConditionalRenderNV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glBeginConditionalRenderNV(GLuint id, GLenum mode)
     * }
     */
    public static MemorySegment glBeginConditionalRenderNV$address() {
        return glBeginConditionalRenderNV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glBeginConditionalRenderNV(GLuint id, GLenum mode)
     * }
     */
    public static void glBeginConditionalRenderNV(int id, int mode) {
        var mh$ = glBeginConditionalRenderNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBeginConditionalRenderNV", id, mode);
            }
            mh$.invokeExact(id, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEndConditionalRenderNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glEndConditionalRenderNV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glEndConditionalRenderNV()
     * }
     */
    public static FunctionDescriptor glEndConditionalRenderNV$descriptor() {
        return glEndConditionalRenderNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glEndConditionalRenderNV()
     * }
     */
    public static MethodHandle glEndConditionalRenderNV$handle() {
        return glEndConditionalRenderNV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glEndConditionalRenderNV()
     * }
     */
    public static MemorySegment glEndConditionalRenderNV$address() {
        return glEndConditionalRenderNV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glEndConditionalRenderNV()
     * }
     */
    public static void glEndConditionalRenderNV() {
        var mh$ = glEndConditionalRenderNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEndConditionalRenderNV");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPointParameteriNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPointParameteriNV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glPointParameteriNV(GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glPointParameteriNV$descriptor() {
        return glPointParameteriNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glPointParameteriNV(GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glPointParameteriNV$handle() {
        return glPointParameteriNV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glPointParameteriNV(GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glPointParameteriNV$address() {
        return glPointParameteriNV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glPointParameteriNV(GLenum pname, GLint param)
     * }
     */
    public static void glPointParameteriNV(int pname, int param) {
        var mh$ = glPointParameteriNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPointParameteriNV", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPointParameterivNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPointParameterivNV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glPointParameterivNV(GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glPointParameterivNV$descriptor() {
        return glPointParameterivNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glPointParameterivNV(GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glPointParameterivNV$handle() {
        return glPointParameterivNV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glPointParameterivNV(GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glPointParameterivNV$address() {
        return glPointParameterivNV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glPointParameterivNV(GLenum pname, const GLint *params)
     * }
     */
    public static void glPointParameterivNV(int pname, MemorySegment params) {
        var mh$ = glPointParameterivNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPointParameterivNV", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTextureBarrierNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTextureBarrierNV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTextureBarrierNV()
     * }
     */
    public static FunctionDescriptor glTextureBarrierNV$descriptor() {
        return glTextureBarrierNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTextureBarrierNV()
     * }
     */
    public static MethodHandle glTextureBarrierNV$handle() {
        return glTextureBarrierNV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTextureBarrierNV()
     * }
     */
    public static MemorySegment glTextureBarrierNV$address() {
        return glTextureBarrierNV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTextureBarrierNV()
     * }
     */
    public static void glTextureBarrierNV() {
        var mh$ = glTextureBarrierNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTextureBarrierNV");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glAccum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glAccum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glAccum(GLenum op, GLfloat value)
     * }
     */
    public static FunctionDescriptor glAccum$descriptor() {
        return glAccum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glAccum(GLenum op, GLfloat value)
     * }
     */
    public static MethodHandle glAccum$handle() {
        return glAccum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glAccum(GLenum op, GLfloat value)
     * }
     */
    public static MemorySegment glAccum$address() {
        return glAccum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glAccum(GLenum op, GLfloat value)
     * }
     */
    public static void glAccum(int op, float value) {
        var mh$ = glAccum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glAccum", op, value);
            }
            mh$.invokeExact(op, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glAlphaFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glAlphaFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glAlphaFunc(GLenum func, GLclampf ref)
     * }
     */
    public static FunctionDescriptor glAlphaFunc$descriptor() {
        return glAlphaFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glAlphaFunc(GLenum func, GLclampf ref)
     * }
     */
    public static MethodHandle glAlphaFunc$handle() {
        return glAlphaFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glAlphaFunc(GLenum func, GLclampf ref)
     * }
     */
    public static MemorySegment glAlphaFunc$address() {
        return glAlphaFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glAlphaFunc(GLenum func, GLclampf ref)
     * }
     */
    public static void glAlphaFunc(int func, float ref) {
        var mh$ = glAlphaFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glAlphaFunc", func, ref);
            }
            mh$.invokeExact(func, ref);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glAreTexturesResident {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glAreTexturesResident");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLboolean glAreTexturesResident(GLsizei n, const GLuint *textures, GLboolean *residences)
     * }
     */
    public static FunctionDescriptor glAreTexturesResident$descriptor() {
        return glAreTexturesResident.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLboolean glAreTexturesResident(GLsizei n, const GLuint *textures, GLboolean *residences)
     * }
     */
    public static MethodHandle glAreTexturesResident$handle() {
        return glAreTexturesResident.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLboolean glAreTexturesResident(GLsizei n, const GLuint *textures, GLboolean *residences)
     * }
     */
    public static MemorySegment glAreTexturesResident$address() {
        return glAreTexturesResident.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLboolean glAreTexturesResident(GLsizei n, const GLuint *textures, GLboolean *residences)
     * }
     */
    public static byte glAreTexturesResident(int n, MemorySegment textures, MemorySegment residences) {
        var mh$ = glAreTexturesResident.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glAreTexturesResident", n, textures, residences);
            }
            return (byte)mh$.invokeExact(n, textures, residences);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glArrayElement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glArrayElement");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glArrayElement(GLint i)
     * }
     */
    public static FunctionDescriptor glArrayElement$descriptor() {
        return glArrayElement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glArrayElement(GLint i)
     * }
     */
    public static MethodHandle glArrayElement$handle() {
        return glArrayElement.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glArrayElement(GLint i)
     * }
     */
    public static MemorySegment glArrayElement$address() {
        return glArrayElement.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glArrayElement(GLint i)
     * }
     */
    public static void glArrayElement(int i) {
        var mh$ = glArrayElement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glArrayElement", i);
            }
            mh$.invokeExact(i);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBegin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glBegin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glBegin(GLenum mode)
     * }
     */
    public static FunctionDescriptor glBegin$descriptor() {
        return glBegin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glBegin(GLenum mode)
     * }
     */
    public static MethodHandle glBegin$handle() {
        return glBegin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glBegin(GLenum mode)
     * }
     */
    public static MemorySegment glBegin$address() {
        return glBegin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glBegin(GLenum mode)
     * }
     */
    public static void glBegin(int mode) {
        var mh$ = glBegin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBegin", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBindTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glBindTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glBindTexture(GLenum target, GLuint texture)
     * }
     */
    public static FunctionDescriptor glBindTexture$descriptor() {
        return glBindTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glBindTexture(GLenum target, GLuint texture)
     * }
     */
    public static MethodHandle glBindTexture$handle() {
        return glBindTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glBindTexture(GLenum target, GLuint texture)
     * }
     */
    public static MemorySegment glBindTexture$address() {
        return glBindTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glBindTexture(GLenum target, GLuint texture)
     * }
     */
    public static void glBindTexture(int target, int texture) {
        var mh$ = glBindTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBindTexture", target, texture);
            }
            mh$.invokeExact(target, texture);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBitmap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glBitmap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap)
     * }
     */
    public static FunctionDescriptor glBitmap$descriptor() {
        return glBitmap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap)
     * }
     */
    public static MethodHandle glBitmap$handle() {
        return glBitmap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap)
     * }
     */
    public static MemorySegment glBitmap$address() {
        return glBitmap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap)
     * }
     */
    public static void glBitmap(int width, int height, float xorig, float yorig, float xmove, float ymove, MemorySegment bitmap) {
        var mh$ = glBitmap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBitmap", width, height, xorig, yorig, xmove, ymove, bitmap);
            }
            mh$.invokeExact(width, height, xorig, yorig, xmove, ymove, bitmap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBlendColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glBlendColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
     * }
     */
    public static FunctionDescriptor glBlendColor$descriptor() {
        return glBlendColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
     * }
     */
    public static MethodHandle glBlendColor$handle() {
        return glBlendColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
     * }
     */
    public static MemorySegment glBlendColor$address() {
        return glBlendColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
     * }
     */
    public static void glBlendColor(float red, float green, float blue, float alpha) {
        var mh$ = glBlendColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBlendColor", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBlendEquation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glBlendEquation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glBlendEquation(GLenum mode)
     * }
     */
    public static FunctionDescriptor glBlendEquation$descriptor() {
        return glBlendEquation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glBlendEquation(GLenum mode)
     * }
     */
    public static MethodHandle glBlendEquation$handle() {
        return glBlendEquation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glBlendEquation(GLenum mode)
     * }
     */
    public static MemorySegment glBlendEquation$address() {
        return glBlendEquation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glBlendEquation(GLenum mode)
     * }
     */
    public static void glBlendEquation(int mode) {
        var mh$ = glBlendEquation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBlendEquation", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBlendEquationSeparate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glBlendEquationSeparate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha)
     * }
     */
    public static FunctionDescriptor glBlendEquationSeparate$descriptor() {
        return glBlendEquationSeparate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha)
     * }
     */
    public static MethodHandle glBlendEquationSeparate$handle() {
        return glBlendEquationSeparate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha)
     * }
     */
    public static MemorySegment glBlendEquationSeparate$address() {
        return glBlendEquationSeparate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha)
     * }
     */
    public static void glBlendEquationSeparate(int modeRGB, int modeAlpha) {
        var mh$ = glBlendEquationSeparate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBlendEquationSeparate", modeRGB, modeAlpha);
            }
            mh$.invokeExact(modeRGB, modeAlpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBlendFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glBlendFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glBlendFunc(GLenum sfactor, GLenum dfactor)
     * }
     */
    public static FunctionDescriptor glBlendFunc$descriptor() {
        return glBlendFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glBlendFunc(GLenum sfactor, GLenum dfactor)
     * }
     */
    public static MethodHandle glBlendFunc$handle() {
        return glBlendFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glBlendFunc(GLenum sfactor, GLenum dfactor)
     * }
     */
    public static MemorySegment glBlendFunc$address() {
        return glBlendFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glBlendFunc(GLenum sfactor, GLenum dfactor)
     * }
     */
    public static void glBlendFunc(int sfactor, int dfactor) {
        var mh$ = glBlendFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBlendFunc", sfactor, dfactor);
            }
            mh$.invokeExact(sfactor, dfactor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCallList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glCallList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glCallList(GLuint list)
     * }
     */
    public static FunctionDescriptor glCallList$descriptor() {
        return glCallList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glCallList(GLuint list)
     * }
     */
    public static MethodHandle glCallList$handle() {
        return glCallList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glCallList(GLuint list)
     * }
     */
    public static MemorySegment glCallList$address() {
        return glCallList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glCallList(GLuint list)
     * }
     */
    public static void glCallList(int list) {
        var mh$ = glCallList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCallList", list);
            }
            mh$.invokeExact(list);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCallLists {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glCallLists");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glCallLists(GLsizei n, GLenum type, const GLvoid *lists)
     * }
     */
    public static FunctionDescriptor glCallLists$descriptor() {
        return glCallLists.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glCallLists(GLsizei n, GLenum type, const GLvoid *lists)
     * }
     */
    public static MethodHandle glCallLists$handle() {
        return glCallLists.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glCallLists(GLsizei n, GLenum type, const GLvoid *lists)
     * }
     */
    public static MemorySegment glCallLists$address() {
        return glCallLists.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glCallLists(GLsizei n, GLenum type, const GLvoid *lists)
     * }
     */
    public static void glCallLists(int n, int type, MemorySegment lists) {
        var mh$ = glCallLists.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCallLists", n, type, lists);
            }
            mh$.invokeExact(n, type, lists);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glClear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glClear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glClear(GLbitfield mask)
     * }
     */
    public static FunctionDescriptor glClear$descriptor() {
        return glClear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glClear(GLbitfield mask)
     * }
     */
    public static MethodHandle glClear$handle() {
        return glClear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glClear(GLbitfield mask)
     * }
     */
    public static MemorySegment glClear$address() {
        return glClear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glClear(GLbitfield mask)
     * }
     */
    public static void glClear(int mask) {
        var mh$ = glClear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClear", mask);
            }
            mh$.invokeExact(mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glClearAccum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glClearAccum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
     * }
     */
    public static FunctionDescriptor glClearAccum$descriptor() {
        return glClearAccum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
     * }
     */
    public static MethodHandle glClearAccum$handle() {
        return glClearAccum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
     * }
     */
    public static MemorySegment glClearAccum$address() {
        return glClearAccum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
     * }
     */
    public static void glClearAccum(float red, float green, float blue, float alpha) {
        var mh$ = glClearAccum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClearAccum", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glClearColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glClearColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
     * }
     */
    public static FunctionDescriptor glClearColor$descriptor() {
        return glClearColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
     * }
     */
    public static MethodHandle glClearColor$handle() {
        return glClearColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
     * }
     */
    public static MemorySegment glClearColor$address() {
        return glClearColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
     * }
     */
    public static void glClearColor(float red, float green, float blue, float alpha) {
        var mh$ = glClearColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClearColor", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glClearDepth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glClearDepth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glClearDepth(GLclampd depth)
     * }
     */
    public static FunctionDescriptor glClearDepth$descriptor() {
        return glClearDepth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glClearDepth(GLclampd depth)
     * }
     */
    public static MethodHandle glClearDepth$handle() {
        return glClearDepth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glClearDepth(GLclampd depth)
     * }
     */
    public static MemorySegment glClearDepth$address() {
        return glClearDepth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glClearDepth(GLclampd depth)
     * }
     */
    public static void glClearDepth(double depth) {
        var mh$ = glClearDepth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClearDepth", depth);
            }
            mh$.invokeExact(depth);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glClearIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glClearIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glClearIndex(GLfloat c)
     * }
     */
    public static FunctionDescriptor glClearIndex$descriptor() {
        return glClearIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glClearIndex(GLfloat c)
     * }
     */
    public static MethodHandle glClearIndex$handle() {
        return glClearIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glClearIndex(GLfloat c)
     * }
     */
    public static MemorySegment glClearIndex$address() {
        return glClearIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glClearIndex(GLfloat c)
     * }
     */
    public static void glClearIndex(float c) {
        var mh$ = glClearIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClearIndex", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glClearStencil {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glClearStencil");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glClearStencil(GLint s)
     * }
     */
    public static FunctionDescriptor glClearStencil$descriptor() {
        return glClearStencil.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glClearStencil(GLint s)
     * }
     */
    public static MethodHandle glClearStencil$handle() {
        return glClearStencil.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glClearStencil(GLint s)
     * }
     */
    public static MemorySegment glClearStencil$address() {
        return glClearStencil.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glClearStencil(GLint s)
     * }
     */
    public static void glClearStencil(int s) {
        var mh$ = glClearStencil.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClearStencil", s);
            }
            mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glClipPlane {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glClipPlane");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glClipPlane(GLenum plane, const GLdouble *equation)
     * }
     */
    public static FunctionDescriptor glClipPlane$descriptor() {
        return glClipPlane.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glClipPlane(GLenum plane, const GLdouble *equation)
     * }
     */
    public static MethodHandle glClipPlane$handle() {
        return glClipPlane.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glClipPlane(GLenum plane, const GLdouble *equation)
     * }
     */
    public static MemorySegment glClipPlane$address() {
        return glClipPlane.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glClipPlane(GLenum plane, const GLdouble *equation)
     * }
     */
    public static void glClipPlane(int plane, MemorySegment equation) {
        var mh$ = glClipPlane.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClipPlane", plane, equation);
            }
            mh$.invokeExact(plane, equation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor3b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glColor3b(GLbyte red, GLbyte green, GLbyte blue)
     * }
     */
    public static FunctionDescriptor glColor3b$descriptor() {
        return glColor3b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glColor3b(GLbyte red, GLbyte green, GLbyte blue)
     * }
     */
    public static MethodHandle glColor3b$handle() {
        return glColor3b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glColor3b(GLbyte red, GLbyte green, GLbyte blue)
     * }
     */
    public static MemorySegment glColor3b$address() {
        return glColor3b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glColor3b(GLbyte red, GLbyte green, GLbyte blue)
     * }
     */
    public static void glColor3b(byte red, byte green, byte blue) {
        var mh$ = glColor3b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3b", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3bv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor3bv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glColor3bv(const GLbyte *v)
     * }
     */
    public static FunctionDescriptor glColor3bv$descriptor() {
        return glColor3bv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glColor3bv(const GLbyte *v)
     * }
     */
    public static MethodHandle glColor3bv$handle() {
        return glColor3bv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glColor3bv(const GLbyte *v)
     * }
     */
    public static MemorySegment glColor3bv$address() {
        return glColor3bv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glColor3bv(const GLbyte *v)
     * }
     */
    public static void glColor3bv(MemorySegment v) {
        var mh$ = glColor3bv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3bv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glColor3d(GLdouble red, GLdouble green, GLdouble blue)
     * }
     */
    public static FunctionDescriptor glColor3d$descriptor() {
        return glColor3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glColor3d(GLdouble red, GLdouble green, GLdouble blue)
     * }
     */
    public static MethodHandle glColor3d$handle() {
        return glColor3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glColor3d(GLdouble red, GLdouble green, GLdouble blue)
     * }
     */
    public static MemorySegment glColor3d$address() {
        return glColor3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glColor3d(GLdouble red, GLdouble green, GLdouble blue)
     * }
     */
    public static void glColor3d(double red, double green, double blue) {
        var mh$ = glColor3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3d", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor3dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glColor3dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glColor3dv$descriptor() {
        return glColor3dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glColor3dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glColor3dv$handle() {
        return glColor3dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glColor3dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glColor3dv$address() {
        return glColor3dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glColor3dv(const GLdouble *v)
     * }
     */
    public static void glColor3dv(MemorySegment v) {
        var mh$ = glColor3dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor3f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glColor3f(GLfloat red, GLfloat green, GLfloat blue)
     * }
     */
    public static FunctionDescriptor glColor3f$descriptor() {
        return glColor3f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glColor3f(GLfloat red, GLfloat green, GLfloat blue)
     * }
     */
    public static MethodHandle glColor3f$handle() {
        return glColor3f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glColor3f(GLfloat red, GLfloat green, GLfloat blue)
     * }
     */
    public static MemorySegment glColor3f$address() {
        return glColor3f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glColor3f(GLfloat red, GLfloat green, GLfloat blue)
     * }
     */
    public static void glColor3f(float red, float green, float blue) {
        var mh$ = glColor3f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3f", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor3fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glColor3fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glColor3fv$descriptor() {
        return glColor3fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glColor3fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glColor3fv$handle() {
        return glColor3fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glColor3fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glColor3fv$address() {
        return glColor3fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glColor3fv(const GLfloat *v)
     * }
     */
    public static void glColor3fv(MemorySegment v) {
        var mh$ = glColor3fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor3i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glColor3i(GLint red, GLint green, GLint blue)
     * }
     */
    public static FunctionDescriptor glColor3i$descriptor() {
        return glColor3i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glColor3i(GLint red, GLint green, GLint blue)
     * }
     */
    public static MethodHandle glColor3i$handle() {
        return glColor3i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glColor3i(GLint red, GLint green, GLint blue)
     * }
     */
    public static MemorySegment glColor3i$address() {
        return glColor3i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glColor3i(GLint red, GLint green, GLint blue)
     * }
     */
    public static void glColor3i(int red, int green, int blue) {
        var mh$ = glColor3i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3i", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor3iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glColor3iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glColor3iv$descriptor() {
        return glColor3iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glColor3iv(const GLint *v)
     * }
     */
    public static MethodHandle glColor3iv$handle() {
        return glColor3iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glColor3iv(const GLint *v)
     * }
     */
    public static MemorySegment glColor3iv$address() {
        return glColor3iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glColor3iv(const GLint *v)
     * }
     */
    public static void glColor3iv(MemorySegment v) {
        var mh$ = glColor3iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor3s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glColor3s(GLshort red, GLshort green, GLshort blue)
     * }
     */
    public static FunctionDescriptor glColor3s$descriptor() {
        return glColor3s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glColor3s(GLshort red, GLshort green, GLshort blue)
     * }
     */
    public static MethodHandle glColor3s$handle() {
        return glColor3s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glColor3s(GLshort red, GLshort green, GLshort blue)
     * }
     */
    public static MemorySegment glColor3s$address() {
        return glColor3s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glColor3s(GLshort red, GLshort green, GLshort blue)
     * }
     */
    public static void glColor3s(short red, short green, short blue) {
        var mh$ = glColor3s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3s", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor3sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glColor3sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glColor3sv$descriptor() {
        return glColor3sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glColor3sv(const GLshort *v)
     * }
     */
    public static MethodHandle glColor3sv$handle() {
        return glColor3sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glColor3sv(const GLshort *v)
     * }
     */
    public static MemorySegment glColor3sv$address() {
        return glColor3sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glColor3sv(const GLshort *v)
     * }
     */
    public static void glColor3sv(MemorySegment v) {
        var mh$ = glColor3sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3ub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor3ub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glColor3ub(GLubyte red, GLubyte green, GLubyte blue)
     * }
     */
    public static FunctionDescriptor glColor3ub$descriptor() {
        return glColor3ub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glColor3ub(GLubyte red, GLubyte green, GLubyte blue)
     * }
     */
    public static MethodHandle glColor3ub$handle() {
        return glColor3ub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glColor3ub(GLubyte red, GLubyte green, GLubyte blue)
     * }
     */
    public static MemorySegment glColor3ub$address() {
        return glColor3ub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glColor3ub(GLubyte red, GLubyte green, GLubyte blue)
     * }
     */
    public static void glColor3ub(byte red, byte green, byte blue) {
        var mh$ = glColor3ub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3ub", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3ubv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor3ubv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glColor3ubv(const GLubyte *v)
     * }
     */
    public static FunctionDescriptor glColor3ubv$descriptor() {
        return glColor3ubv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glColor3ubv(const GLubyte *v)
     * }
     */
    public static MethodHandle glColor3ubv$handle() {
        return glColor3ubv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glColor3ubv(const GLubyte *v)
     * }
     */
    public static MemorySegment glColor3ubv$address() {
        return glColor3ubv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glColor3ubv(const GLubyte *v)
     * }
     */
    public static void glColor3ubv(MemorySegment v) {
        var mh$ = glColor3ubv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3ubv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor3ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glColor3ui(GLuint red, GLuint green, GLuint blue)
     * }
     */
    public static FunctionDescriptor glColor3ui$descriptor() {
        return glColor3ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glColor3ui(GLuint red, GLuint green, GLuint blue)
     * }
     */
    public static MethodHandle glColor3ui$handle() {
        return glColor3ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glColor3ui(GLuint red, GLuint green, GLuint blue)
     * }
     */
    public static MemorySegment glColor3ui$address() {
        return glColor3ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glColor3ui(GLuint red, GLuint green, GLuint blue)
     * }
     */
    public static void glColor3ui(int red, int green, int blue) {
        var mh$ = glColor3ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3ui", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3uiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor3uiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glColor3uiv(const GLuint *v)
     * }
     */
    public static FunctionDescriptor glColor3uiv$descriptor() {
        return glColor3uiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glColor3uiv(const GLuint *v)
     * }
     */
    public static MethodHandle glColor3uiv$handle() {
        return glColor3uiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glColor3uiv(const GLuint *v)
     * }
     */
    public static MemorySegment glColor3uiv$address() {
        return glColor3uiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glColor3uiv(const GLuint *v)
     * }
     */
    public static void glColor3uiv(MemorySegment v) {
        var mh$ = glColor3uiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3uiv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3us {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor3us");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glColor3us(GLushort red, GLushort green, GLushort blue)
     * }
     */
    public static FunctionDescriptor glColor3us$descriptor() {
        return glColor3us.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glColor3us(GLushort red, GLushort green, GLushort blue)
     * }
     */
    public static MethodHandle glColor3us$handle() {
        return glColor3us.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glColor3us(GLushort red, GLushort green, GLushort blue)
     * }
     */
    public static MemorySegment glColor3us$address() {
        return glColor3us.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glColor3us(GLushort red, GLushort green, GLushort blue)
     * }
     */
    public static void glColor3us(short red, short green, short blue) {
        var mh$ = glColor3us.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3us", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3usv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor3usv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glColor3usv(const GLushort *v)
     * }
     */
    public static FunctionDescriptor glColor3usv$descriptor() {
        return glColor3usv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glColor3usv(const GLushort *v)
     * }
     */
    public static MethodHandle glColor3usv$handle() {
        return glColor3usv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glColor3usv(const GLushort *v)
     * }
     */
    public static MemorySegment glColor3usv$address() {
        return glColor3usv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glColor3usv(const GLushort *v)
     * }
     */
    public static void glColor3usv(MemorySegment v) {
        var mh$ = glColor3usv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3usv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor4b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha)
     * }
     */
    public static FunctionDescriptor glColor4b$descriptor() {
        return glColor4b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha)
     * }
     */
    public static MethodHandle glColor4b$handle() {
        return glColor4b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha)
     * }
     */
    public static MemorySegment glColor4b$address() {
        return glColor4b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha)
     * }
     */
    public static void glColor4b(byte red, byte green, byte blue, byte alpha) {
        var mh$ = glColor4b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4b", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4bv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor4bv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glColor4bv(const GLbyte *v)
     * }
     */
    public static FunctionDescriptor glColor4bv$descriptor() {
        return glColor4bv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glColor4bv(const GLbyte *v)
     * }
     */
    public static MethodHandle glColor4bv$handle() {
        return glColor4bv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glColor4bv(const GLbyte *v)
     * }
     */
    public static MemorySegment glColor4bv$address() {
        return glColor4bv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glColor4bv(const GLbyte *v)
     * }
     */
    public static void glColor4bv(MemorySegment v) {
        var mh$ = glColor4bv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4bv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor4d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha)
     * }
     */
    public static FunctionDescriptor glColor4d$descriptor() {
        return glColor4d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha)
     * }
     */
    public static MethodHandle glColor4d$handle() {
        return glColor4d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha)
     * }
     */
    public static MemorySegment glColor4d$address() {
        return glColor4d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha)
     * }
     */
    public static void glColor4d(double red, double green, double blue, double alpha) {
        var mh$ = glColor4d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4d", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor4dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glColor4dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glColor4dv$descriptor() {
        return glColor4dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glColor4dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glColor4dv$handle() {
        return glColor4dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glColor4dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glColor4dv$address() {
        return glColor4dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glColor4dv(const GLdouble *v)
     * }
     */
    public static void glColor4dv(MemorySegment v) {
        var mh$ = glColor4dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor4f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
     * }
     */
    public static FunctionDescriptor glColor4f$descriptor() {
        return glColor4f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
     * }
     */
    public static MethodHandle glColor4f$handle() {
        return glColor4f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
     * }
     */
    public static MemorySegment glColor4f$address() {
        return glColor4f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
     * }
     */
    public static void glColor4f(float red, float green, float blue, float alpha) {
        var mh$ = glColor4f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4f", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor4fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glColor4fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glColor4fv$descriptor() {
        return glColor4fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glColor4fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glColor4fv$handle() {
        return glColor4fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glColor4fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glColor4fv$address() {
        return glColor4fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glColor4fv(const GLfloat *v)
     * }
     */
    public static void glColor4fv(MemorySegment v) {
        var mh$ = glColor4fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor4i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glColor4i(GLint red, GLint green, GLint blue, GLint alpha)
     * }
     */
    public static FunctionDescriptor glColor4i$descriptor() {
        return glColor4i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glColor4i(GLint red, GLint green, GLint blue, GLint alpha)
     * }
     */
    public static MethodHandle glColor4i$handle() {
        return glColor4i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glColor4i(GLint red, GLint green, GLint blue, GLint alpha)
     * }
     */
    public static MemorySegment glColor4i$address() {
        return glColor4i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glColor4i(GLint red, GLint green, GLint blue, GLint alpha)
     * }
     */
    public static void glColor4i(int red, int green, int blue, int alpha) {
        var mh$ = glColor4i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4i", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor4iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glColor4iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glColor4iv$descriptor() {
        return glColor4iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glColor4iv(const GLint *v)
     * }
     */
    public static MethodHandle glColor4iv$handle() {
        return glColor4iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glColor4iv(const GLint *v)
     * }
     */
    public static MemorySegment glColor4iv$address() {
        return glColor4iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glColor4iv(const GLint *v)
     * }
     */
    public static void glColor4iv(MemorySegment v) {
        var mh$ = glColor4iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor4s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha)
     * }
     */
    public static FunctionDescriptor glColor4s$descriptor() {
        return glColor4s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha)
     * }
     */
    public static MethodHandle glColor4s$handle() {
        return glColor4s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha)
     * }
     */
    public static MemorySegment glColor4s$address() {
        return glColor4s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha)
     * }
     */
    public static void glColor4s(short red, short green, short blue, short alpha) {
        var mh$ = glColor4s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4s", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor4sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glColor4sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glColor4sv$descriptor() {
        return glColor4sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glColor4sv(const GLshort *v)
     * }
     */
    public static MethodHandle glColor4sv$handle() {
        return glColor4sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glColor4sv(const GLshort *v)
     * }
     */
    public static MemorySegment glColor4sv$address() {
        return glColor4sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glColor4sv(const GLshort *v)
     * }
     */
    public static void glColor4sv(MemorySegment v) {
        var mh$ = glColor4sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4ub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor4ub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
     * }
     */
    public static FunctionDescriptor glColor4ub$descriptor() {
        return glColor4ub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
     * }
     */
    public static MethodHandle glColor4ub$handle() {
        return glColor4ub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
     * }
     */
    public static MemorySegment glColor4ub$address() {
        return glColor4ub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
     * }
     */
    public static void glColor4ub(byte red, byte green, byte blue, byte alpha) {
        var mh$ = glColor4ub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4ub", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4ubv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor4ubv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glColor4ubv(const GLubyte *v)
     * }
     */
    public static FunctionDescriptor glColor4ubv$descriptor() {
        return glColor4ubv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glColor4ubv(const GLubyte *v)
     * }
     */
    public static MethodHandle glColor4ubv$handle() {
        return glColor4ubv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glColor4ubv(const GLubyte *v)
     * }
     */
    public static MemorySegment glColor4ubv$address() {
        return glColor4ubv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glColor4ubv(const GLubyte *v)
     * }
     */
    public static void glColor4ubv(MemorySegment v) {
        var mh$ = glColor4ubv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4ubv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor4ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha)
     * }
     */
    public static FunctionDescriptor glColor4ui$descriptor() {
        return glColor4ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha)
     * }
     */
    public static MethodHandle glColor4ui$handle() {
        return glColor4ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha)
     * }
     */
    public static MemorySegment glColor4ui$address() {
        return glColor4ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha)
     * }
     */
    public static void glColor4ui(int red, int green, int blue, int alpha) {
        var mh$ = glColor4ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4ui", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4uiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor4uiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glColor4uiv(const GLuint *v)
     * }
     */
    public static FunctionDescriptor glColor4uiv$descriptor() {
        return glColor4uiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glColor4uiv(const GLuint *v)
     * }
     */
    public static MethodHandle glColor4uiv$handle() {
        return glColor4uiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glColor4uiv(const GLuint *v)
     * }
     */
    public static MemorySegment glColor4uiv$address() {
        return glColor4uiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glColor4uiv(const GLuint *v)
     * }
     */
    public static void glColor4uiv(MemorySegment v) {
        var mh$ = glColor4uiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4uiv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4us {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor4us");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha)
     * }
     */
    public static FunctionDescriptor glColor4us$descriptor() {
        return glColor4us.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha)
     * }
     */
    public static MethodHandle glColor4us$handle() {
        return glColor4us.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha)
     * }
     */
    public static MemorySegment glColor4us$address() {
        return glColor4us.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha)
     * }
     */
    public static void glColor4us(short red, short green, short blue, short alpha) {
        var mh$ = glColor4us.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4us", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4usv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColor4usv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glColor4usv(const GLushort *v)
     * }
     */
    public static FunctionDescriptor glColor4usv$descriptor() {
        return glColor4usv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glColor4usv(const GLushort *v)
     * }
     */
    public static MethodHandle glColor4usv$handle() {
        return glColor4usv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glColor4usv(const GLushort *v)
     * }
     */
    public static MemorySegment glColor4usv$address() {
        return glColor4usv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glColor4usv(const GLushort *v)
     * }
     */
    public static void glColor4usv(MemorySegment v) {
        var mh$ = glColor4usv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4usv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColorMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColorMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
     * }
     */
    public static FunctionDescriptor glColorMask$descriptor() {
        return glColorMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
     * }
     */
    public static MethodHandle glColorMask$handle() {
        return glColorMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
     * }
     */
    public static MemorySegment glColorMask$address() {
        return glColorMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
     * }
     */
    public static void glColorMask(byte red, byte green, byte blue, byte alpha) {
        var mh$ = glColorMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColorMask", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColorMaterial {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColorMaterial");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glColorMaterial(GLenum face, GLenum mode)
     * }
     */
    public static FunctionDescriptor glColorMaterial$descriptor() {
        return glColorMaterial.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glColorMaterial(GLenum face, GLenum mode)
     * }
     */
    public static MethodHandle glColorMaterial$handle() {
        return glColorMaterial.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glColorMaterial(GLenum face, GLenum mode)
     * }
     */
    public static MemorySegment glColorMaterial$address() {
        return glColorMaterial.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glColorMaterial(GLenum face, GLenum mode)
     * }
     */
    public static void glColorMaterial(int face, int mode) {
        var mh$ = glColorMaterial.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColorMaterial", face, mode);
            }
            mh$.invokeExact(face, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColorPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColorPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static FunctionDescriptor glColorPointer$descriptor() {
        return glColorPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MethodHandle glColorPointer$handle() {
        return glColorPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MemorySegment glColorPointer$address() {
        return glColorPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static void glColorPointer(int size, int type, int stride, MemorySegment pointer) {
        var mh$ = glColorPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColorPointer", size, type, stride, pointer);
            }
            mh$.invokeExact(size, type, stride, pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColorSubTable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColorSubTable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glColorSubTable(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data)
     * }
     */
    public static FunctionDescriptor glColorSubTable$descriptor() {
        return glColorSubTable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glColorSubTable(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data)
     * }
     */
    public static MethodHandle glColorSubTable$handle() {
        return glColorSubTable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glColorSubTable(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data)
     * }
     */
    public static MemorySegment glColorSubTable$address() {
        return glColorSubTable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glColorSubTable(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data)
     * }
     */
    public static void glColorSubTable(int target, int start, int count, int format, int type, MemorySegment data) {
        var mh$ = glColorSubTable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColorSubTable", target, start, count, format, type, data);
            }
            mh$.invokeExact(target, start, count, format, type, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColorTable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColorTable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glColorTable(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table)
     * }
     */
    public static FunctionDescriptor glColorTable$descriptor() {
        return glColorTable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glColorTable(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table)
     * }
     */
    public static MethodHandle glColorTable$handle() {
        return glColorTable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glColorTable(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table)
     * }
     */
    public static MemorySegment glColorTable$address() {
        return glColorTable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glColorTable(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table)
     * }
     */
    public static void glColorTable(int target, int internalformat, int width, int format, int type, MemorySegment table) {
        var mh$ = glColorTable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColorTable", target, internalformat, width, format, type, table);
            }
            mh$.invokeExact(target, internalformat, width, format, type, table);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColorTableParameterfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColorTableParameterfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glColorTableParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glColorTableParameterfv$descriptor() {
        return glColorTableParameterfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glColorTableParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glColorTableParameterfv$handle() {
        return glColorTableParameterfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glColorTableParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glColorTableParameterfv$address() {
        return glColorTableParameterfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glColorTableParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static void glColorTableParameterfv(int target, int pname, MemorySegment params) {
        var mh$ = glColorTableParameterfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColorTableParameterfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColorTableParameteriv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glColorTableParameteriv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glColorTableParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glColorTableParameteriv$descriptor() {
        return glColorTableParameteriv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glColorTableParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glColorTableParameteriv$handle() {
        return glColorTableParameteriv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glColorTableParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glColorTableParameteriv$address() {
        return glColorTableParameteriv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glColorTableParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static void glColorTableParameteriv(int target, int pname, MemorySegment params) {
        var mh$ = glColorTableParameteriv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColorTableParameteriv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glConvolutionFilter1D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glConvolutionFilter1D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glConvolutionFilter1D(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image)
     * }
     */
    public static FunctionDescriptor glConvolutionFilter1D$descriptor() {
        return glConvolutionFilter1D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glConvolutionFilter1D(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image)
     * }
     */
    public static MethodHandle glConvolutionFilter1D$handle() {
        return glConvolutionFilter1D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glConvolutionFilter1D(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image)
     * }
     */
    public static MemorySegment glConvolutionFilter1D$address() {
        return glConvolutionFilter1D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glConvolutionFilter1D(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image)
     * }
     */
    public static void glConvolutionFilter1D(int target, int internalformat, int width, int format, int type, MemorySegment image) {
        var mh$ = glConvolutionFilter1D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glConvolutionFilter1D", target, internalformat, width, format, type, image);
            }
            mh$.invokeExact(target, internalformat, width, format, type, image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glConvolutionFilter2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glConvolutionFilter2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glConvolutionFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image)
     * }
     */
    public static FunctionDescriptor glConvolutionFilter2D$descriptor() {
        return glConvolutionFilter2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glConvolutionFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image)
     * }
     */
    public static MethodHandle glConvolutionFilter2D$handle() {
        return glConvolutionFilter2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glConvolutionFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image)
     * }
     */
    public static MemorySegment glConvolutionFilter2D$address() {
        return glConvolutionFilter2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glConvolutionFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image)
     * }
     */
    public static void glConvolutionFilter2D(int target, int internalformat, int width, int height, int format, int type, MemorySegment image) {
        var mh$ = glConvolutionFilter2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glConvolutionFilter2D", target, internalformat, width, height, format, type, image);
            }
            mh$.invokeExact(target, internalformat, width, height, format, type, image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glConvolutionParameterf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glConvolutionParameterf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glConvolutionParameterf(GLenum target, GLenum pname, GLfloat params)
     * }
     */
    public static FunctionDescriptor glConvolutionParameterf$descriptor() {
        return glConvolutionParameterf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glConvolutionParameterf(GLenum target, GLenum pname, GLfloat params)
     * }
     */
    public static MethodHandle glConvolutionParameterf$handle() {
        return glConvolutionParameterf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glConvolutionParameterf(GLenum target, GLenum pname, GLfloat params)
     * }
     */
    public static MemorySegment glConvolutionParameterf$address() {
        return glConvolutionParameterf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glConvolutionParameterf(GLenum target, GLenum pname, GLfloat params)
     * }
     */
    public static void glConvolutionParameterf(int target, int pname, float params) {
        var mh$ = glConvolutionParameterf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glConvolutionParameterf", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glConvolutionParameterfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glConvolutionParameterfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glConvolutionParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glConvolutionParameterfv$descriptor() {
        return glConvolutionParameterfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glConvolutionParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glConvolutionParameterfv$handle() {
        return glConvolutionParameterfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glConvolutionParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glConvolutionParameterfv$address() {
        return glConvolutionParameterfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glConvolutionParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static void glConvolutionParameterfv(int target, int pname, MemorySegment params) {
        var mh$ = glConvolutionParameterfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glConvolutionParameterfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glConvolutionParameteri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glConvolutionParameteri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glConvolutionParameteri(GLenum target, GLenum pname, GLint params)
     * }
     */
    public static FunctionDescriptor glConvolutionParameteri$descriptor() {
        return glConvolutionParameteri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glConvolutionParameteri(GLenum target, GLenum pname, GLint params)
     * }
     */
    public static MethodHandle glConvolutionParameteri$handle() {
        return glConvolutionParameteri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glConvolutionParameteri(GLenum target, GLenum pname, GLint params)
     * }
     */
    public static MemorySegment glConvolutionParameteri$address() {
        return glConvolutionParameteri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glConvolutionParameteri(GLenum target, GLenum pname, GLint params)
     * }
     */
    public static void glConvolutionParameteri(int target, int pname, int params) {
        var mh$ = glConvolutionParameteri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glConvolutionParameteri", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glConvolutionParameteriv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glConvolutionParameteriv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glConvolutionParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glConvolutionParameteriv$descriptor() {
        return glConvolutionParameteriv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glConvolutionParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glConvolutionParameteriv$handle() {
        return glConvolutionParameteriv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glConvolutionParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glConvolutionParameteriv$address() {
        return glConvolutionParameteriv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glConvolutionParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static void glConvolutionParameteriv(int target, int pname, MemorySegment params) {
        var mh$ = glConvolutionParameteriv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glConvolutionParameteriv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyColorSubTable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glCopyColorSubTable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glCopyColorSubTable(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width)
     * }
     */
    public static FunctionDescriptor glCopyColorSubTable$descriptor() {
        return glCopyColorSubTable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glCopyColorSubTable(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width)
     * }
     */
    public static MethodHandle glCopyColorSubTable$handle() {
        return glCopyColorSubTable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glCopyColorSubTable(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width)
     * }
     */
    public static MemorySegment glCopyColorSubTable$address() {
        return glCopyColorSubTable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glCopyColorSubTable(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width)
     * }
     */
    public static void glCopyColorSubTable(int target, int start, int x, int y, int width) {
        var mh$ = glCopyColorSubTable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyColorSubTable", target, start, x, y, width);
            }
            mh$.invokeExact(target, start, x, y, width);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyColorTable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glCopyColorTable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glCopyColorTable(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
     * }
     */
    public static FunctionDescriptor glCopyColorTable$descriptor() {
        return glCopyColorTable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glCopyColorTable(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
     * }
     */
    public static MethodHandle glCopyColorTable$handle() {
        return glCopyColorTable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glCopyColorTable(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
     * }
     */
    public static MemorySegment glCopyColorTable$address() {
        return glCopyColorTable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glCopyColorTable(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
     * }
     */
    public static void glCopyColorTable(int target, int internalformat, int x, int y, int width) {
        var mh$ = glCopyColorTable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyColorTable", target, internalformat, x, y, width);
            }
            mh$.invokeExact(target, internalformat, x, y, width);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyConvolutionFilter1D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glCopyConvolutionFilter1D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glCopyConvolutionFilter1D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
     * }
     */
    public static FunctionDescriptor glCopyConvolutionFilter1D$descriptor() {
        return glCopyConvolutionFilter1D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glCopyConvolutionFilter1D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
     * }
     */
    public static MethodHandle glCopyConvolutionFilter1D$handle() {
        return glCopyConvolutionFilter1D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glCopyConvolutionFilter1D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
     * }
     */
    public static MemorySegment glCopyConvolutionFilter1D$address() {
        return glCopyConvolutionFilter1D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glCopyConvolutionFilter1D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
     * }
     */
    public static void glCopyConvolutionFilter1D(int target, int internalformat, int x, int y, int width) {
        var mh$ = glCopyConvolutionFilter1D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyConvolutionFilter1D", target, internalformat, x, y, width);
            }
            mh$.invokeExact(target, internalformat, x, y, width);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyConvolutionFilter2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glCopyConvolutionFilter2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glCopyConvolutionFilter2D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static FunctionDescriptor glCopyConvolutionFilter2D$descriptor() {
        return glCopyConvolutionFilter2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glCopyConvolutionFilter2D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MethodHandle glCopyConvolutionFilter2D$handle() {
        return glCopyConvolutionFilter2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glCopyConvolutionFilter2D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MemorySegment glCopyConvolutionFilter2D$address() {
        return glCopyConvolutionFilter2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glCopyConvolutionFilter2D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static void glCopyConvolutionFilter2D(int target, int internalformat, int x, int y, int width, int height) {
        var mh$ = glCopyConvolutionFilter2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyConvolutionFilter2D", target, internalformat, x, y, width, height);
            }
            mh$.invokeExact(target, internalformat, x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyPixels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glCopyPixels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type)
     * }
     */
    public static FunctionDescriptor glCopyPixels$descriptor() {
        return glCopyPixels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type)
     * }
     */
    public static MethodHandle glCopyPixels$handle() {
        return glCopyPixels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type)
     * }
     */
    public static MemorySegment glCopyPixels$address() {
        return glCopyPixels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type)
     * }
     */
    public static void glCopyPixels(int x, int y, int width, int height, int type) {
        var mh$ = glCopyPixels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyPixels", x, y, width, height, type);
            }
            mh$.invokeExact(x, y, width, height, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyTexImage1D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glCopyTexImage1D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
     * }
     */
    public static FunctionDescriptor glCopyTexImage1D$descriptor() {
        return glCopyTexImage1D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
     * }
     */
    public static MethodHandle glCopyTexImage1D$handle() {
        return glCopyTexImage1D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
     * }
     */
    public static MemorySegment glCopyTexImage1D$address() {
        return glCopyTexImage1D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
     * }
     */
    public static void glCopyTexImage1D(int target, int level, int internalformat, int x, int y, int width, int border) {
        var mh$ = glCopyTexImage1D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyTexImage1D", target, level, internalformat, x, y, width, border);
            }
            mh$.invokeExact(target, level, internalformat, x, y, width, border);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyTexImage2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glCopyTexImage2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
     * }
     */
    public static FunctionDescriptor glCopyTexImage2D$descriptor() {
        return glCopyTexImage2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
     * }
     */
    public static MethodHandle glCopyTexImage2D$handle() {
        return glCopyTexImage2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
     * }
     */
    public static MemorySegment glCopyTexImage2D$address() {
        return glCopyTexImage2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
     * }
     */
    public static void glCopyTexImage2D(int target, int level, int internalformat, int x, int y, int width, int height, int border) {
        var mh$ = glCopyTexImage2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyTexImage2D", target, level, internalformat, x, y, width, height, border);
            }
            mh$.invokeExact(target, level, internalformat, x, y, width, height, border);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyTexSubImage1D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glCopyTexSubImage1D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
     * }
     */
    public static FunctionDescriptor glCopyTexSubImage1D$descriptor() {
        return glCopyTexSubImage1D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
     * }
     */
    public static MethodHandle glCopyTexSubImage1D$handle() {
        return glCopyTexSubImage1D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
     * }
     */
    public static MemorySegment glCopyTexSubImage1D$address() {
        return glCopyTexSubImage1D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
     * }
     */
    public static void glCopyTexSubImage1D(int target, int level, int xoffset, int x, int y, int width) {
        var mh$ = glCopyTexSubImage1D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyTexSubImage1D", target, level, xoffset, x, y, width);
            }
            mh$.invokeExact(target, level, xoffset, x, y, width);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyTexSubImage2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glCopyTexSubImage2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static FunctionDescriptor glCopyTexSubImage2D$descriptor() {
        return glCopyTexSubImage2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MethodHandle glCopyTexSubImage2D$handle() {
        return glCopyTexSubImage2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MemorySegment glCopyTexSubImage2D$address() {
        return glCopyTexSubImage2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static void glCopyTexSubImage2D(int target, int level, int xoffset, int yoffset, int x, int y, int width, int height) {
        var mh$ = glCopyTexSubImage2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyTexSubImage2D", target, level, xoffset, yoffset, x, y, width, height);
            }
            mh$.invokeExact(target, level, xoffset, yoffset, x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyTexSubImage3D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glCopyTexSubImage3D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static FunctionDescriptor glCopyTexSubImage3D$descriptor() {
        return glCopyTexSubImage3D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MethodHandle glCopyTexSubImage3D$handle() {
        return glCopyTexSubImage3D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MemorySegment glCopyTexSubImage3D$address() {
        return glCopyTexSubImage3D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static void glCopyTexSubImage3D(int target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) {
        var mh$ = glCopyTexSubImage3D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyTexSubImage3D", target, level, xoffset, yoffset, zoffset, x, y, width, height);
            }
            mh$.invokeExact(target, level, xoffset, yoffset, zoffset, x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCullFace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glCullFace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glCullFace(GLenum mode)
     * }
     */
    public static FunctionDescriptor glCullFace$descriptor() {
        return glCullFace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glCullFace(GLenum mode)
     * }
     */
    public static MethodHandle glCullFace$handle() {
        return glCullFace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glCullFace(GLenum mode)
     * }
     */
    public static MemorySegment glCullFace$address() {
        return glCullFace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glCullFace(GLenum mode)
     * }
     */
    public static void glCullFace(int mode) {
        var mh$ = glCullFace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCullFace", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDeleteLists {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDeleteLists");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glDeleteLists(GLuint list, GLsizei range)
     * }
     */
    public static FunctionDescriptor glDeleteLists$descriptor() {
        return glDeleteLists.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glDeleteLists(GLuint list, GLsizei range)
     * }
     */
    public static MethodHandle glDeleteLists$handle() {
        return glDeleteLists.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glDeleteLists(GLuint list, GLsizei range)
     * }
     */
    public static MemorySegment glDeleteLists$address() {
        return glDeleteLists.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glDeleteLists(GLuint list, GLsizei range)
     * }
     */
    public static void glDeleteLists(int list, int range) {
        var mh$ = glDeleteLists.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDeleteLists", list, range);
            }
            mh$.invokeExact(list, range);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDeleteTextures {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDeleteTextures");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glDeleteTextures(GLsizei n, const GLuint *textures)
     * }
     */
    public static FunctionDescriptor glDeleteTextures$descriptor() {
        return glDeleteTextures.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glDeleteTextures(GLsizei n, const GLuint *textures)
     * }
     */
    public static MethodHandle glDeleteTextures$handle() {
        return glDeleteTextures.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glDeleteTextures(GLsizei n, const GLuint *textures)
     * }
     */
    public static MemorySegment glDeleteTextures$address() {
        return glDeleteTextures.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glDeleteTextures(GLsizei n, const GLuint *textures)
     * }
     */
    public static void glDeleteTextures(int n, MemorySegment textures) {
        var mh$ = glDeleteTextures.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDeleteTextures", n, textures);
            }
            mh$.invokeExact(n, textures);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDepthFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDepthFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glDepthFunc(GLenum func)
     * }
     */
    public static FunctionDescriptor glDepthFunc$descriptor() {
        return glDepthFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glDepthFunc(GLenum func)
     * }
     */
    public static MethodHandle glDepthFunc$handle() {
        return glDepthFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glDepthFunc(GLenum func)
     * }
     */
    public static MemorySegment glDepthFunc$address() {
        return glDepthFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glDepthFunc(GLenum func)
     * }
     */
    public static void glDepthFunc(int func) {
        var mh$ = glDepthFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDepthFunc", func);
            }
            mh$.invokeExact(func);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDepthMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDepthMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glDepthMask(GLboolean flag)
     * }
     */
    public static FunctionDescriptor glDepthMask$descriptor() {
        return glDepthMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glDepthMask(GLboolean flag)
     * }
     */
    public static MethodHandle glDepthMask$handle() {
        return glDepthMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glDepthMask(GLboolean flag)
     * }
     */
    public static MemorySegment glDepthMask$address() {
        return glDepthMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glDepthMask(GLboolean flag)
     * }
     */
    public static void glDepthMask(byte flag) {
        var mh$ = glDepthMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDepthMask", flag);
            }
            mh$.invokeExact(flag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDepthRange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDepthRange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glDepthRange(GLclampd zNear, GLclampd zFar)
     * }
     */
    public static FunctionDescriptor glDepthRange$descriptor() {
        return glDepthRange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glDepthRange(GLclampd zNear, GLclampd zFar)
     * }
     */
    public static MethodHandle glDepthRange$handle() {
        return glDepthRange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glDepthRange(GLclampd zNear, GLclampd zFar)
     * }
     */
    public static MemorySegment glDepthRange$address() {
        return glDepthRange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glDepthRange(GLclampd zNear, GLclampd zFar)
     * }
     */
    public static void glDepthRange(double zNear, double zFar) {
        var mh$ = glDepthRange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDepthRange", zNear, zFar);
            }
            mh$.invokeExact(zNear, zFar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDisable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDisable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glDisable(GLenum cap)
     * }
     */
    public static FunctionDescriptor glDisable$descriptor() {
        return glDisable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glDisable(GLenum cap)
     * }
     */
    public static MethodHandle glDisable$handle() {
        return glDisable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glDisable(GLenum cap)
     * }
     */
    public static MemorySegment glDisable$address() {
        return glDisable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glDisable(GLenum cap)
     * }
     */
    public static void glDisable(int cap) {
        var mh$ = glDisable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDisable", cap);
            }
            mh$.invokeExact(cap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDisableClientState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDisableClientState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glDisableClientState(GLenum array)
     * }
     */
    public static FunctionDescriptor glDisableClientState$descriptor() {
        return glDisableClientState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glDisableClientState(GLenum array)
     * }
     */
    public static MethodHandle glDisableClientState$handle() {
        return glDisableClientState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glDisableClientState(GLenum array)
     * }
     */
    public static MemorySegment glDisableClientState$address() {
        return glDisableClientState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glDisableClientState(GLenum array)
     * }
     */
    public static void glDisableClientState(int array) {
        var mh$ = glDisableClientState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDisableClientState", array);
            }
            mh$.invokeExact(array);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDrawArrays {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDrawArrays");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glDrawArrays(GLenum mode, GLint first, GLsizei count)
     * }
     */
    public static FunctionDescriptor glDrawArrays$descriptor() {
        return glDrawArrays.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glDrawArrays(GLenum mode, GLint first, GLsizei count)
     * }
     */
    public static MethodHandle glDrawArrays$handle() {
        return glDrawArrays.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glDrawArrays(GLenum mode, GLint first, GLsizei count)
     * }
     */
    public static MemorySegment glDrawArrays$address() {
        return glDrawArrays.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glDrawArrays(GLenum mode, GLint first, GLsizei count)
     * }
     */
    public static void glDrawArrays(int mode, int first, int count) {
        var mh$ = glDrawArrays.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDrawArrays", mode, first, count);
            }
            mh$.invokeExact(mode, first, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDrawBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDrawBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glDrawBuffer(GLenum mode)
     * }
     */
    public static FunctionDescriptor glDrawBuffer$descriptor() {
        return glDrawBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glDrawBuffer(GLenum mode)
     * }
     */
    public static MethodHandle glDrawBuffer$handle() {
        return glDrawBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glDrawBuffer(GLenum mode)
     * }
     */
    public static MemorySegment glDrawBuffer$address() {
        return glDrawBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glDrawBuffer(GLenum mode)
     * }
     */
    public static void glDrawBuffer(int mode) {
        var mh$ = glDrawBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDrawBuffer", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDrawElements {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDrawElements");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
     * }
     */
    public static FunctionDescriptor glDrawElements$descriptor() {
        return glDrawElements.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
     * }
     */
    public static MethodHandle glDrawElements$handle() {
        return glDrawElements.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
     * }
     */
    public static MemorySegment glDrawElements$address() {
        return glDrawElements.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
     * }
     */
    public static void glDrawElements(int mode, int count, int type, MemorySegment indices) {
        var mh$ = glDrawElements.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDrawElements", mode, count, type, indices);
            }
            mh$.invokeExact(mode, count, type, indices);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDrawPixels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDrawPixels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glDrawPixels$descriptor() {
        return glDrawPixels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MethodHandle glDrawPixels$handle() {
        return glDrawPixels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MemorySegment glDrawPixels$address() {
        return glDrawPixels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static void glDrawPixels(int width, int height, int format, int type, MemorySegment pixels) {
        var mh$ = glDrawPixels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDrawPixels", width, height, format, type, pixels);
            }
            mh$.invokeExact(width, height, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDrawRangeElements {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDrawRangeElements");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)
     * }
     */
    public static FunctionDescriptor glDrawRangeElements$descriptor() {
        return glDrawRangeElements.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)
     * }
     */
    public static MethodHandle glDrawRangeElements$handle() {
        return glDrawRangeElements.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)
     * }
     */
    public static MemorySegment glDrawRangeElements$address() {
        return glDrawRangeElements.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)
     * }
     */
    public static void glDrawRangeElements(int mode, int start, int end, int count, int type, MemorySegment indices) {
        var mh$ = glDrawRangeElements.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDrawRangeElements", mode, start, end, count, type, indices);
            }
            mh$.invokeExact(mode, start, end, count, type, indices);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEdgeFlag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glEdgeFlag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glEdgeFlag(GLboolean flag)
     * }
     */
    public static FunctionDescriptor glEdgeFlag$descriptor() {
        return glEdgeFlag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glEdgeFlag(GLboolean flag)
     * }
     */
    public static MethodHandle glEdgeFlag$handle() {
        return glEdgeFlag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glEdgeFlag(GLboolean flag)
     * }
     */
    public static MemorySegment glEdgeFlag$address() {
        return glEdgeFlag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glEdgeFlag(GLboolean flag)
     * }
     */
    public static void glEdgeFlag(byte flag) {
        var mh$ = glEdgeFlag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEdgeFlag", flag);
            }
            mh$.invokeExact(flag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEdgeFlagPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glEdgeFlagPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glEdgeFlagPointer(GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static FunctionDescriptor glEdgeFlagPointer$descriptor() {
        return glEdgeFlagPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glEdgeFlagPointer(GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MethodHandle glEdgeFlagPointer$handle() {
        return glEdgeFlagPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glEdgeFlagPointer(GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MemorySegment glEdgeFlagPointer$address() {
        return glEdgeFlagPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glEdgeFlagPointer(GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static void glEdgeFlagPointer(int stride, MemorySegment pointer) {
        var mh$ = glEdgeFlagPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEdgeFlagPointer", stride, pointer);
            }
            mh$.invokeExact(stride, pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEdgeFlagv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glEdgeFlagv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glEdgeFlagv(const GLboolean *flag)
     * }
     */
    public static FunctionDescriptor glEdgeFlagv$descriptor() {
        return glEdgeFlagv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glEdgeFlagv(const GLboolean *flag)
     * }
     */
    public static MethodHandle glEdgeFlagv$handle() {
        return glEdgeFlagv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glEdgeFlagv(const GLboolean *flag)
     * }
     */
    public static MemorySegment glEdgeFlagv$address() {
        return glEdgeFlagv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glEdgeFlagv(const GLboolean *flag)
     * }
     */
    public static void glEdgeFlagv(MemorySegment flag) {
        var mh$ = glEdgeFlagv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEdgeFlagv", flag);
            }
            mh$.invokeExact(flag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEnable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glEnable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glEnable(GLenum cap)
     * }
     */
    public static FunctionDescriptor glEnable$descriptor() {
        return glEnable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glEnable(GLenum cap)
     * }
     */
    public static MethodHandle glEnable$handle() {
        return glEnable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glEnable(GLenum cap)
     * }
     */
    public static MemorySegment glEnable$address() {
        return glEnable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glEnable(GLenum cap)
     * }
     */
    public static void glEnable(int cap) {
        var mh$ = glEnable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEnable", cap);
            }
            mh$.invokeExact(cap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEnableClientState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glEnableClientState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glEnableClientState(GLenum array)
     * }
     */
    public static FunctionDescriptor glEnableClientState$descriptor() {
        return glEnableClientState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glEnableClientState(GLenum array)
     * }
     */
    public static MethodHandle glEnableClientState$handle() {
        return glEnableClientState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glEnableClientState(GLenum array)
     * }
     */
    public static MemorySegment glEnableClientState$address() {
        return glEnableClientState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glEnableClientState(GLenum array)
     * }
     */
    public static void glEnableClientState(int array) {
        var mh$ = glEnableClientState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEnableClientState", array);
            }
            mh$.invokeExact(array);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glEnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glEnd()
     * }
     */
    public static FunctionDescriptor glEnd$descriptor() {
        return glEnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glEnd()
     * }
     */
    public static MethodHandle glEnd$handle() {
        return glEnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glEnd()
     * }
     */
    public static MemorySegment glEnd$address() {
        return glEnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glEnd()
     * }
     */
    public static void glEnd() {
        var mh$ = glEnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEnd");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEndList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glEndList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glEndList()
     * }
     */
    public static FunctionDescriptor glEndList$descriptor() {
        return glEndList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glEndList()
     * }
     */
    public static MethodHandle glEndList$handle() {
        return glEndList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glEndList()
     * }
     */
    public static MemorySegment glEndList$address() {
        return glEndList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glEndList()
     * }
     */
    public static void glEndList() {
        var mh$ = glEndList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEndList");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glEvalCoord1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glEvalCoord1d(GLdouble u)
     * }
     */
    public static FunctionDescriptor glEvalCoord1d$descriptor() {
        return glEvalCoord1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glEvalCoord1d(GLdouble u)
     * }
     */
    public static MethodHandle glEvalCoord1d$handle() {
        return glEvalCoord1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glEvalCoord1d(GLdouble u)
     * }
     */
    public static MemorySegment glEvalCoord1d$address() {
        return glEvalCoord1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glEvalCoord1d(GLdouble u)
     * }
     */
    public static void glEvalCoord1d(double u) {
        var mh$ = glEvalCoord1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord1d", u);
            }
            mh$.invokeExact(u);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord1dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glEvalCoord1dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glEvalCoord1dv(const GLdouble *u)
     * }
     */
    public static FunctionDescriptor glEvalCoord1dv$descriptor() {
        return glEvalCoord1dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glEvalCoord1dv(const GLdouble *u)
     * }
     */
    public static MethodHandle glEvalCoord1dv$handle() {
        return glEvalCoord1dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glEvalCoord1dv(const GLdouble *u)
     * }
     */
    public static MemorySegment glEvalCoord1dv$address() {
        return glEvalCoord1dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glEvalCoord1dv(const GLdouble *u)
     * }
     */
    public static void glEvalCoord1dv(MemorySegment u) {
        var mh$ = glEvalCoord1dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord1dv", u);
            }
            mh$.invokeExact(u);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glEvalCoord1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glEvalCoord1f(GLfloat u)
     * }
     */
    public static FunctionDescriptor glEvalCoord1f$descriptor() {
        return glEvalCoord1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glEvalCoord1f(GLfloat u)
     * }
     */
    public static MethodHandle glEvalCoord1f$handle() {
        return glEvalCoord1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glEvalCoord1f(GLfloat u)
     * }
     */
    public static MemorySegment glEvalCoord1f$address() {
        return glEvalCoord1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glEvalCoord1f(GLfloat u)
     * }
     */
    public static void glEvalCoord1f(float u) {
        var mh$ = glEvalCoord1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord1f", u);
            }
            mh$.invokeExact(u);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord1fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glEvalCoord1fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glEvalCoord1fv(const GLfloat *u)
     * }
     */
    public static FunctionDescriptor glEvalCoord1fv$descriptor() {
        return glEvalCoord1fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glEvalCoord1fv(const GLfloat *u)
     * }
     */
    public static MethodHandle glEvalCoord1fv$handle() {
        return glEvalCoord1fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glEvalCoord1fv(const GLfloat *u)
     * }
     */
    public static MemorySegment glEvalCoord1fv$address() {
        return glEvalCoord1fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glEvalCoord1fv(const GLfloat *u)
     * }
     */
    public static void glEvalCoord1fv(MemorySegment u) {
        var mh$ = glEvalCoord1fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord1fv", u);
            }
            mh$.invokeExact(u);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glEvalCoord2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glEvalCoord2d(GLdouble u, GLdouble v)
     * }
     */
    public static FunctionDescriptor glEvalCoord2d$descriptor() {
        return glEvalCoord2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glEvalCoord2d(GLdouble u, GLdouble v)
     * }
     */
    public static MethodHandle glEvalCoord2d$handle() {
        return glEvalCoord2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glEvalCoord2d(GLdouble u, GLdouble v)
     * }
     */
    public static MemorySegment glEvalCoord2d$address() {
        return glEvalCoord2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glEvalCoord2d(GLdouble u, GLdouble v)
     * }
     */
    public static void glEvalCoord2d(double u, double v) {
        var mh$ = glEvalCoord2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord2d", u, v);
            }
            mh$.invokeExact(u, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord2dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glEvalCoord2dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glEvalCoord2dv(const GLdouble *u)
     * }
     */
    public static FunctionDescriptor glEvalCoord2dv$descriptor() {
        return glEvalCoord2dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glEvalCoord2dv(const GLdouble *u)
     * }
     */
    public static MethodHandle glEvalCoord2dv$handle() {
        return glEvalCoord2dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glEvalCoord2dv(const GLdouble *u)
     * }
     */
    public static MemorySegment glEvalCoord2dv$address() {
        return glEvalCoord2dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glEvalCoord2dv(const GLdouble *u)
     * }
     */
    public static void glEvalCoord2dv(MemorySegment u) {
        var mh$ = glEvalCoord2dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord2dv", u);
            }
            mh$.invokeExact(u);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glEvalCoord2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glEvalCoord2f(GLfloat u, GLfloat v)
     * }
     */
    public static FunctionDescriptor glEvalCoord2f$descriptor() {
        return glEvalCoord2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glEvalCoord2f(GLfloat u, GLfloat v)
     * }
     */
    public static MethodHandle glEvalCoord2f$handle() {
        return glEvalCoord2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glEvalCoord2f(GLfloat u, GLfloat v)
     * }
     */
    public static MemorySegment glEvalCoord2f$address() {
        return glEvalCoord2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glEvalCoord2f(GLfloat u, GLfloat v)
     * }
     */
    public static void glEvalCoord2f(float u, float v) {
        var mh$ = glEvalCoord2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord2f", u, v);
            }
            mh$.invokeExact(u, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord2fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glEvalCoord2fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glEvalCoord2fv(const GLfloat *u)
     * }
     */
    public static FunctionDescriptor glEvalCoord2fv$descriptor() {
        return glEvalCoord2fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glEvalCoord2fv(const GLfloat *u)
     * }
     */
    public static MethodHandle glEvalCoord2fv$handle() {
        return glEvalCoord2fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glEvalCoord2fv(const GLfloat *u)
     * }
     */
    public static MemorySegment glEvalCoord2fv$address() {
        return glEvalCoord2fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glEvalCoord2fv(const GLfloat *u)
     * }
     */
    public static void glEvalCoord2fv(MemorySegment u) {
        var mh$ = glEvalCoord2fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord2fv", u);
            }
            mh$.invokeExact(u);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalMesh1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glEvalMesh1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glEvalMesh1(GLenum mode, GLint i1, GLint i2)
     * }
     */
    public static FunctionDescriptor glEvalMesh1$descriptor() {
        return glEvalMesh1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glEvalMesh1(GLenum mode, GLint i1, GLint i2)
     * }
     */
    public static MethodHandle glEvalMesh1$handle() {
        return glEvalMesh1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glEvalMesh1(GLenum mode, GLint i1, GLint i2)
     * }
     */
    public static MemorySegment glEvalMesh1$address() {
        return glEvalMesh1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glEvalMesh1(GLenum mode, GLint i1, GLint i2)
     * }
     */
    public static void glEvalMesh1(int mode, int i1, int i2) {
        var mh$ = glEvalMesh1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalMesh1", mode, i1, i2);
            }
            mh$.invokeExact(mode, i1, i2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalMesh2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glEvalMesh2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)
     * }
     */
    public static FunctionDescriptor glEvalMesh2$descriptor() {
        return glEvalMesh2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)
     * }
     */
    public static MethodHandle glEvalMesh2$handle() {
        return glEvalMesh2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)
     * }
     */
    public static MemorySegment glEvalMesh2$address() {
        return glEvalMesh2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)
     * }
     */
    public static void glEvalMesh2(int mode, int i1, int i2, int j1, int j2) {
        var mh$ = glEvalMesh2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalMesh2", mode, i1, i2, j1, j2);
            }
            mh$.invokeExact(mode, i1, i2, j1, j2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalPoint1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glEvalPoint1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glEvalPoint1(GLint i)
     * }
     */
    public static FunctionDescriptor glEvalPoint1$descriptor() {
        return glEvalPoint1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glEvalPoint1(GLint i)
     * }
     */
    public static MethodHandle glEvalPoint1$handle() {
        return glEvalPoint1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glEvalPoint1(GLint i)
     * }
     */
    public static MemorySegment glEvalPoint1$address() {
        return glEvalPoint1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glEvalPoint1(GLint i)
     * }
     */
    public static void glEvalPoint1(int i) {
        var mh$ = glEvalPoint1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalPoint1", i);
            }
            mh$.invokeExact(i);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalPoint2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glEvalPoint2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glEvalPoint2(GLint i, GLint j)
     * }
     */
    public static FunctionDescriptor glEvalPoint2$descriptor() {
        return glEvalPoint2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glEvalPoint2(GLint i, GLint j)
     * }
     */
    public static MethodHandle glEvalPoint2$handle() {
        return glEvalPoint2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glEvalPoint2(GLint i, GLint j)
     * }
     */
    public static MemorySegment glEvalPoint2$address() {
        return glEvalPoint2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glEvalPoint2(GLint i, GLint j)
     * }
     */
    public static void glEvalPoint2(int i, int j) {
        var mh$ = glEvalPoint2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalPoint2", i, j);
            }
            mh$.invokeExact(i, j);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFeedbackBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFeedbackBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer)
     * }
     */
    public static FunctionDescriptor glFeedbackBuffer$descriptor() {
        return glFeedbackBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer)
     * }
     */
    public static MethodHandle glFeedbackBuffer$handle() {
        return glFeedbackBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer)
     * }
     */
    public static MemorySegment glFeedbackBuffer$address() {
        return glFeedbackBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer)
     * }
     */
    public static void glFeedbackBuffer(int size, int type, MemorySegment buffer) {
        var mh$ = glFeedbackBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFeedbackBuffer", size, type, buffer);
            }
            mh$.invokeExact(size, type, buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFinish {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFinish");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glFinish()
     * }
     */
    public static FunctionDescriptor glFinish$descriptor() {
        return glFinish.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glFinish()
     * }
     */
    public static MethodHandle glFinish$handle() {
        return glFinish.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glFinish()
     * }
     */
    public static MemorySegment glFinish$address() {
        return glFinish.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glFinish()
     * }
     */
    public static void glFinish() {
        var mh$ = glFinish.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFinish");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFlush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFlush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glFlush()
     * }
     */
    public static FunctionDescriptor glFlush$descriptor() {
        return glFlush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glFlush()
     * }
     */
    public static MethodHandle glFlush$handle() {
        return glFlush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glFlush()
     * }
     */
    public static MemorySegment glFlush$address() {
        return glFlush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glFlush()
     * }
     */
    public static void glFlush() {
        var mh$ = glFlush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFlush");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFogf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFogf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glFogf(GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glFogf$descriptor() {
        return glFogf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glFogf(GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glFogf$handle() {
        return glFogf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glFogf(GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glFogf$address() {
        return glFogf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glFogf(GLenum pname, GLfloat param)
     * }
     */
    public static void glFogf(int pname, float param) {
        var mh$ = glFogf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFogf", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFogfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFogfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glFogfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glFogfv$descriptor() {
        return glFogfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glFogfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glFogfv$handle() {
        return glFogfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glFogfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glFogfv$address() {
        return glFogfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glFogfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static void glFogfv(int pname, MemorySegment params) {
        var mh$ = glFogfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFogfv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFogi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFogi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glFogi(GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glFogi$descriptor() {
        return glFogi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glFogi(GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glFogi$handle() {
        return glFogi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glFogi(GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glFogi$address() {
        return glFogi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glFogi(GLenum pname, GLint param)
     * }
     */
    public static void glFogi(int pname, int param) {
        var mh$ = glFogi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFogi", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFogiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFogiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glFogiv(GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glFogiv$descriptor() {
        return glFogiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glFogiv(GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glFogiv$handle() {
        return glFogiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glFogiv(GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glFogiv$address() {
        return glFogiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glFogiv(GLenum pname, const GLint *params)
     * }
     */
    public static void glFogiv(int pname, MemorySegment params) {
        var mh$ = glFogiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFogiv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFrontFace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFrontFace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glFrontFace(GLenum mode)
     * }
     */
    public static FunctionDescriptor glFrontFace$descriptor() {
        return glFrontFace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glFrontFace(GLenum mode)
     * }
     */
    public static MethodHandle glFrontFace$handle() {
        return glFrontFace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glFrontFace(GLenum mode)
     * }
     */
    public static MemorySegment glFrontFace$address() {
        return glFrontFace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glFrontFace(GLenum mode)
     * }
     */
    public static void glFrontFace(int mode) {
        var mh$ = glFrontFace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFrontFace", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFrustum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFrustum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
     * }
     */
    public static FunctionDescriptor glFrustum$descriptor() {
        return glFrustum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
     * }
     */
    public static MethodHandle glFrustum$handle() {
        return glFrustum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
     * }
     */
    public static MemorySegment glFrustum$address() {
        return glFrustum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
     * }
     */
    public static void glFrustum(double left, double right, double bottom, double top, double zNear, double zFar) {
        var mh$ = glFrustum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFrustum", left, right, bottom, top, zNear, zFar);
            }
            mh$.invokeExact(left, right, bottom, top, zNear, zFar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGenLists {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGenLists");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLuint glGenLists(GLsizei range)
     * }
     */
    public static FunctionDescriptor glGenLists$descriptor() {
        return glGenLists.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLuint glGenLists(GLsizei range)
     * }
     */
    public static MethodHandle glGenLists$handle() {
        return glGenLists.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLuint glGenLists(GLsizei range)
     * }
     */
    public static MemorySegment glGenLists$address() {
        return glGenLists.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLuint glGenLists(GLsizei range)
     * }
     */
    public static int glGenLists(int range) {
        var mh$ = glGenLists.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGenLists", range);
            }
            return (int)mh$.invokeExact(range);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGenTextures {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGenTextures");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGenTextures(GLsizei n, GLuint *textures)
     * }
     */
    public static FunctionDescriptor glGenTextures$descriptor() {
        return glGenTextures.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGenTextures(GLsizei n, GLuint *textures)
     * }
     */
    public static MethodHandle glGenTextures$handle() {
        return glGenTextures.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGenTextures(GLsizei n, GLuint *textures)
     * }
     */
    public static MemorySegment glGenTextures$address() {
        return glGenTextures.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGenTextures(GLsizei n, GLuint *textures)
     * }
     */
    public static void glGenTextures(int n, MemorySegment textures) {
        var mh$ = glGenTextures.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGenTextures", n, textures);
            }
            mh$.invokeExact(n, textures);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetBooleanv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetBooleanv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetBooleanv(GLenum pname, GLboolean *params)
     * }
     */
    public static FunctionDescriptor glGetBooleanv$descriptor() {
        return glGetBooleanv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetBooleanv(GLenum pname, GLboolean *params)
     * }
     */
    public static MethodHandle glGetBooleanv$handle() {
        return glGetBooleanv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetBooleanv(GLenum pname, GLboolean *params)
     * }
     */
    public static MemorySegment glGetBooleanv$address() {
        return glGetBooleanv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetBooleanv(GLenum pname, GLboolean *params)
     * }
     */
    public static void glGetBooleanv(int pname, MemorySegment params) {
        var mh$ = glGetBooleanv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetBooleanv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetClipPlane {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetClipPlane");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetClipPlane(GLenum plane, GLdouble *equation)
     * }
     */
    public static FunctionDescriptor glGetClipPlane$descriptor() {
        return glGetClipPlane.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetClipPlane(GLenum plane, GLdouble *equation)
     * }
     */
    public static MethodHandle glGetClipPlane$handle() {
        return glGetClipPlane.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetClipPlane(GLenum plane, GLdouble *equation)
     * }
     */
    public static MemorySegment glGetClipPlane$address() {
        return glGetClipPlane.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetClipPlane(GLenum plane, GLdouble *equation)
     * }
     */
    public static void glGetClipPlane(int plane, MemorySegment equation) {
        var mh$ = glGetClipPlane.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetClipPlane", plane, equation);
            }
            mh$.invokeExact(plane, equation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetColorTable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetColorTable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetColorTable(GLenum target, GLenum format, GLenum type, GLvoid *table)
     * }
     */
    public static FunctionDescriptor glGetColorTable$descriptor() {
        return glGetColorTable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetColorTable(GLenum target, GLenum format, GLenum type, GLvoid *table)
     * }
     */
    public static MethodHandle glGetColorTable$handle() {
        return glGetColorTable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetColorTable(GLenum target, GLenum format, GLenum type, GLvoid *table)
     * }
     */
    public static MemorySegment glGetColorTable$address() {
        return glGetColorTable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetColorTable(GLenum target, GLenum format, GLenum type, GLvoid *table)
     * }
     */
    public static void glGetColorTable(int target, int format, int type, MemorySegment table) {
        var mh$ = glGetColorTable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetColorTable", target, format, type, table);
            }
            mh$.invokeExact(target, format, type, table);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetColorTableParameterfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetColorTableParameterfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetColorTableParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetColorTableParameterfv$descriptor() {
        return glGetColorTableParameterfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetColorTableParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetColorTableParameterfv$handle() {
        return glGetColorTableParameterfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetColorTableParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetColorTableParameterfv$address() {
        return glGetColorTableParameterfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetColorTableParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetColorTableParameterfv(int target, int pname, MemorySegment params) {
        var mh$ = glGetColorTableParameterfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetColorTableParameterfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetColorTableParameteriv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetColorTableParameteriv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetColorTableParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetColorTableParameteriv$descriptor() {
        return glGetColorTableParameteriv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetColorTableParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetColorTableParameteriv$handle() {
        return glGetColorTableParameteriv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetColorTableParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetColorTableParameteriv$address() {
        return glGetColorTableParameteriv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetColorTableParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static void glGetColorTableParameteriv(int target, int pname, MemorySegment params) {
        var mh$ = glGetColorTableParameteriv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetColorTableParameteriv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetConvolutionFilter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetConvolutionFilter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetConvolutionFilter(GLenum target, GLenum format, GLenum type, GLvoid *image)
     * }
     */
    public static FunctionDescriptor glGetConvolutionFilter$descriptor() {
        return glGetConvolutionFilter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetConvolutionFilter(GLenum target, GLenum format, GLenum type, GLvoid *image)
     * }
     */
    public static MethodHandle glGetConvolutionFilter$handle() {
        return glGetConvolutionFilter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetConvolutionFilter(GLenum target, GLenum format, GLenum type, GLvoid *image)
     * }
     */
    public static MemorySegment glGetConvolutionFilter$address() {
        return glGetConvolutionFilter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetConvolutionFilter(GLenum target, GLenum format, GLenum type, GLvoid *image)
     * }
     */
    public static void glGetConvolutionFilter(int target, int format, int type, MemorySegment image) {
        var mh$ = glGetConvolutionFilter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetConvolutionFilter", target, format, type, image);
            }
            mh$.invokeExact(target, format, type, image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetConvolutionParameterfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetConvolutionParameterfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetConvolutionParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetConvolutionParameterfv$descriptor() {
        return glGetConvolutionParameterfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetConvolutionParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetConvolutionParameterfv$handle() {
        return glGetConvolutionParameterfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetConvolutionParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetConvolutionParameterfv$address() {
        return glGetConvolutionParameterfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetConvolutionParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetConvolutionParameterfv(int target, int pname, MemorySegment params) {
        var mh$ = glGetConvolutionParameterfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetConvolutionParameterfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetConvolutionParameteriv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetConvolutionParameteriv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetConvolutionParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetConvolutionParameteriv$descriptor() {
        return glGetConvolutionParameteriv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetConvolutionParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetConvolutionParameteriv$handle() {
        return glGetConvolutionParameteriv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetConvolutionParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetConvolutionParameteriv$address() {
        return glGetConvolutionParameteriv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetConvolutionParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static void glGetConvolutionParameteriv(int target, int pname, MemorySegment params) {
        var mh$ = glGetConvolutionParameteriv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetConvolutionParameteriv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetDoublev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetDoublev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetDoublev(GLenum pname, GLdouble *params)
     * }
     */
    public static FunctionDescriptor glGetDoublev$descriptor() {
        return glGetDoublev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetDoublev(GLenum pname, GLdouble *params)
     * }
     */
    public static MethodHandle glGetDoublev$handle() {
        return glGetDoublev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetDoublev(GLenum pname, GLdouble *params)
     * }
     */
    public static MemorySegment glGetDoublev$address() {
        return glGetDoublev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetDoublev(GLenum pname, GLdouble *params)
     * }
     */
    public static void glGetDoublev(int pname, MemorySegment params) {
        var mh$ = glGetDoublev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetDoublev", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLenum glGetError()
     * }
     */
    public static FunctionDescriptor glGetError$descriptor() {
        return glGetError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLenum glGetError()
     * }
     */
    public static MethodHandle glGetError$handle() {
        return glGetError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLenum glGetError()
     * }
     */
    public static MemorySegment glGetError$address() {
        return glGetError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLenum glGetError()
     * }
     */
    public static int glGetError() {
        var mh$ = glGetError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetError");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetFloatv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetFloatv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetFloatv(GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetFloatv$descriptor() {
        return glGetFloatv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetFloatv(GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetFloatv$handle() {
        return glGetFloatv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetFloatv(GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetFloatv$address() {
        return glGetFloatv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetFloatv(GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetFloatv(int pname, MemorySegment params) {
        var mh$ = glGetFloatv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetFloatv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetHistogram {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_CHAR,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetHistogram");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetHistogram(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values)
     * }
     */
    public static FunctionDescriptor glGetHistogram$descriptor() {
        return glGetHistogram.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetHistogram(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values)
     * }
     */
    public static MethodHandle glGetHistogram$handle() {
        return glGetHistogram.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetHistogram(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values)
     * }
     */
    public static MemorySegment glGetHistogram$address() {
        return glGetHistogram.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetHistogram(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values)
     * }
     */
    public static void glGetHistogram(int target, byte reset, int format, int type, MemorySegment values) {
        var mh$ = glGetHistogram.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetHistogram", target, reset, format, type, values);
            }
            mh$.invokeExact(target, reset, format, type, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetHistogramParameterfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetHistogramParameterfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetHistogramParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetHistogramParameterfv$descriptor() {
        return glGetHistogramParameterfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetHistogramParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetHistogramParameterfv$handle() {
        return glGetHistogramParameterfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetHistogramParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetHistogramParameterfv$address() {
        return glGetHistogramParameterfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetHistogramParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetHistogramParameterfv(int target, int pname, MemorySegment params) {
        var mh$ = glGetHistogramParameterfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetHistogramParameterfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetHistogramParameteriv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetHistogramParameteriv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetHistogramParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetHistogramParameteriv$descriptor() {
        return glGetHistogramParameteriv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetHistogramParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetHistogramParameteriv$handle() {
        return glGetHistogramParameteriv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetHistogramParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetHistogramParameteriv$address() {
        return glGetHistogramParameteriv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetHistogramParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static void glGetHistogramParameteriv(int target, int pname, MemorySegment params) {
        var mh$ = glGetHistogramParameteriv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetHistogramParameteriv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetIntegerv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetIntegerv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetIntegerv(GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetIntegerv$descriptor() {
        return glGetIntegerv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetIntegerv(GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetIntegerv$handle() {
        return glGetIntegerv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetIntegerv(GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetIntegerv$address() {
        return glGetIntegerv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetIntegerv(GLenum pname, GLint *params)
     * }
     */
    public static void glGetIntegerv(int pname, MemorySegment params) {
        var mh$ = glGetIntegerv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetIntegerv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetLightfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetLightfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetLightfv(GLenum light, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetLightfv$descriptor() {
        return glGetLightfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetLightfv(GLenum light, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetLightfv$handle() {
        return glGetLightfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetLightfv(GLenum light, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetLightfv$address() {
        return glGetLightfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetLightfv(GLenum light, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetLightfv(int light, int pname, MemorySegment params) {
        var mh$ = glGetLightfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetLightfv", light, pname, params);
            }
            mh$.invokeExact(light, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetLightiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetLightiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetLightiv(GLenum light, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetLightiv$descriptor() {
        return glGetLightiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetLightiv(GLenum light, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetLightiv$handle() {
        return glGetLightiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetLightiv(GLenum light, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetLightiv$address() {
        return glGetLightiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetLightiv(GLenum light, GLenum pname, GLint *params)
     * }
     */
    public static void glGetLightiv(int light, int pname, MemorySegment params) {
        var mh$ = glGetLightiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetLightiv", light, pname, params);
            }
            mh$.invokeExact(light, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetMapdv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetMapdv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetMapdv(GLenum target, GLenum query, GLdouble *v)
     * }
     */
    public static FunctionDescriptor glGetMapdv$descriptor() {
        return glGetMapdv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetMapdv(GLenum target, GLenum query, GLdouble *v)
     * }
     */
    public static MethodHandle glGetMapdv$handle() {
        return glGetMapdv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetMapdv(GLenum target, GLenum query, GLdouble *v)
     * }
     */
    public static MemorySegment glGetMapdv$address() {
        return glGetMapdv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetMapdv(GLenum target, GLenum query, GLdouble *v)
     * }
     */
    public static void glGetMapdv(int target, int query, MemorySegment v) {
        var mh$ = glGetMapdv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetMapdv", target, query, v);
            }
            mh$.invokeExact(target, query, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetMapfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetMapfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetMapfv(GLenum target, GLenum query, GLfloat *v)
     * }
     */
    public static FunctionDescriptor glGetMapfv$descriptor() {
        return glGetMapfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetMapfv(GLenum target, GLenum query, GLfloat *v)
     * }
     */
    public static MethodHandle glGetMapfv$handle() {
        return glGetMapfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetMapfv(GLenum target, GLenum query, GLfloat *v)
     * }
     */
    public static MemorySegment glGetMapfv$address() {
        return glGetMapfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetMapfv(GLenum target, GLenum query, GLfloat *v)
     * }
     */
    public static void glGetMapfv(int target, int query, MemorySegment v) {
        var mh$ = glGetMapfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetMapfv", target, query, v);
            }
            mh$.invokeExact(target, query, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetMapiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetMapiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetMapiv(GLenum target, GLenum query, GLint *v)
     * }
     */
    public static FunctionDescriptor glGetMapiv$descriptor() {
        return glGetMapiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetMapiv(GLenum target, GLenum query, GLint *v)
     * }
     */
    public static MethodHandle glGetMapiv$handle() {
        return glGetMapiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetMapiv(GLenum target, GLenum query, GLint *v)
     * }
     */
    public static MemorySegment glGetMapiv$address() {
        return glGetMapiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetMapiv(GLenum target, GLenum query, GLint *v)
     * }
     */
    public static void glGetMapiv(int target, int query, MemorySegment v) {
        var mh$ = glGetMapiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetMapiv", target, query, v);
            }
            mh$.invokeExact(target, query, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetMaterialfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetMaterialfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetMaterialfv$descriptor() {
        return glGetMaterialfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetMaterialfv$handle() {
        return glGetMaterialfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetMaterialfv$address() {
        return glGetMaterialfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetMaterialfv(int face, int pname, MemorySegment params) {
        var mh$ = glGetMaterialfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetMaterialfv", face, pname, params);
            }
            mh$.invokeExact(face, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetMaterialiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetMaterialiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetMaterialiv(GLenum face, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetMaterialiv$descriptor() {
        return glGetMaterialiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetMaterialiv(GLenum face, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetMaterialiv$handle() {
        return glGetMaterialiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetMaterialiv(GLenum face, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetMaterialiv$address() {
        return glGetMaterialiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetMaterialiv(GLenum face, GLenum pname, GLint *params)
     * }
     */
    public static void glGetMaterialiv(int face, int pname, MemorySegment params) {
        var mh$ = glGetMaterialiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetMaterialiv", face, pname, params);
            }
            mh$.invokeExact(face, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetMinmax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_CHAR,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetMinmax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetMinmax(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values)
     * }
     */
    public static FunctionDescriptor glGetMinmax$descriptor() {
        return glGetMinmax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetMinmax(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values)
     * }
     */
    public static MethodHandle glGetMinmax$handle() {
        return glGetMinmax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetMinmax(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values)
     * }
     */
    public static MemorySegment glGetMinmax$address() {
        return glGetMinmax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetMinmax(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values)
     * }
     */
    public static void glGetMinmax(int target, byte reset, int format, int type, MemorySegment values) {
        var mh$ = glGetMinmax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetMinmax", target, reset, format, type, values);
            }
            mh$.invokeExact(target, reset, format, type, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetMinmaxParameterfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetMinmaxParameterfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetMinmaxParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetMinmaxParameterfv$descriptor() {
        return glGetMinmaxParameterfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetMinmaxParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetMinmaxParameterfv$handle() {
        return glGetMinmaxParameterfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetMinmaxParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetMinmaxParameterfv$address() {
        return glGetMinmaxParameterfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetMinmaxParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetMinmaxParameterfv(int target, int pname, MemorySegment params) {
        var mh$ = glGetMinmaxParameterfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetMinmaxParameterfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetMinmaxParameteriv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetMinmaxParameteriv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetMinmaxParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetMinmaxParameteriv$descriptor() {
        return glGetMinmaxParameteriv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetMinmaxParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetMinmaxParameteriv$handle() {
        return glGetMinmaxParameteriv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetMinmaxParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetMinmaxParameteriv$address() {
        return glGetMinmaxParameteriv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetMinmaxParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static void glGetMinmaxParameteriv(int target, int pname, MemorySegment params) {
        var mh$ = glGetMinmaxParameteriv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetMinmaxParameteriv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetPixelMapfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetPixelMapfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetPixelMapfv(GLenum map, GLfloat *values)
     * }
     */
    public static FunctionDescriptor glGetPixelMapfv$descriptor() {
        return glGetPixelMapfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetPixelMapfv(GLenum map, GLfloat *values)
     * }
     */
    public static MethodHandle glGetPixelMapfv$handle() {
        return glGetPixelMapfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetPixelMapfv(GLenum map, GLfloat *values)
     * }
     */
    public static MemorySegment glGetPixelMapfv$address() {
        return glGetPixelMapfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetPixelMapfv(GLenum map, GLfloat *values)
     * }
     */
    public static void glGetPixelMapfv(int map, MemorySegment values) {
        var mh$ = glGetPixelMapfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetPixelMapfv", map, values);
            }
            mh$.invokeExact(map, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetPixelMapuiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetPixelMapuiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetPixelMapuiv(GLenum map, GLuint *values)
     * }
     */
    public static FunctionDescriptor glGetPixelMapuiv$descriptor() {
        return glGetPixelMapuiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetPixelMapuiv(GLenum map, GLuint *values)
     * }
     */
    public static MethodHandle glGetPixelMapuiv$handle() {
        return glGetPixelMapuiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetPixelMapuiv(GLenum map, GLuint *values)
     * }
     */
    public static MemorySegment glGetPixelMapuiv$address() {
        return glGetPixelMapuiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetPixelMapuiv(GLenum map, GLuint *values)
     * }
     */
    public static void glGetPixelMapuiv(int map, MemorySegment values) {
        var mh$ = glGetPixelMapuiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetPixelMapuiv", map, values);
            }
            mh$.invokeExact(map, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetPixelMapusv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetPixelMapusv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetPixelMapusv(GLenum map, GLushort *values)
     * }
     */
    public static FunctionDescriptor glGetPixelMapusv$descriptor() {
        return glGetPixelMapusv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetPixelMapusv(GLenum map, GLushort *values)
     * }
     */
    public static MethodHandle glGetPixelMapusv$handle() {
        return glGetPixelMapusv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetPixelMapusv(GLenum map, GLushort *values)
     * }
     */
    public static MemorySegment glGetPixelMapusv$address() {
        return glGetPixelMapusv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetPixelMapusv(GLenum map, GLushort *values)
     * }
     */
    public static void glGetPixelMapusv(int map, MemorySegment values) {
        var mh$ = glGetPixelMapusv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetPixelMapusv", map, values);
            }
            mh$.invokeExact(map, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetPointerv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetPointerv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetPointerv(GLenum pname, GLvoid **params)
     * }
     */
    public static FunctionDescriptor glGetPointerv$descriptor() {
        return glGetPointerv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetPointerv(GLenum pname, GLvoid **params)
     * }
     */
    public static MethodHandle glGetPointerv$handle() {
        return glGetPointerv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetPointerv(GLenum pname, GLvoid **params)
     * }
     */
    public static MemorySegment glGetPointerv$address() {
        return glGetPointerv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetPointerv(GLenum pname, GLvoid **params)
     * }
     */
    public static void glGetPointerv(int pname, MemorySegment params) {
        var mh$ = glGetPointerv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetPointerv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetPolygonStipple {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetPolygonStipple");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetPolygonStipple(GLubyte *mask)
     * }
     */
    public static FunctionDescriptor glGetPolygonStipple$descriptor() {
        return glGetPolygonStipple.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetPolygonStipple(GLubyte *mask)
     * }
     */
    public static MethodHandle glGetPolygonStipple$handle() {
        return glGetPolygonStipple.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetPolygonStipple(GLubyte *mask)
     * }
     */
    public static MemorySegment glGetPolygonStipple$address() {
        return glGetPolygonStipple.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetPolygonStipple(GLubyte *mask)
     * }
     */
    public static void glGetPolygonStipple(MemorySegment mask) {
        var mh$ = glGetPolygonStipple.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetPolygonStipple", mask);
            }
            mh$.invokeExact(mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetSeparableFilter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetSeparableFilter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetSeparableFilter(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span)
     * }
     */
    public static FunctionDescriptor glGetSeparableFilter$descriptor() {
        return glGetSeparableFilter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetSeparableFilter(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span)
     * }
     */
    public static MethodHandle glGetSeparableFilter$handle() {
        return glGetSeparableFilter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetSeparableFilter(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span)
     * }
     */
    public static MemorySegment glGetSeparableFilter$address() {
        return glGetSeparableFilter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetSeparableFilter(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span)
     * }
     */
    public static void glGetSeparableFilter(int target, int format, int type, MemorySegment row, MemorySegment column, MemorySegment span) {
        var mh$ = glGetSeparableFilter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetSeparableFilter", target, format, type, row, column, span);
            }
            mh$.invokeExact(target, format, type, row, column, span);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const GLubyte *glGetString(GLenum name)
     * }
     */
    public static FunctionDescriptor glGetString$descriptor() {
        return glGetString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const GLubyte *glGetString(GLenum name)
     * }
     */
    public static MethodHandle glGetString$handle() {
        return glGetString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const GLubyte *glGetString(GLenum name)
     * }
     */
    public static MemorySegment glGetString$address() {
        return glGetString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const GLubyte *glGetString(GLenum name)
     * }
     */
    public static MemorySegment glGetString(int name) {
        var mh$ = glGetString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetString", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexEnvfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetTexEnvfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetTexEnvfv$descriptor() {
        return glGetTexEnvfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetTexEnvfv$handle() {
        return glGetTexEnvfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetTexEnvfv$address() {
        return glGetTexEnvfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetTexEnvfv(int target, int pname, MemorySegment params) {
        var mh$ = glGetTexEnvfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexEnvfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexEnviv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetTexEnviv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetTexEnviv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetTexEnviv$descriptor() {
        return glGetTexEnviv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetTexEnviv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetTexEnviv$handle() {
        return glGetTexEnviv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetTexEnviv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetTexEnviv$address() {
        return glGetTexEnviv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetTexEnviv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static void glGetTexEnviv(int target, int pname, MemorySegment params) {
        var mh$ = glGetTexEnviv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexEnviv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexGendv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetTexGendv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params)
     * }
     */
    public static FunctionDescriptor glGetTexGendv$descriptor() {
        return glGetTexGendv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params)
     * }
     */
    public static MethodHandle glGetTexGendv$handle() {
        return glGetTexGendv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params)
     * }
     */
    public static MemorySegment glGetTexGendv$address() {
        return glGetTexGendv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params)
     * }
     */
    public static void glGetTexGendv(int coord, int pname, MemorySegment params) {
        var mh$ = glGetTexGendv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexGendv", coord, pname, params);
            }
            mh$.invokeExact(coord, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexGenfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetTexGenfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetTexGenfv$descriptor() {
        return glGetTexGenfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetTexGenfv$handle() {
        return glGetTexGenfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetTexGenfv$address() {
        return glGetTexGenfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetTexGenfv(int coord, int pname, MemorySegment params) {
        var mh$ = glGetTexGenfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexGenfv", coord, pname, params);
            }
            mh$.invokeExact(coord, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexGeniv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetTexGeniv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetTexGeniv(GLenum coord, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetTexGeniv$descriptor() {
        return glGetTexGeniv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetTexGeniv(GLenum coord, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetTexGeniv$handle() {
        return glGetTexGeniv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetTexGeniv(GLenum coord, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetTexGeniv$address() {
        return glGetTexGeniv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetTexGeniv(GLenum coord, GLenum pname, GLint *params)
     * }
     */
    public static void glGetTexGeniv(int coord, int pname, MemorySegment params) {
        var mh$ = glGetTexGeniv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexGeniv", coord, pname, params);
            }
            mh$.invokeExact(coord, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetTexImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glGetTexImage$descriptor() {
        return glGetTexImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static MethodHandle glGetTexImage$handle() {
        return glGetTexImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static MemorySegment glGetTexImage$address() {
        return glGetTexImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static void glGetTexImage(int target, int level, int format, int type, MemorySegment pixels) {
        var mh$ = glGetTexImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexImage", target, level, format, type, pixels);
            }
            mh$.invokeExact(target, level, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexLevelParameterfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetTexLevelParameterfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetTexLevelParameterfv$descriptor() {
        return glGetTexLevelParameterfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetTexLevelParameterfv$handle() {
        return glGetTexLevelParameterfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetTexLevelParameterfv$address() {
        return glGetTexLevelParameterfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetTexLevelParameterfv(int target, int level, int pname, MemorySegment params) {
        var mh$ = glGetTexLevelParameterfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexLevelParameterfv", target, level, pname, params);
            }
            mh$.invokeExact(target, level, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexLevelParameteriv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetTexLevelParameteriv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetTexLevelParameteriv$descriptor() {
        return glGetTexLevelParameteriv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetTexLevelParameteriv$handle() {
        return glGetTexLevelParameteriv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetTexLevelParameteriv$address() {
        return glGetTexLevelParameteriv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params)
     * }
     */
    public static void glGetTexLevelParameteriv(int target, int level, int pname, MemorySegment params) {
        var mh$ = glGetTexLevelParameteriv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexLevelParameteriv", target, level, pname, params);
            }
            mh$.invokeExact(target, level, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexParameterfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetTexParameterfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetTexParameterfv$descriptor() {
        return glGetTexParameterfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetTexParameterfv$handle() {
        return glGetTexParameterfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetTexParameterfv$address() {
        return glGetTexParameterfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetTexParameterfv(int target, int pname, MemorySegment params) {
        var mh$ = glGetTexParameterfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexParameterfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexParameteriv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetTexParameteriv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetTexParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetTexParameteriv$descriptor() {
        return glGetTexParameteriv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetTexParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetTexParameteriv$handle() {
        return glGetTexParameteriv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetTexParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetTexParameteriv$address() {
        return glGetTexParameteriv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetTexParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static void glGetTexParameteriv(int target, int pname, MemorySegment params) {
        var mh$ = glGetTexParameteriv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexParameteriv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glHint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glHint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glHint(GLenum target, GLenum mode)
     * }
     */
    public static FunctionDescriptor glHint$descriptor() {
        return glHint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glHint(GLenum target, GLenum mode)
     * }
     */
    public static MethodHandle glHint$handle() {
        return glHint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glHint(GLenum target, GLenum mode)
     * }
     */
    public static MemorySegment glHint$address() {
        return glHint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glHint(GLenum target, GLenum mode)
     * }
     */
    public static void glHint(int target, int mode) {
        var mh$ = glHint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glHint", target, mode);
            }
            mh$.invokeExact(target, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glHistogram {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glHistogram");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glHistogram(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink)
     * }
     */
    public static FunctionDescriptor glHistogram$descriptor() {
        return glHistogram.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glHistogram(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink)
     * }
     */
    public static MethodHandle glHistogram$handle() {
        return glHistogram.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glHistogram(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink)
     * }
     */
    public static MemorySegment glHistogram$address() {
        return glHistogram.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glHistogram(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink)
     * }
     */
    public static void glHistogram(int target, int width, int internalformat, byte sink) {
        var mh$ = glHistogram.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glHistogram", target, width, internalformat, sink);
            }
            mh$.invokeExact(target, width, internalformat, sink);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glIndexMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glIndexMask(GLuint mask)
     * }
     */
    public static FunctionDescriptor glIndexMask$descriptor() {
        return glIndexMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glIndexMask(GLuint mask)
     * }
     */
    public static MethodHandle glIndexMask$handle() {
        return glIndexMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glIndexMask(GLuint mask)
     * }
     */
    public static MemorySegment glIndexMask$address() {
        return glIndexMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glIndexMask(GLuint mask)
     * }
     */
    public static void glIndexMask(int mask) {
        var mh$ = glIndexMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexMask", mask);
            }
            mh$.invokeExact(mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glIndexPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glIndexPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static FunctionDescriptor glIndexPointer$descriptor() {
        return glIndexPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glIndexPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MethodHandle glIndexPointer$handle() {
        return glIndexPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glIndexPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MemorySegment glIndexPointer$address() {
        return glIndexPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glIndexPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static void glIndexPointer(int type, int stride, MemorySegment pointer) {
        var mh$ = glIndexPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexPointer", type, stride, pointer);
            }
            mh$.invokeExact(type, stride, pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glIndexd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glIndexd(GLdouble c)
     * }
     */
    public static FunctionDescriptor glIndexd$descriptor() {
        return glIndexd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glIndexd(GLdouble c)
     * }
     */
    public static MethodHandle glIndexd$handle() {
        return glIndexd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glIndexd(GLdouble c)
     * }
     */
    public static MemorySegment glIndexd$address() {
        return glIndexd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glIndexd(GLdouble c)
     * }
     */
    public static void glIndexd(double c) {
        var mh$ = glIndexd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexd", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexdv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glIndexdv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glIndexdv(const GLdouble *c)
     * }
     */
    public static FunctionDescriptor glIndexdv$descriptor() {
        return glIndexdv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glIndexdv(const GLdouble *c)
     * }
     */
    public static MethodHandle glIndexdv$handle() {
        return glIndexdv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glIndexdv(const GLdouble *c)
     * }
     */
    public static MemorySegment glIndexdv$address() {
        return glIndexdv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glIndexdv(const GLdouble *c)
     * }
     */
    public static void glIndexdv(MemorySegment c) {
        var mh$ = glIndexdv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexdv", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glIndexf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glIndexf(GLfloat c)
     * }
     */
    public static FunctionDescriptor glIndexf$descriptor() {
        return glIndexf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glIndexf(GLfloat c)
     * }
     */
    public static MethodHandle glIndexf$handle() {
        return glIndexf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glIndexf(GLfloat c)
     * }
     */
    public static MemorySegment glIndexf$address() {
        return glIndexf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glIndexf(GLfloat c)
     * }
     */
    public static void glIndexf(float c) {
        var mh$ = glIndexf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexf", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glIndexfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glIndexfv(const GLfloat *c)
     * }
     */
    public static FunctionDescriptor glIndexfv$descriptor() {
        return glIndexfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glIndexfv(const GLfloat *c)
     * }
     */
    public static MethodHandle glIndexfv$handle() {
        return glIndexfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glIndexfv(const GLfloat *c)
     * }
     */
    public static MemorySegment glIndexfv$address() {
        return glIndexfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glIndexfv(const GLfloat *c)
     * }
     */
    public static void glIndexfv(MemorySegment c) {
        var mh$ = glIndexfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexfv", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glIndexi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glIndexi(GLint c)
     * }
     */
    public static FunctionDescriptor glIndexi$descriptor() {
        return glIndexi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glIndexi(GLint c)
     * }
     */
    public static MethodHandle glIndexi$handle() {
        return glIndexi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glIndexi(GLint c)
     * }
     */
    public static MemorySegment glIndexi$address() {
        return glIndexi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glIndexi(GLint c)
     * }
     */
    public static void glIndexi(int c) {
        var mh$ = glIndexi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexi", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glIndexiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glIndexiv(const GLint *c)
     * }
     */
    public static FunctionDescriptor glIndexiv$descriptor() {
        return glIndexiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glIndexiv(const GLint *c)
     * }
     */
    public static MethodHandle glIndexiv$handle() {
        return glIndexiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glIndexiv(const GLint *c)
     * }
     */
    public static MemorySegment glIndexiv$address() {
        return glIndexiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glIndexiv(const GLint *c)
     * }
     */
    public static void glIndexiv(MemorySegment c) {
        var mh$ = glIndexiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexiv", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glIndexs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glIndexs(GLshort c)
     * }
     */
    public static FunctionDescriptor glIndexs$descriptor() {
        return glIndexs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glIndexs(GLshort c)
     * }
     */
    public static MethodHandle glIndexs$handle() {
        return glIndexs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glIndexs(GLshort c)
     * }
     */
    public static MemorySegment glIndexs$address() {
        return glIndexs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glIndexs(GLshort c)
     * }
     */
    public static void glIndexs(short c) {
        var mh$ = glIndexs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexs", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glIndexsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glIndexsv(const GLshort *c)
     * }
     */
    public static FunctionDescriptor glIndexsv$descriptor() {
        return glIndexsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glIndexsv(const GLshort *c)
     * }
     */
    public static MethodHandle glIndexsv$handle() {
        return glIndexsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glIndexsv(const GLshort *c)
     * }
     */
    public static MemorySegment glIndexsv$address() {
        return glIndexsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glIndexsv(const GLshort *c)
     * }
     */
    public static void glIndexsv(MemorySegment c) {
        var mh$ = glIndexsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexsv", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glIndexub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glIndexub(GLubyte c)
     * }
     */
    public static FunctionDescriptor glIndexub$descriptor() {
        return glIndexub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glIndexub(GLubyte c)
     * }
     */
    public static MethodHandle glIndexub$handle() {
        return glIndexub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glIndexub(GLubyte c)
     * }
     */
    public static MemorySegment glIndexub$address() {
        return glIndexub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glIndexub(GLubyte c)
     * }
     */
    public static void glIndexub(byte c) {
        var mh$ = glIndexub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexub", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexubv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glIndexubv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glIndexubv(const GLubyte *c)
     * }
     */
    public static FunctionDescriptor glIndexubv$descriptor() {
        return glIndexubv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glIndexubv(const GLubyte *c)
     * }
     */
    public static MethodHandle glIndexubv$handle() {
        return glIndexubv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glIndexubv(const GLubyte *c)
     * }
     */
    public static MemorySegment glIndexubv$address() {
        return glIndexubv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glIndexubv(const GLubyte *c)
     * }
     */
    public static void glIndexubv(MemorySegment c) {
        var mh$ = glIndexubv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexubv", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glInitNames {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glInitNames");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glInitNames()
     * }
     */
    public static FunctionDescriptor glInitNames$descriptor() {
        return glInitNames.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glInitNames()
     * }
     */
    public static MethodHandle glInitNames$handle() {
        return glInitNames.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glInitNames()
     * }
     */
    public static MemorySegment glInitNames$address() {
        return glInitNames.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glInitNames()
     * }
     */
    public static void glInitNames() {
        var mh$ = glInitNames.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glInitNames");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glInterleavedArrays {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glInterleavedArrays");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glInterleavedArrays(GLenum format, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static FunctionDescriptor glInterleavedArrays$descriptor() {
        return glInterleavedArrays.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glInterleavedArrays(GLenum format, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MethodHandle glInterleavedArrays$handle() {
        return glInterleavedArrays.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glInterleavedArrays(GLenum format, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MemorySegment glInterleavedArrays$address() {
        return glInterleavedArrays.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glInterleavedArrays(GLenum format, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static void glInterleavedArrays(int format, int stride, MemorySegment pointer) {
        var mh$ = glInterleavedArrays.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glInterleavedArrays", format, stride, pointer);
            }
            mh$.invokeExact(format, stride, pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIsEnabled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glIsEnabled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLboolean glIsEnabled(GLenum cap)
     * }
     */
    public static FunctionDescriptor glIsEnabled$descriptor() {
        return glIsEnabled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLboolean glIsEnabled(GLenum cap)
     * }
     */
    public static MethodHandle glIsEnabled$handle() {
        return glIsEnabled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLboolean glIsEnabled(GLenum cap)
     * }
     */
    public static MemorySegment glIsEnabled$address() {
        return glIsEnabled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLboolean glIsEnabled(GLenum cap)
     * }
     */
    public static byte glIsEnabled(int cap) {
        var mh$ = glIsEnabled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIsEnabled", cap);
            }
            return (byte)mh$.invokeExact(cap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIsList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glIsList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLboolean glIsList(GLuint list)
     * }
     */
    public static FunctionDescriptor glIsList$descriptor() {
        return glIsList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLboolean glIsList(GLuint list)
     * }
     */
    public static MethodHandle glIsList$handle() {
        return glIsList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLboolean glIsList(GLuint list)
     * }
     */
    public static MemorySegment glIsList$address() {
        return glIsList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLboolean glIsList(GLuint list)
     * }
     */
    public static byte glIsList(int list) {
        var mh$ = glIsList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIsList", list);
            }
            return (byte)mh$.invokeExact(list);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIsTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glIsTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLboolean glIsTexture(GLuint texture)
     * }
     */
    public static FunctionDescriptor glIsTexture$descriptor() {
        return glIsTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLboolean glIsTexture(GLuint texture)
     * }
     */
    public static MethodHandle glIsTexture$handle() {
        return glIsTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLboolean glIsTexture(GLuint texture)
     * }
     */
    public static MemorySegment glIsTexture$address() {
        return glIsTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLboolean glIsTexture(GLuint texture)
     * }
     */
    public static byte glIsTexture(int texture) {
        var mh$ = glIsTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIsTexture", texture);
            }
            return (byte)mh$.invokeExact(texture);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLightModelf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glLightModelf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glLightModelf(GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glLightModelf$descriptor() {
        return glLightModelf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glLightModelf(GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glLightModelf$handle() {
        return glLightModelf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glLightModelf(GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glLightModelf$address() {
        return glLightModelf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glLightModelf(GLenum pname, GLfloat param)
     * }
     */
    public static void glLightModelf(int pname, float param) {
        var mh$ = glLightModelf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLightModelf", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLightModelfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glLightModelfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glLightModelfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glLightModelfv$descriptor() {
        return glLightModelfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glLightModelfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glLightModelfv$handle() {
        return glLightModelfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glLightModelfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glLightModelfv$address() {
        return glLightModelfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glLightModelfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static void glLightModelfv(int pname, MemorySegment params) {
        var mh$ = glLightModelfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLightModelfv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLightModeli {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glLightModeli");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glLightModeli(GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glLightModeli$descriptor() {
        return glLightModeli.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glLightModeli(GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glLightModeli$handle() {
        return glLightModeli.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glLightModeli(GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glLightModeli$address() {
        return glLightModeli.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glLightModeli(GLenum pname, GLint param)
     * }
     */
    public static void glLightModeli(int pname, int param) {
        var mh$ = glLightModeli.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLightModeli", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLightModeliv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glLightModeliv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glLightModeliv(GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glLightModeliv$descriptor() {
        return glLightModeliv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glLightModeliv(GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glLightModeliv$handle() {
        return glLightModeliv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glLightModeliv(GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glLightModeliv$address() {
        return glLightModeliv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glLightModeliv(GLenum pname, const GLint *params)
     * }
     */
    public static void glLightModeliv(int pname, MemorySegment params) {
        var mh$ = glLightModeliv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLightModeliv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLightf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glLightf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glLightf(GLenum light, GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glLightf$descriptor() {
        return glLightf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glLightf(GLenum light, GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glLightf$handle() {
        return glLightf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glLightf(GLenum light, GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glLightf$address() {
        return glLightf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glLightf(GLenum light, GLenum pname, GLfloat param)
     * }
     */
    public static void glLightf(int light, int pname, float param) {
        var mh$ = glLightf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLightf", light, pname, param);
            }
            mh$.invokeExact(light, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLightfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glLightfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glLightfv(GLenum light, GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glLightfv$descriptor() {
        return glLightfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glLightfv(GLenum light, GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glLightfv$handle() {
        return glLightfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glLightfv(GLenum light, GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glLightfv$address() {
        return glLightfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glLightfv(GLenum light, GLenum pname, const GLfloat *params)
     * }
     */
    public static void glLightfv(int light, int pname, MemorySegment params) {
        var mh$ = glLightfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLightfv", light, pname, params);
            }
            mh$.invokeExact(light, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLighti {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glLighti");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glLighti(GLenum light, GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glLighti$descriptor() {
        return glLighti.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glLighti(GLenum light, GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glLighti$handle() {
        return glLighti.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glLighti(GLenum light, GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glLighti$address() {
        return glLighti.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glLighti(GLenum light, GLenum pname, GLint param)
     * }
     */
    public static void glLighti(int light, int pname, int param) {
        var mh$ = glLighti.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLighti", light, pname, param);
            }
            mh$.invokeExact(light, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLightiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glLightiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glLightiv(GLenum light, GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glLightiv$descriptor() {
        return glLightiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glLightiv(GLenum light, GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glLightiv$handle() {
        return glLightiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glLightiv(GLenum light, GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glLightiv$address() {
        return glLightiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glLightiv(GLenum light, GLenum pname, const GLint *params)
     * }
     */
    public static void glLightiv(int light, int pname, MemorySegment params) {
        var mh$ = glLightiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLightiv", light, pname, params);
            }
            mh$.invokeExact(light, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLineStipple {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glLineStipple");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glLineStipple(GLint factor, GLushort pattern)
     * }
     */
    public static FunctionDescriptor glLineStipple$descriptor() {
        return glLineStipple.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glLineStipple(GLint factor, GLushort pattern)
     * }
     */
    public static MethodHandle glLineStipple$handle() {
        return glLineStipple.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glLineStipple(GLint factor, GLushort pattern)
     * }
     */
    public static MemorySegment glLineStipple$address() {
        return glLineStipple.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glLineStipple(GLint factor, GLushort pattern)
     * }
     */
    public static void glLineStipple(int factor, short pattern) {
        var mh$ = glLineStipple.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLineStipple", factor, pattern);
            }
            mh$.invokeExact(factor, pattern);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLineWidth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glLineWidth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glLineWidth(GLfloat width)
     * }
     */
    public static FunctionDescriptor glLineWidth$descriptor() {
        return glLineWidth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glLineWidth(GLfloat width)
     * }
     */
    public static MethodHandle glLineWidth$handle() {
        return glLineWidth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glLineWidth(GLfloat width)
     * }
     */
    public static MemorySegment glLineWidth$address() {
        return glLineWidth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glLineWidth(GLfloat width)
     * }
     */
    public static void glLineWidth(float width) {
        var mh$ = glLineWidth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLineWidth", width);
            }
            mh$.invokeExact(width);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glListBase {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glListBase");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glListBase(GLuint base)
     * }
     */
    public static FunctionDescriptor glListBase$descriptor() {
        return glListBase.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glListBase(GLuint base)
     * }
     */
    public static MethodHandle glListBase$handle() {
        return glListBase.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glListBase(GLuint base)
     * }
     */
    public static MemorySegment glListBase$address() {
        return glListBase.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glListBase(GLuint base)
     * }
     */
    public static void glListBase(int base) {
        var mh$ = glListBase.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glListBase", base);
            }
            mh$.invokeExact(base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLoadIdentity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glLoadIdentity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glLoadIdentity()
     * }
     */
    public static FunctionDescriptor glLoadIdentity$descriptor() {
        return glLoadIdentity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glLoadIdentity()
     * }
     */
    public static MethodHandle glLoadIdentity$handle() {
        return glLoadIdentity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glLoadIdentity()
     * }
     */
    public static MemorySegment glLoadIdentity$address() {
        return glLoadIdentity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glLoadIdentity()
     * }
     */
    public static void glLoadIdentity() {
        var mh$ = glLoadIdentity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLoadIdentity");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLoadMatrixd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glLoadMatrixd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glLoadMatrixd(const GLdouble *m)
     * }
     */
    public static FunctionDescriptor glLoadMatrixd$descriptor() {
        return glLoadMatrixd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glLoadMatrixd(const GLdouble *m)
     * }
     */
    public static MethodHandle glLoadMatrixd$handle() {
        return glLoadMatrixd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glLoadMatrixd(const GLdouble *m)
     * }
     */
    public static MemorySegment glLoadMatrixd$address() {
        return glLoadMatrixd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glLoadMatrixd(const GLdouble *m)
     * }
     */
    public static void glLoadMatrixd(MemorySegment m) {
        var mh$ = glLoadMatrixd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLoadMatrixd", m);
            }
            mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLoadMatrixf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glLoadMatrixf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glLoadMatrixf(const GLfloat *m)
     * }
     */
    public static FunctionDescriptor glLoadMatrixf$descriptor() {
        return glLoadMatrixf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glLoadMatrixf(const GLfloat *m)
     * }
     */
    public static MethodHandle glLoadMatrixf$handle() {
        return glLoadMatrixf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glLoadMatrixf(const GLfloat *m)
     * }
     */
    public static MemorySegment glLoadMatrixf$address() {
        return glLoadMatrixf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glLoadMatrixf(const GLfloat *m)
     * }
     */
    public static void glLoadMatrixf(MemorySegment m) {
        var mh$ = glLoadMatrixf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLoadMatrixf", m);
            }
            mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLoadName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glLoadName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glLoadName(GLuint name)
     * }
     */
    public static FunctionDescriptor glLoadName$descriptor() {
        return glLoadName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glLoadName(GLuint name)
     * }
     */
    public static MethodHandle glLoadName$handle() {
        return glLoadName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glLoadName(GLuint name)
     * }
     */
    public static MemorySegment glLoadName$address() {
        return glLoadName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glLoadName(GLuint name)
     * }
     */
    public static void glLoadName(int name) {
        var mh$ = glLoadName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLoadName", name);
            }
            mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLogicOp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glLogicOp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glLogicOp(GLenum opcode)
     * }
     */
    public static FunctionDescriptor glLogicOp$descriptor() {
        return glLogicOp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glLogicOp(GLenum opcode)
     * }
     */
    public static MethodHandle glLogicOp$handle() {
        return glLogicOp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glLogicOp(GLenum opcode)
     * }
     */
    public static MemorySegment glLogicOp$address() {
        return glLogicOp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glLogicOp(GLenum opcode)
     * }
     */
    public static void glLogicOp(int opcode) {
        var mh$ = glLogicOp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLogicOp", opcode);
            }
            mh$.invokeExact(opcode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMap1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMap1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
     * }
     */
    public static FunctionDescriptor glMap1d$descriptor() {
        return glMap1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
     * }
     */
    public static MethodHandle glMap1d$handle() {
        return glMap1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
     * }
     */
    public static MemorySegment glMap1d$address() {
        return glMap1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
     * }
     */
    public static void glMap1d(int target, double u1, double u2, int stride, int order, MemorySegment points) {
        var mh$ = glMap1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMap1d", target, u1, u2, stride, order, points);
            }
            mh$.invokeExact(target, u1, u2, stride, order, points);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMap1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMap1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
     * }
     */
    public static FunctionDescriptor glMap1f$descriptor() {
        return glMap1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
     * }
     */
    public static MethodHandle glMap1f$handle() {
        return glMap1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
     * }
     */
    public static MemorySegment glMap1f$address() {
        return glMap1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
     * }
     */
    public static void glMap1f(int target, float u1, float u2, int stride, int order, MemorySegment points) {
        var mh$ = glMap1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMap1f", target, u1, u2, stride, order, points);
            }
            mh$.invokeExact(target, u1, u2, stride, order, points);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMap2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMap2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
     * }
     */
    public static FunctionDescriptor glMap2d$descriptor() {
        return glMap2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
     * }
     */
    public static MethodHandle glMap2d$handle() {
        return glMap2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
     * }
     */
    public static MemorySegment glMap2d$address() {
        return glMap2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
     * }
     */
    public static void glMap2d(int target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, MemorySegment points) {
        var mh$ = glMap2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMap2d", target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
            }
            mh$.invokeExact(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMap2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMap2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
     * }
     */
    public static FunctionDescriptor glMap2f$descriptor() {
        return glMap2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
     * }
     */
    public static MethodHandle glMap2f$handle() {
        return glMap2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
     * }
     */
    public static MemorySegment glMap2f$address() {
        return glMap2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
     * }
     */
    public static void glMap2f(int target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, MemorySegment points) {
        var mh$ = glMap2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMap2f", target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
            }
            mh$.invokeExact(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMapGrid1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMapGrid1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMapGrid1d(GLint un, GLdouble u1, GLdouble u2)
     * }
     */
    public static FunctionDescriptor glMapGrid1d$descriptor() {
        return glMapGrid1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMapGrid1d(GLint un, GLdouble u1, GLdouble u2)
     * }
     */
    public static MethodHandle glMapGrid1d$handle() {
        return glMapGrid1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMapGrid1d(GLint un, GLdouble u1, GLdouble u2)
     * }
     */
    public static MemorySegment glMapGrid1d$address() {
        return glMapGrid1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMapGrid1d(GLint un, GLdouble u1, GLdouble u2)
     * }
     */
    public static void glMapGrid1d(int un, double u1, double u2) {
        var mh$ = glMapGrid1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMapGrid1d", un, u1, u2);
            }
            mh$.invokeExact(un, u1, u2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMapGrid1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMapGrid1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMapGrid1f(GLint un, GLfloat u1, GLfloat u2)
     * }
     */
    public static FunctionDescriptor glMapGrid1f$descriptor() {
        return glMapGrid1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMapGrid1f(GLint un, GLfloat u1, GLfloat u2)
     * }
     */
    public static MethodHandle glMapGrid1f$handle() {
        return glMapGrid1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMapGrid1f(GLint un, GLfloat u1, GLfloat u2)
     * }
     */
    public static MemorySegment glMapGrid1f$address() {
        return glMapGrid1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMapGrid1f(GLint un, GLfloat u1, GLfloat u2)
     * }
     */
    public static void glMapGrid1f(int un, float u1, float u2) {
        var mh$ = glMapGrid1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMapGrid1f", un, u1, u2);
            }
            mh$.invokeExact(un, u1, u2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMapGrid2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMapGrid2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2)
     * }
     */
    public static FunctionDescriptor glMapGrid2d$descriptor() {
        return glMapGrid2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2)
     * }
     */
    public static MethodHandle glMapGrid2d$handle() {
        return glMapGrid2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2)
     * }
     */
    public static MemorySegment glMapGrid2d$address() {
        return glMapGrid2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2)
     * }
     */
    public static void glMapGrid2d(int un, double u1, double u2, int vn, double v1, double v2) {
        var mh$ = glMapGrid2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMapGrid2d", un, u1, u2, vn, v1, v2);
            }
            mh$.invokeExact(un, u1, u2, vn, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMapGrid2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMapGrid2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2)
     * }
     */
    public static FunctionDescriptor glMapGrid2f$descriptor() {
        return glMapGrid2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2)
     * }
     */
    public static MethodHandle glMapGrid2f$handle() {
        return glMapGrid2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2)
     * }
     */
    public static MemorySegment glMapGrid2f$address() {
        return glMapGrid2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2)
     * }
     */
    public static void glMapGrid2f(int un, float u1, float u2, int vn, float v1, float v2) {
        var mh$ = glMapGrid2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMapGrid2f", un, u1, u2, vn, v1, v2);
            }
            mh$.invokeExact(un, u1, u2, vn, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMaterialf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMaterialf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMaterialf(GLenum face, GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glMaterialf$descriptor() {
        return glMaterialf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMaterialf(GLenum face, GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glMaterialf$handle() {
        return glMaterialf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMaterialf(GLenum face, GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glMaterialf$address() {
        return glMaterialf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMaterialf(GLenum face, GLenum pname, GLfloat param)
     * }
     */
    public static void glMaterialf(int face, int pname, float param) {
        var mh$ = glMaterialf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMaterialf", face, pname, param);
            }
            mh$.invokeExact(face, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMaterialfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMaterialfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMaterialfv(GLenum face, GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glMaterialfv$descriptor() {
        return glMaterialfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMaterialfv(GLenum face, GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glMaterialfv$handle() {
        return glMaterialfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMaterialfv(GLenum face, GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glMaterialfv$address() {
        return glMaterialfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMaterialfv(GLenum face, GLenum pname, const GLfloat *params)
     * }
     */
    public static void glMaterialfv(int face, int pname, MemorySegment params) {
        var mh$ = glMaterialfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMaterialfv", face, pname, params);
            }
            mh$.invokeExact(face, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMateriali {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMateriali");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMateriali(GLenum face, GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glMateriali$descriptor() {
        return glMateriali.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMateriali(GLenum face, GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glMateriali$handle() {
        return glMateriali.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMateriali(GLenum face, GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glMateriali$address() {
        return glMateriali.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMateriali(GLenum face, GLenum pname, GLint param)
     * }
     */
    public static void glMateriali(int face, int pname, int param) {
        var mh$ = glMateriali.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMateriali", face, pname, param);
            }
            mh$.invokeExact(face, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMaterialiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMaterialiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMaterialiv(GLenum face, GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glMaterialiv$descriptor() {
        return glMaterialiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMaterialiv(GLenum face, GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glMaterialiv$handle() {
        return glMaterialiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMaterialiv(GLenum face, GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glMaterialiv$address() {
        return glMaterialiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMaterialiv(GLenum face, GLenum pname, const GLint *params)
     * }
     */
    public static void glMaterialiv(int face, int pname, MemorySegment params) {
        var mh$ = glMaterialiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMaterialiv", face, pname, params);
            }
            mh$.invokeExact(face, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMatrixMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMatrixMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMatrixMode(GLenum mode)
     * }
     */
    public static FunctionDescriptor glMatrixMode$descriptor() {
        return glMatrixMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMatrixMode(GLenum mode)
     * }
     */
    public static MethodHandle glMatrixMode$handle() {
        return glMatrixMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMatrixMode(GLenum mode)
     * }
     */
    public static MemorySegment glMatrixMode$address() {
        return glMatrixMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMatrixMode(GLenum mode)
     * }
     */
    public static void glMatrixMode(int mode) {
        var mh$ = glMatrixMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMatrixMode", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMinmax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMinmax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMinmax(GLenum target, GLenum internalformat, GLboolean sink)
     * }
     */
    public static FunctionDescriptor glMinmax$descriptor() {
        return glMinmax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMinmax(GLenum target, GLenum internalformat, GLboolean sink)
     * }
     */
    public static MethodHandle glMinmax$handle() {
        return glMinmax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMinmax(GLenum target, GLenum internalformat, GLboolean sink)
     * }
     */
    public static MemorySegment glMinmax$address() {
        return glMinmax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMinmax(GLenum target, GLenum internalformat, GLboolean sink)
     * }
     */
    public static void glMinmax(int target, int internalformat, byte sink) {
        var mh$ = glMinmax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMinmax", target, internalformat, sink);
            }
            mh$.invokeExact(target, internalformat, sink);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultMatrixd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultMatrixd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultMatrixd(const GLdouble *m)
     * }
     */
    public static FunctionDescriptor glMultMatrixd$descriptor() {
        return glMultMatrixd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultMatrixd(const GLdouble *m)
     * }
     */
    public static MethodHandle glMultMatrixd$handle() {
        return glMultMatrixd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultMatrixd(const GLdouble *m)
     * }
     */
    public static MemorySegment glMultMatrixd$address() {
        return glMultMatrixd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultMatrixd(const GLdouble *m)
     * }
     */
    public static void glMultMatrixd(MemorySegment m) {
        var mh$ = glMultMatrixd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultMatrixd", m);
            }
            mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultMatrixf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultMatrixf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultMatrixf(const GLfloat *m)
     * }
     */
    public static FunctionDescriptor glMultMatrixf$descriptor() {
        return glMultMatrixf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultMatrixf(const GLfloat *m)
     * }
     */
    public static MethodHandle glMultMatrixf$handle() {
        return glMultMatrixf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultMatrixf(const GLfloat *m)
     * }
     */
    public static MemorySegment glMultMatrixf$address() {
        return glMultMatrixf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultMatrixf(const GLfloat *m)
     * }
     */
    public static void glMultMatrixf(MemorySegment m) {
        var mh$ = glMultMatrixf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultMatrixf", m);
            }
            mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNewList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glNewList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glNewList(GLuint list, GLenum mode)
     * }
     */
    public static FunctionDescriptor glNewList$descriptor() {
        return glNewList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glNewList(GLuint list, GLenum mode)
     * }
     */
    public static MethodHandle glNewList$handle() {
        return glNewList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glNewList(GLuint list, GLenum mode)
     * }
     */
    public static MemorySegment glNewList$address() {
        return glNewList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glNewList(GLuint list, GLenum mode)
     * }
     */
    public static void glNewList(int list, int mode) {
        var mh$ = glNewList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNewList", list, mode);
            }
            mh$.invokeExact(list, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glNormal3b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz)
     * }
     */
    public static FunctionDescriptor glNormal3b$descriptor() {
        return glNormal3b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz)
     * }
     */
    public static MethodHandle glNormal3b$handle() {
        return glNormal3b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz)
     * }
     */
    public static MemorySegment glNormal3b$address() {
        return glNormal3b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz)
     * }
     */
    public static void glNormal3b(byte nx, byte ny, byte nz) {
        var mh$ = glNormal3b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3b", nx, ny, nz);
            }
            mh$.invokeExact(nx, ny, nz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3bv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glNormal3bv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glNormal3bv(const GLbyte *v)
     * }
     */
    public static FunctionDescriptor glNormal3bv$descriptor() {
        return glNormal3bv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glNormal3bv(const GLbyte *v)
     * }
     */
    public static MethodHandle glNormal3bv$handle() {
        return glNormal3bv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glNormal3bv(const GLbyte *v)
     * }
     */
    public static MemorySegment glNormal3bv$address() {
        return glNormal3bv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glNormal3bv(const GLbyte *v)
     * }
     */
    public static void glNormal3bv(MemorySegment v) {
        var mh$ = glNormal3bv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3bv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glNormal3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz)
     * }
     */
    public static FunctionDescriptor glNormal3d$descriptor() {
        return glNormal3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz)
     * }
     */
    public static MethodHandle glNormal3d$handle() {
        return glNormal3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz)
     * }
     */
    public static MemorySegment glNormal3d$address() {
        return glNormal3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz)
     * }
     */
    public static void glNormal3d(double nx, double ny, double nz) {
        var mh$ = glNormal3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3d", nx, ny, nz);
            }
            mh$.invokeExact(nx, ny, nz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glNormal3dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glNormal3dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glNormal3dv$descriptor() {
        return glNormal3dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glNormal3dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glNormal3dv$handle() {
        return glNormal3dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glNormal3dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glNormal3dv$address() {
        return glNormal3dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glNormal3dv(const GLdouble *v)
     * }
     */
    public static void glNormal3dv(MemorySegment v) {
        var mh$ = glNormal3dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glNormal3f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz)
     * }
     */
    public static FunctionDescriptor glNormal3f$descriptor() {
        return glNormal3f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz)
     * }
     */
    public static MethodHandle glNormal3f$handle() {
        return glNormal3f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz)
     * }
     */
    public static MemorySegment glNormal3f$address() {
        return glNormal3f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz)
     * }
     */
    public static void glNormal3f(float nx, float ny, float nz) {
        var mh$ = glNormal3f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3f", nx, ny, nz);
            }
            mh$.invokeExact(nx, ny, nz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glNormal3fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glNormal3fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glNormal3fv$descriptor() {
        return glNormal3fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glNormal3fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glNormal3fv$handle() {
        return glNormal3fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glNormal3fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glNormal3fv$address() {
        return glNormal3fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glNormal3fv(const GLfloat *v)
     * }
     */
    public static void glNormal3fv(MemorySegment v) {
        var mh$ = glNormal3fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glNormal3i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glNormal3i(GLint nx, GLint ny, GLint nz)
     * }
     */
    public static FunctionDescriptor glNormal3i$descriptor() {
        return glNormal3i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glNormal3i(GLint nx, GLint ny, GLint nz)
     * }
     */
    public static MethodHandle glNormal3i$handle() {
        return glNormal3i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glNormal3i(GLint nx, GLint ny, GLint nz)
     * }
     */
    public static MemorySegment glNormal3i$address() {
        return glNormal3i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glNormal3i(GLint nx, GLint ny, GLint nz)
     * }
     */
    public static void glNormal3i(int nx, int ny, int nz) {
        var mh$ = glNormal3i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3i", nx, ny, nz);
            }
            mh$.invokeExact(nx, ny, nz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glNormal3iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glNormal3iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glNormal3iv$descriptor() {
        return glNormal3iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glNormal3iv(const GLint *v)
     * }
     */
    public static MethodHandle glNormal3iv$handle() {
        return glNormal3iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glNormal3iv(const GLint *v)
     * }
     */
    public static MemorySegment glNormal3iv$address() {
        return glNormal3iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glNormal3iv(const GLint *v)
     * }
     */
    public static void glNormal3iv(MemorySegment v) {
        var mh$ = glNormal3iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glNormal3s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glNormal3s(GLshort nx, GLshort ny, GLshort nz)
     * }
     */
    public static FunctionDescriptor glNormal3s$descriptor() {
        return glNormal3s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glNormal3s(GLshort nx, GLshort ny, GLshort nz)
     * }
     */
    public static MethodHandle glNormal3s$handle() {
        return glNormal3s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glNormal3s(GLshort nx, GLshort ny, GLshort nz)
     * }
     */
    public static MemorySegment glNormal3s$address() {
        return glNormal3s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glNormal3s(GLshort nx, GLshort ny, GLshort nz)
     * }
     */
    public static void glNormal3s(short nx, short ny, short nz) {
        var mh$ = glNormal3s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3s", nx, ny, nz);
            }
            mh$.invokeExact(nx, ny, nz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glNormal3sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glNormal3sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glNormal3sv$descriptor() {
        return glNormal3sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glNormal3sv(const GLshort *v)
     * }
     */
    public static MethodHandle glNormal3sv$handle() {
        return glNormal3sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glNormal3sv(const GLshort *v)
     * }
     */
    public static MemorySegment glNormal3sv$address() {
        return glNormal3sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glNormal3sv(const GLshort *v)
     * }
     */
    public static void glNormal3sv(MemorySegment v) {
        var mh$ = glNormal3sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormalPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glNormalPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glNormalPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static FunctionDescriptor glNormalPointer$descriptor() {
        return glNormalPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glNormalPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MethodHandle glNormalPointer$handle() {
        return glNormalPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glNormalPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MemorySegment glNormalPointer$address() {
        return glNormalPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glNormalPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static void glNormalPointer(int type, int stride, MemorySegment pointer) {
        var mh$ = glNormalPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormalPointer", type, stride, pointer);
            }
            mh$.invokeExact(type, stride, pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glOrtho {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glOrtho");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
     * }
     */
    public static FunctionDescriptor glOrtho$descriptor() {
        return glOrtho.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
     * }
     */
    public static MethodHandle glOrtho$handle() {
        return glOrtho.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
     * }
     */
    public static MemorySegment glOrtho$address() {
        return glOrtho.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
     * }
     */
    public static void glOrtho(double left, double right, double bottom, double top, double zNear, double zFar) {
        var mh$ = glOrtho.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glOrtho", left, right, bottom, top, zNear, zFar);
            }
            mh$.invokeExact(left, right, bottom, top, zNear, zFar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPassThrough {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPassThrough");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glPassThrough(GLfloat token)
     * }
     */
    public static FunctionDescriptor glPassThrough$descriptor() {
        return glPassThrough.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glPassThrough(GLfloat token)
     * }
     */
    public static MethodHandle glPassThrough$handle() {
        return glPassThrough.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glPassThrough(GLfloat token)
     * }
     */
    public static MemorySegment glPassThrough$address() {
        return glPassThrough.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glPassThrough(GLfloat token)
     * }
     */
    public static void glPassThrough(float token) {
        var mh$ = glPassThrough.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPassThrough", token);
            }
            mh$.invokeExact(token);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelMapfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPixelMapfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glPixelMapfv(GLenum map, GLint mapsize, const GLfloat *values)
     * }
     */
    public static FunctionDescriptor glPixelMapfv$descriptor() {
        return glPixelMapfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glPixelMapfv(GLenum map, GLint mapsize, const GLfloat *values)
     * }
     */
    public static MethodHandle glPixelMapfv$handle() {
        return glPixelMapfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glPixelMapfv(GLenum map, GLint mapsize, const GLfloat *values)
     * }
     */
    public static MemorySegment glPixelMapfv$address() {
        return glPixelMapfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glPixelMapfv(GLenum map, GLint mapsize, const GLfloat *values)
     * }
     */
    public static void glPixelMapfv(int map, int mapsize, MemorySegment values) {
        var mh$ = glPixelMapfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelMapfv", map, mapsize, values);
            }
            mh$.invokeExact(map, mapsize, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelMapuiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPixelMapuiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glPixelMapuiv(GLenum map, GLint mapsize, const GLuint *values)
     * }
     */
    public static FunctionDescriptor glPixelMapuiv$descriptor() {
        return glPixelMapuiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glPixelMapuiv(GLenum map, GLint mapsize, const GLuint *values)
     * }
     */
    public static MethodHandle glPixelMapuiv$handle() {
        return glPixelMapuiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glPixelMapuiv(GLenum map, GLint mapsize, const GLuint *values)
     * }
     */
    public static MemorySegment glPixelMapuiv$address() {
        return glPixelMapuiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glPixelMapuiv(GLenum map, GLint mapsize, const GLuint *values)
     * }
     */
    public static void glPixelMapuiv(int map, int mapsize, MemorySegment values) {
        var mh$ = glPixelMapuiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelMapuiv", map, mapsize, values);
            }
            mh$.invokeExact(map, mapsize, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelMapusv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPixelMapusv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glPixelMapusv(GLenum map, GLint mapsize, const GLushort *values)
     * }
     */
    public static FunctionDescriptor glPixelMapusv$descriptor() {
        return glPixelMapusv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glPixelMapusv(GLenum map, GLint mapsize, const GLushort *values)
     * }
     */
    public static MethodHandle glPixelMapusv$handle() {
        return glPixelMapusv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glPixelMapusv(GLenum map, GLint mapsize, const GLushort *values)
     * }
     */
    public static MemorySegment glPixelMapusv$address() {
        return glPixelMapusv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glPixelMapusv(GLenum map, GLint mapsize, const GLushort *values)
     * }
     */
    public static void glPixelMapusv(int map, int mapsize, MemorySegment values) {
        var mh$ = glPixelMapusv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelMapusv", map, mapsize, values);
            }
            mh$.invokeExact(map, mapsize, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelStoref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPixelStoref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glPixelStoref(GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glPixelStoref$descriptor() {
        return glPixelStoref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glPixelStoref(GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glPixelStoref$handle() {
        return glPixelStoref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glPixelStoref(GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glPixelStoref$address() {
        return glPixelStoref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glPixelStoref(GLenum pname, GLfloat param)
     * }
     */
    public static void glPixelStoref(int pname, float param) {
        var mh$ = glPixelStoref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelStoref", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelStorei {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPixelStorei");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glPixelStorei(GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glPixelStorei$descriptor() {
        return glPixelStorei.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glPixelStorei(GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glPixelStorei$handle() {
        return glPixelStorei.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glPixelStorei(GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glPixelStorei$address() {
        return glPixelStorei.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glPixelStorei(GLenum pname, GLint param)
     * }
     */
    public static void glPixelStorei(int pname, int param) {
        var mh$ = glPixelStorei.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelStorei", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelTransferf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPixelTransferf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glPixelTransferf(GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glPixelTransferf$descriptor() {
        return glPixelTransferf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glPixelTransferf(GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glPixelTransferf$handle() {
        return glPixelTransferf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glPixelTransferf(GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glPixelTransferf$address() {
        return glPixelTransferf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glPixelTransferf(GLenum pname, GLfloat param)
     * }
     */
    public static void glPixelTransferf(int pname, float param) {
        var mh$ = glPixelTransferf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelTransferf", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelTransferi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPixelTransferi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glPixelTransferi(GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glPixelTransferi$descriptor() {
        return glPixelTransferi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glPixelTransferi(GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glPixelTransferi$handle() {
        return glPixelTransferi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glPixelTransferi(GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glPixelTransferi$address() {
        return glPixelTransferi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glPixelTransferi(GLenum pname, GLint param)
     * }
     */
    public static void glPixelTransferi(int pname, int param) {
        var mh$ = glPixelTransferi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelTransferi", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelZoom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPixelZoom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glPixelZoom(GLfloat xfactor, GLfloat yfactor)
     * }
     */
    public static FunctionDescriptor glPixelZoom$descriptor() {
        return glPixelZoom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glPixelZoom(GLfloat xfactor, GLfloat yfactor)
     * }
     */
    public static MethodHandle glPixelZoom$handle() {
        return glPixelZoom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glPixelZoom(GLfloat xfactor, GLfloat yfactor)
     * }
     */
    public static MemorySegment glPixelZoom$address() {
        return glPixelZoom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glPixelZoom(GLfloat xfactor, GLfloat yfactor)
     * }
     */
    public static void glPixelZoom(float xfactor, float yfactor) {
        var mh$ = glPixelZoom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelZoom", xfactor, yfactor);
            }
            mh$.invokeExact(xfactor, yfactor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPointSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPointSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glPointSize(GLfloat size)
     * }
     */
    public static FunctionDescriptor glPointSize$descriptor() {
        return glPointSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glPointSize(GLfloat size)
     * }
     */
    public static MethodHandle glPointSize$handle() {
        return glPointSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glPointSize(GLfloat size)
     * }
     */
    public static MemorySegment glPointSize$address() {
        return glPointSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glPointSize(GLfloat size)
     * }
     */
    public static void glPointSize(float size) {
        var mh$ = glPointSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPointSize", size);
            }
            mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPolygonMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPolygonMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glPolygonMode(GLenum face, GLenum mode)
     * }
     */
    public static FunctionDescriptor glPolygonMode$descriptor() {
        return glPolygonMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glPolygonMode(GLenum face, GLenum mode)
     * }
     */
    public static MethodHandle glPolygonMode$handle() {
        return glPolygonMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glPolygonMode(GLenum face, GLenum mode)
     * }
     */
    public static MemorySegment glPolygonMode$address() {
        return glPolygonMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glPolygonMode(GLenum face, GLenum mode)
     * }
     */
    public static void glPolygonMode(int face, int mode) {
        var mh$ = glPolygonMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPolygonMode", face, mode);
            }
            mh$.invokeExact(face, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPolygonOffset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPolygonOffset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glPolygonOffset(GLfloat factor, GLfloat units)
     * }
     */
    public static FunctionDescriptor glPolygonOffset$descriptor() {
        return glPolygonOffset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glPolygonOffset(GLfloat factor, GLfloat units)
     * }
     */
    public static MethodHandle glPolygonOffset$handle() {
        return glPolygonOffset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glPolygonOffset(GLfloat factor, GLfloat units)
     * }
     */
    public static MemorySegment glPolygonOffset$address() {
        return glPolygonOffset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glPolygonOffset(GLfloat factor, GLfloat units)
     * }
     */
    public static void glPolygonOffset(float factor, float units) {
        var mh$ = glPolygonOffset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPolygonOffset", factor, units);
            }
            mh$.invokeExact(factor, units);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPolygonStipple {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPolygonStipple");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glPolygonStipple(const GLubyte *mask)
     * }
     */
    public static FunctionDescriptor glPolygonStipple$descriptor() {
        return glPolygonStipple.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glPolygonStipple(const GLubyte *mask)
     * }
     */
    public static MethodHandle glPolygonStipple$handle() {
        return glPolygonStipple.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glPolygonStipple(const GLubyte *mask)
     * }
     */
    public static MemorySegment glPolygonStipple$address() {
        return glPolygonStipple.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glPolygonStipple(const GLubyte *mask)
     * }
     */
    public static void glPolygonStipple(MemorySegment mask) {
        var mh$ = glPolygonStipple.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPolygonStipple", mask);
            }
            mh$.invokeExact(mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPopAttrib {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPopAttrib");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glPopAttrib()
     * }
     */
    public static FunctionDescriptor glPopAttrib$descriptor() {
        return glPopAttrib.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glPopAttrib()
     * }
     */
    public static MethodHandle glPopAttrib$handle() {
        return glPopAttrib.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glPopAttrib()
     * }
     */
    public static MemorySegment glPopAttrib$address() {
        return glPopAttrib.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glPopAttrib()
     * }
     */
    public static void glPopAttrib() {
        var mh$ = glPopAttrib.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPopAttrib");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPopClientAttrib {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPopClientAttrib");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glPopClientAttrib()
     * }
     */
    public static FunctionDescriptor glPopClientAttrib$descriptor() {
        return glPopClientAttrib.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glPopClientAttrib()
     * }
     */
    public static MethodHandle glPopClientAttrib$handle() {
        return glPopClientAttrib.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glPopClientAttrib()
     * }
     */
    public static MemorySegment glPopClientAttrib$address() {
        return glPopClientAttrib.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glPopClientAttrib()
     * }
     */
    public static void glPopClientAttrib() {
        var mh$ = glPopClientAttrib.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPopClientAttrib");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPopMatrix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPopMatrix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glPopMatrix()
     * }
     */
    public static FunctionDescriptor glPopMatrix$descriptor() {
        return glPopMatrix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glPopMatrix()
     * }
     */
    public static MethodHandle glPopMatrix$handle() {
        return glPopMatrix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glPopMatrix()
     * }
     */
    public static MemorySegment glPopMatrix$address() {
        return glPopMatrix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glPopMatrix()
     * }
     */
    public static void glPopMatrix() {
        var mh$ = glPopMatrix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPopMatrix");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPopName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPopName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glPopName()
     * }
     */
    public static FunctionDescriptor glPopName$descriptor() {
        return glPopName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glPopName()
     * }
     */
    public static MethodHandle glPopName$handle() {
        return glPopName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glPopName()
     * }
     */
    public static MemorySegment glPopName$address() {
        return glPopName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glPopName()
     * }
     */
    public static void glPopName() {
        var mh$ = glPopName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPopName");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPrioritizeTextures {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPrioritizeTextures");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glPrioritizeTextures(GLsizei n, const GLuint *textures, const GLclampf *priorities)
     * }
     */
    public static FunctionDescriptor glPrioritizeTextures$descriptor() {
        return glPrioritizeTextures.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glPrioritizeTextures(GLsizei n, const GLuint *textures, const GLclampf *priorities)
     * }
     */
    public static MethodHandle glPrioritizeTextures$handle() {
        return glPrioritizeTextures.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glPrioritizeTextures(GLsizei n, const GLuint *textures, const GLclampf *priorities)
     * }
     */
    public static MemorySegment glPrioritizeTextures$address() {
        return glPrioritizeTextures.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glPrioritizeTextures(GLsizei n, const GLuint *textures, const GLclampf *priorities)
     * }
     */
    public static void glPrioritizeTextures(int n, MemorySegment textures, MemorySegment priorities) {
        var mh$ = glPrioritizeTextures.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPrioritizeTextures", n, textures, priorities);
            }
            mh$.invokeExact(n, textures, priorities);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPushAttrib {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPushAttrib");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glPushAttrib(GLbitfield mask)
     * }
     */
    public static FunctionDescriptor glPushAttrib$descriptor() {
        return glPushAttrib.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glPushAttrib(GLbitfield mask)
     * }
     */
    public static MethodHandle glPushAttrib$handle() {
        return glPushAttrib.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glPushAttrib(GLbitfield mask)
     * }
     */
    public static MemorySegment glPushAttrib$address() {
        return glPushAttrib.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glPushAttrib(GLbitfield mask)
     * }
     */
    public static void glPushAttrib(int mask) {
        var mh$ = glPushAttrib.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPushAttrib", mask);
            }
            mh$.invokeExact(mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPushClientAttrib {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPushClientAttrib");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glPushClientAttrib(GLbitfield mask)
     * }
     */
    public static FunctionDescriptor glPushClientAttrib$descriptor() {
        return glPushClientAttrib.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glPushClientAttrib(GLbitfield mask)
     * }
     */
    public static MethodHandle glPushClientAttrib$handle() {
        return glPushClientAttrib.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glPushClientAttrib(GLbitfield mask)
     * }
     */
    public static MemorySegment glPushClientAttrib$address() {
        return glPushClientAttrib.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glPushClientAttrib(GLbitfield mask)
     * }
     */
    public static void glPushClientAttrib(int mask) {
        var mh$ = glPushClientAttrib.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPushClientAttrib", mask);
            }
            mh$.invokeExact(mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPushMatrix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPushMatrix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glPushMatrix()
     * }
     */
    public static FunctionDescriptor glPushMatrix$descriptor() {
        return glPushMatrix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glPushMatrix()
     * }
     */
    public static MethodHandle glPushMatrix$handle() {
        return glPushMatrix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glPushMatrix()
     * }
     */
    public static MemorySegment glPushMatrix$address() {
        return glPushMatrix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glPushMatrix()
     * }
     */
    public static void glPushMatrix() {
        var mh$ = glPushMatrix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPushMatrix");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPushName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPushName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glPushName(GLuint name)
     * }
     */
    public static FunctionDescriptor glPushName$descriptor() {
        return glPushName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glPushName(GLuint name)
     * }
     */
    public static MethodHandle glPushName$handle() {
        return glPushName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glPushName(GLuint name)
     * }
     */
    public static MemorySegment glPushName$address() {
        return glPushName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glPushName(GLuint name)
     * }
     */
    public static void glPushName(int name) {
        var mh$ = glPushName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPushName", name);
            }
            mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glRasterPos2d(GLdouble x, GLdouble y)
     * }
     */
    public static FunctionDescriptor glRasterPos2d$descriptor() {
        return glRasterPos2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glRasterPos2d(GLdouble x, GLdouble y)
     * }
     */
    public static MethodHandle glRasterPos2d$handle() {
        return glRasterPos2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glRasterPos2d(GLdouble x, GLdouble y)
     * }
     */
    public static MemorySegment glRasterPos2d$address() {
        return glRasterPos2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glRasterPos2d(GLdouble x, GLdouble y)
     * }
     */
    public static void glRasterPos2d(double x, double y) {
        var mh$ = glRasterPos2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2d", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos2dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glRasterPos2dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glRasterPos2dv$descriptor() {
        return glRasterPos2dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glRasterPos2dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glRasterPos2dv$handle() {
        return glRasterPos2dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glRasterPos2dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glRasterPos2dv$address() {
        return glRasterPos2dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glRasterPos2dv(const GLdouble *v)
     * }
     */
    public static void glRasterPos2dv(MemorySegment v) {
        var mh$ = glRasterPos2dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glRasterPos2f(GLfloat x, GLfloat y)
     * }
     */
    public static FunctionDescriptor glRasterPos2f$descriptor() {
        return glRasterPos2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glRasterPos2f(GLfloat x, GLfloat y)
     * }
     */
    public static MethodHandle glRasterPos2f$handle() {
        return glRasterPos2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glRasterPos2f(GLfloat x, GLfloat y)
     * }
     */
    public static MemorySegment glRasterPos2f$address() {
        return glRasterPos2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glRasterPos2f(GLfloat x, GLfloat y)
     * }
     */
    public static void glRasterPos2f(float x, float y) {
        var mh$ = glRasterPos2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2f", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos2fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glRasterPos2fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glRasterPos2fv$descriptor() {
        return glRasterPos2fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glRasterPos2fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glRasterPos2fv$handle() {
        return glRasterPos2fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glRasterPos2fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glRasterPos2fv$address() {
        return glRasterPos2fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glRasterPos2fv(const GLfloat *v)
     * }
     */
    public static void glRasterPos2fv(MemorySegment v) {
        var mh$ = glRasterPos2fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos2i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glRasterPos2i(GLint x, GLint y)
     * }
     */
    public static FunctionDescriptor glRasterPos2i$descriptor() {
        return glRasterPos2i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glRasterPos2i(GLint x, GLint y)
     * }
     */
    public static MethodHandle glRasterPos2i$handle() {
        return glRasterPos2i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glRasterPos2i(GLint x, GLint y)
     * }
     */
    public static MemorySegment glRasterPos2i$address() {
        return glRasterPos2i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glRasterPos2i(GLint x, GLint y)
     * }
     */
    public static void glRasterPos2i(int x, int y) {
        var mh$ = glRasterPos2i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2i", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos2iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glRasterPos2iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glRasterPos2iv$descriptor() {
        return glRasterPos2iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glRasterPos2iv(const GLint *v)
     * }
     */
    public static MethodHandle glRasterPos2iv$handle() {
        return glRasterPos2iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glRasterPos2iv(const GLint *v)
     * }
     */
    public static MemorySegment glRasterPos2iv$address() {
        return glRasterPos2iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glRasterPos2iv(const GLint *v)
     * }
     */
    public static void glRasterPos2iv(MemorySegment v) {
        var mh$ = glRasterPos2iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos2s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glRasterPos2s(GLshort x, GLshort y)
     * }
     */
    public static FunctionDescriptor glRasterPos2s$descriptor() {
        return glRasterPos2s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glRasterPos2s(GLshort x, GLshort y)
     * }
     */
    public static MethodHandle glRasterPos2s$handle() {
        return glRasterPos2s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glRasterPos2s(GLshort x, GLshort y)
     * }
     */
    public static MemorySegment glRasterPos2s$address() {
        return glRasterPos2s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glRasterPos2s(GLshort x, GLshort y)
     * }
     */
    public static void glRasterPos2s(short x, short y) {
        var mh$ = glRasterPos2s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2s", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos2sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glRasterPos2sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glRasterPos2sv$descriptor() {
        return glRasterPos2sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glRasterPos2sv(const GLshort *v)
     * }
     */
    public static MethodHandle glRasterPos2sv$handle() {
        return glRasterPos2sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glRasterPos2sv(const GLshort *v)
     * }
     */
    public static MemorySegment glRasterPos2sv$address() {
        return glRasterPos2sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glRasterPos2sv(const GLshort *v)
     * }
     */
    public static void glRasterPos2sv(MemorySegment v) {
        var mh$ = glRasterPos2sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glRasterPos3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static FunctionDescriptor glRasterPos3d$descriptor() {
        return glRasterPos3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glRasterPos3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MethodHandle glRasterPos3d$handle() {
        return glRasterPos3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glRasterPos3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MemorySegment glRasterPos3d$address() {
        return glRasterPos3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glRasterPos3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static void glRasterPos3d(double x, double y, double z) {
        var mh$ = glRasterPos3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3d", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos3dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glRasterPos3dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glRasterPos3dv$descriptor() {
        return glRasterPos3dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glRasterPos3dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glRasterPos3dv$handle() {
        return glRasterPos3dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glRasterPos3dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glRasterPos3dv$address() {
        return glRasterPos3dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glRasterPos3dv(const GLdouble *v)
     * }
     */
    public static void glRasterPos3dv(MemorySegment v) {
        var mh$ = glRasterPos3dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos3f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glRasterPos3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static FunctionDescriptor glRasterPos3f$descriptor() {
        return glRasterPos3f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glRasterPos3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MethodHandle glRasterPos3f$handle() {
        return glRasterPos3f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glRasterPos3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MemorySegment glRasterPos3f$address() {
        return glRasterPos3f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glRasterPos3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static void glRasterPos3f(float x, float y, float z) {
        var mh$ = glRasterPos3f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3f", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos3fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glRasterPos3fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glRasterPos3fv$descriptor() {
        return glRasterPos3fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glRasterPos3fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glRasterPos3fv$handle() {
        return glRasterPos3fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glRasterPos3fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glRasterPos3fv$address() {
        return glRasterPos3fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glRasterPos3fv(const GLfloat *v)
     * }
     */
    public static void glRasterPos3fv(MemorySegment v) {
        var mh$ = glRasterPos3fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos3i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glRasterPos3i(GLint x, GLint y, GLint z)
     * }
     */
    public static FunctionDescriptor glRasterPos3i$descriptor() {
        return glRasterPos3i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glRasterPos3i(GLint x, GLint y, GLint z)
     * }
     */
    public static MethodHandle glRasterPos3i$handle() {
        return glRasterPos3i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glRasterPos3i(GLint x, GLint y, GLint z)
     * }
     */
    public static MemorySegment glRasterPos3i$address() {
        return glRasterPos3i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glRasterPos3i(GLint x, GLint y, GLint z)
     * }
     */
    public static void glRasterPos3i(int x, int y, int z) {
        var mh$ = glRasterPos3i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3i", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos3iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glRasterPos3iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glRasterPos3iv$descriptor() {
        return glRasterPos3iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glRasterPos3iv(const GLint *v)
     * }
     */
    public static MethodHandle glRasterPos3iv$handle() {
        return glRasterPos3iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glRasterPos3iv(const GLint *v)
     * }
     */
    public static MemorySegment glRasterPos3iv$address() {
        return glRasterPos3iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glRasterPos3iv(const GLint *v)
     * }
     */
    public static void glRasterPos3iv(MemorySegment v) {
        var mh$ = glRasterPos3iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos3s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glRasterPos3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static FunctionDescriptor glRasterPos3s$descriptor() {
        return glRasterPos3s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glRasterPos3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static MethodHandle glRasterPos3s$handle() {
        return glRasterPos3s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glRasterPos3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static MemorySegment glRasterPos3s$address() {
        return glRasterPos3s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glRasterPos3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static void glRasterPos3s(short x, short y, short z) {
        var mh$ = glRasterPos3s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3s", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos3sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glRasterPos3sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glRasterPos3sv$descriptor() {
        return glRasterPos3sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glRasterPos3sv(const GLshort *v)
     * }
     */
    public static MethodHandle glRasterPos3sv$handle() {
        return glRasterPos3sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glRasterPos3sv(const GLshort *v)
     * }
     */
    public static MemorySegment glRasterPos3sv$address() {
        return glRasterPos3sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glRasterPos3sv(const GLshort *v)
     * }
     */
    public static void glRasterPos3sv(MemorySegment v) {
        var mh$ = glRasterPos3sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos4d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static FunctionDescriptor glRasterPos4d$descriptor() {
        return glRasterPos4d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static MethodHandle glRasterPos4d$handle() {
        return glRasterPos4d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static MemorySegment glRasterPos4d$address() {
        return glRasterPos4d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static void glRasterPos4d(double x, double y, double z, double w) {
        var mh$ = glRasterPos4d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4d", x, y, z, w);
            }
            mh$.invokeExact(x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos4dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glRasterPos4dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glRasterPos4dv$descriptor() {
        return glRasterPos4dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glRasterPos4dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glRasterPos4dv$handle() {
        return glRasterPos4dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glRasterPos4dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glRasterPos4dv$address() {
        return glRasterPos4dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glRasterPos4dv(const GLdouble *v)
     * }
     */
    public static void glRasterPos4dv(MemorySegment v) {
        var mh$ = glRasterPos4dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos4f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static FunctionDescriptor glRasterPos4f$descriptor() {
        return glRasterPos4f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static MethodHandle glRasterPos4f$handle() {
        return glRasterPos4f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static MemorySegment glRasterPos4f$address() {
        return glRasterPos4f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static void glRasterPos4f(float x, float y, float z, float w) {
        var mh$ = glRasterPos4f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4f", x, y, z, w);
            }
            mh$.invokeExact(x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos4fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glRasterPos4fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glRasterPos4fv$descriptor() {
        return glRasterPos4fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glRasterPos4fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glRasterPos4fv$handle() {
        return glRasterPos4fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glRasterPos4fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glRasterPos4fv$address() {
        return glRasterPos4fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glRasterPos4fv(const GLfloat *v)
     * }
     */
    public static void glRasterPos4fv(MemorySegment v) {
        var mh$ = glRasterPos4fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos4i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glRasterPos4i(GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static FunctionDescriptor glRasterPos4i$descriptor() {
        return glRasterPos4i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glRasterPos4i(GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static MethodHandle glRasterPos4i$handle() {
        return glRasterPos4i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glRasterPos4i(GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static MemorySegment glRasterPos4i$address() {
        return glRasterPos4i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glRasterPos4i(GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static void glRasterPos4i(int x, int y, int z, int w) {
        var mh$ = glRasterPos4i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4i", x, y, z, w);
            }
            mh$.invokeExact(x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos4iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glRasterPos4iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glRasterPos4iv$descriptor() {
        return glRasterPos4iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glRasterPos4iv(const GLint *v)
     * }
     */
    public static MethodHandle glRasterPos4iv$handle() {
        return glRasterPos4iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glRasterPos4iv(const GLint *v)
     * }
     */
    public static MemorySegment glRasterPos4iv$address() {
        return glRasterPos4iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glRasterPos4iv(const GLint *v)
     * }
     */
    public static void glRasterPos4iv(MemorySegment v) {
        var mh$ = glRasterPos4iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos4s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static FunctionDescriptor glRasterPos4s$descriptor() {
        return glRasterPos4s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static MethodHandle glRasterPos4s$handle() {
        return glRasterPos4s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static MemorySegment glRasterPos4s$address() {
        return glRasterPos4s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static void glRasterPos4s(short x, short y, short z, short w) {
        var mh$ = glRasterPos4s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4s", x, y, z, w);
            }
            mh$.invokeExact(x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRasterPos4sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glRasterPos4sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glRasterPos4sv$descriptor() {
        return glRasterPos4sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glRasterPos4sv(const GLshort *v)
     * }
     */
    public static MethodHandle glRasterPos4sv$handle() {
        return glRasterPos4sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glRasterPos4sv(const GLshort *v)
     * }
     */
    public static MemorySegment glRasterPos4sv$address() {
        return glRasterPos4sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glRasterPos4sv(const GLshort *v)
     * }
     */
    public static void glRasterPos4sv(MemorySegment v) {
        var mh$ = glRasterPos4sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glReadBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glReadBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glReadBuffer(GLenum mode)
     * }
     */
    public static FunctionDescriptor glReadBuffer$descriptor() {
        return glReadBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glReadBuffer(GLenum mode)
     * }
     */
    public static MethodHandle glReadBuffer$handle() {
        return glReadBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glReadBuffer(GLenum mode)
     * }
     */
    public static MemorySegment glReadBuffer$address() {
        return glReadBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glReadBuffer(GLenum mode)
     * }
     */
    public static void glReadBuffer(int mode) {
        var mh$ = glReadBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glReadBuffer", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glReadPixels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glReadPixels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glReadPixels$descriptor() {
        return glReadPixels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static MethodHandle glReadPixels$handle() {
        return glReadPixels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static MemorySegment glReadPixels$address() {
        return glReadPixels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static void glReadPixels(int x, int y, int width, int height, int format, int type, MemorySegment pixels) {
        var mh$ = glReadPixels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glReadPixels", x, y, width, height, format, type, pixels);
            }
            mh$.invokeExact(x, y, width, height, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRectd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRectd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2)
     * }
     */
    public static FunctionDescriptor glRectd$descriptor() {
        return glRectd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2)
     * }
     */
    public static MethodHandle glRectd$handle() {
        return glRectd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2)
     * }
     */
    public static MemorySegment glRectd$address() {
        return glRectd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2)
     * }
     */
    public static void glRectd(double x1, double y1, double x2, double y2) {
        var mh$ = glRectd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRectd", x1, y1, x2, y2);
            }
            mh$.invokeExact(x1, y1, x2, y2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRectdv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRectdv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glRectdv(const GLdouble *v1, const GLdouble *v2)
     * }
     */
    public static FunctionDescriptor glRectdv$descriptor() {
        return glRectdv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glRectdv(const GLdouble *v1, const GLdouble *v2)
     * }
     */
    public static MethodHandle glRectdv$handle() {
        return glRectdv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glRectdv(const GLdouble *v1, const GLdouble *v2)
     * }
     */
    public static MemorySegment glRectdv$address() {
        return glRectdv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glRectdv(const GLdouble *v1, const GLdouble *v2)
     * }
     */
    public static void glRectdv(MemorySegment v1, MemorySegment v2) {
        var mh$ = glRectdv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRectdv", v1, v2);
            }
            mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRectf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRectf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)
     * }
     */
    public static FunctionDescriptor glRectf$descriptor() {
        return glRectf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)
     * }
     */
    public static MethodHandle glRectf$handle() {
        return glRectf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)
     * }
     */
    public static MemorySegment glRectf$address() {
        return glRectf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)
     * }
     */
    public static void glRectf(float x1, float y1, float x2, float y2) {
        var mh$ = glRectf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRectf", x1, y1, x2, y2);
            }
            mh$.invokeExact(x1, y1, x2, y2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRectfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRectfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glRectfv(const GLfloat *v1, const GLfloat *v2)
     * }
     */
    public static FunctionDescriptor glRectfv$descriptor() {
        return glRectfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glRectfv(const GLfloat *v1, const GLfloat *v2)
     * }
     */
    public static MethodHandle glRectfv$handle() {
        return glRectfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glRectfv(const GLfloat *v1, const GLfloat *v2)
     * }
     */
    public static MemorySegment glRectfv$address() {
        return glRectfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glRectfv(const GLfloat *v1, const GLfloat *v2)
     * }
     */
    public static void glRectfv(MemorySegment v1, MemorySegment v2) {
        var mh$ = glRectfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRectfv", v1, v2);
            }
            mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRecti {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRecti");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glRecti(GLint x1, GLint y1, GLint x2, GLint y2)
     * }
     */
    public static FunctionDescriptor glRecti$descriptor() {
        return glRecti.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glRecti(GLint x1, GLint y1, GLint x2, GLint y2)
     * }
     */
    public static MethodHandle glRecti$handle() {
        return glRecti.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glRecti(GLint x1, GLint y1, GLint x2, GLint y2)
     * }
     */
    public static MemorySegment glRecti$address() {
        return glRecti.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glRecti(GLint x1, GLint y1, GLint x2, GLint y2)
     * }
     */
    public static void glRecti(int x1, int y1, int x2, int y2) {
        var mh$ = glRecti.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRecti", x1, y1, x2, y2);
            }
            mh$.invokeExact(x1, y1, x2, y2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRectiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRectiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glRectiv(const GLint *v1, const GLint *v2)
     * }
     */
    public static FunctionDescriptor glRectiv$descriptor() {
        return glRectiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glRectiv(const GLint *v1, const GLint *v2)
     * }
     */
    public static MethodHandle glRectiv$handle() {
        return glRectiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glRectiv(const GLint *v1, const GLint *v2)
     * }
     */
    public static MemorySegment glRectiv$address() {
        return glRectiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glRectiv(const GLint *v1, const GLint *v2)
     * }
     */
    public static void glRectiv(MemorySegment v1, MemorySegment v2) {
        var mh$ = glRectiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRectiv", v1, v2);
            }
            mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRects {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRects");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2)
     * }
     */
    public static FunctionDescriptor glRects$descriptor() {
        return glRects.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2)
     * }
     */
    public static MethodHandle glRects$handle() {
        return glRects.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2)
     * }
     */
    public static MemorySegment glRects$address() {
        return glRects.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2)
     * }
     */
    public static void glRects(short x1, short y1, short x2, short y2) {
        var mh$ = glRects.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRects", x1, y1, x2, y2);
            }
            mh$.invokeExact(x1, y1, x2, y2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRectsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRectsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glRectsv(const GLshort *v1, const GLshort *v2)
     * }
     */
    public static FunctionDescriptor glRectsv$descriptor() {
        return glRectsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glRectsv(const GLshort *v1, const GLshort *v2)
     * }
     */
    public static MethodHandle glRectsv$handle() {
        return glRectsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glRectsv(const GLshort *v1, const GLshort *v2)
     * }
     */
    public static MemorySegment glRectsv$address() {
        return glRectsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glRectsv(const GLshort *v1, const GLshort *v2)
     * }
     */
    public static void glRectsv(MemorySegment v1, MemorySegment v2) {
        var mh$ = glRectsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRectsv", v1, v2);
            }
            mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRenderMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRenderMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLint glRenderMode(GLenum mode)
     * }
     */
    public static FunctionDescriptor glRenderMode$descriptor() {
        return glRenderMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLint glRenderMode(GLenum mode)
     * }
     */
    public static MethodHandle glRenderMode$handle() {
        return glRenderMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLint glRenderMode(GLenum mode)
     * }
     */
    public static MemorySegment glRenderMode$address() {
        return glRenderMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLint glRenderMode(GLenum mode)
     * }
     */
    public static int glRenderMode(int mode) {
        var mh$ = glRenderMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRenderMode", mode);
            }
            return (int)mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glResetHistogram {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glResetHistogram");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glResetHistogram(GLenum target)
     * }
     */
    public static FunctionDescriptor glResetHistogram$descriptor() {
        return glResetHistogram.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glResetHistogram(GLenum target)
     * }
     */
    public static MethodHandle glResetHistogram$handle() {
        return glResetHistogram.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glResetHistogram(GLenum target)
     * }
     */
    public static MemorySegment glResetHistogram$address() {
        return glResetHistogram.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glResetHistogram(GLenum target)
     * }
     */
    public static void glResetHistogram(int target) {
        var mh$ = glResetHistogram.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glResetHistogram", target);
            }
            mh$.invokeExact(target);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glResetMinmax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glResetMinmax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glResetMinmax(GLenum target)
     * }
     */
    public static FunctionDescriptor glResetMinmax$descriptor() {
        return glResetMinmax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glResetMinmax(GLenum target)
     * }
     */
    public static MethodHandle glResetMinmax$handle() {
        return glResetMinmax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glResetMinmax(GLenum target)
     * }
     */
    public static MemorySegment glResetMinmax$address() {
        return glResetMinmax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glResetMinmax(GLenum target)
     * }
     */
    public static void glResetMinmax(int target) {
        var mh$ = glResetMinmax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glResetMinmax", target);
            }
            mh$.invokeExact(target);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRotated {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRotated");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static FunctionDescriptor glRotated$descriptor() {
        return glRotated.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MethodHandle glRotated$handle() {
        return glRotated.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MemorySegment glRotated$address() {
        return glRotated.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static void glRotated(double angle, double x, double y, double z) {
        var mh$ = glRotated.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRotated", angle, x, y, z);
            }
            mh$.invokeExact(angle, x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRotatef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glRotatef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static FunctionDescriptor glRotatef$descriptor() {
        return glRotatef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MethodHandle glRotatef$handle() {
        return glRotatef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MemorySegment glRotatef$address() {
        return glRotatef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static void glRotatef(float angle, float x, float y, float z) {
        var mh$ = glRotatef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRotatef", angle, x, y, z);
            }
            mh$.invokeExact(angle, x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glScaled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glScaled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glScaled(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static FunctionDescriptor glScaled$descriptor() {
        return glScaled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glScaled(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MethodHandle glScaled$handle() {
        return glScaled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glScaled(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MemorySegment glScaled$address() {
        return glScaled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glScaled(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static void glScaled(double x, double y, double z) {
        var mh$ = glScaled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glScaled", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glScalef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glScalef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glScalef(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static FunctionDescriptor glScalef$descriptor() {
        return glScalef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glScalef(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MethodHandle glScalef$handle() {
        return glScalef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glScalef(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MemorySegment glScalef$address() {
        return glScalef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glScalef(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static void glScalef(float x, float y, float z) {
        var mh$ = glScalef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glScalef", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glScissor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glScissor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glScissor(GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static FunctionDescriptor glScissor$descriptor() {
        return glScissor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glScissor(GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MethodHandle glScissor$handle() {
        return glScissor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glScissor(GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MemorySegment glScissor$address() {
        return glScissor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glScissor(GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static void glScissor(int x, int y, int width, int height) {
        var mh$ = glScissor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glScissor", x, y, width, height);
            }
            mh$.invokeExact(x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSelectBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glSelectBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glSelectBuffer(GLsizei size, GLuint *buffer)
     * }
     */
    public static FunctionDescriptor glSelectBuffer$descriptor() {
        return glSelectBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glSelectBuffer(GLsizei size, GLuint *buffer)
     * }
     */
    public static MethodHandle glSelectBuffer$handle() {
        return glSelectBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glSelectBuffer(GLsizei size, GLuint *buffer)
     * }
     */
    public static MemorySegment glSelectBuffer$address() {
        return glSelectBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glSelectBuffer(GLsizei size, GLuint *buffer)
     * }
     */
    public static void glSelectBuffer(int size, MemorySegment buffer) {
        var mh$ = glSelectBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSelectBuffer", size, buffer);
            }
            mh$.invokeExact(size, buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSeparableFilter2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glSeparableFilter2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glSeparableFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column)
     * }
     */
    public static FunctionDescriptor glSeparableFilter2D$descriptor() {
        return glSeparableFilter2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glSeparableFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column)
     * }
     */
    public static MethodHandle glSeparableFilter2D$handle() {
        return glSeparableFilter2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glSeparableFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column)
     * }
     */
    public static MemorySegment glSeparableFilter2D$address() {
        return glSeparableFilter2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glSeparableFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column)
     * }
     */
    public static void glSeparableFilter2D(int target, int internalformat, int width, int height, int format, int type, MemorySegment row, MemorySegment column) {
        var mh$ = glSeparableFilter2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSeparableFilter2D", target, internalformat, width, height, format, type, row, column);
            }
            mh$.invokeExact(target, internalformat, width, height, format, type, row, column);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glShadeModel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glShadeModel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glShadeModel(GLenum mode)
     * }
     */
    public static FunctionDescriptor glShadeModel$descriptor() {
        return glShadeModel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glShadeModel(GLenum mode)
     * }
     */
    public static MethodHandle glShadeModel$handle() {
        return glShadeModel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glShadeModel(GLenum mode)
     * }
     */
    public static MemorySegment glShadeModel$address() {
        return glShadeModel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glShadeModel(GLenum mode)
     * }
     */
    public static void glShadeModel(int mode) {
        var mh$ = glShadeModel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glShadeModel", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glStencilFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glStencilFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glStencilFunc(GLenum func, GLint ref, GLuint mask)
     * }
     */
    public static FunctionDescriptor glStencilFunc$descriptor() {
        return glStencilFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glStencilFunc(GLenum func, GLint ref, GLuint mask)
     * }
     */
    public static MethodHandle glStencilFunc$handle() {
        return glStencilFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glStencilFunc(GLenum func, GLint ref, GLuint mask)
     * }
     */
    public static MemorySegment glStencilFunc$address() {
        return glStencilFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glStencilFunc(GLenum func, GLint ref, GLuint mask)
     * }
     */
    public static void glStencilFunc(int func, int ref, int mask) {
        var mh$ = glStencilFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glStencilFunc", func, ref, mask);
            }
            mh$.invokeExact(func, ref, mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glStencilMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glStencilMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glStencilMask(GLuint mask)
     * }
     */
    public static FunctionDescriptor glStencilMask$descriptor() {
        return glStencilMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glStencilMask(GLuint mask)
     * }
     */
    public static MethodHandle glStencilMask$handle() {
        return glStencilMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glStencilMask(GLuint mask)
     * }
     */
    public static MemorySegment glStencilMask$address() {
        return glStencilMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glStencilMask(GLuint mask)
     * }
     */
    public static void glStencilMask(int mask) {
        var mh$ = glStencilMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glStencilMask", mask);
            }
            mh$.invokeExact(mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glStencilOp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glStencilOp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glStencilOp(GLenum fail, GLenum zfail, GLenum zpass)
     * }
     */
    public static FunctionDescriptor glStencilOp$descriptor() {
        return glStencilOp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glStencilOp(GLenum fail, GLenum zfail, GLenum zpass)
     * }
     */
    public static MethodHandle glStencilOp$handle() {
        return glStencilOp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glStencilOp(GLenum fail, GLenum zfail, GLenum zpass)
     * }
     */
    public static MemorySegment glStencilOp$address() {
        return glStencilOp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glStencilOp(GLenum fail, GLenum zfail, GLenum zpass)
     * }
     */
    public static void glStencilOp(int fail, int zfail, int zpass) {
        var mh$ = glStencilOp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glStencilOp", fail, zfail, zpass);
            }
            mh$.invokeExact(fail, zfail, zpass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexCoord1d(GLdouble s)
     * }
     */
    public static FunctionDescriptor glTexCoord1d$descriptor() {
        return glTexCoord1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexCoord1d(GLdouble s)
     * }
     */
    public static MethodHandle glTexCoord1d$handle() {
        return glTexCoord1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexCoord1d(GLdouble s)
     * }
     */
    public static MemorySegment glTexCoord1d$address() {
        return glTexCoord1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexCoord1d(GLdouble s)
     * }
     */
    public static void glTexCoord1d(double s) {
        var mh$ = glTexCoord1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1d", s);
            }
            mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord1dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexCoord1dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glTexCoord1dv$descriptor() {
        return glTexCoord1dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexCoord1dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glTexCoord1dv$handle() {
        return glTexCoord1dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexCoord1dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glTexCoord1dv$address() {
        return glTexCoord1dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexCoord1dv(const GLdouble *v)
     * }
     */
    public static void glTexCoord1dv(MemorySegment v) {
        var mh$ = glTexCoord1dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexCoord1f(GLfloat s)
     * }
     */
    public static FunctionDescriptor glTexCoord1f$descriptor() {
        return glTexCoord1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexCoord1f(GLfloat s)
     * }
     */
    public static MethodHandle glTexCoord1f$handle() {
        return glTexCoord1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexCoord1f(GLfloat s)
     * }
     */
    public static MemorySegment glTexCoord1f$address() {
        return glTexCoord1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexCoord1f(GLfloat s)
     * }
     */
    public static void glTexCoord1f(float s) {
        var mh$ = glTexCoord1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1f", s);
            }
            mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord1fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexCoord1fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glTexCoord1fv$descriptor() {
        return glTexCoord1fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexCoord1fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glTexCoord1fv$handle() {
        return glTexCoord1fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexCoord1fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glTexCoord1fv$address() {
        return glTexCoord1fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexCoord1fv(const GLfloat *v)
     * }
     */
    public static void glTexCoord1fv(MemorySegment v) {
        var mh$ = glTexCoord1fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord1i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexCoord1i(GLint s)
     * }
     */
    public static FunctionDescriptor glTexCoord1i$descriptor() {
        return glTexCoord1i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexCoord1i(GLint s)
     * }
     */
    public static MethodHandle glTexCoord1i$handle() {
        return glTexCoord1i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexCoord1i(GLint s)
     * }
     */
    public static MemorySegment glTexCoord1i$address() {
        return glTexCoord1i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexCoord1i(GLint s)
     * }
     */
    public static void glTexCoord1i(int s) {
        var mh$ = glTexCoord1i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1i", s);
            }
            mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord1iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexCoord1iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glTexCoord1iv$descriptor() {
        return glTexCoord1iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexCoord1iv(const GLint *v)
     * }
     */
    public static MethodHandle glTexCoord1iv$handle() {
        return glTexCoord1iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexCoord1iv(const GLint *v)
     * }
     */
    public static MemorySegment glTexCoord1iv$address() {
        return glTexCoord1iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexCoord1iv(const GLint *v)
     * }
     */
    public static void glTexCoord1iv(MemorySegment v) {
        var mh$ = glTexCoord1iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord1s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexCoord1s(GLshort s)
     * }
     */
    public static FunctionDescriptor glTexCoord1s$descriptor() {
        return glTexCoord1s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexCoord1s(GLshort s)
     * }
     */
    public static MethodHandle glTexCoord1s$handle() {
        return glTexCoord1s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexCoord1s(GLshort s)
     * }
     */
    public static MemorySegment glTexCoord1s$address() {
        return glTexCoord1s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexCoord1s(GLshort s)
     * }
     */
    public static void glTexCoord1s(short s) {
        var mh$ = glTexCoord1s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1s", s);
            }
            mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord1sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexCoord1sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glTexCoord1sv$descriptor() {
        return glTexCoord1sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexCoord1sv(const GLshort *v)
     * }
     */
    public static MethodHandle glTexCoord1sv$handle() {
        return glTexCoord1sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexCoord1sv(const GLshort *v)
     * }
     */
    public static MemorySegment glTexCoord1sv$address() {
        return glTexCoord1sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexCoord1sv(const GLshort *v)
     * }
     */
    public static void glTexCoord1sv(MemorySegment v) {
        var mh$ = glTexCoord1sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexCoord2d(GLdouble s, GLdouble t)
     * }
     */
    public static FunctionDescriptor glTexCoord2d$descriptor() {
        return glTexCoord2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexCoord2d(GLdouble s, GLdouble t)
     * }
     */
    public static MethodHandle glTexCoord2d$handle() {
        return glTexCoord2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexCoord2d(GLdouble s, GLdouble t)
     * }
     */
    public static MemorySegment glTexCoord2d$address() {
        return glTexCoord2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexCoord2d(GLdouble s, GLdouble t)
     * }
     */
    public static void glTexCoord2d(double s, double t) {
        var mh$ = glTexCoord2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2d", s, t);
            }
            mh$.invokeExact(s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord2dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexCoord2dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glTexCoord2dv$descriptor() {
        return glTexCoord2dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexCoord2dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glTexCoord2dv$handle() {
        return glTexCoord2dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexCoord2dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glTexCoord2dv$address() {
        return glTexCoord2dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexCoord2dv(const GLdouble *v)
     * }
     */
    public static void glTexCoord2dv(MemorySegment v) {
        var mh$ = glTexCoord2dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexCoord2f(GLfloat s, GLfloat t)
     * }
     */
    public static FunctionDescriptor glTexCoord2f$descriptor() {
        return glTexCoord2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexCoord2f(GLfloat s, GLfloat t)
     * }
     */
    public static MethodHandle glTexCoord2f$handle() {
        return glTexCoord2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexCoord2f(GLfloat s, GLfloat t)
     * }
     */
    public static MemorySegment glTexCoord2f$address() {
        return glTexCoord2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexCoord2f(GLfloat s, GLfloat t)
     * }
     */
    public static void glTexCoord2f(float s, float t) {
        var mh$ = glTexCoord2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2f", s, t);
            }
            mh$.invokeExact(s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord2fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexCoord2fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glTexCoord2fv$descriptor() {
        return glTexCoord2fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexCoord2fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glTexCoord2fv$handle() {
        return glTexCoord2fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexCoord2fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glTexCoord2fv$address() {
        return glTexCoord2fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexCoord2fv(const GLfloat *v)
     * }
     */
    public static void glTexCoord2fv(MemorySegment v) {
        var mh$ = glTexCoord2fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord2i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexCoord2i(GLint s, GLint t)
     * }
     */
    public static FunctionDescriptor glTexCoord2i$descriptor() {
        return glTexCoord2i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexCoord2i(GLint s, GLint t)
     * }
     */
    public static MethodHandle glTexCoord2i$handle() {
        return glTexCoord2i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexCoord2i(GLint s, GLint t)
     * }
     */
    public static MemorySegment glTexCoord2i$address() {
        return glTexCoord2i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexCoord2i(GLint s, GLint t)
     * }
     */
    public static void glTexCoord2i(int s, int t) {
        var mh$ = glTexCoord2i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2i", s, t);
            }
            mh$.invokeExact(s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord2iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexCoord2iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glTexCoord2iv$descriptor() {
        return glTexCoord2iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexCoord2iv(const GLint *v)
     * }
     */
    public static MethodHandle glTexCoord2iv$handle() {
        return glTexCoord2iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexCoord2iv(const GLint *v)
     * }
     */
    public static MemorySegment glTexCoord2iv$address() {
        return glTexCoord2iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexCoord2iv(const GLint *v)
     * }
     */
    public static void glTexCoord2iv(MemorySegment v) {
        var mh$ = glTexCoord2iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord2s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexCoord2s(GLshort s, GLshort t)
     * }
     */
    public static FunctionDescriptor glTexCoord2s$descriptor() {
        return glTexCoord2s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexCoord2s(GLshort s, GLshort t)
     * }
     */
    public static MethodHandle glTexCoord2s$handle() {
        return glTexCoord2s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexCoord2s(GLshort s, GLshort t)
     * }
     */
    public static MemorySegment glTexCoord2s$address() {
        return glTexCoord2s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexCoord2s(GLshort s, GLshort t)
     * }
     */
    public static void glTexCoord2s(short s, short t) {
        var mh$ = glTexCoord2s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2s", s, t);
            }
            mh$.invokeExact(s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord2sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexCoord2sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glTexCoord2sv$descriptor() {
        return glTexCoord2sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexCoord2sv(const GLshort *v)
     * }
     */
    public static MethodHandle glTexCoord2sv$handle() {
        return glTexCoord2sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexCoord2sv(const GLshort *v)
     * }
     */
    public static MemorySegment glTexCoord2sv$address() {
        return glTexCoord2sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexCoord2sv(const GLshort *v)
     * }
     */
    public static void glTexCoord2sv(MemorySegment v) {
        var mh$ = glTexCoord2sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexCoord3d(GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static FunctionDescriptor glTexCoord3d$descriptor() {
        return glTexCoord3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexCoord3d(GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static MethodHandle glTexCoord3d$handle() {
        return glTexCoord3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexCoord3d(GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static MemorySegment glTexCoord3d$address() {
        return glTexCoord3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexCoord3d(GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static void glTexCoord3d(double s, double t, double r) {
        var mh$ = glTexCoord3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3d", s, t, r);
            }
            mh$.invokeExact(s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord3dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexCoord3dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glTexCoord3dv$descriptor() {
        return glTexCoord3dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexCoord3dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glTexCoord3dv$handle() {
        return glTexCoord3dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexCoord3dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glTexCoord3dv$address() {
        return glTexCoord3dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexCoord3dv(const GLdouble *v)
     * }
     */
    public static void glTexCoord3dv(MemorySegment v) {
        var mh$ = glTexCoord3dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord3f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexCoord3f(GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static FunctionDescriptor glTexCoord3f$descriptor() {
        return glTexCoord3f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexCoord3f(GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static MethodHandle glTexCoord3f$handle() {
        return glTexCoord3f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexCoord3f(GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static MemorySegment glTexCoord3f$address() {
        return glTexCoord3f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexCoord3f(GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static void glTexCoord3f(float s, float t, float r) {
        var mh$ = glTexCoord3f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3f", s, t, r);
            }
            mh$.invokeExact(s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord3fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexCoord3fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glTexCoord3fv$descriptor() {
        return glTexCoord3fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexCoord3fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glTexCoord3fv$handle() {
        return glTexCoord3fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexCoord3fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glTexCoord3fv$address() {
        return glTexCoord3fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexCoord3fv(const GLfloat *v)
     * }
     */
    public static void glTexCoord3fv(MemorySegment v) {
        var mh$ = glTexCoord3fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord3i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexCoord3i(GLint s, GLint t, GLint r)
     * }
     */
    public static FunctionDescriptor glTexCoord3i$descriptor() {
        return glTexCoord3i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexCoord3i(GLint s, GLint t, GLint r)
     * }
     */
    public static MethodHandle glTexCoord3i$handle() {
        return glTexCoord3i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexCoord3i(GLint s, GLint t, GLint r)
     * }
     */
    public static MemorySegment glTexCoord3i$address() {
        return glTexCoord3i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexCoord3i(GLint s, GLint t, GLint r)
     * }
     */
    public static void glTexCoord3i(int s, int t, int r) {
        var mh$ = glTexCoord3i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3i", s, t, r);
            }
            mh$.invokeExact(s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord3iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexCoord3iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glTexCoord3iv$descriptor() {
        return glTexCoord3iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexCoord3iv(const GLint *v)
     * }
     */
    public static MethodHandle glTexCoord3iv$handle() {
        return glTexCoord3iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexCoord3iv(const GLint *v)
     * }
     */
    public static MemorySegment glTexCoord3iv$address() {
        return glTexCoord3iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexCoord3iv(const GLint *v)
     * }
     */
    public static void glTexCoord3iv(MemorySegment v) {
        var mh$ = glTexCoord3iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord3s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexCoord3s(GLshort s, GLshort t, GLshort r)
     * }
     */
    public static FunctionDescriptor glTexCoord3s$descriptor() {
        return glTexCoord3s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexCoord3s(GLshort s, GLshort t, GLshort r)
     * }
     */
    public static MethodHandle glTexCoord3s$handle() {
        return glTexCoord3s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexCoord3s(GLshort s, GLshort t, GLshort r)
     * }
     */
    public static MemorySegment glTexCoord3s$address() {
        return glTexCoord3s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexCoord3s(GLshort s, GLshort t, GLshort r)
     * }
     */
    public static void glTexCoord3s(short s, short t, short r) {
        var mh$ = glTexCoord3s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3s", s, t, r);
            }
            mh$.invokeExact(s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord3sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexCoord3sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glTexCoord3sv$descriptor() {
        return glTexCoord3sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexCoord3sv(const GLshort *v)
     * }
     */
    public static MethodHandle glTexCoord3sv$handle() {
        return glTexCoord3sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexCoord3sv(const GLshort *v)
     * }
     */
    public static MemorySegment glTexCoord3sv$address() {
        return glTexCoord3sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexCoord3sv(const GLshort *v)
     * }
     */
    public static void glTexCoord3sv(MemorySegment v) {
        var mh$ = glTexCoord3sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord4d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static FunctionDescriptor glTexCoord4d$descriptor() {
        return glTexCoord4d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static MethodHandle glTexCoord4d$handle() {
        return glTexCoord4d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static MemorySegment glTexCoord4d$address() {
        return glTexCoord4d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static void glTexCoord4d(double s, double t, double r, double q) {
        var mh$ = glTexCoord4d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4d", s, t, r, q);
            }
            mh$.invokeExact(s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord4dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexCoord4dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glTexCoord4dv$descriptor() {
        return glTexCoord4dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexCoord4dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glTexCoord4dv$handle() {
        return glTexCoord4dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexCoord4dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glTexCoord4dv$address() {
        return glTexCoord4dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexCoord4dv(const GLdouble *v)
     * }
     */
    public static void glTexCoord4dv(MemorySegment v) {
        var mh$ = glTexCoord4dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord4f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static FunctionDescriptor glTexCoord4f$descriptor() {
        return glTexCoord4f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static MethodHandle glTexCoord4f$handle() {
        return glTexCoord4f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static MemorySegment glTexCoord4f$address() {
        return glTexCoord4f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static void glTexCoord4f(float s, float t, float r, float q) {
        var mh$ = glTexCoord4f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4f", s, t, r, q);
            }
            mh$.invokeExact(s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord4fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexCoord4fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glTexCoord4fv$descriptor() {
        return glTexCoord4fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexCoord4fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glTexCoord4fv$handle() {
        return glTexCoord4fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexCoord4fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glTexCoord4fv$address() {
        return glTexCoord4fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexCoord4fv(const GLfloat *v)
     * }
     */
    public static void glTexCoord4fv(MemorySegment v) {
        var mh$ = glTexCoord4fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord4i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexCoord4i(GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static FunctionDescriptor glTexCoord4i$descriptor() {
        return glTexCoord4i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexCoord4i(GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static MethodHandle glTexCoord4i$handle() {
        return glTexCoord4i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexCoord4i(GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static MemorySegment glTexCoord4i$address() {
        return glTexCoord4i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexCoord4i(GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static void glTexCoord4i(int s, int t, int r, int q) {
        var mh$ = glTexCoord4i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4i", s, t, r, q);
            }
            mh$.invokeExact(s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord4iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexCoord4iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glTexCoord4iv$descriptor() {
        return glTexCoord4iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexCoord4iv(const GLint *v)
     * }
     */
    public static MethodHandle glTexCoord4iv$handle() {
        return glTexCoord4iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexCoord4iv(const GLint *v)
     * }
     */
    public static MemorySegment glTexCoord4iv$address() {
        return glTexCoord4iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexCoord4iv(const GLint *v)
     * }
     */
    public static void glTexCoord4iv(MemorySegment v) {
        var mh$ = glTexCoord4iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord4s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static FunctionDescriptor glTexCoord4s$descriptor() {
        return glTexCoord4s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static MethodHandle glTexCoord4s$handle() {
        return glTexCoord4s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static MemorySegment glTexCoord4s$address() {
        return glTexCoord4s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static void glTexCoord4s(short s, short t, short r, short q) {
        var mh$ = glTexCoord4s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4s", s, t, r, q);
            }
            mh$.invokeExact(s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoord4sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexCoord4sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glTexCoord4sv$descriptor() {
        return glTexCoord4sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexCoord4sv(const GLshort *v)
     * }
     */
    public static MethodHandle glTexCoord4sv$handle() {
        return glTexCoord4sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexCoord4sv(const GLshort *v)
     * }
     */
    public static MemorySegment glTexCoord4sv$address() {
        return glTexCoord4sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexCoord4sv(const GLshort *v)
     * }
     */
    public static void glTexCoord4sv(MemorySegment v) {
        var mh$ = glTexCoord4sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoordPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexCoordPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static FunctionDescriptor glTexCoordPointer$descriptor() {
        return glTexCoordPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MethodHandle glTexCoordPointer$handle() {
        return glTexCoordPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MemorySegment glTexCoordPointer$address() {
        return glTexCoordPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static void glTexCoordPointer(int size, int type, int stride, MemorySegment pointer) {
        var mh$ = glTexCoordPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoordPointer", size, type, stride, pointer);
            }
            mh$.invokeExact(size, type, stride, pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexEnvf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexEnvf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexEnvf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glTexEnvf$descriptor() {
        return glTexEnvf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexEnvf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glTexEnvf$handle() {
        return glTexEnvf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexEnvf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glTexEnvf$address() {
        return glTexEnvf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexEnvf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static void glTexEnvf(int target, int pname, float param) {
        var mh$ = glTexEnvf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexEnvf", target, pname, param);
            }
            mh$.invokeExact(target, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexEnvfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexEnvfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glTexEnvfv$descriptor() {
        return glTexEnvfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glTexEnvfv$handle() {
        return glTexEnvfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glTexEnvfv$address() {
        return glTexEnvfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static void glTexEnvfv(int target, int pname, MemorySegment params) {
        var mh$ = glTexEnvfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexEnvfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexEnvi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexEnvi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexEnvi(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glTexEnvi$descriptor() {
        return glTexEnvi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexEnvi(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glTexEnvi$handle() {
        return glTexEnvi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexEnvi(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glTexEnvi$address() {
        return glTexEnvi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexEnvi(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static void glTexEnvi(int target, int pname, int param) {
        var mh$ = glTexEnvi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexEnvi", target, pname, param);
            }
            mh$.invokeExact(target, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexEnviv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexEnviv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexEnviv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glTexEnviv$descriptor() {
        return glTexEnviv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexEnviv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glTexEnviv$handle() {
        return glTexEnviv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexEnviv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glTexEnviv$address() {
        return glTexEnviv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexEnviv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static void glTexEnviv(int target, int pname, MemorySegment params) {
        var mh$ = glTexEnviv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexEnviv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexGend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexGend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexGend(GLenum coord, GLenum pname, GLdouble param)
     * }
     */
    public static FunctionDescriptor glTexGend$descriptor() {
        return glTexGend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexGend(GLenum coord, GLenum pname, GLdouble param)
     * }
     */
    public static MethodHandle glTexGend$handle() {
        return glTexGend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexGend(GLenum coord, GLenum pname, GLdouble param)
     * }
     */
    public static MemorySegment glTexGend$address() {
        return glTexGend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexGend(GLenum coord, GLenum pname, GLdouble param)
     * }
     */
    public static void glTexGend(int coord, int pname, double param) {
        var mh$ = glTexGend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexGend", coord, pname, param);
            }
            mh$.invokeExact(coord, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexGendv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexGendv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexGendv(GLenum coord, GLenum pname, const GLdouble *params)
     * }
     */
    public static FunctionDescriptor glTexGendv$descriptor() {
        return glTexGendv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexGendv(GLenum coord, GLenum pname, const GLdouble *params)
     * }
     */
    public static MethodHandle glTexGendv$handle() {
        return glTexGendv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexGendv(GLenum coord, GLenum pname, const GLdouble *params)
     * }
     */
    public static MemorySegment glTexGendv$address() {
        return glTexGendv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexGendv(GLenum coord, GLenum pname, const GLdouble *params)
     * }
     */
    public static void glTexGendv(int coord, int pname, MemorySegment params) {
        var mh$ = glTexGendv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexGendv", coord, pname, params);
            }
            mh$.invokeExact(coord, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexGenf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexGenf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexGenf(GLenum coord, GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glTexGenf$descriptor() {
        return glTexGenf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexGenf(GLenum coord, GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glTexGenf$handle() {
        return glTexGenf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexGenf(GLenum coord, GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glTexGenf$address() {
        return glTexGenf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexGenf(GLenum coord, GLenum pname, GLfloat param)
     * }
     */
    public static void glTexGenf(int coord, int pname, float param) {
        var mh$ = glTexGenf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexGenf", coord, pname, param);
            }
            mh$.invokeExact(coord, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexGenfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexGenfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glTexGenfv$descriptor() {
        return glTexGenfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glTexGenfv$handle() {
        return glTexGenfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glTexGenfv$address() {
        return glTexGenfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params)
     * }
     */
    public static void glTexGenfv(int coord, int pname, MemorySegment params) {
        var mh$ = glTexGenfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexGenfv", coord, pname, params);
            }
            mh$.invokeExact(coord, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexGeni {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexGeni");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexGeni(GLenum coord, GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glTexGeni$descriptor() {
        return glTexGeni.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexGeni(GLenum coord, GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glTexGeni$handle() {
        return glTexGeni.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexGeni(GLenum coord, GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glTexGeni$address() {
        return glTexGeni.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexGeni(GLenum coord, GLenum pname, GLint param)
     * }
     */
    public static void glTexGeni(int coord, int pname, int param) {
        var mh$ = glTexGeni.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexGeni", coord, pname, param);
            }
            mh$.invokeExact(coord, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexGeniv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexGeniv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexGeniv(GLenum coord, GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glTexGeniv$descriptor() {
        return glTexGeniv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexGeniv(GLenum coord, GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glTexGeniv$handle() {
        return glTexGeniv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexGeniv(GLenum coord, GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glTexGeniv$address() {
        return glTexGeniv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexGeniv(GLenum coord, GLenum pname, const GLint *params)
     * }
     */
    public static void glTexGeniv(int coord, int pname, MemorySegment params) {
        var mh$ = glTexGeniv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexGeniv", coord, pname, params);
            }
            mh$.invokeExact(coord, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexImage1D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexImage1D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexImage1D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glTexImage1D$descriptor() {
        return glTexImage1D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexImage1D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MethodHandle glTexImage1D$handle() {
        return glTexImage1D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexImage1D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MemorySegment glTexImage1D$address() {
        return glTexImage1D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexImage1D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static void glTexImage1D(int target, int level, int internalformat, int width, int border, int format, int type, MemorySegment pixels) {
        var mh$ = glTexImage1D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexImage1D", target, level, internalformat, width, border, format, type, pixels);
            }
            mh$.invokeExact(target, level, internalformat, width, border, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexImage2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexImage2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glTexImage2D$descriptor() {
        return glTexImage2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MethodHandle glTexImage2D$handle() {
        return glTexImage2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MemorySegment glTexImage2D$address() {
        return glTexImage2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static void glTexImage2D(int target, int level, int internalformat, int width, int height, int border, int format, int type, MemorySegment pixels) {
        var mh$ = glTexImage2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexImage2D", target, level, internalformat, width, height, border, format, type, pixels);
            }
            mh$.invokeExact(target, level, internalformat, width, height, border, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexImage3D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexImage3D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glTexImage3D$descriptor() {
        return glTexImage3D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MethodHandle glTexImage3D$handle() {
        return glTexImage3D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MemorySegment glTexImage3D$address() {
        return glTexImage3D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static void glTexImage3D(int target, int level, int internalformat, int width, int height, int depth, int border, int format, int type, MemorySegment pixels) {
        var mh$ = glTexImage3D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexImage3D", target, level, internalformat, width, height, depth, border, format, type, pixels);
            }
            mh$.invokeExact(target, level, internalformat, width, height, depth, border, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexParameterf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexParameterf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexParameterf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glTexParameterf$descriptor() {
        return glTexParameterf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexParameterf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glTexParameterf$handle() {
        return glTexParameterf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexParameterf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glTexParameterf$address() {
        return glTexParameterf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexParameterf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static void glTexParameterf(int target, int pname, float param) {
        var mh$ = glTexParameterf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexParameterf", target, pname, param);
            }
            mh$.invokeExact(target, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexParameterfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexParameterfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glTexParameterfv$descriptor() {
        return glTexParameterfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glTexParameterfv$handle() {
        return glTexParameterfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glTexParameterfv$address() {
        return glTexParameterfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static void glTexParameterfv(int target, int pname, MemorySegment params) {
        var mh$ = glTexParameterfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexParameterfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexParameteri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexParameteri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexParameteri(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glTexParameteri$descriptor() {
        return glTexParameteri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexParameteri(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glTexParameteri$handle() {
        return glTexParameteri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexParameteri(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glTexParameteri$address() {
        return glTexParameteri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexParameteri(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static void glTexParameteri(int target, int pname, int param) {
        var mh$ = glTexParameteri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexParameteri", target, pname, param);
            }
            mh$.invokeExact(target, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexParameteriv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexParameteriv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glTexParameteriv$descriptor() {
        return glTexParameteriv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glTexParameteriv$handle() {
        return glTexParameteriv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glTexParameteriv$address() {
        return glTexParameteriv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static void glTexParameteriv(int target, int pname, MemorySegment params) {
        var mh$ = glTexParameteriv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexParameteriv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexSubImage1D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexSubImage1D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glTexSubImage1D$descriptor() {
        return glTexSubImage1D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MethodHandle glTexSubImage1D$handle() {
        return glTexSubImage1D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MemorySegment glTexSubImage1D$address() {
        return glTexSubImage1D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static void glTexSubImage1D(int target, int level, int xoffset, int width, int format, int type, MemorySegment pixels) {
        var mh$ = glTexSubImage1D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexSubImage1D", target, level, xoffset, width, format, type, pixels);
            }
            mh$.invokeExact(target, level, xoffset, width, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexSubImage2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexSubImage2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glTexSubImage2D$descriptor() {
        return glTexSubImage2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MethodHandle glTexSubImage2D$handle() {
        return glTexSubImage2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MemorySegment glTexSubImage2D$address() {
        return glTexSubImage2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static void glTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, MemorySegment pixels) {
        var mh$ = glTexSubImage2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexSubImage2D", target, level, xoffset, yoffset, width, height, format, type, pixels);
            }
            mh$.invokeExact(target, level, xoffset, yoffset, width, height, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexSubImage3D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTexSubImage3D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glTexSubImage3D$descriptor() {
        return glTexSubImage3D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MethodHandle glTexSubImage3D$handle() {
        return glTexSubImage3D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MemorySegment glTexSubImage3D$address() {
        return glTexSubImage3D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static void glTexSubImage3D(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, MemorySegment pixels) {
        var mh$ = glTexSubImage3D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexSubImage3D", target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
            }
            mh$.invokeExact(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTranslated {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTranslated");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTranslated(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static FunctionDescriptor glTranslated$descriptor() {
        return glTranslated.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTranslated(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MethodHandle glTranslated$handle() {
        return glTranslated.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTranslated(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MemorySegment glTranslated$address() {
        return glTranslated.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTranslated(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static void glTranslated(double x, double y, double z) {
        var mh$ = glTranslated.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTranslated", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTranslatef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glTranslatef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glTranslatef(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static FunctionDescriptor glTranslatef$descriptor() {
        return glTranslatef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glTranslatef(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MethodHandle glTranslatef$handle() {
        return glTranslatef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glTranslatef(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MemorySegment glTranslatef$address() {
        return glTranslatef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glTranslatef(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static void glTranslatef(float x, float y, float z) {
        var mh$ = glTranslatef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTranslatef", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertex2d(GLdouble x, GLdouble y)
     * }
     */
    public static FunctionDescriptor glVertex2d$descriptor() {
        return glVertex2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertex2d(GLdouble x, GLdouble y)
     * }
     */
    public static MethodHandle glVertex2d$handle() {
        return glVertex2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertex2d(GLdouble x, GLdouble y)
     * }
     */
    public static MemorySegment glVertex2d$address() {
        return glVertex2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertex2d(GLdouble x, GLdouble y)
     * }
     */
    public static void glVertex2d(double x, double y) {
        var mh$ = glVertex2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex2d", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex2dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex2dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertex2dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glVertex2dv$descriptor() {
        return glVertex2dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertex2dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glVertex2dv$handle() {
        return glVertex2dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertex2dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glVertex2dv$address() {
        return glVertex2dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertex2dv(const GLdouble *v)
     * }
     */
    public static void glVertex2dv(MemorySegment v) {
        var mh$ = glVertex2dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex2dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertex2f(GLfloat x, GLfloat y)
     * }
     */
    public static FunctionDescriptor glVertex2f$descriptor() {
        return glVertex2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertex2f(GLfloat x, GLfloat y)
     * }
     */
    public static MethodHandle glVertex2f$handle() {
        return glVertex2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertex2f(GLfloat x, GLfloat y)
     * }
     */
    public static MemorySegment glVertex2f$address() {
        return glVertex2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertex2f(GLfloat x, GLfloat y)
     * }
     */
    public static void glVertex2f(float x, float y) {
        var mh$ = glVertex2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex2f", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex2fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex2fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertex2fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glVertex2fv$descriptor() {
        return glVertex2fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertex2fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glVertex2fv$handle() {
        return glVertex2fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertex2fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glVertex2fv$address() {
        return glVertex2fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertex2fv(const GLfloat *v)
     * }
     */
    public static void glVertex2fv(MemorySegment v) {
        var mh$ = glVertex2fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex2fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex2i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex2i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertex2i(GLint x, GLint y)
     * }
     */
    public static FunctionDescriptor glVertex2i$descriptor() {
        return glVertex2i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertex2i(GLint x, GLint y)
     * }
     */
    public static MethodHandle glVertex2i$handle() {
        return glVertex2i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertex2i(GLint x, GLint y)
     * }
     */
    public static MemorySegment glVertex2i$address() {
        return glVertex2i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertex2i(GLint x, GLint y)
     * }
     */
    public static void glVertex2i(int x, int y) {
        var mh$ = glVertex2i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex2i", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex2iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex2iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertex2iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glVertex2iv$descriptor() {
        return glVertex2iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertex2iv(const GLint *v)
     * }
     */
    public static MethodHandle glVertex2iv$handle() {
        return glVertex2iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertex2iv(const GLint *v)
     * }
     */
    public static MemorySegment glVertex2iv$address() {
        return glVertex2iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertex2iv(const GLint *v)
     * }
     */
    public static void glVertex2iv(MemorySegment v) {
        var mh$ = glVertex2iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex2iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex2s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex2s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertex2s(GLshort x, GLshort y)
     * }
     */
    public static FunctionDescriptor glVertex2s$descriptor() {
        return glVertex2s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertex2s(GLshort x, GLshort y)
     * }
     */
    public static MethodHandle glVertex2s$handle() {
        return glVertex2s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertex2s(GLshort x, GLshort y)
     * }
     */
    public static MemorySegment glVertex2s$address() {
        return glVertex2s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertex2s(GLshort x, GLshort y)
     * }
     */
    public static void glVertex2s(short x, short y) {
        var mh$ = glVertex2s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex2s", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex2sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex2sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertex2sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glVertex2sv$descriptor() {
        return glVertex2sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertex2sv(const GLshort *v)
     * }
     */
    public static MethodHandle glVertex2sv$handle() {
        return glVertex2sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertex2sv(const GLshort *v)
     * }
     */
    public static MemorySegment glVertex2sv$address() {
        return glVertex2sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertex2sv(const GLshort *v)
     * }
     */
    public static void glVertex2sv(MemorySegment v) {
        var mh$ = glVertex2sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex2sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertex3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static FunctionDescriptor glVertex3d$descriptor() {
        return glVertex3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertex3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MethodHandle glVertex3d$handle() {
        return glVertex3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertex3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MemorySegment glVertex3d$address() {
        return glVertex3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertex3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static void glVertex3d(double x, double y, double z) {
        var mh$ = glVertex3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex3d", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex3dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex3dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertex3dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glVertex3dv$descriptor() {
        return glVertex3dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertex3dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glVertex3dv$handle() {
        return glVertex3dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertex3dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glVertex3dv$address() {
        return glVertex3dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertex3dv(const GLdouble *v)
     * }
     */
    public static void glVertex3dv(MemorySegment v) {
        var mh$ = glVertex3dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex3dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex3f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex3f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertex3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static FunctionDescriptor glVertex3f$descriptor() {
        return glVertex3f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertex3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MethodHandle glVertex3f$handle() {
        return glVertex3f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertex3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MemorySegment glVertex3f$address() {
        return glVertex3f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertex3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static void glVertex3f(float x, float y, float z) {
        var mh$ = glVertex3f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex3f", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex3fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex3fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertex3fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glVertex3fv$descriptor() {
        return glVertex3fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertex3fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glVertex3fv$handle() {
        return glVertex3fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertex3fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glVertex3fv$address() {
        return glVertex3fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertex3fv(const GLfloat *v)
     * }
     */
    public static void glVertex3fv(MemorySegment v) {
        var mh$ = glVertex3fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex3fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex3i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex3i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertex3i(GLint x, GLint y, GLint z)
     * }
     */
    public static FunctionDescriptor glVertex3i$descriptor() {
        return glVertex3i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertex3i(GLint x, GLint y, GLint z)
     * }
     */
    public static MethodHandle glVertex3i$handle() {
        return glVertex3i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertex3i(GLint x, GLint y, GLint z)
     * }
     */
    public static MemorySegment glVertex3i$address() {
        return glVertex3i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertex3i(GLint x, GLint y, GLint z)
     * }
     */
    public static void glVertex3i(int x, int y, int z) {
        var mh$ = glVertex3i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex3i", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex3iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex3iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertex3iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glVertex3iv$descriptor() {
        return glVertex3iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertex3iv(const GLint *v)
     * }
     */
    public static MethodHandle glVertex3iv$handle() {
        return glVertex3iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertex3iv(const GLint *v)
     * }
     */
    public static MemorySegment glVertex3iv$address() {
        return glVertex3iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertex3iv(const GLint *v)
     * }
     */
    public static void glVertex3iv(MemorySegment v) {
        var mh$ = glVertex3iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex3iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex3s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex3s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertex3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static FunctionDescriptor glVertex3s$descriptor() {
        return glVertex3s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertex3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static MethodHandle glVertex3s$handle() {
        return glVertex3s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertex3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static MemorySegment glVertex3s$address() {
        return glVertex3s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertex3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static void glVertex3s(short x, short y, short z) {
        var mh$ = glVertex3s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex3s", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex3sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex3sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertex3sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glVertex3sv$descriptor() {
        return glVertex3sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertex3sv(const GLshort *v)
     * }
     */
    public static MethodHandle glVertex3sv$handle() {
        return glVertex3sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertex3sv(const GLshort *v)
     * }
     */
    public static MemorySegment glVertex3sv$address() {
        return glVertex3sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertex3sv(const GLshort *v)
     * }
     */
    public static void glVertex3sv(MemorySegment v) {
        var mh$ = glVertex3sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex3sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex4d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex4d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static FunctionDescriptor glVertex4d$descriptor() {
        return glVertex4d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static MethodHandle glVertex4d$handle() {
        return glVertex4d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static MemorySegment glVertex4d$address() {
        return glVertex4d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static void glVertex4d(double x, double y, double z, double w) {
        var mh$ = glVertex4d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex4d", x, y, z, w);
            }
            mh$.invokeExact(x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex4dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex4dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertex4dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glVertex4dv$descriptor() {
        return glVertex4dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertex4dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glVertex4dv$handle() {
        return glVertex4dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertex4dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glVertex4dv$address() {
        return glVertex4dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertex4dv(const GLdouble *v)
     * }
     */
    public static void glVertex4dv(MemorySegment v) {
        var mh$ = glVertex4dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex4dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex4f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex4f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static FunctionDescriptor glVertex4f$descriptor() {
        return glVertex4f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static MethodHandle glVertex4f$handle() {
        return glVertex4f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static MemorySegment glVertex4f$address() {
        return glVertex4f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static void glVertex4f(float x, float y, float z, float w) {
        var mh$ = glVertex4f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex4f", x, y, z, w);
            }
            mh$.invokeExact(x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex4fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex4fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertex4fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glVertex4fv$descriptor() {
        return glVertex4fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertex4fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glVertex4fv$handle() {
        return glVertex4fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertex4fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glVertex4fv$address() {
        return glVertex4fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertex4fv(const GLfloat *v)
     * }
     */
    public static void glVertex4fv(MemorySegment v) {
        var mh$ = glVertex4fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex4fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex4i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex4i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertex4i(GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static FunctionDescriptor glVertex4i$descriptor() {
        return glVertex4i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertex4i(GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static MethodHandle glVertex4i$handle() {
        return glVertex4i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertex4i(GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static MemorySegment glVertex4i$address() {
        return glVertex4i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertex4i(GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static void glVertex4i(int x, int y, int z, int w) {
        var mh$ = glVertex4i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex4i", x, y, z, w);
            }
            mh$.invokeExact(x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex4iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex4iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertex4iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glVertex4iv$descriptor() {
        return glVertex4iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertex4iv(const GLint *v)
     * }
     */
    public static MethodHandle glVertex4iv$handle() {
        return glVertex4iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertex4iv(const GLint *v)
     * }
     */
    public static MemorySegment glVertex4iv$address() {
        return glVertex4iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertex4iv(const GLint *v)
     * }
     */
    public static void glVertex4iv(MemorySegment v) {
        var mh$ = glVertex4iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex4iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex4s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex4s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static FunctionDescriptor glVertex4s$descriptor() {
        return glVertex4s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static MethodHandle glVertex4s$handle() {
        return glVertex4s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static MemorySegment glVertex4s$address() {
        return glVertex4s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static void glVertex4s(short x, short y, short z, short w) {
        var mh$ = glVertex4s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex4s", x, y, z, w);
            }
            mh$.invokeExact(x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex4sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertex4sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertex4sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glVertex4sv$descriptor() {
        return glVertex4sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertex4sv(const GLshort *v)
     * }
     */
    public static MethodHandle glVertex4sv$handle() {
        return glVertex4sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertex4sv(const GLshort *v)
     * }
     */
    public static MemorySegment glVertex4sv$address() {
        return glVertex4sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertex4sv(const GLshort *v)
     * }
     */
    public static void glVertex4sv(MemorySegment v) {
        var mh$ = glVertex4sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex4sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static FunctionDescriptor glVertexPointer$descriptor() {
        return glVertexPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MethodHandle glVertexPointer$handle() {
        return glVertexPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MemorySegment glVertexPointer$address() {
        return glVertexPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static void glVertexPointer(int size, int type, int stride, MemorySegment pointer) {
        var mh$ = glVertexPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexPointer", size, type, stride, pointer);
            }
            mh$.invokeExact(size, type, stride, pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glViewport {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glViewport");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glViewport(GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static FunctionDescriptor glViewport$descriptor() {
        return glViewport.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glViewport(GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MethodHandle glViewport$handle() {
        return glViewport.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glViewport(GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MemorySegment glViewport$address() {
        return glViewport.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glViewport(GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static void glViewport(int x, int y, int width, int height) {
        var mh$ = glViewport.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glViewport", x, y, width, height);
            }
            mh$.invokeExact(x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSampleCoverage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glSampleCoverage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glSampleCoverage(GLclampf value, GLboolean invert)
     * }
     */
    public static FunctionDescriptor glSampleCoverage$descriptor() {
        return glSampleCoverage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glSampleCoverage(GLclampf value, GLboolean invert)
     * }
     */
    public static MethodHandle glSampleCoverage$handle() {
        return glSampleCoverage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glSampleCoverage(GLclampf value, GLboolean invert)
     * }
     */
    public static MemorySegment glSampleCoverage$address() {
        return glSampleCoverage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glSampleCoverage(GLclampf value, GLboolean invert)
     * }
     */
    public static void glSampleCoverage(float value, byte invert) {
        var mh$ = glSampleCoverage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSampleCoverage", value, invert);
            }
            mh$.invokeExact(value, invert);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLoadTransposeMatrixf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glLoadTransposeMatrixf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glLoadTransposeMatrixf(const GLfloat *m)
     * }
     */
    public static FunctionDescriptor glLoadTransposeMatrixf$descriptor() {
        return glLoadTransposeMatrixf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glLoadTransposeMatrixf(const GLfloat *m)
     * }
     */
    public static MethodHandle glLoadTransposeMatrixf$handle() {
        return glLoadTransposeMatrixf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glLoadTransposeMatrixf(const GLfloat *m)
     * }
     */
    public static MemorySegment glLoadTransposeMatrixf$address() {
        return glLoadTransposeMatrixf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glLoadTransposeMatrixf(const GLfloat *m)
     * }
     */
    public static void glLoadTransposeMatrixf(MemorySegment m) {
        var mh$ = glLoadTransposeMatrixf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLoadTransposeMatrixf", m);
            }
            mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLoadTransposeMatrixd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glLoadTransposeMatrixd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glLoadTransposeMatrixd(const GLdouble *m)
     * }
     */
    public static FunctionDescriptor glLoadTransposeMatrixd$descriptor() {
        return glLoadTransposeMatrixd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glLoadTransposeMatrixd(const GLdouble *m)
     * }
     */
    public static MethodHandle glLoadTransposeMatrixd$handle() {
        return glLoadTransposeMatrixd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glLoadTransposeMatrixd(const GLdouble *m)
     * }
     */
    public static MemorySegment glLoadTransposeMatrixd$address() {
        return glLoadTransposeMatrixd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glLoadTransposeMatrixd(const GLdouble *m)
     * }
     */
    public static void glLoadTransposeMatrixd(MemorySegment m) {
        var mh$ = glLoadTransposeMatrixd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLoadTransposeMatrixd", m);
            }
            mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultTransposeMatrixf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultTransposeMatrixf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultTransposeMatrixf(const GLfloat *m)
     * }
     */
    public static FunctionDescriptor glMultTransposeMatrixf$descriptor() {
        return glMultTransposeMatrixf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultTransposeMatrixf(const GLfloat *m)
     * }
     */
    public static MethodHandle glMultTransposeMatrixf$handle() {
        return glMultTransposeMatrixf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultTransposeMatrixf(const GLfloat *m)
     * }
     */
    public static MemorySegment glMultTransposeMatrixf$address() {
        return glMultTransposeMatrixf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultTransposeMatrixf(const GLfloat *m)
     * }
     */
    public static void glMultTransposeMatrixf(MemorySegment m) {
        var mh$ = glMultTransposeMatrixf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultTransposeMatrixf", m);
            }
            mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultTransposeMatrixd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultTransposeMatrixd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultTransposeMatrixd(const GLdouble *m)
     * }
     */
    public static FunctionDescriptor glMultTransposeMatrixd$descriptor() {
        return glMultTransposeMatrixd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultTransposeMatrixd(const GLdouble *m)
     * }
     */
    public static MethodHandle glMultTransposeMatrixd$handle() {
        return glMultTransposeMatrixd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultTransposeMatrixd(const GLdouble *m)
     * }
     */
    public static MemorySegment glMultTransposeMatrixd$address() {
        return glMultTransposeMatrixd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultTransposeMatrixd(const GLdouble *m)
     * }
     */
    public static void glMultTransposeMatrixd(MemorySegment m) {
        var mh$ = glMultTransposeMatrixd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultTransposeMatrixd", m);
            }
            mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCompressedTexImage3D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glCompressedTexImage3D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static FunctionDescriptor glCompressedTexImage3D$descriptor() {
        return glCompressedTexImage3D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MethodHandle glCompressedTexImage3D$handle() {
        return glCompressedTexImage3D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MemorySegment glCompressedTexImage3D$address() {
        return glCompressedTexImage3D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static void glCompressedTexImage3D(int target, int level, int internalformat, int width, int height, int depth, int border, int imageSize, MemorySegment data) {
        var mh$ = glCompressedTexImage3D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCompressedTexImage3D", target, level, internalformat, width, height, depth, border, imageSize, data);
            }
            mh$.invokeExact(target, level, internalformat, width, height, depth, border, imageSize, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCompressedTexImage2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glCompressedTexImage2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static FunctionDescriptor glCompressedTexImage2D$descriptor() {
        return glCompressedTexImage2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MethodHandle glCompressedTexImage2D$handle() {
        return glCompressedTexImage2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MemorySegment glCompressedTexImage2D$address() {
        return glCompressedTexImage2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static void glCompressedTexImage2D(int target, int level, int internalformat, int width, int height, int border, int imageSize, MemorySegment data) {
        var mh$ = glCompressedTexImage2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCompressedTexImage2D", target, level, internalformat, width, height, border, imageSize, data);
            }
            mh$.invokeExact(target, level, internalformat, width, height, border, imageSize, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCompressedTexImage1D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glCompressedTexImage1D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glCompressedTexImage1D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static FunctionDescriptor glCompressedTexImage1D$descriptor() {
        return glCompressedTexImage1D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glCompressedTexImage1D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MethodHandle glCompressedTexImage1D$handle() {
        return glCompressedTexImage1D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glCompressedTexImage1D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MemorySegment glCompressedTexImage1D$address() {
        return glCompressedTexImage1D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glCompressedTexImage1D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static void glCompressedTexImage1D(int target, int level, int internalformat, int width, int border, int imageSize, MemorySegment data) {
        var mh$ = glCompressedTexImage1D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCompressedTexImage1D", target, level, internalformat, width, border, imageSize, data);
            }
            mh$.invokeExact(target, level, internalformat, width, border, imageSize, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCompressedTexSubImage3D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glCompressedTexSubImage3D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static FunctionDescriptor glCompressedTexSubImage3D$descriptor() {
        return glCompressedTexSubImage3D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MethodHandle glCompressedTexSubImage3D$handle() {
        return glCompressedTexSubImage3D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MemorySegment glCompressedTexSubImage3D$address() {
        return glCompressedTexSubImage3D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static void glCompressedTexSubImage3D(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, MemorySegment data) {
        var mh$ = glCompressedTexSubImage3D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCompressedTexSubImage3D", target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
            }
            mh$.invokeExact(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCompressedTexSubImage2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glCompressedTexSubImage2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static FunctionDescriptor glCompressedTexSubImage2D$descriptor() {
        return glCompressedTexSubImage2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MethodHandle glCompressedTexSubImage2D$handle() {
        return glCompressedTexSubImage2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MemorySegment glCompressedTexSubImage2D$address() {
        return glCompressedTexSubImage2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static void glCompressedTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, MemorySegment data) {
        var mh$ = glCompressedTexSubImage2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCompressedTexSubImage2D", target, level, xoffset, yoffset, width, height, format, imageSize, data);
            }
            mh$.invokeExact(target, level, xoffset, yoffset, width, height, format, imageSize, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCompressedTexSubImage1D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glCompressedTexSubImage1D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glCompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static FunctionDescriptor glCompressedTexSubImage1D$descriptor() {
        return glCompressedTexSubImage1D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glCompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MethodHandle glCompressedTexSubImage1D$handle() {
        return glCompressedTexSubImage1D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glCompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MemorySegment glCompressedTexSubImage1D$address() {
        return glCompressedTexSubImage1D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glCompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static void glCompressedTexSubImage1D(int target, int level, int xoffset, int width, int format, int imageSize, MemorySegment data) {
        var mh$ = glCompressedTexSubImage1D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCompressedTexSubImage1D", target, level, xoffset, width, format, imageSize, data);
            }
            mh$.invokeExact(target, level, xoffset, width, format, imageSize, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetCompressedTexImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetCompressedTexImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetCompressedTexImage(GLenum target, GLint lod, GLvoid *img)
     * }
     */
    public static FunctionDescriptor glGetCompressedTexImage$descriptor() {
        return glGetCompressedTexImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetCompressedTexImage(GLenum target, GLint lod, GLvoid *img)
     * }
     */
    public static MethodHandle glGetCompressedTexImage$handle() {
        return glGetCompressedTexImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetCompressedTexImage(GLenum target, GLint lod, GLvoid *img)
     * }
     */
    public static MemorySegment glGetCompressedTexImage$address() {
        return glGetCompressedTexImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetCompressedTexImage(GLenum target, GLint lod, GLvoid *img)
     * }
     */
    public static void glGetCompressedTexImage(int target, int lod, MemorySegment img) {
        var mh$ = glGetCompressedTexImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetCompressedTexImage", target, lod, img);
            }
            mh$.invokeExact(target, lod, img);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glActiveTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glActiveTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glActiveTexture(GLenum texture)
     * }
     */
    public static FunctionDescriptor glActiveTexture$descriptor() {
        return glActiveTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glActiveTexture(GLenum texture)
     * }
     */
    public static MethodHandle glActiveTexture$handle() {
        return glActiveTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glActiveTexture(GLenum texture)
     * }
     */
    public static MemorySegment glActiveTexture$address() {
        return glActiveTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glActiveTexture(GLenum texture)
     * }
     */
    public static void glActiveTexture(int texture) {
        var mh$ = glActiveTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glActiveTexture", texture);
            }
            mh$.invokeExact(texture);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glClientActiveTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glClientActiveTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glClientActiveTexture(GLenum texture)
     * }
     */
    public static FunctionDescriptor glClientActiveTexture$descriptor() {
        return glClientActiveTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glClientActiveTexture(GLenum texture)
     * }
     */
    public static MethodHandle glClientActiveTexture$handle() {
        return glClientActiveTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glClientActiveTexture(GLenum texture)
     * }
     */
    public static MemorySegment glClientActiveTexture$address() {
        return glClientActiveTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glClientActiveTexture(GLenum texture)
     * }
     */
    public static void glClientActiveTexture(int texture) {
        var mh$ = glClientActiveTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClientActiveTexture", texture);
            }
            mh$.invokeExact(texture);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1d(GLenum target, GLdouble s)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1d$descriptor() {
        return glMultiTexCoord1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1d(GLenum target, GLdouble s)
     * }
     */
    public static MethodHandle glMultiTexCoord1d$handle() {
        return glMultiTexCoord1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1d(GLenum target, GLdouble s)
     * }
     */
    public static MemorySegment glMultiTexCoord1d$address() {
        return glMultiTexCoord1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord1d(GLenum target, GLdouble s)
     * }
     */
    public static void glMultiTexCoord1d(int target, double s) {
        var mh$ = glMultiTexCoord1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1d", target, s);
            }
            mh$.invokeExact(target, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord1dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1dv(GLenum target, const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1dv$descriptor() {
        return glMultiTexCoord1dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1dv(GLenum target, const GLdouble *v)
     * }
     */
    public static MethodHandle glMultiTexCoord1dv$handle() {
        return glMultiTexCoord1dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1dv(GLenum target, const GLdouble *v)
     * }
     */
    public static MemorySegment glMultiTexCoord1dv$address() {
        return glMultiTexCoord1dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord1dv(GLenum target, const GLdouble *v)
     * }
     */
    public static void glMultiTexCoord1dv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord1dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1dv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1f(GLenum target, GLfloat s)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1f$descriptor() {
        return glMultiTexCoord1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1f(GLenum target, GLfloat s)
     * }
     */
    public static MethodHandle glMultiTexCoord1f$handle() {
        return glMultiTexCoord1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1f(GLenum target, GLfloat s)
     * }
     */
    public static MemorySegment glMultiTexCoord1f$address() {
        return glMultiTexCoord1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord1f(GLenum target, GLfloat s)
     * }
     */
    public static void glMultiTexCoord1f(int target, float s) {
        var mh$ = glMultiTexCoord1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1f", target, s);
            }
            mh$.invokeExact(target, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord1fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1fv(GLenum target, const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1fv$descriptor() {
        return glMultiTexCoord1fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1fv(GLenum target, const GLfloat *v)
     * }
     */
    public static MethodHandle glMultiTexCoord1fv$handle() {
        return glMultiTexCoord1fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1fv(GLenum target, const GLfloat *v)
     * }
     */
    public static MemorySegment glMultiTexCoord1fv$address() {
        return glMultiTexCoord1fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord1fv(GLenum target, const GLfloat *v)
     * }
     */
    public static void glMultiTexCoord1fv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord1fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1fv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord1i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1i(GLenum target, GLint s)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1i$descriptor() {
        return glMultiTexCoord1i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1i(GLenum target, GLint s)
     * }
     */
    public static MethodHandle glMultiTexCoord1i$handle() {
        return glMultiTexCoord1i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1i(GLenum target, GLint s)
     * }
     */
    public static MemorySegment glMultiTexCoord1i$address() {
        return glMultiTexCoord1i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord1i(GLenum target, GLint s)
     * }
     */
    public static void glMultiTexCoord1i(int target, int s) {
        var mh$ = glMultiTexCoord1i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1i", target, s);
            }
            mh$.invokeExact(target, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord1iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1iv(GLenum target, const GLint *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1iv$descriptor() {
        return glMultiTexCoord1iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1iv(GLenum target, const GLint *v)
     * }
     */
    public static MethodHandle glMultiTexCoord1iv$handle() {
        return glMultiTexCoord1iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1iv(GLenum target, const GLint *v)
     * }
     */
    public static MemorySegment glMultiTexCoord1iv$address() {
        return glMultiTexCoord1iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord1iv(GLenum target, const GLint *v)
     * }
     */
    public static void glMultiTexCoord1iv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord1iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1iv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord1s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1s(GLenum target, GLshort s)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1s$descriptor() {
        return glMultiTexCoord1s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1s(GLenum target, GLshort s)
     * }
     */
    public static MethodHandle glMultiTexCoord1s$handle() {
        return glMultiTexCoord1s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1s(GLenum target, GLshort s)
     * }
     */
    public static MemorySegment glMultiTexCoord1s$address() {
        return glMultiTexCoord1s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord1s(GLenum target, GLshort s)
     * }
     */
    public static void glMultiTexCoord1s(int target, short s) {
        var mh$ = glMultiTexCoord1s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1s", target, s);
            }
            mh$.invokeExact(target, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord1sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1sv(GLenum target, const GLshort *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1sv$descriptor() {
        return glMultiTexCoord1sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1sv(GLenum target, const GLshort *v)
     * }
     */
    public static MethodHandle glMultiTexCoord1sv$handle() {
        return glMultiTexCoord1sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord1sv(GLenum target, const GLshort *v)
     * }
     */
    public static MemorySegment glMultiTexCoord1sv$address() {
        return glMultiTexCoord1sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord1sv(GLenum target, const GLshort *v)
     * }
     */
    public static void glMultiTexCoord1sv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord1sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1sv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2d(GLenum target, GLdouble s, GLdouble t)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2d$descriptor() {
        return glMultiTexCoord2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2d(GLenum target, GLdouble s, GLdouble t)
     * }
     */
    public static MethodHandle glMultiTexCoord2d$handle() {
        return glMultiTexCoord2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2d(GLenum target, GLdouble s, GLdouble t)
     * }
     */
    public static MemorySegment glMultiTexCoord2d$address() {
        return glMultiTexCoord2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord2d(GLenum target, GLdouble s, GLdouble t)
     * }
     */
    public static void glMultiTexCoord2d(int target, double s, double t) {
        var mh$ = glMultiTexCoord2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2d", target, s, t);
            }
            mh$.invokeExact(target, s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord2dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2dv(GLenum target, const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2dv$descriptor() {
        return glMultiTexCoord2dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2dv(GLenum target, const GLdouble *v)
     * }
     */
    public static MethodHandle glMultiTexCoord2dv$handle() {
        return glMultiTexCoord2dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2dv(GLenum target, const GLdouble *v)
     * }
     */
    public static MemorySegment glMultiTexCoord2dv$address() {
        return glMultiTexCoord2dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord2dv(GLenum target, const GLdouble *v)
     * }
     */
    public static void glMultiTexCoord2dv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord2dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2dv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2f(GLenum target, GLfloat s, GLfloat t)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2f$descriptor() {
        return glMultiTexCoord2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2f(GLenum target, GLfloat s, GLfloat t)
     * }
     */
    public static MethodHandle glMultiTexCoord2f$handle() {
        return glMultiTexCoord2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2f(GLenum target, GLfloat s, GLfloat t)
     * }
     */
    public static MemorySegment glMultiTexCoord2f$address() {
        return glMultiTexCoord2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord2f(GLenum target, GLfloat s, GLfloat t)
     * }
     */
    public static void glMultiTexCoord2f(int target, float s, float t) {
        var mh$ = glMultiTexCoord2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2f", target, s, t);
            }
            mh$.invokeExact(target, s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord2fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2fv(GLenum target, const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2fv$descriptor() {
        return glMultiTexCoord2fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2fv(GLenum target, const GLfloat *v)
     * }
     */
    public static MethodHandle glMultiTexCoord2fv$handle() {
        return glMultiTexCoord2fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2fv(GLenum target, const GLfloat *v)
     * }
     */
    public static MemorySegment glMultiTexCoord2fv$address() {
        return glMultiTexCoord2fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord2fv(GLenum target, const GLfloat *v)
     * }
     */
    public static void glMultiTexCoord2fv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord2fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2fv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord2i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2i(GLenum target, GLint s, GLint t)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2i$descriptor() {
        return glMultiTexCoord2i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2i(GLenum target, GLint s, GLint t)
     * }
     */
    public static MethodHandle glMultiTexCoord2i$handle() {
        return glMultiTexCoord2i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2i(GLenum target, GLint s, GLint t)
     * }
     */
    public static MemorySegment glMultiTexCoord2i$address() {
        return glMultiTexCoord2i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord2i(GLenum target, GLint s, GLint t)
     * }
     */
    public static void glMultiTexCoord2i(int target, int s, int t) {
        var mh$ = glMultiTexCoord2i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2i", target, s, t);
            }
            mh$.invokeExact(target, s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord2iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2iv(GLenum target, const GLint *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2iv$descriptor() {
        return glMultiTexCoord2iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2iv(GLenum target, const GLint *v)
     * }
     */
    public static MethodHandle glMultiTexCoord2iv$handle() {
        return glMultiTexCoord2iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2iv(GLenum target, const GLint *v)
     * }
     */
    public static MemorySegment glMultiTexCoord2iv$address() {
        return glMultiTexCoord2iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord2iv(GLenum target, const GLint *v)
     * }
     */
    public static void glMultiTexCoord2iv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord2iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2iv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord2s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2s(GLenum target, GLshort s, GLshort t)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2s$descriptor() {
        return glMultiTexCoord2s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2s(GLenum target, GLshort s, GLshort t)
     * }
     */
    public static MethodHandle glMultiTexCoord2s$handle() {
        return glMultiTexCoord2s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2s(GLenum target, GLshort s, GLshort t)
     * }
     */
    public static MemorySegment glMultiTexCoord2s$address() {
        return glMultiTexCoord2s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord2s(GLenum target, GLshort s, GLshort t)
     * }
     */
    public static void glMultiTexCoord2s(int target, short s, short t) {
        var mh$ = glMultiTexCoord2s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2s", target, s, t);
            }
            mh$.invokeExact(target, s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord2sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2sv(GLenum target, const GLshort *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2sv$descriptor() {
        return glMultiTexCoord2sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2sv(GLenum target, const GLshort *v)
     * }
     */
    public static MethodHandle glMultiTexCoord2sv$handle() {
        return glMultiTexCoord2sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord2sv(GLenum target, const GLshort *v)
     * }
     */
    public static MemorySegment glMultiTexCoord2sv$address() {
        return glMultiTexCoord2sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord2sv(GLenum target, const GLshort *v)
     * }
     */
    public static void glMultiTexCoord2sv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord2sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2sv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3d(GLenum target, GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3d$descriptor() {
        return glMultiTexCoord3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3d(GLenum target, GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static MethodHandle glMultiTexCoord3d$handle() {
        return glMultiTexCoord3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3d(GLenum target, GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static MemorySegment glMultiTexCoord3d$address() {
        return glMultiTexCoord3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord3d(GLenum target, GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static void glMultiTexCoord3d(int target, double s, double t, double r) {
        var mh$ = glMultiTexCoord3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3d", target, s, t, r);
            }
            mh$.invokeExact(target, s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord3dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3dv(GLenum target, const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3dv$descriptor() {
        return glMultiTexCoord3dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3dv(GLenum target, const GLdouble *v)
     * }
     */
    public static MethodHandle glMultiTexCoord3dv$handle() {
        return glMultiTexCoord3dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3dv(GLenum target, const GLdouble *v)
     * }
     */
    public static MemorySegment glMultiTexCoord3dv$address() {
        return glMultiTexCoord3dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord3dv(GLenum target, const GLdouble *v)
     * }
     */
    public static void glMultiTexCoord3dv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord3dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3dv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord3f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3f(GLenum target, GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3f$descriptor() {
        return glMultiTexCoord3f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3f(GLenum target, GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static MethodHandle glMultiTexCoord3f$handle() {
        return glMultiTexCoord3f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3f(GLenum target, GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static MemorySegment glMultiTexCoord3f$address() {
        return glMultiTexCoord3f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord3f(GLenum target, GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static void glMultiTexCoord3f(int target, float s, float t, float r) {
        var mh$ = glMultiTexCoord3f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3f", target, s, t, r);
            }
            mh$.invokeExact(target, s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord3fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3fv(GLenum target, const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3fv$descriptor() {
        return glMultiTexCoord3fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3fv(GLenum target, const GLfloat *v)
     * }
     */
    public static MethodHandle glMultiTexCoord3fv$handle() {
        return glMultiTexCoord3fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3fv(GLenum target, const GLfloat *v)
     * }
     */
    public static MemorySegment glMultiTexCoord3fv$address() {
        return glMultiTexCoord3fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord3fv(GLenum target, const GLfloat *v)
     * }
     */
    public static void glMultiTexCoord3fv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord3fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3fv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord3i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3i(GLenum target, GLint s, GLint t, GLint r)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3i$descriptor() {
        return glMultiTexCoord3i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3i(GLenum target, GLint s, GLint t, GLint r)
     * }
     */
    public static MethodHandle glMultiTexCoord3i$handle() {
        return glMultiTexCoord3i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3i(GLenum target, GLint s, GLint t, GLint r)
     * }
     */
    public static MemorySegment glMultiTexCoord3i$address() {
        return glMultiTexCoord3i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord3i(GLenum target, GLint s, GLint t, GLint r)
     * }
     */
    public static void glMultiTexCoord3i(int target, int s, int t, int r) {
        var mh$ = glMultiTexCoord3i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3i", target, s, t, r);
            }
            mh$.invokeExact(target, s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord3iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3iv(GLenum target, const GLint *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3iv$descriptor() {
        return glMultiTexCoord3iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3iv(GLenum target, const GLint *v)
     * }
     */
    public static MethodHandle glMultiTexCoord3iv$handle() {
        return glMultiTexCoord3iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3iv(GLenum target, const GLint *v)
     * }
     */
    public static MemorySegment glMultiTexCoord3iv$address() {
        return glMultiTexCoord3iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord3iv(GLenum target, const GLint *v)
     * }
     */
    public static void glMultiTexCoord3iv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord3iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3iv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord3s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3s(GLenum target, GLshort s, GLshort t, GLshort r)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3s$descriptor() {
        return glMultiTexCoord3s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3s(GLenum target, GLshort s, GLshort t, GLshort r)
     * }
     */
    public static MethodHandle glMultiTexCoord3s$handle() {
        return glMultiTexCoord3s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3s(GLenum target, GLshort s, GLshort t, GLshort r)
     * }
     */
    public static MemorySegment glMultiTexCoord3s$address() {
        return glMultiTexCoord3s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord3s(GLenum target, GLshort s, GLshort t, GLshort r)
     * }
     */
    public static void glMultiTexCoord3s(int target, short s, short t, short r) {
        var mh$ = glMultiTexCoord3s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3s", target, s, t, r);
            }
            mh$.invokeExact(target, s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord3sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3sv(GLenum target, const GLshort *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3sv$descriptor() {
        return glMultiTexCoord3sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3sv(GLenum target, const GLshort *v)
     * }
     */
    public static MethodHandle glMultiTexCoord3sv$handle() {
        return glMultiTexCoord3sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord3sv(GLenum target, const GLshort *v)
     * }
     */
    public static MemorySegment glMultiTexCoord3sv$address() {
        return glMultiTexCoord3sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord3sv(GLenum target, const GLshort *v)
     * }
     */
    public static void glMultiTexCoord3sv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord3sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3sv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord4d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4d(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4d$descriptor() {
        return glMultiTexCoord4d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4d(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static MethodHandle glMultiTexCoord4d$handle() {
        return glMultiTexCoord4d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4d(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static MemorySegment glMultiTexCoord4d$address() {
        return glMultiTexCoord4d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord4d(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static void glMultiTexCoord4d(int target, double s, double t, double r, double q) {
        var mh$ = glMultiTexCoord4d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4d", target, s, t, r, q);
            }
            mh$.invokeExact(target, s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord4dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4dv(GLenum target, const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4dv$descriptor() {
        return glMultiTexCoord4dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4dv(GLenum target, const GLdouble *v)
     * }
     */
    public static MethodHandle glMultiTexCoord4dv$handle() {
        return glMultiTexCoord4dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4dv(GLenum target, const GLdouble *v)
     * }
     */
    public static MemorySegment glMultiTexCoord4dv$address() {
        return glMultiTexCoord4dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord4dv(GLenum target, const GLdouble *v)
     * }
     */
    public static void glMultiTexCoord4dv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord4dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4dv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord4f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4f(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4f$descriptor() {
        return glMultiTexCoord4f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4f(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static MethodHandle glMultiTexCoord4f$handle() {
        return glMultiTexCoord4f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4f(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static MemorySegment glMultiTexCoord4f$address() {
        return glMultiTexCoord4f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord4f(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static void glMultiTexCoord4f(int target, float s, float t, float r, float q) {
        var mh$ = glMultiTexCoord4f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4f", target, s, t, r, q);
            }
            mh$.invokeExact(target, s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord4fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4fv(GLenum target, const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4fv$descriptor() {
        return glMultiTexCoord4fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4fv(GLenum target, const GLfloat *v)
     * }
     */
    public static MethodHandle glMultiTexCoord4fv$handle() {
        return glMultiTexCoord4fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4fv(GLenum target, const GLfloat *v)
     * }
     */
    public static MemorySegment glMultiTexCoord4fv$address() {
        return glMultiTexCoord4fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord4fv(GLenum target, const GLfloat *v)
     * }
     */
    public static void glMultiTexCoord4fv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord4fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4fv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord4i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4i(GLenum target, GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4i$descriptor() {
        return glMultiTexCoord4i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4i(GLenum target, GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static MethodHandle glMultiTexCoord4i$handle() {
        return glMultiTexCoord4i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4i(GLenum target, GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static MemorySegment glMultiTexCoord4i$address() {
        return glMultiTexCoord4i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord4i(GLenum target, GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static void glMultiTexCoord4i(int target, int s, int t, int r, int q) {
        var mh$ = glMultiTexCoord4i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4i", target, s, t, r, q);
            }
            mh$.invokeExact(target, s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord4iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4iv(GLenum target, const GLint *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4iv$descriptor() {
        return glMultiTexCoord4iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4iv(GLenum target, const GLint *v)
     * }
     */
    public static MethodHandle glMultiTexCoord4iv$handle() {
        return glMultiTexCoord4iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4iv(GLenum target, const GLint *v)
     * }
     */
    public static MemorySegment glMultiTexCoord4iv$address() {
        return glMultiTexCoord4iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord4iv(GLenum target, const GLint *v)
     * }
     */
    public static void glMultiTexCoord4iv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord4iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4iv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord4s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4s(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4s$descriptor() {
        return glMultiTexCoord4s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4s(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static MethodHandle glMultiTexCoord4s$handle() {
        return glMultiTexCoord4s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4s(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static MemorySegment glMultiTexCoord4s$address() {
        return glMultiTexCoord4s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord4s(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static void glMultiTexCoord4s(int target, short s, short t, short r, short q) {
        var mh$ = glMultiTexCoord4s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4s", target, s, t, r, q);
            }
            mh$.invokeExact(target, s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiTexCoord4sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4sv(GLenum target, const GLshort *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4sv$descriptor() {
        return glMultiTexCoord4sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4sv(GLenum target, const GLshort *v)
     * }
     */
    public static MethodHandle glMultiTexCoord4sv$handle() {
        return glMultiTexCoord4sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiTexCoord4sv(GLenum target, const GLshort *v)
     * }
     */
    public static MemorySegment glMultiTexCoord4sv$address() {
        return glMultiTexCoord4sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiTexCoord4sv(GLenum target, const GLshort *v)
     * }
     */
    public static void glMultiTexCoord4sv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord4sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4sv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFogCoordf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFogCoordf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glFogCoordf(GLfloat coord)
     * }
     */
    public static FunctionDescriptor glFogCoordf$descriptor() {
        return glFogCoordf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glFogCoordf(GLfloat coord)
     * }
     */
    public static MethodHandle glFogCoordf$handle() {
        return glFogCoordf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glFogCoordf(GLfloat coord)
     * }
     */
    public static MemorySegment glFogCoordf$address() {
        return glFogCoordf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glFogCoordf(GLfloat coord)
     * }
     */
    public static void glFogCoordf(float coord) {
        var mh$ = glFogCoordf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFogCoordf", coord);
            }
            mh$.invokeExact(coord);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFogCoordfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFogCoordfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glFogCoordfv(const GLfloat *coord)
     * }
     */
    public static FunctionDescriptor glFogCoordfv$descriptor() {
        return glFogCoordfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glFogCoordfv(const GLfloat *coord)
     * }
     */
    public static MethodHandle glFogCoordfv$handle() {
        return glFogCoordfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glFogCoordfv(const GLfloat *coord)
     * }
     */
    public static MemorySegment glFogCoordfv$address() {
        return glFogCoordfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glFogCoordfv(const GLfloat *coord)
     * }
     */
    public static void glFogCoordfv(MemorySegment coord) {
        var mh$ = glFogCoordfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFogCoordfv", coord);
            }
            mh$.invokeExact(coord);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFogCoordd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFogCoordd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glFogCoordd(GLdouble coord)
     * }
     */
    public static FunctionDescriptor glFogCoordd$descriptor() {
        return glFogCoordd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glFogCoordd(GLdouble coord)
     * }
     */
    public static MethodHandle glFogCoordd$handle() {
        return glFogCoordd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glFogCoordd(GLdouble coord)
     * }
     */
    public static MemorySegment glFogCoordd$address() {
        return glFogCoordd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glFogCoordd(GLdouble coord)
     * }
     */
    public static void glFogCoordd(double coord) {
        var mh$ = glFogCoordd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFogCoordd", coord);
            }
            mh$.invokeExact(coord);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFogCoorddv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFogCoorddv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glFogCoorddv(const GLdouble *coord)
     * }
     */
    public static FunctionDescriptor glFogCoorddv$descriptor() {
        return glFogCoorddv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glFogCoorddv(const GLdouble *coord)
     * }
     */
    public static MethodHandle glFogCoorddv$handle() {
        return glFogCoorddv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glFogCoorddv(const GLdouble *coord)
     * }
     */
    public static MemorySegment glFogCoorddv$address() {
        return glFogCoorddv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glFogCoorddv(const GLdouble *coord)
     * }
     */
    public static void glFogCoorddv(MemorySegment coord) {
        var mh$ = glFogCoorddv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFogCoorddv", coord);
            }
            mh$.invokeExact(coord);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFogCoordPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glFogCoordPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glFogCoordPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static FunctionDescriptor glFogCoordPointer$descriptor() {
        return glFogCoordPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glFogCoordPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MethodHandle glFogCoordPointer$handle() {
        return glFogCoordPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glFogCoordPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MemorySegment glFogCoordPointer$address() {
        return glFogCoordPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glFogCoordPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static void glFogCoordPointer(int type, int stride, MemorySegment pointer) {
        var mh$ = glFogCoordPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFogCoordPointer", type, stride, pointer);
            }
            mh$.invokeExact(type, stride, pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSecondaryColor3b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glSecondaryColor3b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3b(GLbyte red, GLbyte green, GLbyte blue)
     * }
     */
    public static FunctionDescriptor glSecondaryColor3b$descriptor() {
        return glSecondaryColor3b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3b(GLbyte red, GLbyte green, GLbyte blue)
     * }
     */
    public static MethodHandle glSecondaryColor3b$handle() {
        return glSecondaryColor3b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3b(GLbyte red, GLbyte green, GLbyte blue)
     * }
     */
    public static MemorySegment glSecondaryColor3b$address() {
        return glSecondaryColor3b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glSecondaryColor3b(GLbyte red, GLbyte green, GLbyte blue)
     * }
     */
    public static void glSecondaryColor3b(byte red, byte green, byte blue) {
        var mh$ = glSecondaryColor3b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSecondaryColor3b", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSecondaryColor3bv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glSecondaryColor3bv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3bv(const GLbyte *v)
     * }
     */
    public static FunctionDescriptor glSecondaryColor3bv$descriptor() {
        return glSecondaryColor3bv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3bv(const GLbyte *v)
     * }
     */
    public static MethodHandle glSecondaryColor3bv$handle() {
        return glSecondaryColor3bv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3bv(const GLbyte *v)
     * }
     */
    public static MemorySegment glSecondaryColor3bv$address() {
        return glSecondaryColor3bv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glSecondaryColor3bv(const GLbyte *v)
     * }
     */
    public static void glSecondaryColor3bv(MemorySegment v) {
        var mh$ = glSecondaryColor3bv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSecondaryColor3bv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSecondaryColor3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glSecondaryColor3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3d(GLdouble red, GLdouble green, GLdouble blue)
     * }
     */
    public static FunctionDescriptor glSecondaryColor3d$descriptor() {
        return glSecondaryColor3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3d(GLdouble red, GLdouble green, GLdouble blue)
     * }
     */
    public static MethodHandle glSecondaryColor3d$handle() {
        return glSecondaryColor3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3d(GLdouble red, GLdouble green, GLdouble blue)
     * }
     */
    public static MemorySegment glSecondaryColor3d$address() {
        return glSecondaryColor3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glSecondaryColor3d(GLdouble red, GLdouble green, GLdouble blue)
     * }
     */
    public static void glSecondaryColor3d(double red, double green, double blue) {
        var mh$ = glSecondaryColor3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSecondaryColor3d", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSecondaryColor3dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glSecondaryColor3dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glSecondaryColor3dv$descriptor() {
        return glSecondaryColor3dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glSecondaryColor3dv$handle() {
        return glSecondaryColor3dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glSecondaryColor3dv$address() {
        return glSecondaryColor3dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glSecondaryColor3dv(const GLdouble *v)
     * }
     */
    public static void glSecondaryColor3dv(MemorySegment v) {
        var mh$ = glSecondaryColor3dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSecondaryColor3dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSecondaryColor3f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glSecondaryColor3f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3f(GLfloat red, GLfloat green, GLfloat blue)
     * }
     */
    public static FunctionDescriptor glSecondaryColor3f$descriptor() {
        return glSecondaryColor3f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3f(GLfloat red, GLfloat green, GLfloat blue)
     * }
     */
    public static MethodHandle glSecondaryColor3f$handle() {
        return glSecondaryColor3f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3f(GLfloat red, GLfloat green, GLfloat blue)
     * }
     */
    public static MemorySegment glSecondaryColor3f$address() {
        return glSecondaryColor3f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glSecondaryColor3f(GLfloat red, GLfloat green, GLfloat blue)
     * }
     */
    public static void glSecondaryColor3f(float red, float green, float blue) {
        var mh$ = glSecondaryColor3f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSecondaryColor3f", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSecondaryColor3fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glSecondaryColor3fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glSecondaryColor3fv$descriptor() {
        return glSecondaryColor3fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glSecondaryColor3fv$handle() {
        return glSecondaryColor3fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glSecondaryColor3fv$address() {
        return glSecondaryColor3fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glSecondaryColor3fv(const GLfloat *v)
     * }
     */
    public static void glSecondaryColor3fv(MemorySegment v) {
        var mh$ = glSecondaryColor3fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSecondaryColor3fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSecondaryColor3i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glSecondaryColor3i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3i(GLint red, GLint green, GLint blue)
     * }
     */
    public static FunctionDescriptor glSecondaryColor3i$descriptor() {
        return glSecondaryColor3i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3i(GLint red, GLint green, GLint blue)
     * }
     */
    public static MethodHandle glSecondaryColor3i$handle() {
        return glSecondaryColor3i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3i(GLint red, GLint green, GLint blue)
     * }
     */
    public static MemorySegment glSecondaryColor3i$address() {
        return glSecondaryColor3i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glSecondaryColor3i(GLint red, GLint green, GLint blue)
     * }
     */
    public static void glSecondaryColor3i(int red, int green, int blue) {
        var mh$ = glSecondaryColor3i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSecondaryColor3i", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSecondaryColor3iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glSecondaryColor3iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glSecondaryColor3iv$descriptor() {
        return glSecondaryColor3iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3iv(const GLint *v)
     * }
     */
    public static MethodHandle glSecondaryColor3iv$handle() {
        return glSecondaryColor3iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3iv(const GLint *v)
     * }
     */
    public static MemorySegment glSecondaryColor3iv$address() {
        return glSecondaryColor3iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glSecondaryColor3iv(const GLint *v)
     * }
     */
    public static void glSecondaryColor3iv(MemorySegment v) {
        var mh$ = glSecondaryColor3iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSecondaryColor3iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSecondaryColor3s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glSecondaryColor3s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3s(GLshort red, GLshort green, GLshort blue)
     * }
     */
    public static FunctionDescriptor glSecondaryColor3s$descriptor() {
        return glSecondaryColor3s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3s(GLshort red, GLshort green, GLshort blue)
     * }
     */
    public static MethodHandle glSecondaryColor3s$handle() {
        return glSecondaryColor3s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3s(GLshort red, GLshort green, GLshort blue)
     * }
     */
    public static MemorySegment glSecondaryColor3s$address() {
        return glSecondaryColor3s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glSecondaryColor3s(GLshort red, GLshort green, GLshort blue)
     * }
     */
    public static void glSecondaryColor3s(short red, short green, short blue) {
        var mh$ = glSecondaryColor3s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSecondaryColor3s", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSecondaryColor3sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glSecondaryColor3sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glSecondaryColor3sv$descriptor() {
        return glSecondaryColor3sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3sv(const GLshort *v)
     * }
     */
    public static MethodHandle glSecondaryColor3sv$handle() {
        return glSecondaryColor3sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3sv(const GLshort *v)
     * }
     */
    public static MemorySegment glSecondaryColor3sv$address() {
        return glSecondaryColor3sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glSecondaryColor3sv(const GLshort *v)
     * }
     */
    public static void glSecondaryColor3sv(MemorySegment v) {
        var mh$ = glSecondaryColor3sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSecondaryColor3sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSecondaryColor3ub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glSecondaryColor3ub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3ub(GLubyte red, GLubyte green, GLubyte blue)
     * }
     */
    public static FunctionDescriptor glSecondaryColor3ub$descriptor() {
        return glSecondaryColor3ub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3ub(GLubyte red, GLubyte green, GLubyte blue)
     * }
     */
    public static MethodHandle glSecondaryColor3ub$handle() {
        return glSecondaryColor3ub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3ub(GLubyte red, GLubyte green, GLubyte blue)
     * }
     */
    public static MemorySegment glSecondaryColor3ub$address() {
        return glSecondaryColor3ub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glSecondaryColor3ub(GLubyte red, GLubyte green, GLubyte blue)
     * }
     */
    public static void glSecondaryColor3ub(byte red, byte green, byte blue) {
        var mh$ = glSecondaryColor3ub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSecondaryColor3ub", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSecondaryColor3ubv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glSecondaryColor3ubv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3ubv(const GLubyte *v)
     * }
     */
    public static FunctionDescriptor glSecondaryColor3ubv$descriptor() {
        return glSecondaryColor3ubv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3ubv(const GLubyte *v)
     * }
     */
    public static MethodHandle glSecondaryColor3ubv$handle() {
        return glSecondaryColor3ubv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3ubv(const GLubyte *v)
     * }
     */
    public static MemorySegment glSecondaryColor3ubv$address() {
        return glSecondaryColor3ubv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glSecondaryColor3ubv(const GLubyte *v)
     * }
     */
    public static void glSecondaryColor3ubv(MemorySegment v) {
        var mh$ = glSecondaryColor3ubv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSecondaryColor3ubv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSecondaryColor3ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glSecondaryColor3ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3ui(GLuint red, GLuint green, GLuint blue)
     * }
     */
    public static FunctionDescriptor glSecondaryColor3ui$descriptor() {
        return glSecondaryColor3ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3ui(GLuint red, GLuint green, GLuint blue)
     * }
     */
    public static MethodHandle glSecondaryColor3ui$handle() {
        return glSecondaryColor3ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3ui(GLuint red, GLuint green, GLuint blue)
     * }
     */
    public static MemorySegment glSecondaryColor3ui$address() {
        return glSecondaryColor3ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glSecondaryColor3ui(GLuint red, GLuint green, GLuint blue)
     * }
     */
    public static void glSecondaryColor3ui(int red, int green, int blue) {
        var mh$ = glSecondaryColor3ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSecondaryColor3ui", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSecondaryColor3uiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glSecondaryColor3uiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3uiv(const GLuint *v)
     * }
     */
    public static FunctionDescriptor glSecondaryColor3uiv$descriptor() {
        return glSecondaryColor3uiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3uiv(const GLuint *v)
     * }
     */
    public static MethodHandle glSecondaryColor3uiv$handle() {
        return glSecondaryColor3uiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3uiv(const GLuint *v)
     * }
     */
    public static MemorySegment glSecondaryColor3uiv$address() {
        return glSecondaryColor3uiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glSecondaryColor3uiv(const GLuint *v)
     * }
     */
    public static void glSecondaryColor3uiv(MemorySegment v) {
        var mh$ = glSecondaryColor3uiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSecondaryColor3uiv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSecondaryColor3us {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glSecondaryColor3us");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3us(GLushort red, GLushort green, GLushort blue)
     * }
     */
    public static FunctionDescriptor glSecondaryColor3us$descriptor() {
        return glSecondaryColor3us.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3us(GLushort red, GLushort green, GLushort blue)
     * }
     */
    public static MethodHandle glSecondaryColor3us$handle() {
        return glSecondaryColor3us.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3us(GLushort red, GLushort green, GLushort blue)
     * }
     */
    public static MemorySegment glSecondaryColor3us$address() {
        return glSecondaryColor3us.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glSecondaryColor3us(GLushort red, GLushort green, GLushort blue)
     * }
     */
    public static void glSecondaryColor3us(short red, short green, short blue) {
        var mh$ = glSecondaryColor3us.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSecondaryColor3us", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSecondaryColor3usv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glSecondaryColor3usv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3usv(const GLushort *v)
     * }
     */
    public static FunctionDescriptor glSecondaryColor3usv$descriptor() {
        return glSecondaryColor3usv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3usv(const GLushort *v)
     * }
     */
    public static MethodHandle glSecondaryColor3usv$handle() {
        return glSecondaryColor3usv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glSecondaryColor3usv(const GLushort *v)
     * }
     */
    public static MemorySegment glSecondaryColor3usv$address() {
        return glSecondaryColor3usv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glSecondaryColor3usv(const GLushort *v)
     * }
     */
    public static void glSecondaryColor3usv(MemorySegment v) {
        var mh$ = glSecondaryColor3usv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSecondaryColor3usv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSecondaryColorPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glSecondaryColorPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glSecondaryColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static FunctionDescriptor glSecondaryColorPointer$descriptor() {
        return glSecondaryColorPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glSecondaryColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MethodHandle glSecondaryColorPointer$handle() {
        return glSecondaryColorPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glSecondaryColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MemorySegment glSecondaryColorPointer$address() {
        return glSecondaryColorPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glSecondaryColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static void glSecondaryColorPointer(int size, int type, int stride, MemorySegment pointer) {
        var mh$ = glSecondaryColorPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSecondaryColorPointer", size, type, stride, pointer);
            }
            mh$.invokeExact(size, type, stride, pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPointParameterf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPointParameterf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glPointParameterf(GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glPointParameterf$descriptor() {
        return glPointParameterf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glPointParameterf(GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glPointParameterf$handle() {
        return glPointParameterf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glPointParameterf(GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glPointParameterf$address() {
        return glPointParameterf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glPointParameterf(GLenum pname, GLfloat param)
     * }
     */
    public static void glPointParameterf(int pname, float param) {
        var mh$ = glPointParameterf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPointParameterf", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPointParameterfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPointParameterfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glPointParameterfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glPointParameterfv$descriptor() {
        return glPointParameterfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glPointParameterfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glPointParameterfv$handle() {
        return glPointParameterfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glPointParameterfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glPointParameterfv$address() {
        return glPointParameterfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glPointParameterfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static void glPointParameterfv(int pname, MemorySegment params) {
        var mh$ = glPointParameterfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPointParameterfv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPointParameteri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPointParameteri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glPointParameteri(GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glPointParameteri$descriptor() {
        return glPointParameteri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glPointParameteri(GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glPointParameteri$handle() {
        return glPointParameteri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glPointParameteri(GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glPointParameteri$address() {
        return glPointParameteri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glPointParameteri(GLenum pname, GLint param)
     * }
     */
    public static void glPointParameteri(int pname, int param) {
        var mh$ = glPointParameteri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPointParameteri", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPointParameteriv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glPointParameteriv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glPointParameteriv(GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glPointParameteriv$descriptor() {
        return glPointParameteriv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glPointParameteriv(GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glPointParameteriv$handle() {
        return glPointParameteriv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glPointParameteriv(GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glPointParameteriv$address() {
        return glPointParameteriv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glPointParameteriv(GLenum pname, const GLint *params)
     * }
     */
    public static void glPointParameteriv(int pname, MemorySegment params) {
        var mh$ = glPointParameteriv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPointParameteriv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBlendFuncSeparate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glBlendFuncSeparate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glBlendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
     * }
     */
    public static FunctionDescriptor glBlendFuncSeparate$descriptor() {
        return glBlendFuncSeparate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glBlendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
     * }
     */
    public static MethodHandle glBlendFuncSeparate$handle() {
        return glBlendFuncSeparate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glBlendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
     * }
     */
    public static MemorySegment glBlendFuncSeparate$address() {
        return glBlendFuncSeparate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glBlendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
     * }
     */
    public static void glBlendFuncSeparate(int srcRGB, int dstRGB, int srcAlpha, int dstAlpha) {
        var mh$ = glBlendFuncSeparate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBlendFuncSeparate", srcRGB, dstRGB, srcAlpha, dstAlpha);
            }
            mh$.invokeExact(srcRGB, dstRGB, srcAlpha, dstAlpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiDrawArrays {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiDrawArrays");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiDrawArrays(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount)
     * }
     */
    public static FunctionDescriptor glMultiDrawArrays$descriptor() {
        return glMultiDrawArrays.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiDrawArrays(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount)
     * }
     */
    public static MethodHandle glMultiDrawArrays$handle() {
        return glMultiDrawArrays.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiDrawArrays(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount)
     * }
     */
    public static MemorySegment glMultiDrawArrays$address() {
        return glMultiDrawArrays.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiDrawArrays(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount)
     * }
     */
    public static void glMultiDrawArrays(int mode, MemorySegment first, MemorySegment count, int primcount) {
        var mh$ = glMultiDrawArrays.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiDrawArrays", mode, first, count, primcount);
            }
            mh$.invokeExact(mode, first, count, primcount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiDrawElements {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMultiDrawElements");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glMultiDrawElements(GLenum mode, const GLsizei *count, GLenum type, const GLvoid *const *indices, GLsizei primcount)
     * }
     */
    public static FunctionDescriptor glMultiDrawElements$descriptor() {
        return glMultiDrawElements.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glMultiDrawElements(GLenum mode, const GLsizei *count, GLenum type, const GLvoid *const *indices, GLsizei primcount)
     * }
     */
    public static MethodHandle glMultiDrawElements$handle() {
        return glMultiDrawElements.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glMultiDrawElements(GLenum mode, const GLsizei *count, GLenum type, const GLvoid *const *indices, GLsizei primcount)
     * }
     */
    public static MemorySegment glMultiDrawElements$address() {
        return glMultiDrawElements.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glMultiDrawElements(GLenum mode, const GLsizei *count, GLenum type, const GLvoid *const *indices, GLsizei primcount)
     * }
     */
    public static void glMultiDrawElements(int mode, MemorySegment count, int type, MemorySegment indices, int primcount) {
        var mh$ = glMultiDrawElements.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiDrawElements", mode, count, type, indices, primcount);
            }
            mh$.invokeExact(mode, count, type, indices, primcount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glWindowPos2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glWindowPos2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glWindowPos2d(GLdouble x, GLdouble y)
     * }
     */
    public static FunctionDescriptor glWindowPos2d$descriptor() {
        return glWindowPos2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glWindowPos2d(GLdouble x, GLdouble y)
     * }
     */
    public static MethodHandle glWindowPos2d$handle() {
        return glWindowPos2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glWindowPos2d(GLdouble x, GLdouble y)
     * }
     */
    public static MemorySegment glWindowPos2d$address() {
        return glWindowPos2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glWindowPos2d(GLdouble x, GLdouble y)
     * }
     */
    public static void glWindowPos2d(double x, double y) {
        var mh$ = glWindowPos2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glWindowPos2d", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glWindowPos2dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glWindowPos2dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glWindowPos2dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glWindowPos2dv$descriptor() {
        return glWindowPos2dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glWindowPos2dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glWindowPos2dv$handle() {
        return glWindowPos2dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glWindowPos2dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glWindowPos2dv$address() {
        return glWindowPos2dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glWindowPos2dv(const GLdouble *v)
     * }
     */
    public static void glWindowPos2dv(MemorySegment v) {
        var mh$ = glWindowPos2dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glWindowPos2dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glWindowPos2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glWindowPos2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glWindowPos2f(GLfloat x, GLfloat y)
     * }
     */
    public static FunctionDescriptor glWindowPos2f$descriptor() {
        return glWindowPos2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glWindowPos2f(GLfloat x, GLfloat y)
     * }
     */
    public static MethodHandle glWindowPos2f$handle() {
        return glWindowPos2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glWindowPos2f(GLfloat x, GLfloat y)
     * }
     */
    public static MemorySegment glWindowPos2f$address() {
        return glWindowPos2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glWindowPos2f(GLfloat x, GLfloat y)
     * }
     */
    public static void glWindowPos2f(float x, float y) {
        var mh$ = glWindowPos2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glWindowPos2f", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glWindowPos2fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glWindowPos2fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glWindowPos2fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glWindowPos2fv$descriptor() {
        return glWindowPos2fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glWindowPos2fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glWindowPos2fv$handle() {
        return glWindowPos2fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glWindowPos2fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glWindowPos2fv$address() {
        return glWindowPos2fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glWindowPos2fv(const GLfloat *v)
     * }
     */
    public static void glWindowPos2fv(MemorySegment v) {
        var mh$ = glWindowPos2fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glWindowPos2fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glWindowPos2i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glWindowPos2i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glWindowPos2i(GLint x, GLint y)
     * }
     */
    public static FunctionDescriptor glWindowPos2i$descriptor() {
        return glWindowPos2i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glWindowPos2i(GLint x, GLint y)
     * }
     */
    public static MethodHandle glWindowPos2i$handle() {
        return glWindowPos2i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glWindowPos2i(GLint x, GLint y)
     * }
     */
    public static MemorySegment glWindowPos2i$address() {
        return glWindowPos2i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glWindowPos2i(GLint x, GLint y)
     * }
     */
    public static void glWindowPos2i(int x, int y) {
        var mh$ = glWindowPos2i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glWindowPos2i", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glWindowPos2iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glWindowPos2iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glWindowPos2iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glWindowPos2iv$descriptor() {
        return glWindowPos2iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glWindowPos2iv(const GLint *v)
     * }
     */
    public static MethodHandle glWindowPos2iv$handle() {
        return glWindowPos2iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glWindowPos2iv(const GLint *v)
     * }
     */
    public static MemorySegment glWindowPos2iv$address() {
        return glWindowPos2iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glWindowPos2iv(const GLint *v)
     * }
     */
    public static void glWindowPos2iv(MemorySegment v) {
        var mh$ = glWindowPos2iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glWindowPos2iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glWindowPos2s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glWindowPos2s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glWindowPos2s(GLshort x, GLshort y)
     * }
     */
    public static FunctionDescriptor glWindowPos2s$descriptor() {
        return glWindowPos2s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glWindowPos2s(GLshort x, GLshort y)
     * }
     */
    public static MethodHandle glWindowPos2s$handle() {
        return glWindowPos2s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glWindowPos2s(GLshort x, GLshort y)
     * }
     */
    public static MemorySegment glWindowPos2s$address() {
        return glWindowPos2s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glWindowPos2s(GLshort x, GLshort y)
     * }
     */
    public static void glWindowPos2s(short x, short y) {
        var mh$ = glWindowPos2s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glWindowPos2s", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glWindowPos2sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glWindowPos2sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glWindowPos2sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glWindowPos2sv$descriptor() {
        return glWindowPos2sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glWindowPos2sv(const GLshort *v)
     * }
     */
    public static MethodHandle glWindowPos2sv$handle() {
        return glWindowPos2sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glWindowPos2sv(const GLshort *v)
     * }
     */
    public static MemorySegment glWindowPos2sv$address() {
        return glWindowPos2sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glWindowPos2sv(const GLshort *v)
     * }
     */
    public static void glWindowPos2sv(MemorySegment v) {
        var mh$ = glWindowPos2sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glWindowPos2sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glWindowPos3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glWindowPos3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glWindowPos3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static FunctionDescriptor glWindowPos3d$descriptor() {
        return glWindowPos3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glWindowPos3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MethodHandle glWindowPos3d$handle() {
        return glWindowPos3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glWindowPos3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MemorySegment glWindowPos3d$address() {
        return glWindowPos3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glWindowPos3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static void glWindowPos3d(double x, double y, double z) {
        var mh$ = glWindowPos3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glWindowPos3d", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glWindowPos3dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glWindowPos3dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glWindowPos3dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glWindowPos3dv$descriptor() {
        return glWindowPos3dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glWindowPos3dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glWindowPos3dv$handle() {
        return glWindowPos3dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glWindowPos3dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glWindowPos3dv$address() {
        return glWindowPos3dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glWindowPos3dv(const GLdouble *v)
     * }
     */
    public static void glWindowPos3dv(MemorySegment v) {
        var mh$ = glWindowPos3dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glWindowPos3dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glWindowPos3f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glWindowPos3f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glWindowPos3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static FunctionDescriptor glWindowPos3f$descriptor() {
        return glWindowPos3f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glWindowPos3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MethodHandle glWindowPos3f$handle() {
        return glWindowPos3f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glWindowPos3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MemorySegment glWindowPos3f$address() {
        return glWindowPos3f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glWindowPos3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static void glWindowPos3f(float x, float y, float z) {
        var mh$ = glWindowPos3f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glWindowPos3f", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glWindowPos3fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glWindowPos3fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glWindowPos3fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glWindowPos3fv$descriptor() {
        return glWindowPos3fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glWindowPos3fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glWindowPos3fv$handle() {
        return glWindowPos3fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glWindowPos3fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glWindowPos3fv$address() {
        return glWindowPos3fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glWindowPos3fv(const GLfloat *v)
     * }
     */
    public static void glWindowPos3fv(MemorySegment v) {
        var mh$ = glWindowPos3fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glWindowPos3fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glWindowPos3i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glWindowPos3i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glWindowPos3i(GLint x, GLint y, GLint z)
     * }
     */
    public static FunctionDescriptor glWindowPos3i$descriptor() {
        return glWindowPos3i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glWindowPos3i(GLint x, GLint y, GLint z)
     * }
     */
    public static MethodHandle glWindowPos3i$handle() {
        return glWindowPos3i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glWindowPos3i(GLint x, GLint y, GLint z)
     * }
     */
    public static MemorySegment glWindowPos3i$address() {
        return glWindowPos3i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glWindowPos3i(GLint x, GLint y, GLint z)
     * }
     */
    public static void glWindowPos3i(int x, int y, int z) {
        var mh$ = glWindowPos3i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glWindowPos3i", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glWindowPos3iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glWindowPos3iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glWindowPos3iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glWindowPos3iv$descriptor() {
        return glWindowPos3iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glWindowPos3iv(const GLint *v)
     * }
     */
    public static MethodHandle glWindowPos3iv$handle() {
        return glWindowPos3iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glWindowPos3iv(const GLint *v)
     * }
     */
    public static MemorySegment glWindowPos3iv$address() {
        return glWindowPos3iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glWindowPos3iv(const GLint *v)
     * }
     */
    public static void glWindowPos3iv(MemorySegment v) {
        var mh$ = glWindowPos3iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glWindowPos3iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glWindowPos3s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glWindowPos3s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glWindowPos3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static FunctionDescriptor glWindowPos3s$descriptor() {
        return glWindowPos3s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glWindowPos3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static MethodHandle glWindowPos3s$handle() {
        return glWindowPos3s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glWindowPos3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static MemorySegment glWindowPos3s$address() {
        return glWindowPos3s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glWindowPos3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static void glWindowPos3s(short x, short y, short z) {
        var mh$ = glWindowPos3s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glWindowPos3s", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glWindowPos3sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glWindowPos3sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glWindowPos3sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glWindowPos3sv$descriptor() {
        return glWindowPos3sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glWindowPos3sv(const GLshort *v)
     * }
     */
    public static MethodHandle glWindowPos3sv$handle() {
        return glWindowPos3sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glWindowPos3sv(const GLshort *v)
     * }
     */
    public static MemorySegment glWindowPos3sv$address() {
        return glWindowPos3sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glWindowPos3sv(const GLshort *v)
     * }
     */
    public static void glWindowPos3sv(MemorySegment v) {
        var mh$ = glWindowPos3sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glWindowPos3sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGenQueries {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGenQueries");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGenQueries(GLsizei n, GLuint *ids)
     * }
     */
    public static FunctionDescriptor glGenQueries$descriptor() {
        return glGenQueries.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGenQueries(GLsizei n, GLuint *ids)
     * }
     */
    public static MethodHandle glGenQueries$handle() {
        return glGenQueries.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGenQueries(GLsizei n, GLuint *ids)
     * }
     */
    public static MemorySegment glGenQueries$address() {
        return glGenQueries.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGenQueries(GLsizei n, GLuint *ids)
     * }
     */
    public static void glGenQueries(int n, MemorySegment ids) {
        var mh$ = glGenQueries.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGenQueries", n, ids);
            }
            mh$.invokeExact(n, ids);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDeleteQueries {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDeleteQueries");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glDeleteQueries(GLsizei n, const GLuint *ids)
     * }
     */
    public static FunctionDescriptor glDeleteQueries$descriptor() {
        return glDeleteQueries.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glDeleteQueries(GLsizei n, const GLuint *ids)
     * }
     */
    public static MethodHandle glDeleteQueries$handle() {
        return glDeleteQueries.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glDeleteQueries(GLsizei n, const GLuint *ids)
     * }
     */
    public static MemorySegment glDeleteQueries$address() {
        return glDeleteQueries.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glDeleteQueries(GLsizei n, const GLuint *ids)
     * }
     */
    public static void glDeleteQueries(int n, MemorySegment ids) {
        var mh$ = glDeleteQueries.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDeleteQueries", n, ids);
            }
            mh$.invokeExact(n, ids);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIsQuery {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glIsQuery");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLboolean glIsQuery(GLuint id)
     * }
     */
    public static FunctionDescriptor glIsQuery$descriptor() {
        return glIsQuery.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLboolean glIsQuery(GLuint id)
     * }
     */
    public static MethodHandle glIsQuery$handle() {
        return glIsQuery.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLboolean glIsQuery(GLuint id)
     * }
     */
    public static MemorySegment glIsQuery$address() {
        return glIsQuery.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLboolean glIsQuery(GLuint id)
     * }
     */
    public static byte glIsQuery(int id) {
        var mh$ = glIsQuery.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIsQuery", id);
            }
            return (byte)mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBeginQuery {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glBeginQuery");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glBeginQuery(GLenum target, GLuint id)
     * }
     */
    public static FunctionDescriptor glBeginQuery$descriptor() {
        return glBeginQuery.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glBeginQuery(GLenum target, GLuint id)
     * }
     */
    public static MethodHandle glBeginQuery$handle() {
        return glBeginQuery.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glBeginQuery(GLenum target, GLuint id)
     * }
     */
    public static MemorySegment glBeginQuery$address() {
        return glBeginQuery.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glBeginQuery(GLenum target, GLuint id)
     * }
     */
    public static void glBeginQuery(int target, int id) {
        var mh$ = glBeginQuery.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBeginQuery", target, id);
            }
            mh$.invokeExact(target, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEndQuery {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glEndQuery");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glEndQuery(GLenum target)
     * }
     */
    public static FunctionDescriptor glEndQuery$descriptor() {
        return glEndQuery.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glEndQuery(GLenum target)
     * }
     */
    public static MethodHandle glEndQuery$handle() {
        return glEndQuery.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glEndQuery(GLenum target)
     * }
     */
    public static MemorySegment glEndQuery$address() {
        return glEndQuery.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glEndQuery(GLenum target)
     * }
     */
    public static void glEndQuery(int target) {
        var mh$ = glEndQuery.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEndQuery", target);
            }
            mh$.invokeExact(target);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetQueryiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetQueryiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetQueryiv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetQueryiv$descriptor() {
        return glGetQueryiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetQueryiv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetQueryiv$handle() {
        return glGetQueryiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetQueryiv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetQueryiv$address() {
        return glGetQueryiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetQueryiv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static void glGetQueryiv(int target, int pname, MemorySegment params) {
        var mh$ = glGetQueryiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetQueryiv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetQueryObjectiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetQueryObjectiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetQueryObjectiv(GLuint id, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetQueryObjectiv$descriptor() {
        return glGetQueryObjectiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetQueryObjectiv(GLuint id, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetQueryObjectiv$handle() {
        return glGetQueryObjectiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetQueryObjectiv(GLuint id, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetQueryObjectiv$address() {
        return glGetQueryObjectiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetQueryObjectiv(GLuint id, GLenum pname, GLint *params)
     * }
     */
    public static void glGetQueryObjectiv(int id, int pname, MemorySegment params) {
        var mh$ = glGetQueryObjectiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetQueryObjectiv", id, pname, params);
            }
            mh$.invokeExact(id, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetQueryObjectuiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetQueryObjectuiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetQueryObjectuiv(GLuint id, GLenum pname, GLuint *params)
     * }
     */
    public static FunctionDescriptor glGetQueryObjectuiv$descriptor() {
        return glGetQueryObjectuiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetQueryObjectuiv(GLuint id, GLenum pname, GLuint *params)
     * }
     */
    public static MethodHandle glGetQueryObjectuiv$handle() {
        return glGetQueryObjectuiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetQueryObjectuiv(GLuint id, GLenum pname, GLuint *params)
     * }
     */
    public static MemorySegment glGetQueryObjectuiv$address() {
        return glGetQueryObjectuiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetQueryObjectuiv(GLuint id, GLenum pname, GLuint *params)
     * }
     */
    public static void glGetQueryObjectuiv(int id, int pname, MemorySegment params) {
        var mh$ = glGetQueryObjectuiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetQueryObjectuiv", id, pname, params);
            }
            mh$.invokeExact(id, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBindBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glBindBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glBindBuffer(GLenum target, GLuint buffer)
     * }
     */
    public static FunctionDescriptor glBindBuffer$descriptor() {
        return glBindBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glBindBuffer(GLenum target, GLuint buffer)
     * }
     */
    public static MethodHandle glBindBuffer$handle() {
        return glBindBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glBindBuffer(GLenum target, GLuint buffer)
     * }
     */
    public static MemorySegment glBindBuffer$address() {
        return glBindBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glBindBuffer(GLenum target, GLuint buffer)
     * }
     */
    public static void glBindBuffer(int target, int buffer) {
        var mh$ = glBindBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBindBuffer", target, buffer);
            }
            mh$.invokeExact(target, buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDeleteBuffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDeleteBuffers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glDeleteBuffers(GLsizei n, const GLuint *buffers)
     * }
     */
    public static FunctionDescriptor glDeleteBuffers$descriptor() {
        return glDeleteBuffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glDeleteBuffers(GLsizei n, const GLuint *buffers)
     * }
     */
    public static MethodHandle glDeleteBuffers$handle() {
        return glDeleteBuffers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glDeleteBuffers(GLsizei n, const GLuint *buffers)
     * }
     */
    public static MemorySegment glDeleteBuffers$address() {
        return glDeleteBuffers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glDeleteBuffers(GLsizei n, const GLuint *buffers)
     * }
     */
    public static void glDeleteBuffers(int n, MemorySegment buffers) {
        var mh$ = glDeleteBuffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDeleteBuffers", n, buffers);
            }
            mh$.invokeExact(n, buffers);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGenBuffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGenBuffers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGenBuffers(GLsizei n, GLuint *buffers)
     * }
     */
    public static FunctionDescriptor glGenBuffers$descriptor() {
        return glGenBuffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGenBuffers(GLsizei n, GLuint *buffers)
     * }
     */
    public static MethodHandle glGenBuffers$handle() {
        return glGenBuffers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGenBuffers(GLsizei n, GLuint *buffers)
     * }
     */
    public static MemorySegment glGenBuffers$address() {
        return glGenBuffers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGenBuffers(GLsizei n, GLuint *buffers)
     * }
     */
    public static void glGenBuffers(int n, MemorySegment buffers) {
        var mh$ = glGenBuffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGenBuffers", n, buffers);
            }
            mh$.invokeExact(n, buffers);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIsBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glIsBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLboolean glIsBuffer(GLuint buffer)
     * }
     */
    public static FunctionDescriptor glIsBuffer$descriptor() {
        return glIsBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLboolean glIsBuffer(GLuint buffer)
     * }
     */
    public static MethodHandle glIsBuffer$handle() {
        return glIsBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLboolean glIsBuffer(GLuint buffer)
     * }
     */
    public static MemorySegment glIsBuffer$address() {
        return glIsBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLboolean glIsBuffer(GLuint buffer)
     * }
     */
    public static byte glIsBuffer(int buffer) {
        var mh$ = glIsBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIsBuffer", buffer);
            }
            return (byte)mh$.invokeExact(buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBufferData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glBufferData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glBufferData(GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage)
     * }
     */
    public static FunctionDescriptor glBufferData$descriptor() {
        return glBufferData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glBufferData(GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage)
     * }
     */
    public static MethodHandle glBufferData$handle() {
        return glBufferData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glBufferData(GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage)
     * }
     */
    public static MemorySegment glBufferData$address() {
        return glBufferData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glBufferData(GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage)
     * }
     */
    public static void glBufferData(int target, long size, MemorySegment data, int usage) {
        var mh$ = glBufferData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBufferData", target, size, data, usage);
            }
            mh$.invokeExact(target, size, data, usage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBufferSubData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glBufferSubData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *data)
     * }
     */
    public static FunctionDescriptor glBufferSubData$descriptor() {
        return glBufferSubData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *data)
     * }
     */
    public static MethodHandle glBufferSubData$handle() {
        return glBufferSubData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *data)
     * }
     */
    public static MemorySegment glBufferSubData$address() {
        return glBufferSubData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *data)
     * }
     */
    public static void glBufferSubData(int target, long offset, long size, MemorySegment data) {
        var mh$ = glBufferSubData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBufferSubData", target, offset, size, data);
            }
            mh$.invokeExact(target, offset, size, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetBufferSubData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetBufferSubData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, GLvoid *data)
     * }
     */
    public static FunctionDescriptor glGetBufferSubData$descriptor() {
        return glGetBufferSubData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, GLvoid *data)
     * }
     */
    public static MethodHandle glGetBufferSubData$handle() {
        return glGetBufferSubData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, GLvoid *data)
     * }
     */
    public static MemorySegment glGetBufferSubData$address() {
        return glGetBufferSubData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, GLvoid *data)
     * }
     */
    public static void glGetBufferSubData(int target, long offset, long size, MemorySegment data) {
        var mh$ = glGetBufferSubData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetBufferSubData", target, offset, size, data);
            }
            mh$.invokeExact(target, offset, size, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMapBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glMapBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLvoid *glMapBuffer(GLenum target, GLenum access)
     * }
     */
    public static FunctionDescriptor glMapBuffer$descriptor() {
        return glMapBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLvoid *glMapBuffer(GLenum target, GLenum access)
     * }
     */
    public static MethodHandle glMapBuffer$handle() {
        return glMapBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLvoid *glMapBuffer(GLenum target, GLenum access)
     * }
     */
    public static MemorySegment glMapBuffer$address() {
        return glMapBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLvoid *glMapBuffer(GLenum target, GLenum access)
     * }
     */
    public static MemorySegment glMapBuffer(int target, int access) {
        var mh$ = glMapBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMapBuffer", target, access);
            }
            return (MemorySegment)mh$.invokeExact(target, access);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUnmapBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUnmapBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLboolean glUnmapBuffer(GLenum target)
     * }
     */
    public static FunctionDescriptor glUnmapBuffer$descriptor() {
        return glUnmapBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLboolean glUnmapBuffer(GLenum target)
     * }
     */
    public static MethodHandle glUnmapBuffer$handle() {
        return glUnmapBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLboolean glUnmapBuffer(GLenum target)
     * }
     */
    public static MemorySegment glUnmapBuffer$address() {
        return glUnmapBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLboolean glUnmapBuffer(GLenum target)
     * }
     */
    public static byte glUnmapBuffer(int target) {
        var mh$ = glUnmapBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUnmapBuffer", target);
            }
            return (byte)mh$.invokeExact(target);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetBufferParameteriv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetBufferParameteriv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetBufferParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetBufferParameteriv$descriptor() {
        return glGetBufferParameteriv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetBufferParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetBufferParameteriv$handle() {
        return glGetBufferParameteriv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetBufferParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetBufferParameteriv$address() {
        return glGetBufferParameteriv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetBufferParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static void glGetBufferParameteriv(int target, int pname, MemorySegment params) {
        var mh$ = glGetBufferParameteriv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetBufferParameteriv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetBufferPointerv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetBufferPointerv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetBufferPointerv(GLenum target, GLenum pname, GLvoid **params)
     * }
     */
    public static FunctionDescriptor glGetBufferPointerv$descriptor() {
        return glGetBufferPointerv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetBufferPointerv(GLenum target, GLenum pname, GLvoid **params)
     * }
     */
    public static MethodHandle glGetBufferPointerv$handle() {
        return glGetBufferPointerv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetBufferPointerv(GLenum target, GLenum pname, GLvoid **params)
     * }
     */
    public static MemorySegment glGetBufferPointerv$address() {
        return glGetBufferPointerv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetBufferPointerv(GLenum target, GLenum pname, GLvoid **params)
     * }
     */
    public static void glGetBufferPointerv(int target, int pname, MemorySegment params) {
        var mh$ = glGetBufferPointerv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetBufferPointerv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDrawBuffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDrawBuffers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glDrawBuffers(GLsizei n, const GLenum *bufs)
     * }
     */
    public static FunctionDescriptor glDrawBuffers$descriptor() {
        return glDrawBuffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glDrawBuffers(GLsizei n, const GLenum *bufs)
     * }
     */
    public static MethodHandle glDrawBuffers$handle() {
        return glDrawBuffers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glDrawBuffers(GLsizei n, const GLenum *bufs)
     * }
     */
    public static MemorySegment glDrawBuffers$address() {
        return glDrawBuffers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glDrawBuffers(GLsizei n, const GLenum *bufs)
     * }
     */
    public static void glDrawBuffers(int n, MemorySegment bufs) {
        var mh$ = glDrawBuffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDrawBuffers", n, bufs);
            }
            mh$.invokeExact(n, bufs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib1d(GLuint index, GLdouble x)
     * }
     */
    public static FunctionDescriptor glVertexAttrib1d$descriptor() {
        return glVertexAttrib1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib1d(GLuint index, GLdouble x)
     * }
     */
    public static MethodHandle glVertexAttrib1d$handle() {
        return glVertexAttrib1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib1d(GLuint index, GLdouble x)
     * }
     */
    public static MemorySegment glVertexAttrib1d$address() {
        return glVertexAttrib1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib1d(GLuint index, GLdouble x)
     * }
     */
    public static void glVertexAttrib1d(int index, double x) {
        var mh$ = glVertexAttrib1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib1d", index, x);
            }
            mh$.invokeExact(index, x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib1dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib1dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib1dv(GLuint index, const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glVertexAttrib1dv$descriptor() {
        return glVertexAttrib1dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib1dv(GLuint index, const GLdouble *v)
     * }
     */
    public static MethodHandle glVertexAttrib1dv$handle() {
        return glVertexAttrib1dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib1dv(GLuint index, const GLdouble *v)
     * }
     */
    public static MemorySegment glVertexAttrib1dv$address() {
        return glVertexAttrib1dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib1dv(GLuint index, const GLdouble *v)
     * }
     */
    public static void glVertexAttrib1dv(int index, MemorySegment v) {
        var mh$ = glVertexAttrib1dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib1dv", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib1f(GLuint index, GLfloat x)
     * }
     */
    public static FunctionDescriptor glVertexAttrib1f$descriptor() {
        return glVertexAttrib1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib1f(GLuint index, GLfloat x)
     * }
     */
    public static MethodHandle glVertexAttrib1f$handle() {
        return glVertexAttrib1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib1f(GLuint index, GLfloat x)
     * }
     */
    public static MemorySegment glVertexAttrib1f$address() {
        return glVertexAttrib1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib1f(GLuint index, GLfloat x)
     * }
     */
    public static void glVertexAttrib1f(int index, float x) {
        var mh$ = glVertexAttrib1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib1f", index, x);
            }
            mh$.invokeExact(index, x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib1fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib1fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib1fv(GLuint index, const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glVertexAttrib1fv$descriptor() {
        return glVertexAttrib1fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib1fv(GLuint index, const GLfloat *v)
     * }
     */
    public static MethodHandle glVertexAttrib1fv$handle() {
        return glVertexAttrib1fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib1fv(GLuint index, const GLfloat *v)
     * }
     */
    public static MemorySegment glVertexAttrib1fv$address() {
        return glVertexAttrib1fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib1fv(GLuint index, const GLfloat *v)
     * }
     */
    public static void glVertexAttrib1fv(int index, MemorySegment v) {
        var mh$ = glVertexAttrib1fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib1fv", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib1s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib1s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib1s(GLuint index, GLshort x)
     * }
     */
    public static FunctionDescriptor glVertexAttrib1s$descriptor() {
        return glVertexAttrib1s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib1s(GLuint index, GLshort x)
     * }
     */
    public static MethodHandle glVertexAttrib1s$handle() {
        return glVertexAttrib1s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib1s(GLuint index, GLshort x)
     * }
     */
    public static MemorySegment glVertexAttrib1s$address() {
        return glVertexAttrib1s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib1s(GLuint index, GLshort x)
     * }
     */
    public static void glVertexAttrib1s(int index, short x) {
        var mh$ = glVertexAttrib1s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib1s", index, x);
            }
            mh$.invokeExact(index, x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib1sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib1sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib1sv(GLuint index, const GLshort *v)
     * }
     */
    public static FunctionDescriptor glVertexAttrib1sv$descriptor() {
        return glVertexAttrib1sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib1sv(GLuint index, const GLshort *v)
     * }
     */
    public static MethodHandle glVertexAttrib1sv$handle() {
        return glVertexAttrib1sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib1sv(GLuint index, const GLshort *v)
     * }
     */
    public static MemorySegment glVertexAttrib1sv$address() {
        return glVertexAttrib1sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib1sv(GLuint index, const GLshort *v)
     * }
     */
    public static void glVertexAttrib1sv(int index, MemorySegment v) {
        var mh$ = glVertexAttrib1sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib1sv", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib2d(GLuint index, GLdouble x, GLdouble y)
     * }
     */
    public static FunctionDescriptor glVertexAttrib2d$descriptor() {
        return glVertexAttrib2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib2d(GLuint index, GLdouble x, GLdouble y)
     * }
     */
    public static MethodHandle glVertexAttrib2d$handle() {
        return glVertexAttrib2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib2d(GLuint index, GLdouble x, GLdouble y)
     * }
     */
    public static MemorySegment glVertexAttrib2d$address() {
        return glVertexAttrib2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib2d(GLuint index, GLdouble x, GLdouble y)
     * }
     */
    public static void glVertexAttrib2d(int index, double x, double y) {
        var mh$ = glVertexAttrib2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib2d", index, x, y);
            }
            mh$.invokeExact(index, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib2dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib2dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib2dv(GLuint index, const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glVertexAttrib2dv$descriptor() {
        return glVertexAttrib2dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib2dv(GLuint index, const GLdouble *v)
     * }
     */
    public static MethodHandle glVertexAttrib2dv$handle() {
        return glVertexAttrib2dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib2dv(GLuint index, const GLdouble *v)
     * }
     */
    public static MemorySegment glVertexAttrib2dv$address() {
        return glVertexAttrib2dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib2dv(GLuint index, const GLdouble *v)
     * }
     */
    public static void glVertexAttrib2dv(int index, MemorySegment v) {
        var mh$ = glVertexAttrib2dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib2dv", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib2f(GLuint index, GLfloat x, GLfloat y)
     * }
     */
    public static FunctionDescriptor glVertexAttrib2f$descriptor() {
        return glVertexAttrib2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib2f(GLuint index, GLfloat x, GLfloat y)
     * }
     */
    public static MethodHandle glVertexAttrib2f$handle() {
        return glVertexAttrib2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib2f(GLuint index, GLfloat x, GLfloat y)
     * }
     */
    public static MemorySegment glVertexAttrib2f$address() {
        return glVertexAttrib2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib2f(GLuint index, GLfloat x, GLfloat y)
     * }
     */
    public static void glVertexAttrib2f(int index, float x, float y) {
        var mh$ = glVertexAttrib2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib2f", index, x, y);
            }
            mh$.invokeExact(index, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib2fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib2fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib2fv(GLuint index, const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glVertexAttrib2fv$descriptor() {
        return glVertexAttrib2fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib2fv(GLuint index, const GLfloat *v)
     * }
     */
    public static MethodHandle glVertexAttrib2fv$handle() {
        return glVertexAttrib2fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib2fv(GLuint index, const GLfloat *v)
     * }
     */
    public static MemorySegment glVertexAttrib2fv$address() {
        return glVertexAttrib2fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib2fv(GLuint index, const GLfloat *v)
     * }
     */
    public static void glVertexAttrib2fv(int index, MemorySegment v) {
        var mh$ = glVertexAttrib2fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib2fv", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib2s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib2s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib2s(GLuint index, GLshort x, GLshort y)
     * }
     */
    public static FunctionDescriptor glVertexAttrib2s$descriptor() {
        return glVertexAttrib2s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib2s(GLuint index, GLshort x, GLshort y)
     * }
     */
    public static MethodHandle glVertexAttrib2s$handle() {
        return glVertexAttrib2s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib2s(GLuint index, GLshort x, GLshort y)
     * }
     */
    public static MemorySegment glVertexAttrib2s$address() {
        return glVertexAttrib2s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib2s(GLuint index, GLshort x, GLshort y)
     * }
     */
    public static void glVertexAttrib2s(int index, short x, short y) {
        var mh$ = glVertexAttrib2s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib2s", index, x, y);
            }
            mh$.invokeExact(index, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib2sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib2sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib2sv(GLuint index, const GLshort *v)
     * }
     */
    public static FunctionDescriptor glVertexAttrib2sv$descriptor() {
        return glVertexAttrib2sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib2sv(GLuint index, const GLshort *v)
     * }
     */
    public static MethodHandle glVertexAttrib2sv$handle() {
        return glVertexAttrib2sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib2sv(GLuint index, const GLshort *v)
     * }
     */
    public static MemorySegment glVertexAttrib2sv$address() {
        return glVertexAttrib2sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib2sv(GLuint index, const GLshort *v)
     * }
     */
    public static void glVertexAttrib2sv(int index, MemorySegment v) {
        var mh$ = glVertexAttrib2sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib2sv", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib3d(GLuint index, GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static FunctionDescriptor glVertexAttrib3d$descriptor() {
        return glVertexAttrib3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib3d(GLuint index, GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MethodHandle glVertexAttrib3d$handle() {
        return glVertexAttrib3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib3d(GLuint index, GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MemorySegment glVertexAttrib3d$address() {
        return glVertexAttrib3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib3d(GLuint index, GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static void glVertexAttrib3d(int index, double x, double y, double z) {
        var mh$ = glVertexAttrib3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib3d", index, x, y, z);
            }
            mh$.invokeExact(index, x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib3dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib3dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib3dv(GLuint index, const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glVertexAttrib3dv$descriptor() {
        return glVertexAttrib3dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib3dv(GLuint index, const GLdouble *v)
     * }
     */
    public static MethodHandle glVertexAttrib3dv$handle() {
        return glVertexAttrib3dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib3dv(GLuint index, const GLdouble *v)
     * }
     */
    public static MemorySegment glVertexAttrib3dv$address() {
        return glVertexAttrib3dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib3dv(GLuint index, const GLdouble *v)
     * }
     */
    public static void glVertexAttrib3dv(int index, MemorySegment v) {
        var mh$ = glVertexAttrib3dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib3dv", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib3f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib3f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib3f(GLuint index, GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static FunctionDescriptor glVertexAttrib3f$descriptor() {
        return glVertexAttrib3f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib3f(GLuint index, GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MethodHandle glVertexAttrib3f$handle() {
        return glVertexAttrib3f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib3f(GLuint index, GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MemorySegment glVertexAttrib3f$address() {
        return glVertexAttrib3f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib3f(GLuint index, GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static void glVertexAttrib3f(int index, float x, float y, float z) {
        var mh$ = glVertexAttrib3f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib3f", index, x, y, z);
            }
            mh$.invokeExact(index, x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib3fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib3fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib3fv(GLuint index, const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glVertexAttrib3fv$descriptor() {
        return glVertexAttrib3fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib3fv(GLuint index, const GLfloat *v)
     * }
     */
    public static MethodHandle glVertexAttrib3fv$handle() {
        return glVertexAttrib3fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib3fv(GLuint index, const GLfloat *v)
     * }
     */
    public static MemorySegment glVertexAttrib3fv$address() {
        return glVertexAttrib3fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib3fv(GLuint index, const GLfloat *v)
     * }
     */
    public static void glVertexAttrib3fv(int index, MemorySegment v) {
        var mh$ = glVertexAttrib3fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib3fv", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib3s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib3s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib3s(GLuint index, GLshort x, GLshort y, GLshort z)
     * }
     */
    public static FunctionDescriptor glVertexAttrib3s$descriptor() {
        return glVertexAttrib3s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib3s(GLuint index, GLshort x, GLshort y, GLshort z)
     * }
     */
    public static MethodHandle glVertexAttrib3s$handle() {
        return glVertexAttrib3s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib3s(GLuint index, GLshort x, GLshort y, GLshort z)
     * }
     */
    public static MemorySegment glVertexAttrib3s$address() {
        return glVertexAttrib3s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib3s(GLuint index, GLshort x, GLshort y, GLshort z)
     * }
     */
    public static void glVertexAttrib3s(int index, short x, short y, short z) {
        var mh$ = glVertexAttrib3s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib3s", index, x, y, z);
            }
            mh$.invokeExact(index, x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib3sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib3sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib3sv(GLuint index, const GLshort *v)
     * }
     */
    public static FunctionDescriptor glVertexAttrib3sv$descriptor() {
        return glVertexAttrib3sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib3sv(GLuint index, const GLshort *v)
     * }
     */
    public static MethodHandle glVertexAttrib3sv$handle() {
        return glVertexAttrib3sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib3sv(GLuint index, const GLshort *v)
     * }
     */
    public static MemorySegment glVertexAttrib3sv$address() {
        return glVertexAttrib3sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib3sv(GLuint index, const GLshort *v)
     * }
     */
    public static void glVertexAttrib3sv(int index, MemorySegment v) {
        var mh$ = glVertexAttrib3sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib3sv", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib4Nbv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib4Nbv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4Nbv(GLuint index, const GLbyte *v)
     * }
     */
    public static FunctionDescriptor glVertexAttrib4Nbv$descriptor() {
        return glVertexAttrib4Nbv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4Nbv(GLuint index, const GLbyte *v)
     * }
     */
    public static MethodHandle glVertexAttrib4Nbv$handle() {
        return glVertexAttrib4Nbv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4Nbv(GLuint index, const GLbyte *v)
     * }
     */
    public static MemorySegment glVertexAttrib4Nbv$address() {
        return glVertexAttrib4Nbv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib4Nbv(GLuint index, const GLbyte *v)
     * }
     */
    public static void glVertexAttrib4Nbv(int index, MemorySegment v) {
        var mh$ = glVertexAttrib4Nbv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib4Nbv", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib4Niv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib4Niv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4Niv(GLuint index, const GLint *v)
     * }
     */
    public static FunctionDescriptor glVertexAttrib4Niv$descriptor() {
        return glVertexAttrib4Niv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4Niv(GLuint index, const GLint *v)
     * }
     */
    public static MethodHandle glVertexAttrib4Niv$handle() {
        return glVertexAttrib4Niv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4Niv(GLuint index, const GLint *v)
     * }
     */
    public static MemorySegment glVertexAttrib4Niv$address() {
        return glVertexAttrib4Niv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib4Niv(GLuint index, const GLint *v)
     * }
     */
    public static void glVertexAttrib4Niv(int index, MemorySegment v) {
        var mh$ = glVertexAttrib4Niv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib4Niv", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib4Nsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib4Nsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4Nsv(GLuint index, const GLshort *v)
     * }
     */
    public static FunctionDescriptor glVertexAttrib4Nsv$descriptor() {
        return glVertexAttrib4Nsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4Nsv(GLuint index, const GLshort *v)
     * }
     */
    public static MethodHandle glVertexAttrib4Nsv$handle() {
        return glVertexAttrib4Nsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4Nsv(GLuint index, const GLshort *v)
     * }
     */
    public static MemorySegment glVertexAttrib4Nsv$address() {
        return glVertexAttrib4Nsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib4Nsv(GLuint index, const GLshort *v)
     * }
     */
    public static void glVertexAttrib4Nsv(int index, MemorySegment v) {
        var mh$ = glVertexAttrib4Nsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib4Nsv", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib4Nub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib4Nub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4Nub(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
     * }
     */
    public static FunctionDescriptor glVertexAttrib4Nub$descriptor() {
        return glVertexAttrib4Nub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4Nub(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
     * }
     */
    public static MethodHandle glVertexAttrib4Nub$handle() {
        return glVertexAttrib4Nub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4Nub(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
     * }
     */
    public static MemorySegment glVertexAttrib4Nub$address() {
        return glVertexAttrib4Nub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib4Nub(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
     * }
     */
    public static void glVertexAttrib4Nub(int index, byte x, byte y, byte z, byte w) {
        var mh$ = glVertexAttrib4Nub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib4Nub", index, x, y, z, w);
            }
            mh$.invokeExact(index, x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib4Nubv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib4Nubv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4Nubv(GLuint index, const GLubyte *v)
     * }
     */
    public static FunctionDescriptor glVertexAttrib4Nubv$descriptor() {
        return glVertexAttrib4Nubv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4Nubv(GLuint index, const GLubyte *v)
     * }
     */
    public static MethodHandle glVertexAttrib4Nubv$handle() {
        return glVertexAttrib4Nubv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4Nubv(GLuint index, const GLubyte *v)
     * }
     */
    public static MemorySegment glVertexAttrib4Nubv$address() {
        return glVertexAttrib4Nubv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib4Nubv(GLuint index, const GLubyte *v)
     * }
     */
    public static void glVertexAttrib4Nubv(int index, MemorySegment v) {
        var mh$ = glVertexAttrib4Nubv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib4Nubv", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib4Nuiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib4Nuiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4Nuiv(GLuint index, const GLuint *v)
     * }
     */
    public static FunctionDescriptor glVertexAttrib4Nuiv$descriptor() {
        return glVertexAttrib4Nuiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4Nuiv(GLuint index, const GLuint *v)
     * }
     */
    public static MethodHandle glVertexAttrib4Nuiv$handle() {
        return glVertexAttrib4Nuiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4Nuiv(GLuint index, const GLuint *v)
     * }
     */
    public static MemorySegment glVertexAttrib4Nuiv$address() {
        return glVertexAttrib4Nuiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib4Nuiv(GLuint index, const GLuint *v)
     * }
     */
    public static void glVertexAttrib4Nuiv(int index, MemorySegment v) {
        var mh$ = glVertexAttrib4Nuiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib4Nuiv", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib4Nusv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib4Nusv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4Nusv(GLuint index, const GLushort *v)
     * }
     */
    public static FunctionDescriptor glVertexAttrib4Nusv$descriptor() {
        return glVertexAttrib4Nusv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4Nusv(GLuint index, const GLushort *v)
     * }
     */
    public static MethodHandle glVertexAttrib4Nusv$handle() {
        return glVertexAttrib4Nusv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4Nusv(GLuint index, const GLushort *v)
     * }
     */
    public static MemorySegment glVertexAttrib4Nusv$address() {
        return glVertexAttrib4Nusv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib4Nusv(GLuint index, const GLushort *v)
     * }
     */
    public static void glVertexAttrib4Nusv(int index, MemorySegment v) {
        var mh$ = glVertexAttrib4Nusv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib4Nusv", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib4bv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib4bv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4bv(GLuint index, const GLbyte *v)
     * }
     */
    public static FunctionDescriptor glVertexAttrib4bv$descriptor() {
        return glVertexAttrib4bv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4bv(GLuint index, const GLbyte *v)
     * }
     */
    public static MethodHandle glVertexAttrib4bv$handle() {
        return glVertexAttrib4bv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4bv(GLuint index, const GLbyte *v)
     * }
     */
    public static MemorySegment glVertexAttrib4bv$address() {
        return glVertexAttrib4bv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib4bv(GLuint index, const GLbyte *v)
     * }
     */
    public static void glVertexAttrib4bv(int index, MemorySegment v) {
        var mh$ = glVertexAttrib4bv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib4bv", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib4d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib4d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4d(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static FunctionDescriptor glVertexAttrib4d$descriptor() {
        return glVertexAttrib4d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4d(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static MethodHandle glVertexAttrib4d$handle() {
        return glVertexAttrib4d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4d(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static MemorySegment glVertexAttrib4d$address() {
        return glVertexAttrib4d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib4d(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static void glVertexAttrib4d(int index, double x, double y, double z, double w) {
        var mh$ = glVertexAttrib4d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib4d", index, x, y, z, w);
            }
            mh$.invokeExact(index, x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib4dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib4dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4dv(GLuint index, const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glVertexAttrib4dv$descriptor() {
        return glVertexAttrib4dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4dv(GLuint index, const GLdouble *v)
     * }
     */
    public static MethodHandle glVertexAttrib4dv$handle() {
        return glVertexAttrib4dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4dv(GLuint index, const GLdouble *v)
     * }
     */
    public static MemorySegment glVertexAttrib4dv$address() {
        return glVertexAttrib4dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib4dv(GLuint index, const GLdouble *v)
     * }
     */
    public static void glVertexAttrib4dv(int index, MemorySegment v) {
        var mh$ = glVertexAttrib4dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib4dv", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib4f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib4f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4f(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static FunctionDescriptor glVertexAttrib4f$descriptor() {
        return glVertexAttrib4f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4f(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static MethodHandle glVertexAttrib4f$handle() {
        return glVertexAttrib4f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4f(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static MemorySegment glVertexAttrib4f$address() {
        return glVertexAttrib4f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib4f(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static void glVertexAttrib4f(int index, float x, float y, float z, float w) {
        var mh$ = glVertexAttrib4f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib4f", index, x, y, z, w);
            }
            mh$.invokeExact(index, x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib4fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib4fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4fv(GLuint index, const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glVertexAttrib4fv$descriptor() {
        return glVertexAttrib4fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4fv(GLuint index, const GLfloat *v)
     * }
     */
    public static MethodHandle glVertexAttrib4fv$handle() {
        return glVertexAttrib4fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4fv(GLuint index, const GLfloat *v)
     * }
     */
    public static MemorySegment glVertexAttrib4fv$address() {
        return glVertexAttrib4fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib4fv(GLuint index, const GLfloat *v)
     * }
     */
    public static void glVertexAttrib4fv(int index, MemorySegment v) {
        var mh$ = glVertexAttrib4fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib4fv", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib4iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib4iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4iv(GLuint index, const GLint *v)
     * }
     */
    public static FunctionDescriptor glVertexAttrib4iv$descriptor() {
        return glVertexAttrib4iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4iv(GLuint index, const GLint *v)
     * }
     */
    public static MethodHandle glVertexAttrib4iv$handle() {
        return glVertexAttrib4iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4iv(GLuint index, const GLint *v)
     * }
     */
    public static MemorySegment glVertexAttrib4iv$address() {
        return glVertexAttrib4iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib4iv(GLuint index, const GLint *v)
     * }
     */
    public static void glVertexAttrib4iv(int index, MemorySegment v) {
        var mh$ = glVertexAttrib4iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib4iv", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib4s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib4s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4s(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static FunctionDescriptor glVertexAttrib4s$descriptor() {
        return glVertexAttrib4s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4s(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static MethodHandle glVertexAttrib4s$handle() {
        return glVertexAttrib4s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4s(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static MemorySegment glVertexAttrib4s$address() {
        return glVertexAttrib4s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib4s(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static void glVertexAttrib4s(int index, short x, short y, short z, short w) {
        var mh$ = glVertexAttrib4s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib4s", index, x, y, z, w);
            }
            mh$.invokeExact(index, x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib4sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib4sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4sv(GLuint index, const GLshort *v)
     * }
     */
    public static FunctionDescriptor glVertexAttrib4sv$descriptor() {
        return glVertexAttrib4sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4sv(GLuint index, const GLshort *v)
     * }
     */
    public static MethodHandle glVertexAttrib4sv$handle() {
        return glVertexAttrib4sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4sv(GLuint index, const GLshort *v)
     * }
     */
    public static MemorySegment glVertexAttrib4sv$address() {
        return glVertexAttrib4sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib4sv(GLuint index, const GLshort *v)
     * }
     */
    public static void glVertexAttrib4sv(int index, MemorySegment v) {
        var mh$ = glVertexAttrib4sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib4sv", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib4ubv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib4ubv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4ubv(GLuint index, const GLubyte *v)
     * }
     */
    public static FunctionDescriptor glVertexAttrib4ubv$descriptor() {
        return glVertexAttrib4ubv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4ubv(GLuint index, const GLubyte *v)
     * }
     */
    public static MethodHandle glVertexAttrib4ubv$handle() {
        return glVertexAttrib4ubv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4ubv(GLuint index, const GLubyte *v)
     * }
     */
    public static MemorySegment glVertexAttrib4ubv$address() {
        return glVertexAttrib4ubv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib4ubv(GLuint index, const GLubyte *v)
     * }
     */
    public static void glVertexAttrib4ubv(int index, MemorySegment v) {
        var mh$ = glVertexAttrib4ubv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib4ubv", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib4uiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib4uiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4uiv(GLuint index, const GLuint *v)
     * }
     */
    public static FunctionDescriptor glVertexAttrib4uiv$descriptor() {
        return glVertexAttrib4uiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4uiv(GLuint index, const GLuint *v)
     * }
     */
    public static MethodHandle glVertexAttrib4uiv$handle() {
        return glVertexAttrib4uiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4uiv(GLuint index, const GLuint *v)
     * }
     */
    public static MemorySegment glVertexAttrib4uiv$address() {
        return glVertexAttrib4uiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib4uiv(GLuint index, const GLuint *v)
     * }
     */
    public static void glVertexAttrib4uiv(int index, MemorySegment v) {
        var mh$ = glVertexAttrib4uiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib4uiv", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttrib4usv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttrib4usv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4usv(GLuint index, const GLushort *v)
     * }
     */
    public static FunctionDescriptor glVertexAttrib4usv$descriptor() {
        return glVertexAttrib4usv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4usv(GLuint index, const GLushort *v)
     * }
     */
    public static MethodHandle glVertexAttrib4usv$handle() {
        return glVertexAttrib4usv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttrib4usv(GLuint index, const GLushort *v)
     * }
     */
    public static MemorySegment glVertexAttrib4usv$address() {
        return glVertexAttrib4usv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttrib4usv(GLuint index, const GLushort *v)
     * }
     */
    public static void glVertexAttrib4usv(int index, MemorySegment v) {
        var mh$ = glVertexAttrib4usv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttrib4usv", index, v);
            }
            mh$.invokeExact(index, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexAttribPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_CHAR,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glVertexAttribPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static FunctionDescriptor glVertexAttribPointer$descriptor() {
        return glVertexAttribPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MethodHandle glVertexAttribPointer$handle() {
        return glVertexAttribPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MemorySegment glVertexAttribPointer$address() {
        return glVertexAttribPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static void glVertexAttribPointer(int index, int size, int type, byte normalized, int stride, MemorySegment pointer) {
        var mh$ = glVertexAttribPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexAttribPointer", index, size, type, normalized, stride, pointer);
            }
            mh$.invokeExact(index, size, type, normalized, stride, pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEnableVertexAttribArray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glEnableVertexAttribArray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glEnableVertexAttribArray(GLuint index)
     * }
     */
    public static FunctionDescriptor glEnableVertexAttribArray$descriptor() {
        return glEnableVertexAttribArray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glEnableVertexAttribArray(GLuint index)
     * }
     */
    public static MethodHandle glEnableVertexAttribArray$handle() {
        return glEnableVertexAttribArray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glEnableVertexAttribArray(GLuint index)
     * }
     */
    public static MemorySegment glEnableVertexAttribArray$address() {
        return glEnableVertexAttribArray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glEnableVertexAttribArray(GLuint index)
     * }
     */
    public static void glEnableVertexAttribArray(int index) {
        var mh$ = glEnableVertexAttribArray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEnableVertexAttribArray", index);
            }
            mh$.invokeExact(index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDisableVertexAttribArray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDisableVertexAttribArray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glDisableVertexAttribArray(GLuint index)
     * }
     */
    public static FunctionDescriptor glDisableVertexAttribArray$descriptor() {
        return glDisableVertexAttribArray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glDisableVertexAttribArray(GLuint index)
     * }
     */
    public static MethodHandle glDisableVertexAttribArray$handle() {
        return glDisableVertexAttribArray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glDisableVertexAttribArray(GLuint index)
     * }
     */
    public static MemorySegment glDisableVertexAttribArray$address() {
        return glDisableVertexAttribArray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glDisableVertexAttribArray(GLuint index)
     * }
     */
    public static void glDisableVertexAttribArray(int index) {
        var mh$ = glDisableVertexAttribArray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDisableVertexAttribArray", index);
            }
            mh$.invokeExact(index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetVertexAttribdv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetVertexAttribdv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetVertexAttribdv(GLuint index, GLenum pname, GLdouble *params)
     * }
     */
    public static FunctionDescriptor glGetVertexAttribdv$descriptor() {
        return glGetVertexAttribdv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetVertexAttribdv(GLuint index, GLenum pname, GLdouble *params)
     * }
     */
    public static MethodHandle glGetVertexAttribdv$handle() {
        return glGetVertexAttribdv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetVertexAttribdv(GLuint index, GLenum pname, GLdouble *params)
     * }
     */
    public static MemorySegment glGetVertexAttribdv$address() {
        return glGetVertexAttribdv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetVertexAttribdv(GLuint index, GLenum pname, GLdouble *params)
     * }
     */
    public static void glGetVertexAttribdv(int index, int pname, MemorySegment params) {
        var mh$ = glGetVertexAttribdv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetVertexAttribdv", index, pname, params);
            }
            mh$.invokeExact(index, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetVertexAttribfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetVertexAttribfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetVertexAttribfv$descriptor() {
        return glGetVertexAttribfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetVertexAttribfv$handle() {
        return glGetVertexAttribfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetVertexAttribfv$address() {
        return glGetVertexAttribfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetVertexAttribfv(int index, int pname, MemorySegment params) {
        var mh$ = glGetVertexAttribfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetVertexAttribfv", index, pname, params);
            }
            mh$.invokeExact(index, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetVertexAttribiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetVertexAttribiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetVertexAttribiv(GLuint index, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetVertexAttribiv$descriptor() {
        return glGetVertexAttribiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetVertexAttribiv(GLuint index, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetVertexAttribiv$handle() {
        return glGetVertexAttribiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetVertexAttribiv(GLuint index, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetVertexAttribiv$address() {
        return glGetVertexAttribiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetVertexAttribiv(GLuint index, GLenum pname, GLint *params)
     * }
     */
    public static void glGetVertexAttribiv(int index, int pname, MemorySegment params) {
        var mh$ = glGetVertexAttribiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetVertexAttribiv", index, pname, params);
            }
            mh$.invokeExact(index, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetVertexAttribPointerv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetVertexAttribPointerv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetVertexAttribPointerv(GLuint index, GLenum pname, GLvoid **pointer)
     * }
     */
    public static FunctionDescriptor glGetVertexAttribPointerv$descriptor() {
        return glGetVertexAttribPointerv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetVertexAttribPointerv(GLuint index, GLenum pname, GLvoid **pointer)
     * }
     */
    public static MethodHandle glGetVertexAttribPointerv$handle() {
        return glGetVertexAttribPointerv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetVertexAttribPointerv(GLuint index, GLenum pname, GLvoid **pointer)
     * }
     */
    public static MemorySegment glGetVertexAttribPointerv$address() {
        return glGetVertexAttribPointerv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetVertexAttribPointerv(GLuint index, GLenum pname, GLvoid **pointer)
     * }
     */
    public static void glGetVertexAttribPointerv(int index, int pname, MemorySegment pointer) {
        var mh$ = glGetVertexAttribPointerv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetVertexAttribPointerv", index, pname, pointer);
            }
            mh$.invokeExact(index, pname, pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDeleteShader {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDeleteShader");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glDeleteShader(GLuint shader)
     * }
     */
    public static FunctionDescriptor glDeleteShader$descriptor() {
        return glDeleteShader.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glDeleteShader(GLuint shader)
     * }
     */
    public static MethodHandle glDeleteShader$handle() {
        return glDeleteShader.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glDeleteShader(GLuint shader)
     * }
     */
    public static MemorySegment glDeleteShader$address() {
        return glDeleteShader.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glDeleteShader(GLuint shader)
     * }
     */
    public static void glDeleteShader(int shader) {
        var mh$ = glDeleteShader.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDeleteShader", shader);
            }
            mh$.invokeExact(shader);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDetachShader {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDetachShader");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glDetachShader(GLuint program, GLuint shader)
     * }
     */
    public static FunctionDescriptor glDetachShader$descriptor() {
        return glDetachShader.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glDetachShader(GLuint program, GLuint shader)
     * }
     */
    public static MethodHandle glDetachShader$handle() {
        return glDetachShader.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glDetachShader(GLuint program, GLuint shader)
     * }
     */
    public static MemorySegment glDetachShader$address() {
        return glDetachShader.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glDetachShader(GLuint program, GLuint shader)
     * }
     */
    public static void glDetachShader(int program, int shader) {
        var mh$ = glDetachShader.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDetachShader", program, shader);
            }
            mh$.invokeExact(program, shader);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCreateShader {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glCreateShader");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLuint glCreateShader(GLenum type)
     * }
     */
    public static FunctionDescriptor glCreateShader$descriptor() {
        return glCreateShader.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLuint glCreateShader(GLenum type)
     * }
     */
    public static MethodHandle glCreateShader$handle() {
        return glCreateShader.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLuint glCreateShader(GLenum type)
     * }
     */
    public static MemorySegment glCreateShader$address() {
        return glCreateShader.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLuint glCreateShader(GLenum type)
     * }
     */
    public static int glCreateShader(int type) {
        var mh$ = glCreateShader.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCreateShader", type);
            }
            return (int)mh$.invokeExact(type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glShaderSource {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glShaderSource");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glShaderSource(GLuint shader, GLsizei count, const GLchar *const *string, const GLint *length)
     * }
     */
    public static FunctionDescriptor glShaderSource$descriptor() {
        return glShaderSource.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glShaderSource(GLuint shader, GLsizei count, const GLchar *const *string, const GLint *length)
     * }
     */
    public static MethodHandle glShaderSource$handle() {
        return glShaderSource.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glShaderSource(GLuint shader, GLsizei count, const GLchar *const *string, const GLint *length)
     * }
     */
    public static MemorySegment glShaderSource$address() {
        return glShaderSource.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glShaderSource(GLuint shader, GLsizei count, const GLchar *const *string, const GLint *length)
     * }
     */
    public static void glShaderSource(int shader, int count, MemorySegment string, MemorySegment length) {
        var mh$ = glShaderSource.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glShaderSource", shader, count, string, length);
            }
            mh$.invokeExact(shader, count, string, length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCompileShader {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glCompileShader");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glCompileShader(GLuint shader)
     * }
     */
    public static FunctionDescriptor glCompileShader$descriptor() {
        return glCompileShader.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glCompileShader(GLuint shader)
     * }
     */
    public static MethodHandle glCompileShader$handle() {
        return glCompileShader.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glCompileShader(GLuint shader)
     * }
     */
    public static MemorySegment glCompileShader$address() {
        return glCompileShader.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glCompileShader(GLuint shader)
     * }
     */
    public static void glCompileShader(int shader) {
        var mh$ = glCompileShader.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCompileShader", shader);
            }
            mh$.invokeExact(shader);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCreateProgram {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glCreateProgram");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLuint glCreateProgram()
     * }
     */
    public static FunctionDescriptor glCreateProgram$descriptor() {
        return glCreateProgram.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLuint glCreateProgram()
     * }
     */
    public static MethodHandle glCreateProgram$handle() {
        return glCreateProgram.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLuint glCreateProgram()
     * }
     */
    public static MemorySegment glCreateProgram$address() {
        return glCreateProgram.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLuint glCreateProgram()
     * }
     */
    public static int glCreateProgram() {
        var mh$ = glCreateProgram.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCreateProgram");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glAttachShader {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glAttachShader");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glAttachShader(GLuint program, GLuint shader)
     * }
     */
    public static FunctionDescriptor glAttachShader$descriptor() {
        return glAttachShader.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glAttachShader(GLuint program, GLuint shader)
     * }
     */
    public static MethodHandle glAttachShader$handle() {
        return glAttachShader.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glAttachShader(GLuint program, GLuint shader)
     * }
     */
    public static MemorySegment glAttachShader$address() {
        return glAttachShader.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glAttachShader(GLuint program, GLuint shader)
     * }
     */
    public static void glAttachShader(int program, int shader) {
        var mh$ = glAttachShader.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glAttachShader", program, shader);
            }
            mh$.invokeExact(program, shader);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLinkProgram {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glLinkProgram");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glLinkProgram(GLuint program)
     * }
     */
    public static FunctionDescriptor glLinkProgram$descriptor() {
        return glLinkProgram.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glLinkProgram(GLuint program)
     * }
     */
    public static MethodHandle glLinkProgram$handle() {
        return glLinkProgram.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glLinkProgram(GLuint program)
     * }
     */
    public static MemorySegment glLinkProgram$address() {
        return glLinkProgram.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glLinkProgram(GLuint program)
     * }
     */
    public static void glLinkProgram(int program) {
        var mh$ = glLinkProgram.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLinkProgram", program);
            }
            mh$.invokeExact(program);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUseProgram {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUseProgram");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUseProgram(GLuint program)
     * }
     */
    public static FunctionDescriptor glUseProgram$descriptor() {
        return glUseProgram.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUseProgram(GLuint program)
     * }
     */
    public static MethodHandle glUseProgram$handle() {
        return glUseProgram.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUseProgram(GLuint program)
     * }
     */
    public static MemorySegment glUseProgram$address() {
        return glUseProgram.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUseProgram(GLuint program)
     * }
     */
    public static void glUseProgram(int program) {
        var mh$ = glUseProgram.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUseProgram", program);
            }
            mh$.invokeExact(program);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDeleteProgram {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glDeleteProgram");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glDeleteProgram(GLuint program)
     * }
     */
    public static FunctionDescriptor glDeleteProgram$descriptor() {
        return glDeleteProgram.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glDeleteProgram(GLuint program)
     * }
     */
    public static MethodHandle glDeleteProgram$handle() {
        return glDeleteProgram.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glDeleteProgram(GLuint program)
     * }
     */
    public static MemorySegment glDeleteProgram$address() {
        return glDeleteProgram.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glDeleteProgram(GLuint program)
     * }
     */
    public static void glDeleteProgram(int program) {
        var mh$ = glDeleteProgram.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDeleteProgram", program);
            }
            mh$.invokeExact(program);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glValidateProgram {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glValidateProgram");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glValidateProgram(GLuint program)
     * }
     */
    public static FunctionDescriptor glValidateProgram$descriptor() {
        return glValidateProgram.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glValidateProgram(GLuint program)
     * }
     */
    public static MethodHandle glValidateProgram$handle() {
        return glValidateProgram.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glValidateProgram(GLuint program)
     * }
     */
    public static MemorySegment glValidateProgram$address() {
        return glValidateProgram.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glValidateProgram(GLuint program)
     * }
     */
    public static void glValidateProgram(int program) {
        var mh$ = glValidateProgram.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glValidateProgram", program);
            }
            mh$.invokeExact(program);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniform1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniform1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniform1f(GLint location, GLfloat v0)
     * }
     */
    public static FunctionDescriptor glUniform1f$descriptor() {
        return glUniform1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniform1f(GLint location, GLfloat v0)
     * }
     */
    public static MethodHandle glUniform1f$handle() {
        return glUniform1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniform1f(GLint location, GLfloat v0)
     * }
     */
    public static MemorySegment glUniform1f$address() {
        return glUniform1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniform1f(GLint location, GLfloat v0)
     * }
     */
    public static void glUniform1f(int location, float v0) {
        var mh$ = glUniform1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniform1f", location, v0);
            }
            mh$.invokeExact(location, v0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniform2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniform2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniform2f(GLint location, GLfloat v0, GLfloat v1)
     * }
     */
    public static FunctionDescriptor glUniform2f$descriptor() {
        return glUniform2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniform2f(GLint location, GLfloat v0, GLfloat v1)
     * }
     */
    public static MethodHandle glUniform2f$handle() {
        return glUniform2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniform2f(GLint location, GLfloat v0, GLfloat v1)
     * }
     */
    public static MemorySegment glUniform2f$address() {
        return glUniform2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniform2f(GLint location, GLfloat v0, GLfloat v1)
     * }
     */
    public static void glUniform2f(int location, float v0, float v1) {
        var mh$ = glUniform2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniform2f", location, v0, v1);
            }
            mh$.invokeExact(location, v0, v1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniform3f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniform3f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
     * }
     */
    public static FunctionDescriptor glUniform3f$descriptor() {
        return glUniform3f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
     * }
     */
    public static MethodHandle glUniform3f$handle() {
        return glUniform3f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
     * }
     */
    public static MemorySegment glUniform3f$address() {
        return glUniform3f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
     * }
     */
    public static void glUniform3f(int location, float v0, float v1, float v2) {
        var mh$ = glUniform3f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniform3f", location, v0, v1, v2);
            }
            mh$.invokeExact(location, v0, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniform4f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniform4f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
     * }
     */
    public static FunctionDescriptor glUniform4f$descriptor() {
        return glUniform4f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
     * }
     */
    public static MethodHandle glUniform4f$handle() {
        return glUniform4f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
     * }
     */
    public static MemorySegment glUniform4f$address() {
        return glUniform4f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
     * }
     */
    public static void glUniform4f(int location, float v0, float v1, float v2, float v3) {
        var mh$ = glUniform4f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniform4f", location, v0, v1, v2, v3);
            }
            mh$.invokeExact(location, v0, v1, v2, v3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniform1i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniform1i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniform1i(GLint location, GLint v0)
     * }
     */
    public static FunctionDescriptor glUniform1i$descriptor() {
        return glUniform1i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniform1i(GLint location, GLint v0)
     * }
     */
    public static MethodHandle glUniform1i$handle() {
        return glUniform1i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniform1i(GLint location, GLint v0)
     * }
     */
    public static MemorySegment glUniform1i$address() {
        return glUniform1i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniform1i(GLint location, GLint v0)
     * }
     */
    public static void glUniform1i(int location, int v0) {
        var mh$ = glUniform1i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniform1i", location, v0);
            }
            mh$.invokeExact(location, v0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniform2i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniform2i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniform2i(GLint location, GLint v0, GLint v1)
     * }
     */
    public static FunctionDescriptor glUniform2i$descriptor() {
        return glUniform2i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniform2i(GLint location, GLint v0, GLint v1)
     * }
     */
    public static MethodHandle glUniform2i$handle() {
        return glUniform2i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniform2i(GLint location, GLint v0, GLint v1)
     * }
     */
    public static MemorySegment glUniform2i$address() {
        return glUniform2i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniform2i(GLint location, GLint v0, GLint v1)
     * }
     */
    public static void glUniform2i(int location, int v0, int v1) {
        var mh$ = glUniform2i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniform2i", location, v0, v1);
            }
            mh$.invokeExact(location, v0, v1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniform3i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniform3i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2)
     * }
     */
    public static FunctionDescriptor glUniform3i$descriptor() {
        return glUniform3i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2)
     * }
     */
    public static MethodHandle glUniform3i$handle() {
        return glUniform3i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2)
     * }
     */
    public static MemorySegment glUniform3i$address() {
        return glUniform3i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2)
     * }
     */
    public static void glUniform3i(int location, int v0, int v1, int v2) {
        var mh$ = glUniform3i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniform3i", location, v0, v1, v2);
            }
            mh$.invokeExact(location, v0, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniform4i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniform4i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
     * }
     */
    public static FunctionDescriptor glUniform4i$descriptor() {
        return glUniform4i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
     * }
     */
    public static MethodHandle glUniform4i$handle() {
        return glUniform4i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
     * }
     */
    public static MemorySegment glUniform4i$address() {
        return glUniform4i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
     * }
     */
    public static void glUniform4i(int location, int v0, int v1, int v2, int v3) {
        var mh$ = glUniform4i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniform4i", location, v0, v1, v2, v3);
            }
            mh$.invokeExact(location, v0, v1, v2, v3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniform1fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniform1fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniform1fv(GLint location, GLsizei count, const GLfloat *value)
     * }
     */
    public static FunctionDescriptor glUniform1fv$descriptor() {
        return glUniform1fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniform1fv(GLint location, GLsizei count, const GLfloat *value)
     * }
     */
    public static MethodHandle glUniform1fv$handle() {
        return glUniform1fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniform1fv(GLint location, GLsizei count, const GLfloat *value)
     * }
     */
    public static MemorySegment glUniform1fv$address() {
        return glUniform1fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniform1fv(GLint location, GLsizei count, const GLfloat *value)
     * }
     */
    public static void glUniform1fv(int location, int count, MemorySegment value) {
        var mh$ = glUniform1fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniform1fv", location, count, value);
            }
            mh$.invokeExact(location, count, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniform2fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniform2fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniform2fv(GLint location, GLsizei count, const GLfloat *value)
     * }
     */
    public static FunctionDescriptor glUniform2fv$descriptor() {
        return glUniform2fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniform2fv(GLint location, GLsizei count, const GLfloat *value)
     * }
     */
    public static MethodHandle glUniform2fv$handle() {
        return glUniform2fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniform2fv(GLint location, GLsizei count, const GLfloat *value)
     * }
     */
    public static MemorySegment glUniform2fv$address() {
        return glUniform2fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniform2fv(GLint location, GLsizei count, const GLfloat *value)
     * }
     */
    public static void glUniform2fv(int location, int count, MemorySegment value) {
        var mh$ = glUniform2fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniform2fv", location, count, value);
            }
            mh$.invokeExact(location, count, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniform3fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniform3fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniform3fv(GLint location, GLsizei count, const GLfloat *value)
     * }
     */
    public static FunctionDescriptor glUniform3fv$descriptor() {
        return glUniform3fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniform3fv(GLint location, GLsizei count, const GLfloat *value)
     * }
     */
    public static MethodHandle glUniform3fv$handle() {
        return glUniform3fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniform3fv(GLint location, GLsizei count, const GLfloat *value)
     * }
     */
    public static MemorySegment glUniform3fv$address() {
        return glUniform3fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniform3fv(GLint location, GLsizei count, const GLfloat *value)
     * }
     */
    public static void glUniform3fv(int location, int count, MemorySegment value) {
        var mh$ = glUniform3fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniform3fv", location, count, value);
            }
            mh$.invokeExact(location, count, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniform4fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniform4fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniform4fv(GLint location, GLsizei count, const GLfloat *value)
     * }
     */
    public static FunctionDescriptor glUniform4fv$descriptor() {
        return glUniform4fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniform4fv(GLint location, GLsizei count, const GLfloat *value)
     * }
     */
    public static MethodHandle glUniform4fv$handle() {
        return glUniform4fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniform4fv(GLint location, GLsizei count, const GLfloat *value)
     * }
     */
    public static MemorySegment glUniform4fv$address() {
        return glUniform4fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniform4fv(GLint location, GLsizei count, const GLfloat *value)
     * }
     */
    public static void glUniform4fv(int location, int count, MemorySegment value) {
        var mh$ = glUniform4fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniform4fv", location, count, value);
            }
            mh$.invokeExact(location, count, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniform1iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniform1iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniform1iv(GLint location, GLsizei count, const GLint *value)
     * }
     */
    public static FunctionDescriptor glUniform1iv$descriptor() {
        return glUniform1iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniform1iv(GLint location, GLsizei count, const GLint *value)
     * }
     */
    public static MethodHandle glUniform1iv$handle() {
        return glUniform1iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniform1iv(GLint location, GLsizei count, const GLint *value)
     * }
     */
    public static MemorySegment glUniform1iv$address() {
        return glUniform1iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniform1iv(GLint location, GLsizei count, const GLint *value)
     * }
     */
    public static void glUniform1iv(int location, int count, MemorySegment value) {
        var mh$ = glUniform1iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniform1iv", location, count, value);
            }
            mh$.invokeExact(location, count, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniform2iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniform2iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniform2iv(GLint location, GLsizei count, const GLint *value)
     * }
     */
    public static FunctionDescriptor glUniform2iv$descriptor() {
        return glUniform2iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniform2iv(GLint location, GLsizei count, const GLint *value)
     * }
     */
    public static MethodHandle glUniform2iv$handle() {
        return glUniform2iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniform2iv(GLint location, GLsizei count, const GLint *value)
     * }
     */
    public static MemorySegment glUniform2iv$address() {
        return glUniform2iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniform2iv(GLint location, GLsizei count, const GLint *value)
     * }
     */
    public static void glUniform2iv(int location, int count, MemorySegment value) {
        var mh$ = glUniform2iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniform2iv", location, count, value);
            }
            mh$.invokeExact(location, count, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniform3iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniform3iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniform3iv(GLint location, GLsizei count, const GLint *value)
     * }
     */
    public static FunctionDescriptor glUniform3iv$descriptor() {
        return glUniform3iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniform3iv(GLint location, GLsizei count, const GLint *value)
     * }
     */
    public static MethodHandle glUniform3iv$handle() {
        return glUniform3iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniform3iv(GLint location, GLsizei count, const GLint *value)
     * }
     */
    public static MemorySegment glUniform3iv$address() {
        return glUniform3iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniform3iv(GLint location, GLsizei count, const GLint *value)
     * }
     */
    public static void glUniform3iv(int location, int count, MemorySegment value) {
        var mh$ = glUniform3iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniform3iv", location, count, value);
            }
            mh$.invokeExact(location, count, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniform4iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniform4iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniform4iv(GLint location, GLsizei count, const GLint *value)
     * }
     */
    public static FunctionDescriptor glUniform4iv$descriptor() {
        return glUniform4iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniform4iv(GLint location, GLsizei count, const GLint *value)
     * }
     */
    public static MethodHandle glUniform4iv$handle() {
        return glUniform4iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniform4iv(GLint location, GLsizei count, const GLint *value)
     * }
     */
    public static MemorySegment glUniform4iv$address() {
        return glUniform4iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniform4iv(GLint location, GLsizei count, const GLint *value)
     * }
     */
    public static void glUniform4iv(int location, int count, MemorySegment value) {
        var mh$ = glUniform4iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniform4iv", location, count, value);
            }
            mh$.invokeExact(location, count, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniformMatrix2fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniformMatrix2fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static FunctionDescriptor glUniformMatrix2fv$descriptor() {
        return glUniformMatrix2fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static MethodHandle glUniformMatrix2fv$handle() {
        return glUniformMatrix2fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static MemorySegment glUniformMatrix2fv$address() {
        return glUniformMatrix2fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static void glUniformMatrix2fv(int location, int count, byte transpose, MemorySegment value) {
        var mh$ = glUniformMatrix2fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniformMatrix2fv", location, count, transpose, value);
            }
            mh$.invokeExact(location, count, transpose, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniformMatrix3fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniformMatrix3fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static FunctionDescriptor glUniformMatrix3fv$descriptor() {
        return glUniformMatrix3fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static MethodHandle glUniformMatrix3fv$handle() {
        return glUniformMatrix3fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static MemorySegment glUniformMatrix3fv$address() {
        return glUniformMatrix3fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static void glUniformMatrix3fv(int location, int count, byte transpose, MemorySegment value) {
        var mh$ = glUniformMatrix3fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniformMatrix3fv", location, count, transpose, value);
            }
            mh$.invokeExact(location, count, transpose, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniformMatrix4fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniformMatrix4fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static FunctionDescriptor glUniformMatrix4fv$descriptor() {
        return glUniformMatrix4fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static MethodHandle glUniformMatrix4fv$handle() {
        return glUniformMatrix4fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static MemorySegment glUniformMatrix4fv$address() {
        return glUniformMatrix4fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static void glUniformMatrix4fv(int location, int count, byte transpose, MemorySegment value) {
        var mh$ = glUniformMatrix4fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniformMatrix4fv", location, count, transpose, value);
            }
            mh$.invokeExact(location, count, transpose, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIsShader {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glIsShader");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLboolean glIsShader(GLuint shader)
     * }
     */
    public static FunctionDescriptor glIsShader$descriptor() {
        return glIsShader.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLboolean glIsShader(GLuint shader)
     * }
     */
    public static MethodHandle glIsShader$handle() {
        return glIsShader.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLboolean glIsShader(GLuint shader)
     * }
     */
    public static MemorySegment glIsShader$address() {
        return glIsShader.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLboolean glIsShader(GLuint shader)
     * }
     */
    public static byte glIsShader(int shader) {
        var mh$ = glIsShader.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIsShader", shader);
            }
            return (byte)mh$.invokeExact(shader);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIsProgram {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glIsProgram");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLboolean glIsProgram(GLuint program)
     * }
     */
    public static FunctionDescriptor glIsProgram$descriptor() {
        return glIsProgram.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLboolean glIsProgram(GLuint program)
     * }
     */
    public static MethodHandle glIsProgram$handle() {
        return glIsProgram.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLboolean glIsProgram(GLuint program)
     * }
     */
    public static MemorySegment glIsProgram$address() {
        return glIsProgram.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLboolean glIsProgram(GLuint program)
     * }
     */
    public static byte glIsProgram(int program) {
        var mh$ = glIsProgram.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIsProgram", program);
            }
            return (byte)mh$.invokeExact(program);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetShaderiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetShaderiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetShaderiv(GLuint shader, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetShaderiv$descriptor() {
        return glGetShaderiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetShaderiv(GLuint shader, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetShaderiv$handle() {
        return glGetShaderiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetShaderiv(GLuint shader, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetShaderiv$address() {
        return glGetShaderiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetShaderiv(GLuint shader, GLenum pname, GLint *params)
     * }
     */
    public static void glGetShaderiv(int shader, int pname, MemorySegment params) {
        var mh$ = glGetShaderiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetShaderiv", shader, pname, params);
            }
            mh$.invokeExact(shader, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetProgramiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetProgramiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetProgramiv(GLuint program, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetProgramiv$descriptor() {
        return glGetProgramiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetProgramiv(GLuint program, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetProgramiv$handle() {
        return glGetProgramiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetProgramiv(GLuint program, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetProgramiv$address() {
        return glGetProgramiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetProgramiv(GLuint program, GLenum pname, GLint *params)
     * }
     */
    public static void glGetProgramiv(int program, int pname, MemorySegment params) {
        var mh$ = glGetProgramiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetProgramiv", program, pname, params);
            }
            mh$.invokeExact(program, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetAttachedShaders {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetAttachedShaders");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders)
     * }
     */
    public static FunctionDescriptor glGetAttachedShaders$descriptor() {
        return glGetAttachedShaders.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders)
     * }
     */
    public static MethodHandle glGetAttachedShaders$handle() {
        return glGetAttachedShaders.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders)
     * }
     */
    public static MemorySegment glGetAttachedShaders$address() {
        return glGetAttachedShaders.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders)
     * }
     */
    public static void glGetAttachedShaders(int program, int maxCount, MemorySegment count, MemorySegment shaders) {
        var mh$ = glGetAttachedShaders.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetAttachedShaders", program, maxCount, count, shaders);
            }
            mh$.invokeExact(program, maxCount, count, shaders);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetShaderInfoLog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetShaderInfoLog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetShaderInfoLog(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog)
     * }
     */
    public static FunctionDescriptor glGetShaderInfoLog$descriptor() {
        return glGetShaderInfoLog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetShaderInfoLog(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog)
     * }
     */
    public static MethodHandle glGetShaderInfoLog$handle() {
        return glGetShaderInfoLog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetShaderInfoLog(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog)
     * }
     */
    public static MemorySegment glGetShaderInfoLog$address() {
        return glGetShaderInfoLog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetShaderInfoLog(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog)
     * }
     */
    public static void glGetShaderInfoLog(int shader, int bufSize, MemorySegment length, MemorySegment infoLog) {
        var mh$ = glGetShaderInfoLog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetShaderInfoLog", shader, bufSize, length, infoLog);
            }
            mh$.invokeExact(shader, bufSize, length, infoLog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetProgramInfoLog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetProgramInfoLog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetProgramInfoLog(GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog)
     * }
     */
    public static FunctionDescriptor glGetProgramInfoLog$descriptor() {
        return glGetProgramInfoLog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetProgramInfoLog(GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog)
     * }
     */
    public static MethodHandle glGetProgramInfoLog$handle() {
        return glGetProgramInfoLog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetProgramInfoLog(GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog)
     * }
     */
    public static MemorySegment glGetProgramInfoLog$address() {
        return glGetProgramInfoLog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetProgramInfoLog(GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog)
     * }
     */
    public static void glGetProgramInfoLog(int program, int bufSize, MemorySegment length, MemorySegment infoLog) {
        var mh$ = glGetProgramInfoLog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetProgramInfoLog", program, bufSize, length, infoLog);
            }
            mh$.invokeExact(program, bufSize, length, infoLog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetUniformLocation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetUniformLocation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLint glGetUniformLocation(GLuint program, const GLchar *name)
     * }
     */
    public static FunctionDescriptor glGetUniformLocation$descriptor() {
        return glGetUniformLocation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLint glGetUniformLocation(GLuint program, const GLchar *name)
     * }
     */
    public static MethodHandle glGetUniformLocation$handle() {
        return glGetUniformLocation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLint glGetUniformLocation(GLuint program, const GLchar *name)
     * }
     */
    public static MemorySegment glGetUniformLocation$address() {
        return glGetUniformLocation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLint glGetUniformLocation(GLuint program, const GLchar *name)
     * }
     */
    public static int glGetUniformLocation(int program, MemorySegment name) {
        var mh$ = glGetUniformLocation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetUniformLocation", program, name);
            }
            return (int)mh$.invokeExact(program, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetActiveUniform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetActiveUniform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)
     * }
     */
    public static FunctionDescriptor glGetActiveUniform$descriptor() {
        return glGetActiveUniform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)
     * }
     */
    public static MethodHandle glGetActiveUniform$handle() {
        return glGetActiveUniform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)
     * }
     */
    public static MemorySegment glGetActiveUniform$address() {
        return glGetActiveUniform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)
     * }
     */
    public static void glGetActiveUniform(int program, int index, int bufSize, MemorySegment length, MemorySegment size, MemorySegment type, MemorySegment name) {
        var mh$ = glGetActiveUniform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetActiveUniform", program, index, bufSize, length, size, type, name);
            }
            mh$.invokeExact(program, index, bufSize, length, size, type, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetUniformfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetUniformfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetUniformfv(GLuint program, GLint location, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetUniformfv$descriptor() {
        return glGetUniformfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetUniformfv(GLuint program, GLint location, GLfloat *params)
     * }
     */
    public static MethodHandle glGetUniformfv$handle() {
        return glGetUniformfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetUniformfv(GLuint program, GLint location, GLfloat *params)
     * }
     */
    public static MemorySegment glGetUniformfv$address() {
        return glGetUniformfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetUniformfv(GLuint program, GLint location, GLfloat *params)
     * }
     */
    public static void glGetUniformfv(int program, int location, MemorySegment params) {
        var mh$ = glGetUniformfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetUniformfv", program, location, params);
            }
            mh$.invokeExact(program, location, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetUniformiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetUniformiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetUniformiv(GLuint program, GLint location, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetUniformiv$descriptor() {
        return glGetUniformiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetUniformiv(GLuint program, GLint location, GLint *params)
     * }
     */
    public static MethodHandle glGetUniformiv$handle() {
        return glGetUniformiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetUniformiv(GLuint program, GLint location, GLint *params)
     * }
     */
    public static MemorySegment glGetUniformiv$address() {
        return glGetUniformiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetUniformiv(GLuint program, GLint location, GLint *params)
     * }
     */
    public static void glGetUniformiv(int program, int location, MemorySegment params) {
        var mh$ = glGetUniformiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetUniformiv", program, location, params);
            }
            mh$.invokeExact(program, location, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetShaderSource {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetShaderSource");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetShaderSource(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source)
     * }
     */
    public static FunctionDescriptor glGetShaderSource$descriptor() {
        return glGetShaderSource.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetShaderSource(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source)
     * }
     */
    public static MethodHandle glGetShaderSource$handle() {
        return glGetShaderSource.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetShaderSource(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source)
     * }
     */
    public static MemorySegment glGetShaderSource$address() {
        return glGetShaderSource.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetShaderSource(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source)
     * }
     */
    public static void glGetShaderSource(int shader, int bufSize, MemorySegment length, MemorySegment source) {
        var mh$ = glGetShaderSource.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetShaderSource", shader, bufSize, length, source);
            }
            mh$.invokeExact(shader, bufSize, length, source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBindAttribLocation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glBindAttribLocation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glBindAttribLocation(GLuint program, GLuint index, const GLchar *name)
     * }
     */
    public static FunctionDescriptor glBindAttribLocation$descriptor() {
        return glBindAttribLocation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glBindAttribLocation(GLuint program, GLuint index, const GLchar *name)
     * }
     */
    public static MethodHandle glBindAttribLocation$handle() {
        return glBindAttribLocation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glBindAttribLocation(GLuint program, GLuint index, const GLchar *name)
     * }
     */
    public static MemorySegment glBindAttribLocation$address() {
        return glBindAttribLocation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glBindAttribLocation(GLuint program, GLuint index, const GLchar *name)
     * }
     */
    public static void glBindAttribLocation(int program, int index, MemorySegment name) {
        var mh$ = glBindAttribLocation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBindAttribLocation", program, index, name);
            }
            mh$.invokeExact(program, index, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetActiveAttrib {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetActiveAttrib");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)
     * }
     */
    public static FunctionDescriptor glGetActiveAttrib$descriptor() {
        return glGetActiveAttrib.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)
     * }
     */
    public static MethodHandle glGetActiveAttrib$handle() {
        return glGetActiveAttrib.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)
     * }
     */
    public static MemorySegment glGetActiveAttrib$address() {
        return glGetActiveAttrib.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)
     * }
     */
    public static void glGetActiveAttrib(int program, int index, int bufSize, MemorySegment length, MemorySegment size, MemorySegment type, MemorySegment name) {
        var mh$ = glGetActiveAttrib.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetActiveAttrib", program, index, bufSize, length, size, type, name);
            }
            mh$.invokeExact(program, index, bufSize, length, size, type, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

