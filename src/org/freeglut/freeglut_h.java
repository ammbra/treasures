// Generated by jextract

package org.freeglut;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class freeglut_h extends freeglut_h_1 {

    freeglut_h() {
        // Should not be called directly
    }

    private static class glGetAttribLocation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glGetAttribLocation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLint glGetAttribLocation(GLuint program, const GLchar *name)
     * }
     */
    public static FunctionDescriptor glGetAttribLocation$descriptor() {
        return glGetAttribLocation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLint glGetAttribLocation(GLuint program, const GLchar *name)
     * }
     */
    public static MethodHandle glGetAttribLocation$handle() {
        return glGetAttribLocation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLint glGetAttribLocation(GLuint program, const GLchar *name)
     * }
     */
    public static MemorySegment glGetAttribLocation$address() {
        return glGetAttribLocation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLint glGetAttribLocation(GLuint program, const GLchar *name)
     * }
     */
    public static int glGetAttribLocation(int program, MemorySegment name) {
        var mh$ = glGetAttribLocation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetAttribLocation", program, name);
            }
            return (int)mh$.invokeExact(program, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glStencilFuncSeparate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glStencilFuncSeparate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask)
     * }
     */
    public static FunctionDescriptor glStencilFuncSeparate$descriptor() {
        return glStencilFuncSeparate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask)
     * }
     */
    public static MethodHandle glStencilFuncSeparate$handle() {
        return glStencilFuncSeparate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask)
     * }
     */
    public static MemorySegment glStencilFuncSeparate$address() {
        return glStencilFuncSeparate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask)
     * }
     */
    public static void glStencilFuncSeparate(int face, int func, int ref, int mask) {
        var mh$ = glStencilFuncSeparate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glStencilFuncSeparate", face, func, ref, mask);
            }
            mh$.invokeExact(face, func, ref, mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glStencilOpSeparate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glStencilOpSeparate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glStencilOpSeparate(GLenum face, GLenum fail, GLenum zfail, GLenum zpass)
     * }
     */
    public static FunctionDescriptor glStencilOpSeparate$descriptor() {
        return glStencilOpSeparate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glStencilOpSeparate(GLenum face, GLenum fail, GLenum zfail, GLenum zpass)
     * }
     */
    public static MethodHandle glStencilOpSeparate$handle() {
        return glStencilOpSeparate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glStencilOpSeparate(GLenum face, GLenum fail, GLenum zfail, GLenum zpass)
     * }
     */
    public static MemorySegment glStencilOpSeparate$address() {
        return glStencilOpSeparate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glStencilOpSeparate(GLenum face, GLenum fail, GLenum zfail, GLenum zpass)
     * }
     */
    public static void glStencilOpSeparate(int face, int fail, int zfail, int zpass) {
        var mh$ = glStencilOpSeparate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glStencilOpSeparate", face, fail, zfail, zpass);
            }
            mh$.invokeExact(face, fail, zfail, zpass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glStencilMaskSeparate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glStencilMaskSeparate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glStencilMaskSeparate(GLenum face, GLuint mask)
     * }
     */
    public static FunctionDescriptor glStencilMaskSeparate$descriptor() {
        return glStencilMaskSeparate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glStencilMaskSeparate(GLenum face, GLuint mask)
     * }
     */
    public static MethodHandle glStencilMaskSeparate$handle() {
        return glStencilMaskSeparate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glStencilMaskSeparate(GLenum face, GLuint mask)
     * }
     */
    public static MemorySegment glStencilMaskSeparate$address() {
        return glStencilMaskSeparate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glStencilMaskSeparate(GLenum face, GLuint mask)
     * }
     */
    public static void glStencilMaskSeparate(int face, int mask) {
        var mh$ = glStencilMaskSeparate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glStencilMaskSeparate", face, mask);
            }
            mh$.invokeExact(face, mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniformMatrix2x3fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniformMatrix2x3fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static FunctionDescriptor glUniformMatrix2x3fv$descriptor() {
        return glUniformMatrix2x3fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static MethodHandle glUniformMatrix2x3fv$handle() {
        return glUniformMatrix2x3fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static MemorySegment glUniformMatrix2x3fv$address() {
        return glUniformMatrix2x3fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static void glUniformMatrix2x3fv(int location, int count, byte transpose, MemorySegment value) {
        var mh$ = glUniformMatrix2x3fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniformMatrix2x3fv", location, count, transpose, value);
            }
            mh$.invokeExact(location, count, transpose, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniformMatrix3x2fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniformMatrix3x2fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static FunctionDescriptor glUniformMatrix3x2fv$descriptor() {
        return glUniformMatrix3x2fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static MethodHandle glUniformMatrix3x2fv$handle() {
        return glUniformMatrix3x2fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static MemorySegment glUniformMatrix3x2fv$address() {
        return glUniformMatrix3x2fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static void glUniformMatrix3x2fv(int location, int count, byte transpose, MemorySegment value) {
        var mh$ = glUniformMatrix3x2fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniformMatrix3x2fv", location, count, transpose, value);
            }
            mh$.invokeExact(location, count, transpose, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniformMatrix2x4fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniformMatrix2x4fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static FunctionDescriptor glUniformMatrix2x4fv$descriptor() {
        return glUniformMatrix2x4fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static MethodHandle glUniformMatrix2x4fv$handle() {
        return glUniformMatrix2x4fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static MemorySegment glUniformMatrix2x4fv$address() {
        return glUniformMatrix2x4fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static void glUniformMatrix2x4fv(int location, int count, byte transpose, MemorySegment value) {
        var mh$ = glUniformMatrix2x4fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniformMatrix2x4fv", location, count, transpose, value);
            }
            mh$.invokeExact(location, count, transpose, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniformMatrix4x2fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniformMatrix4x2fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static FunctionDescriptor glUniformMatrix4x2fv$descriptor() {
        return glUniformMatrix4x2fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static MethodHandle glUniformMatrix4x2fv$handle() {
        return glUniformMatrix4x2fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static MemorySegment glUniformMatrix4x2fv$address() {
        return glUniformMatrix4x2fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static void glUniformMatrix4x2fv(int location, int count, byte transpose, MemorySegment value) {
        var mh$ = glUniformMatrix4x2fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniformMatrix4x2fv", location, count, transpose, value);
            }
            mh$.invokeExact(location, count, transpose, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniformMatrix3x4fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniformMatrix3x4fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static FunctionDescriptor glUniformMatrix3x4fv$descriptor() {
        return glUniformMatrix3x4fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static MethodHandle glUniformMatrix3x4fv$handle() {
        return glUniformMatrix3x4fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static MemorySegment glUniformMatrix3x4fv$address() {
        return glUniformMatrix3x4fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static void glUniformMatrix3x4fv(int location, int count, byte transpose, MemorySegment value) {
        var mh$ = glUniformMatrix3x4fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniformMatrix3x4fv", location, count, transpose, value);
            }
            mh$.invokeExact(location, count, transpose, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glUniformMatrix4x3fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glUniformMatrix4x3fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static FunctionDescriptor glUniformMatrix4x3fv$descriptor() {
        return glUniformMatrix4x3fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static MethodHandle glUniformMatrix4x3fv$handle() {
        return glUniformMatrix4x3fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static MemorySegment glUniformMatrix4x3fv$address() {
        return glUniformMatrix4x3fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
     * }
     */
    public static void glUniformMatrix4x3fv(int location, int count, byte transpose, MemorySegment value) {
        var mh$ = glUniformMatrix4x3fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glUniformMatrix4x3fv", location, count, transpose, value);
            }
            mh$.invokeExact(location, count, transpose, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluBeginCurve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluBeginCurve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gluBeginCurve(GLUnurbs *nurb)
     * }
     */
    public static FunctionDescriptor gluBeginCurve$descriptor() {
        return gluBeginCurve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gluBeginCurve(GLUnurbs *nurb)
     * }
     */
    public static MethodHandle gluBeginCurve$handle() {
        return gluBeginCurve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gluBeginCurve(GLUnurbs *nurb)
     * }
     */
    public static MemorySegment gluBeginCurve$address() {
        return gluBeginCurve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gluBeginCurve(GLUnurbs *nurb)
     * }
     */
    public static void gluBeginCurve(MemorySegment nurb) {
        var mh$ = gluBeginCurve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluBeginCurve", nurb);
            }
            mh$.invokeExact(nurb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluBeginPolygon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluBeginPolygon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gluBeginPolygon(GLUtesselator *tess)
     * }
     */
    public static FunctionDescriptor gluBeginPolygon$descriptor() {
        return gluBeginPolygon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gluBeginPolygon(GLUtesselator *tess)
     * }
     */
    public static MethodHandle gluBeginPolygon$handle() {
        return gluBeginPolygon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gluBeginPolygon(GLUtesselator *tess)
     * }
     */
    public static MemorySegment gluBeginPolygon$address() {
        return gluBeginPolygon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gluBeginPolygon(GLUtesselator *tess)
     * }
     */
    public static void gluBeginPolygon(MemorySegment tess) {
        var mh$ = gluBeginPolygon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluBeginPolygon", tess);
            }
            mh$.invokeExact(tess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluBeginSurface {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluBeginSurface");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gluBeginSurface(GLUnurbs *nurb)
     * }
     */
    public static FunctionDescriptor gluBeginSurface$descriptor() {
        return gluBeginSurface.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gluBeginSurface(GLUnurbs *nurb)
     * }
     */
    public static MethodHandle gluBeginSurface$handle() {
        return gluBeginSurface.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gluBeginSurface(GLUnurbs *nurb)
     * }
     */
    public static MemorySegment gluBeginSurface$address() {
        return gluBeginSurface.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gluBeginSurface(GLUnurbs *nurb)
     * }
     */
    public static void gluBeginSurface(MemorySegment nurb) {
        var mh$ = gluBeginSurface.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluBeginSurface", nurb);
            }
            mh$.invokeExact(nurb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluBeginTrim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluBeginTrim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gluBeginTrim(GLUnurbs *nurb)
     * }
     */
    public static FunctionDescriptor gluBeginTrim$descriptor() {
        return gluBeginTrim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gluBeginTrim(GLUnurbs *nurb)
     * }
     */
    public static MethodHandle gluBeginTrim$handle() {
        return gluBeginTrim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gluBeginTrim(GLUnurbs *nurb)
     * }
     */
    public static MemorySegment gluBeginTrim$address() {
        return gluBeginTrim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gluBeginTrim(GLUnurbs *nurb)
     * }
     */
    public static void gluBeginTrim(MemorySegment nurb) {
        var mh$ = gluBeginTrim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluBeginTrim", nurb);
            }
            mh$.invokeExact(nurb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluBuild1DMipmapLevels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluBuild1DMipmapLevels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLint gluBuild1DMipmapLevels(GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data)
     * }
     */
    public static FunctionDescriptor gluBuild1DMipmapLevels$descriptor() {
        return gluBuild1DMipmapLevels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLint gluBuild1DMipmapLevels(GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data)
     * }
     */
    public static MethodHandle gluBuild1DMipmapLevels$handle() {
        return gluBuild1DMipmapLevels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLint gluBuild1DMipmapLevels(GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data)
     * }
     */
    public static MemorySegment gluBuild1DMipmapLevels$address() {
        return gluBuild1DMipmapLevels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLint gluBuild1DMipmapLevels(GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data)
     * }
     */
    public static int gluBuild1DMipmapLevels(int target, int internalFormat, int width, int format, int type, int level, int base, int max, MemorySegment data) {
        var mh$ = gluBuild1DMipmapLevels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluBuild1DMipmapLevels", target, internalFormat, width, format, type, level, base, max, data);
            }
            return (int)mh$.invokeExact(target, internalFormat, width, format, type, level, base, max, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluBuild1DMipmaps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluBuild1DMipmaps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLint gluBuild1DMipmaps(GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void *data)
     * }
     */
    public static FunctionDescriptor gluBuild1DMipmaps$descriptor() {
        return gluBuild1DMipmaps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLint gluBuild1DMipmaps(GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void *data)
     * }
     */
    public static MethodHandle gluBuild1DMipmaps$handle() {
        return gluBuild1DMipmaps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLint gluBuild1DMipmaps(GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void *data)
     * }
     */
    public static MemorySegment gluBuild1DMipmaps$address() {
        return gluBuild1DMipmaps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLint gluBuild1DMipmaps(GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void *data)
     * }
     */
    public static int gluBuild1DMipmaps(int target, int internalFormat, int width, int format, int type, MemorySegment data) {
        var mh$ = gluBuild1DMipmaps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluBuild1DMipmaps", target, internalFormat, width, format, type, data);
            }
            return (int)mh$.invokeExact(target, internalFormat, width, format, type, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluBuild2DMipmapLevels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluBuild2DMipmapLevels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLint gluBuild2DMipmapLevels(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data)
     * }
     */
    public static FunctionDescriptor gluBuild2DMipmapLevels$descriptor() {
        return gluBuild2DMipmapLevels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLint gluBuild2DMipmapLevels(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data)
     * }
     */
    public static MethodHandle gluBuild2DMipmapLevels$handle() {
        return gluBuild2DMipmapLevels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLint gluBuild2DMipmapLevels(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data)
     * }
     */
    public static MemorySegment gluBuild2DMipmapLevels$address() {
        return gluBuild2DMipmapLevels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLint gluBuild2DMipmapLevels(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data)
     * }
     */
    public static int gluBuild2DMipmapLevels(int target, int internalFormat, int width, int height, int format, int type, int level, int base, int max, MemorySegment data) {
        var mh$ = gluBuild2DMipmapLevels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluBuild2DMipmapLevels", target, internalFormat, width, height, format, type, level, base, max, data);
            }
            return (int)mh$.invokeExact(target, internalFormat, width, height, format, type, level, base, max, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluBuild2DMipmaps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluBuild2DMipmaps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLint gluBuild2DMipmaps(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *data)
     * }
     */
    public static FunctionDescriptor gluBuild2DMipmaps$descriptor() {
        return gluBuild2DMipmaps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLint gluBuild2DMipmaps(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *data)
     * }
     */
    public static MethodHandle gluBuild2DMipmaps$handle() {
        return gluBuild2DMipmaps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLint gluBuild2DMipmaps(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *data)
     * }
     */
    public static MemorySegment gluBuild2DMipmaps$address() {
        return gluBuild2DMipmaps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLint gluBuild2DMipmaps(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *data)
     * }
     */
    public static int gluBuild2DMipmaps(int target, int internalFormat, int width, int height, int format, int type, MemorySegment data) {
        var mh$ = gluBuild2DMipmaps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluBuild2DMipmaps", target, internalFormat, width, height, format, type, data);
            }
            return (int)mh$.invokeExact(target, internalFormat, width, height, format, type, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluBuild3DMipmapLevels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluBuild3DMipmapLevels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLint gluBuild3DMipmapLevels(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data)
     * }
     */
    public static FunctionDescriptor gluBuild3DMipmapLevels$descriptor() {
        return gluBuild3DMipmapLevels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLint gluBuild3DMipmapLevels(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data)
     * }
     */
    public static MethodHandle gluBuild3DMipmapLevels$handle() {
        return gluBuild3DMipmapLevels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLint gluBuild3DMipmapLevels(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data)
     * }
     */
    public static MemorySegment gluBuild3DMipmapLevels$address() {
        return gluBuild3DMipmapLevels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLint gluBuild3DMipmapLevels(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data)
     * }
     */
    public static int gluBuild3DMipmapLevels(int target, int internalFormat, int width, int height, int depth, int format, int type, int level, int base, int max, MemorySegment data) {
        var mh$ = gluBuild3DMipmapLevels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluBuild3DMipmapLevels", target, internalFormat, width, height, depth, format, type, level, base, max, data);
            }
            return (int)mh$.invokeExact(target, internalFormat, width, height, depth, format, type, level, base, max, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluBuild3DMipmaps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluBuild3DMipmaps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLint gluBuild3DMipmaps(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data)
     * }
     */
    public static FunctionDescriptor gluBuild3DMipmaps$descriptor() {
        return gluBuild3DMipmaps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLint gluBuild3DMipmaps(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data)
     * }
     */
    public static MethodHandle gluBuild3DMipmaps$handle() {
        return gluBuild3DMipmaps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLint gluBuild3DMipmaps(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data)
     * }
     */
    public static MemorySegment gluBuild3DMipmaps$address() {
        return gluBuild3DMipmaps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLint gluBuild3DMipmaps(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data)
     * }
     */
    public static int gluBuild3DMipmaps(int target, int internalFormat, int width, int height, int depth, int format, int type, MemorySegment data) {
        var mh$ = gluBuild3DMipmaps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluBuild3DMipmaps", target, internalFormat, width, height, depth, format, type, data);
            }
            return (int)mh$.invokeExact(target, internalFormat, width, height, depth, format, type, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluCheckExtension {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_CHAR,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluCheckExtension");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLboolean gluCheckExtension(const GLubyte *extName, const GLubyte *extString)
     * }
     */
    public static FunctionDescriptor gluCheckExtension$descriptor() {
        return gluCheckExtension.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLboolean gluCheckExtension(const GLubyte *extName, const GLubyte *extString)
     * }
     */
    public static MethodHandle gluCheckExtension$handle() {
        return gluCheckExtension.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLboolean gluCheckExtension(const GLubyte *extName, const GLubyte *extString)
     * }
     */
    public static MemorySegment gluCheckExtension$address() {
        return gluCheckExtension.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLboolean gluCheckExtension(const GLubyte *extName, const GLubyte *extString)
     * }
     */
    public static byte gluCheckExtension(MemorySegment extName, MemorySegment extString) {
        var mh$ = gluCheckExtension.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluCheckExtension", extName, extString);
            }
            return (byte)mh$.invokeExact(extName, extString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluCylinder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluCylinder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gluCylinder(GLUquadric *quad, GLdouble base, GLdouble top, GLdouble height, GLint slices, GLint stacks)
     * }
     */
    public static FunctionDescriptor gluCylinder$descriptor() {
        return gluCylinder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gluCylinder(GLUquadric *quad, GLdouble base, GLdouble top, GLdouble height, GLint slices, GLint stacks)
     * }
     */
    public static MethodHandle gluCylinder$handle() {
        return gluCylinder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gluCylinder(GLUquadric *quad, GLdouble base, GLdouble top, GLdouble height, GLint slices, GLint stacks)
     * }
     */
    public static MemorySegment gluCylinder$address() {
        return gluCylinder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gluCylinder(GLUquadric *quad, GLdouble base, GLdouble top, GLdouble height, GLint slices, GLint stacks)
     * }
     */
    public static void gluCylinder(MemorySegment quad, double base, double top, double height, int slices, int stacks) {
        var mh$ = gluCylinder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluCylinder", quad, base, top, height, slices, stacks);
            }
            mh$.invokeExact(quad, base, top, height, slices, stacks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluDeleteNurbsRenderer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluDeleteNurbsRenderer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gluDeleteNurbsRenderer(GLUnurbs *nurb)
     * }
     */
    public static FunctionDescriptor gluDeleteNurbsRenderer$descriptor() {
        return gluDeleteNurbsRenderer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gluDeleteNurbsRenderer(GLUnurbs *nurb)
     * }
     */
    public static MethodHandle gluDeleteNurbsRenderer$handle() {
        return gluDeleteNurbsRenderer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gluDeleteNurbsRenderer(GLUnurbs *nurb)
     * }
     */
    public static MemorySegment gluDeleteNurbsRenderer$address() {
        return gluDeleteNurbsRenderer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gluDeleteNurbsRenderer(GLUnurbs *nurb)
     * }
     */
    public static void gluDeleteNurbsRenderer(MemorySegment nurb) {
        var mh$ = gluDeleteNurbsRenderer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluDeleteNurbsRenderer", nurb);
            }
            mh$.invokeExact(nurb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluDeleteQuadric {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluDeleteQuadric");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gluDeleteQuadric(GLUquadric *quad)
     * }
     */
    public static FunctionDescriptor gluDeleteQuadric$descriptor() {
        return gluDeleteQuadric.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gluDeleteQuadric(GLUquadric *quad)
     * }
     */
    public static MethodHandle gluDeleteQuadric$handle() {
        return gluDeleteQuadric.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gluDeleteQuadric(GLUquadric *quad)
     * }
     */
    public static MemorySegment gluDeleteQuadric$address() {
        return gluDeleteQuadric.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gluDeleteQuadric(GLUquadric *quad)
     * }
     */
    public static void gluDeleteQuadric(MemorySegment quad) {
        var mh$ = gluDeleteQuadric.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluDeleteQuadric", quad);
            }
            mh$.invokeExact(quad);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluDeleteTess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluDeleteTess");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gluDeleteTess(GLUtesselator *tess)
     * }
     */
    public static FunctionDescriptor gluDeleteTess$descriptor() {
        return gluDeleteTess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gluDeleteTess(GLUtesselator *tess)
     * }
     */
    public static MethodHandle gluDeleteTess$handle() {
        return gluDeleteTess.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gluDeleteTess(GLUtesselator *tess)
     * }
     */
    public static MemorySegment gluDeleteTess$address() {
        return gluDeleteTess.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gluDeleteTess(GLUtesselator *tess)
     * }
     */
    public static void gluDeleteTess(MemorySegment tess) {
        var mh$ = gluDeleteTess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluDeleteTess", tess);
            }
            mh$.invokeExact(tess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluDisk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluDisk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gluDisk(GLUquadric *quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops)
     * }
     */
    public static FunctionDescriptor gluDisk$descriptor() {
        return gluDisk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gluDisk(GLUquadric *quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops)
     * }
     */
    public static MethodHandle gluDisk$handle() {
        return gluDisk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gluDisk(GLUquadric *quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops)
     * }
     */
    public static MemorySegment gluDisk$address() {
        return gluDisk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gluDisk(GLUquadric *quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops)
     * }
     */
    public static void gluDisk(MemorySegment quad, double inner, double outer, int slices, int loops) {
        var mh$ = gluDisk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluDisk", quad, inner, outer, slices, loops);
            }
            mh$.invokeExact(quad, inner, outer, slices, loops);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluEndCurve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluEndCurve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gluEndCurve(GLUnurbs *nurb)
     * }
     */
    public static FunctionDescriptor gluEndCurve$descriptor() {
        return gluEndCurve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gluEndCurve(GLUnurbs *nurb)
     * }
     */
    public static MethodHandle gluEndCurve$handle() {
        return gluEndCurve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gluEndCurve(GLUnurbs *nurb)
     * }
     */
    public static MemorySegment gluEndCurve$address() {
        return gluEndCurve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gluEndCurve(GLUnurbs *nurb)
     * }
     */
    public static void gluEndCurve(MemorySegment nurb) {
        var mh$ = gluEndCurve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluEndCurve", nurb);
            }
            mh$.invokeExact(nurb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluEndPolygon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluEndPolygon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gluEndPolygon(GLUtesselator *tess)
     * }
     */
    public static FunctionDescriptor gluEndPolygon$descriptor() {
        return gluEndPolygon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gluEndPolygon(GLUtesselator *tess)
     * }
     */
    public static MethodHandle gluEndPolygon$handle() {
        return gluEndPolygon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gluEndPolygon(GLUtesselator *tess)
     * }
     */
    public static MemorySegment gluEndPolygon$address() {
        return gluEndPolygon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gluEndPolygon(GLUtesselator *tess)
     * }
     */
    public static void gluEndPolygon(MemorySegment tess) {
        var mh$ = gluEndPolygon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluEndPolygon", tess);
            }
            mh$.invokeExact(tess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluEndSurface {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluEndSurface");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gluEndSurface(GLUnurbs *nurb)
     * }
     */
    public static FunctionDescriptor gluEndSurface$descriptor() {
        return gluEndSurface.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gluEndSurface(GLUnurbs *nurb)
     * }
     */
    public static MethodHandle gluEndSurface$handle() {
        return gluEndSurface.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gluEndSurface(GLUnurbs *nurb)
     * }
     */
    public static MemorySegment gluEndSurface$address() {
        return gluEndSurface.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gluEndSurface(GLUnurbs *nurb)
     * }
     */
    public static void gluEndSurface(MemorySegment nurb) {
        var mh$ = gluEndSurface.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluEndSurface", nurb);
            }
            mh$.invokeExact(nurb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluEndTrim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluEndTrim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gluEndTrim(GLUnurbs *nurb)
     * }
     */
    public static FunctionDescriptor gluEndTrim$descriptor() {
        return gluEndTrim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gluEndTrim(GLUnurbs *nurb)
     * }
     */
    public static MethodHandle gluEndTrim$handle() {
        return gluEndTrim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gluEndTrim(GLUnurbs *nurb)
     * }
     */
    public static MemorySegment gluEndTrim$address() {
        return gluEndTrim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gluEndTrim(GLUnurbs *nurb)
     * }
     */
    public static void gluEndTrim(MemorySegment nurb) {
        var mh$ = gluEndTrim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluEndTrim", nurb);
            }
            mh$.invokeExact(nurb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluErrorString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluErrorString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const GLubyte *gluErrorString(GLenum error)
     * }
     */
    public static FunctionDescriptor gluErrorString$descriptor() {
        return gluErrorString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const GLubyte *gluErrorString(GLenum error)
     * }
     */
    public static MethodHandle gluErrorString$handle() {
        return gluErrorString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const GLubyte *gluErrorString(GLenum error)
     * }
     */
    public static MemorySegment gluErrorString$address() {
        return gluErrorString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const GLubyte *gluErrorString(GLenum error)
     * }
     */
    public static MemorySegment gluErrorString(int error) {
        var mh$ = gluErrorString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluErrorString", error);
            }
            return (MemorySegment)mh$.invokeExact(error);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluGetNurbsProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluGetNurbsProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gluGetNurbsProperty(GLUnurbs *nurb, GLenum property, GLfloat *data)
     * }
     */
    public static FunctionDescriptor gluGetNurbsProperty$descriptor() {
        return gluGetNurbsProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gluGetNurbsProperty(GLUnurbs *nurb, GLenum property, GLfloat *data)
     * }
     */
    public static MethodHandle gluGetNurbsProperty$handle() {
        return gluGetNurbsProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gluGetNurbsProperty(GLUnurbs *nurb, GLenum property, GLfloat *data)
     * }
     */
    public static MemorySegment gluGetNurbsProperty$address() {
        return gluGetNurbsProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gluGetNurbsProperty(GLUnurbs *nurb, GLenum property, GLfloat *data)
     * }
     */
    public static void gluGetNurbsProperty(MemorySegment nurb, int property, MemorySegment data) {
        var mh$ = gluGetNurbsProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluGetNurbsProperty", nurb, property, data);
            }
            mh$.invokeExact(nurb, property, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluGetString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluGetString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const GLubyte *gluGetString(GLenum name)
     * }
     */
    public static FunctionDescriptor gluGetString$descriptor() {
        return gluGetString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const GLubyte *gluGetString(GLenum name)
     * }
     */
    public static MethodHandle gluGetString$handle() {
        return gluGetString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const GLubyte *gluGetString(GLenum name)
     * }
     */
    public static MemorySegment gluGetString$address() {
        return gluGetString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const GLubyte *gluGetString(GLenum name)
     * }
     */
    public static MemorySegment gluGetString(int name) {
        var mh$ = gluGetString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluGetString", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluGetTessProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluGetTessProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gluGetTessProperty(GLUtesselator *tess, GLenum which, GLdouble *data)
     * }
     */
    public static FunctionDescriptor gluGetTessProperty$descriptor() {
        return gluGetTessProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gluGetTessProperty(GLUtesselator *tess, GLenum which, GLdouble *data)
     * }
     */
    public static MethodHandle gluGetTessProperty$handle() {
        return gluGetTessProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gluGetTessProperty(GLUtesselator *tess, GLenum which, GLdouble *data)
     * }
     */
    public static MemorySegment gluGetTessProperty$address() {
        return gluGetTessProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gluGetTessProperty(GLUtesselator *tess, GLenum which, GLdouble *data)
     * }
     */
    public static void gluGetTessProperty(MemorySegment tess, int which, MemorySegment data) {
        var mh$ = gluGetTessProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluGetTessProperty", tess, which, data);
            }
            mh$.invokeExact(tess, which, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluLoadSamplingMatrices {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluLoadSamplingMatrices");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gluLoadSamplingMatrices(GLUnurbs *nurb, const GLfloat *model, const GLfloat *perspective, const GLint *view)
     * }
     */
    public static FunctionDescriptor gluLoadSamplingMatrices$descriptor() {
        return gluLoadSamplingMatrices.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gluLoadSamplingMatrices(GLUnurbs *nurb, const GLfloat *model, const GLfloat *perspective, const GLint *view)
     * }
     */
    public static MethodHandle gluLoadSamplingMatrices$handle() {
        return gluLoadSamplingMatrices.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gluLoadSamplingMatrices(GLUnurbs *nurb, const GLfloat *model, const GLfloat *perspective, const GLint *view)
     * }
     */
    public static MemorySegment gluLoadSamplingMatrices$address() {
        return gluLoadSamplingMatrices.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gluLoadSamplingMatrices(GLUnurbs *nurb, const GLfloat *model, const GLfloat *perspective, const GLint *view)
     * }
     */
    public static void gluLoadSamplingMatrices(MemorySegment nurb, MemorySegment model, MemorySegment perspective, MemorySegment view) {
        var mh$ = gluLoadSamplingMatrices.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluLoadSamplingMatrices", nurb, model, perspective, view);
            }
            mh$.invokeExact(nurb, model, perspective, view);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluLookAt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluLookAt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gluLookAt(GLdouble eyeX, GLdouble eyeY, GLdouble eyeZ, GLdouble centerX, GLdouble centerY, GLdouble centerZ, GLdouble upX, GLdouble upY, GLdouble upZ)
     * }
     */
    public static FunctionDescriptor gluLookAt$descriptor() {
        return gluLookAt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gluLookAt(GLdouble eyeX, GLdouble eyeY, GLdouble eyeZ, GLdouble centerX, GLdouble centerY, GLdouble centerZ, GLdouble upX, GLdouble upY, GLdouble upZ)
     * }
     */
    public static MethodHandle gluLookAt$handle() {
        return gluLookAt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gluLookAt(GLdouble eyeX, GLdouble eyeY, GLdouble eyeZ, GLdouble centerX, GLdouble centerY, GLdouble centerZ, GLdouble upX, GLdouble upY, GLdouble upZ)
     * }
     */
    public static MemorySegment gluLookAt$address() {
        return gluLookAt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gluLookAt(GLdouble eyeX, GLdouble eyeY, GLdouble eyeZ, GLdouble centerX, GLdouble centerY, GLdouble centerZ, GLdouble upX, GLdouble upY, GLdouble upZ)
     * }
     */
    public static void gluLookAt(double eyeX, double eyeY, double eyeZ, double centerX, double centerY, double centerZ, double upX, double upY, double upZ) {
        var mh$ = gluLookAt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluLookAt", eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ);
            }
            mh$.invokeExact(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluNewNurbsRenderer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluNewNurbsRenderer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLUnurbs *gluNewNurbsRenderer()
     * }
     */
    public static FunctionDescriptor gluNewNurbsRenderer$descriptor() {
        return gluNewNurbsRenderer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLUnurbs *gluNewNurbsRenderer()
     * }
     */
    public static MethodHandle gluNewNurbsRenderer$handle() {
        return gluNewNurbsRenderer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLUnurbs *gluNewNurbsRenderer()
     * }
     */
    public static MemorySegment gluNewNurbsRenderer$address() {
        return gluNewNurbsRenderer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLUnurbs *gluNewNurbsRenderer()
     * }
     */
    public static MemorySegment gluNewNurbsRenderer() {
        var mh$ = gluNewNurbsRenderer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluNewNurbsRenderer");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluNewQuadric {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluNewQuadric");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLUquadric *gluNewQuadric()
     * }
     */
    public static FunctionDescriptor gluNewQuadric$descriptor() {
        return gluNewQuadric.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLUquadric *gluNewQuadric()
     * }
     */
    public static MethodHandle gluNewQuadric$handle() {
        return gluNewQuadric.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLUquadric *gluNewQuadric()
     * }
     */
    public static MemorySegment gluNewQuadric$address() {
        return gluNewQuadric.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLUquadric *gluNewQuadric()
     * }
     */
    public static MemorySegment gluNewQuadric() {
        var mh$ = gluNewQuadric.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluNewQuadric");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluNewTess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluNewTess");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLUtesselator *gluNewTess()
     * }
     */
    public static FunctionDescriptor gluNewTess$descriptor() {
        return gluNewTess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLUtesselator *gluNewTess()
     * }
     */
    public static MethodHandle gluNewTess$handle() {
        return gluNewTess.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLUtesselator *gluNewTess()
     * }
     */
    public static MemorySegment gluNewTess$address() {
        return gluNewTess.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLUtesselator *gluNewTess()
     * }
     */
    public static MemorySegment gluNewTess() {
        var mh$ = gluNewTess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluNewTess");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluNextContour {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluNextContour");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gluNextContour(GLUtesselator *tess, GLenum type)
     * }
     */
    public static FunctionDescriptor gluNextContour$descriptor() {
        return gluNextContour.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gluNextContour(GLUtesselator *tess, GLenum type)
     * }
     */
    public static MethodHandle gluNextContour$handle() {
        return gluNextContour.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gluNextContour(GLUtesselator *tess, GLenum type)
     * }
     */
    public static MemorySegment gluNextContour$address() {
        return gluNextContour.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gluNextContour(GLUtesselator *tess, GLenum type)
     * }
     */
    public static void gluNextContour(MemorySegment tess, int type) {
        var mh$ = gluNextContour.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluNextContour", tess, type);
            }
            mh$.invokeExact(tess, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluNurbsCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluNurbsCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gluNurbsCallback(GLUnurbs *nurb, GLenum which, GLvoid (*CallBackFunc)())
     * }
     */
    public static FunctionDescriptor gluNurbsCallback$descriptor() {
        return gluNurbsCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gluNurbsCallback(GLUnurbs *nurb, GLenum which, GLvoid (*CallBackFunc)())
     * }
     */
    public static MethodHandle gluNurbsCallback$handle() {
        return gluNurbsCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gluNurbsCallback(GLUnurbs *nurb, GLenum which, GLvoid (*CallBackFunc)())
     * }
     */
    public static MemorySegment gluNurbsCallback$address() {
        return gluNurbsCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gluNurbsCallback(GLUnurbs *nurb, GLenum which, GLvoid (*CallBackFunc)())
     * }
     */
    public static void gluNurbsCallback(MemorySegment nurb, int which, MemorySegment CallBackFunc) {
        var mh$ = gluNurbsCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluNurbsCallback", nurb, which, CallBackFunc);
            }
            mh$.invokeExact(nurb, which, CallBackFunc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluNurbsCallbackData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluNurbsCallbackData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gluNurbsCallbackData(GLUnurbs *nurb, GLvoid *userData)
     * }
     */
    public static FunctionDescriptor gluNurbsCallbackData$descriptor() {
        return gluNurbsCallbackData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gluNurbsCallbackData(GLUnurbs *nurb, GLvoid *userData)
     * }
     */
    public static MethodHandle gluNurbsCallbackData$handle() {
        return gluNurbsCallbackData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gluNurbsCallbackData(GLUnurbs *nurb, GLvoid *userData)
     * }
     */
    public static MemorySegment gluNurbsCallbackData$address() {
        return gluNurbsCallbackData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gluNurbsCallbackData(GLUnurbs *nurb, GLvoid *userData)
     * }
     */
    public static void gluNurbsCallbackData(MemorySegment nurb, MemorySegment userData) {
        var mh$ = gluNurbsCallbackData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluNurbsCallbackData", nurb, userData);
            }
            mh$.invokeExact(nurb, userData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluNurbsCallbackDataEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluNurbsCallbackDataEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gluNurbsCallbackDataEXT(GLUnurbs *nurb, GLvoid *userData)
     * }
     */
    public static FunctionDescriptor gluNurbsCallbackDataEXT$descriptor() {
        return gluNurbsCallbackDataEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gluNurbsCallbackDataEXT(GLUnurbs *nurb, GLvoid *userData)
     * }
     */
    public static MethodHandle gluNurbsCallbackDataEXT$handle() {
        return gluNurbsCallbackDataEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gluNurbsCallbackDataEXT(GLUnurbs *nurb, GLvoid *userData)
     * }
     */
    public static MemorySegment gluNurbsCallbackDataEXT$address() {
        return gluNurbsCallbackDataEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gluNurbsCallbackDataEXT(GLUnurbs *nurb, GLvoid *userData)
     * }
     */
    public static void gluNurbsCallbackDataEXT(MemorySegment nurb, MemorySegment userData) {
        var mh$ = gluNurbsCallbackDataEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluNurbsCallbackDataEXT", nurb, userData);
            }
            mh$.invokeExact(nurb, userData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluNurbsCurve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluNurbsCurve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gluNurbsCurve(GLUnurbs *nurb, GLint knotCount, GLfloat *knots, GLint stride, GLfloat *control, GLint order, GLenum type)
     * }
     */
    public static FunctionDescriptor gluNurbsCurve$descriptor() {
        return gluNurbsCurve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gluNurbsCurve(GLUnurbs *nurb, GLint knotCount, GLfloat *knots, GLint stride, GLfloat *control, GLint order, GLenum type)
     * }
     */
    public static MethodHandle gluNurbsCurve$handle() {
        return gluNurbsCurve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gluNurbsCurve(GLUnurbs *nurb, GLint knotCount, GLfloat *knots, GLint stride, GLfloat *control, GLint order, GLenum type)
     * }
     */
    public static MemorySegment gluNurbsCurve$address() {
        return gluNurbsCurve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gluNurbsCurve(GLUnurbs *nurb, GLint knotCount, GLfloat *knots, GLint stride, GLfloat *control, GLint order, GLenum type)
     * }
     */
    public static void gluNurbsCurve(MemorySegment nurb, int knotCount, MemorySegment knots, int stride, MemorySegment control, int order, int type) {
        var mh$ = gluNurbsCurve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluNurbsCurve", nurb, knotCount, knots, stride, control, order, type);
            }
            mh$.invokeExact(nurb, knotCount, knots, stride, control, order, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluNurbsProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluNurbsProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gluNurbsProperty(GLUnurbs *nurb, GLenum property, GLfloat value)
     * }
     */
    public static FunctionDescriptor gluNurbsProperty$descriptor() {
        return gluNurbsProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gluNurbsProperty(GLUnurbs *nurb, GLenum property, GLfloat value)
     * }
     */
    public static MethodHandle gluNurbsProperty$handle() {
        return gluNurbsProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gluNurbsProperty(GLUnurbs *nurb, GLenum property, GLfloat value)
     * }
     */
    public static MemorySegment gluNurbsProperty$address() {
        return gluNurbsProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gluNurbsProperty(GLUnurbs *nurb, GLenum property, GLfloat value)
     * }
     */
    public static void gluNurbsProperty(MemorySegment nurb, int property, float value) {
        var mh$ = gluNurbsProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluNurbsProperty", nurb, property, value);
            }
            mh$.invokeExact(nurb, property, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluNurbsSurface {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluNurbsSurface");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gluNurbsSurface(GLUnurbs *nurb, GLint sKnotCount, GLfloat *sKnots, GLint tKnotCount, GLfloat *tKnots, GLint sStride, GLint tStride, GLfloat *control, GLint sOrder, GLint tOrder, GLenum type)
     * }
     */
    public static FunctionDescriptor gluNurbsSurface$descriptor() {
        return gluNurbsSurface.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gluNurbsSurface(GLUnurbs *nurb, GLint sKnotCount, GLfloat *sKnots, GLint tKnotCount, GLfloat *tKnots, GLint sStride, GLint tStride, GLfloat *control, GLint sOrder, GLint tOrder, GLenum type)
     * }
     */
    public static MethodHandle gluNurbsSurface$handle() {
        return gluNurbsSurface.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gluNurbsSurface(GLUnurbs *nurb, GLint sKnotCount, GLfloat *sKnots, GLint tKnotCount, GLfloat *tKnots, GLint sStride, GLint tStride, GLfloat *control, GLint sOrder, GLint tOrder, GLenum type)
     * }
     */
    public static MemorySegment gluNurbsSurface$address() {
        return gluNurbsSurface.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gluNurbsSurface(GLUnurbs *nurb, GLint sKnotCount, GLfloat *sKnots, GLint tKnotCount, GLfloat *tKnots, GLint sStride, GLint tStride, GLfloat *control, GLint sOrder, GLint tOrder, GLenum type)
     * }
     */
    public static void gluNurbsSurface(MemorySegment nurb, int sKnotCount, MemorySegment sKnots, int tKnotCount, MemorySegment tKnots, int sStride, int tStride, MemorySegment control, int sOrder, int tOrder, int type) {
        var mh$ = gluNurbsSurface.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluNurbsSurface", nurb, sKnotCount, sKnots, tKnotCount, tKnots, sStride, tStride, control, sOrder, tOrder, type);
            }
            mh$.invokeExact(nurb, sKnotCount, sKnots, tKnotCount, tKnots, sStride, tStride, control, sOrder, tOrder, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluOrtho2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluOrtho2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gluOrtho2D(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top)
     * }
     */
    public static FunctionDescriptor gluOrtho2D$descriptor() {
        return gluOrtho2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gluOrtho2D(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top)
     * }
     */
    public static MethodHandle gluOrtho2D$handle() {
        return gluOrtho2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gluOrtho2D(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top)
     * }
     */
    public static MemorySegment gluOrtho2D$address() {
        return gluOrtho2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gluOrtho2D(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top)
     * }
     */
    public static void gluOrtho2D(double left, double right, double bottom, double top) {
        var mh$ = gluOrtho2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluOrtho2D", left, right, bottom, top);
            }
            mh$.invokeExact(left, right, bottom, top);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluPartialDisk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluPartialDisk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gluPartialDisk(GLUquadric *quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops, GLdouble start, GLdouble sweep)
     * }
     */
    public static FunctionDescriptor gluPartialDisk$descriptor() {
        return gluPartialDisk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gluPartialDisk(GLUquadric *quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops, GLdouble start, GLdouble sweep)
     * }
     */
    public static MethodHandle gluPartialDisk$handle() {
        return gluPartialDisk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gluPartialDisk(GLUquadric *quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops, GLdouble start, GLdouble sweep)
     * }
     */
    public static MemorySegment gluPartialDisk$address() {
        return gluPartialDisk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gluPartialDisk(GLUquadric *quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops, GLdouble start, GLdouble sweep)
     * }
     */
    public static void gluPartialDisk(MemorySegment quad, double inner, double outer, int slices, int loops, double start, double sweep) {
        var mh$ = gluPartialDisk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluPartialDisk", quad, inner, outer, slices, loops, start, sweep);
            }
            mh$.invokeExact(quad, inner, outer, slices, loops, start, sweep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluPerspective {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluPerspective");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gluPerspective(GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar)
     * }
     */
    public static FunctionDescriptor gluPerspective$descriptor() {
        return gluPerspective.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gluPerspective(GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar)
     * }
     */
    public static MethodHandle gluPerspective$handle() {
        return gluPerspective.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gluPerspective(GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar)
     * }
     */
    public static MemorySegment gluPerspective$address() {
        return gluPerspective.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gluPerspective(GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar)
     * }
     */
    public static void gluPerspective(double fovy, double aspect, double zNear, double zFar) {
        var mh$ = gluPerspective.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluPerspective", fovy, aspect, zNear, zFar);
            }
            mh$.invokeExact(fovy, aspect, zNear, zFar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluPickMatrix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluPickMatrix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gluPickMatrix(GLdouble x, GLdouble y, GLdouble delX, GLdouble delY, GLint *viewport)
     * }
     */
    public static FunctionDescriptor gluPickMatrix$descriptor() {
        return gluPickMatrix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gluPickMatrix(GLdouble x, GLdouble y, GLdouble delX, GLdouble delY, GLint *viewport)
     * }
     */
    public static MethodHandle gluPickMatrix$handle() {
        return gluPickMatrix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gluPickMatrix(GLdouble x, GLdouble y, GLdouble delX, GLdouble delY, GLint *viewport)
     * }
     */
    public static MemorySegment gluPickMatrix$address() {
        return gluPickMatrix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gluPickMatrix(GLdouble x, GLdouble y, GLdouble delX, GLdouble delY, GLint *viewport)
     * }
     */
    public static void gluPickMatrix(double x, double y, double delX, double delY, MemorySegment viewport) {
        var mh$ = gluPickMatrix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluPickMatrix", x, y, delX, delY, viewport);
            }
            mh$.invokeExact(x, y, delX, delY, viewport);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluProject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluProject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLint gluProject(GLdouble objX, GLdouble objY, GLdouble objZ, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble *winX, GLdouble *winY, GLdouble *winZ)
     * }
     */
    public static FunctionDescriptor gluProject$descriptor() {
        return gluProject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLint gluProject(GLdouble objX, GLdouble objY, GLdouble objZ, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble *winX, GLdouble *winY, GLdouble *winZ)
     * }
     */
    public static MethodHandle gluProject$handle() {
        return gluProject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLint gluProject(GLdouble objX, GLdouble objY, GLdouble objZ, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble *winX, GLdouble *winY, GLdouble *winZ)
     * }
     */
    public static MemorySegment gluProject$address() {
        return gluProject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLint gluProject(GLdouble objX, GLdouble objY, GLdouble objZ, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble *winX, GLdouble *winY, GLdouble *winZ)
     * }
     */
    public static int gluProject(double objX, double objY, double objZ, MemorySegment model, MemorySegment proj, MemorySegment view, MemorySegment winX, MemorySegment winY, MemorySegment winZ) {
        var mh$ = gluProject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluProject", objX, objY, objZ, model, proj, view, winX, winY, winZ);
            }
            return (int)mh$.invokeExact(objX, objY, objZ, model, proj, view, winX, winY, winZ);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluPwlCurve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluPwlCurve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gluPwlCurve(GLUnurbs *nurb, GLint count, GLfloat *data, GLint stride, GLenum type)
     * }
     */
    public static FunctionDescriptor gluPwlCurve$descriptor() {
        return gluPwlCurve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gluPwlCurve(GLUnurbs *nurb, GLint count, GLfloat *data, GLint stride, GLenum type)
     * }
     */
    public static MethodHandle gluPwlCurve$handle() {
        return gluPwlCurve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gluPwlCurve(GLUnurbs *nurb, GLint count, GLfloat *data, GLint stride, GLenum type)
     * }
     */
    public static MemorySegment gluPwlCurve$address() {
        return gluPwlCurve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gluPwlCurve(GLUnurbs *nurb, GLint count, GLfloat *data, GLint stride, GLenum type)
     * }
     */
    public static void gluPwlCurve(MemorySegment nurb, int count, MemorySegment data, int stride, int type) {
        var mh$ = gluPwlCurve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluPwlCurve", nurb, count, data, stride, type);
            }
            mh$.invokeExact(nurb, count, data, stride, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluQuadricCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluQuadricCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gluQuadricCallback(GLUquadric *quad, GLenum which, GLvoid (*CallBackFunc)())
     * }
     */
    public static FunctionDescriptor gluQuadricCallback$descriptor() {
        return gluQuadricCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gluQuadricCallback(GLUquadric *quad, GLenum which, GLvoid (*CallBackFunc)())
     * }
     */
    public static MethodHandle gluQuadricCallback$handle() {
        return gluQuadricCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gluQuadricCallback(GLUquadric *quad, GLenum which, GLvoid (*CallBackFunc)())
     * }
     */
    public static MemorySegment gluQuadricCallback$address() {
        return gluQuadricCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gluQuadricCallback(GLUquadric *quad, GLenum which, GLvoid (*CallBackFunc)())
     * }
     */
    public static void gluQuadricCallback(MemorySegment quad, int which, MemorySegment CallBackFunc) {
        var mh$ = gluQuadricCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluQuadricCallback", quad, which, CallBackFunc);
            }
            mh$.invokeExact(quad, which, CallBackFunc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluQuadricDrawStyle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluQuadricDrawStyle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gluQuadricDrawStyle(GLUquadric *quad, GLenum draw)
     * }
     */
    public static FunctionDescriptor gluQuadricDrawStyle$descriptor() {
        return gluQuadricDrawStyle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gluQuadricDrawStyle(GLUquadric *quad, GLenum draw)
     * }
     */
    public static MethodHandle gluQuadricDrawStyle$handle() {
        return gluQuadricDrawStyle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gluQuadricDrawStyle(GLUquadric *quad, GLenum draw)
     * }
     */
    public static MemorySegment gluQuadricDrawStyle$address() {
        return gluQuadricDrawStyle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gluQuadricDrawStyle(GLUquadric *quad, GLenum draw)
     * }
     */
    public static void gluQuadricDrawStyle(MemorySegment quad, int draw) {
        var mh$ = gluQuadricDrawStyle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluQuadricDrawStyle", quad, draw);
            }
            mh$.invokeExact(quad, draw);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluQuadricNormals {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluQuadricNormals");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gluQuadricNormals(GLUquadric *quad, GLenum normal)
     * }
     */
    public static FunctionDescriptor gluQuadricNormals$descriptor() {
        return gluQuadricNormals.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gluQuadricNormals(GLUquadric *quad, GLenum normal)
     * }
     */
    public static MethodHandle gluQuadricNormals$handle() {
        return gluQuadricNormals.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gluQuadricNormals(GLUquadric *quad, GLenum normal)
     * }
     */
    public static MemorySegment gluQuadricNormals$address() {
        return gluQuadricNormals.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gluQuadricNormals(GLUquadric *quad, GLenum normal)
     * }
     */
    public static void gluQuadricNormals(MemorySegment quad, int normal) {
        var mh$ = gluQuadricNormals.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluQuadricNormals", quad, normal);
            }
            mh$.invokeExact(quad, normal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluQuadricOrientation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluQuadricOrientation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gluQuadricOrientation(GLUquadric *quad, GLenum orientation)
     * }
     */
    public static FunctionDescriptor gluQuadricOrientation$descriptor() {
        return gluQuadricOrientation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gluQuadricOrientation(GLUquadric *quad, GLenum orientation)
     * }
     */
    public static MethodHandle gluQuadricOrientation$handle() {
        return gluQuadricOrientation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gluQuadricOrientation(GLUquadric *quad, GLenum orientation)
     * }
     */
    public static MemorySegment gluQuadricOrientation$address() {
        return gluQuadricOrientation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gluQuadricOrientation(GLUquadric *quad, GLenum orientation)
     * }
     */
    public static void gluQuadricOrientation(MemorySegment quad, int orientation) {
        var mh$ = gluQuadricOrientation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluQuadricOrientation", quad, orientation);
            }
            mh$.invokeExact(quad, orientation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluQuadricTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_CHAR
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluQuadricTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gluQuadricTexture(GLUquadric *quad, GLboolean texture)
     * }
     */
    public static FunctionDescriptor gluQuadricTexture$descriptor() {
        return gluQuadricTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gluQuadricTexture(GLUquadric *quad, GLboolean texture)
     * }
     */
    public static MethodHandle gluQuadricTexture$handle() {
        return gluQuadricTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gluQuadricTexture(GLUquadric *quad, GLboolean texture)
     * }
     */
    public static MemorySegment gluQuadricTexture$address() {
        return gluQuadricTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gluQuadricTexture(GLUquadric *quad, GLboolean texture)
     * }
     */
    public static void gluQuadricTexture(MemorySegment quad, byte texture) {
        var mh$ = gluQuadricTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluQuadricTexture", quad, texture);
            }
            mh$.invokeExact(quad, texture);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluScaleImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluScaleImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLint gluScaleImage(GLenum format, GLsizei wIn, GLsizei hIn, GLenum typeIn, const void *dataIn, GLsizei wOut, GLsizei hOut, GLenum typeOut, GLvoid *dataOut)
     * }
     */
    public static FunctionDescriptor gluScaleImage$descriptor() {
        return gluScaleImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLint gluScaleImage(GLenum format, GLsizei wIn, GLsizei hIn, GLenum typeIn, const void *dataIn, GLsizei wOut, GLsizei hOut, GLenum typeOut, GLvoid *dataOut)
     * }
     */
    public static MethodHandle gluScaleImage$handle() {
        return gluScaleImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLint gluScaleImage(GLenum format, GLsizei wIn, GLsizei hIn, GLenum typeIn, const void *dataIn, GLsizei wOut, GLsizei hOut, GLenum typeOut, GLvoid *dataOut)
     * }
     */
    public static MemorySegment gluScaleImage$address() {
        return gluScaleImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLint gluScaleImage(GLenum format, GLsizei wIn, GLsizei hIn, GLenum typeIn, const void *dataIn, GLsizei wOut, GLsizei hOut, GLenum typeOut, GLvoid *dataOut)
     * }
     */
    public static int gluScaleImage(int format, int wIn, int hIn, int typeIn, MemorySegment dataIn, int wOut, int hOut, int typeOut, MemorySegment dataOut) {
        var mh$ = gluScaleImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluScaleImage", format, wIn, hIn, typeIn, dataIn, wOut, hOut, typeOut, dataOut);
            }
            return (int)mh$.invokeExact(format, wIn, hIn, typeIn, dataIn, wOut, hOut, typeOut, dataOut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluSphere {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluSphere");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gluSphere(GLUquadric *quad, GLdouble radius, GLint slices, GLint stacks)
     * }
     */
    public static FunctionDescriptor gluSphere$descriptor() {
        return gluSphere.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gluSphere(GLUquadric *quad, GLdouble radius, GLint slices, GLint stacks)
     * }
     */
    public static MethodHandle gluSphere$handle() {
        return gluSphere.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gluSphere(GLUquadric *quad, GLdouble radius, GLint slices, GLint stacks)
     * }
     */
    public static MemorySegment gluSphere$address() {
        return gluSphere.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gluSphere(GLUquadric *quad, GLdouble radius, GLint slices, GLint stacks)
     * }
     */
    public static void gluSphere(MemorySegment quad, double radius, int slices, int stacks) {
        var mh$ = gluSphere.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluSphere", quad, radius, slices, stacks);
            }
            mh$.invokeExact(quad, radius, slices, stacks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluTessBeginContour {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluTessBeginContour");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gluTessBeginContour(GLUtesselator *tess)
     * }
     */
    public static FunctionDescriptor gluTessBeginContour$descriptor() {
        return gluTessBeginContour.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gluTessBeginContour(GLUtesselator *tess)
     * }
     */
    public static MethodHandle gluTessBeginContour$handle() {
        return gluTessBeginContour.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gluTessBeginContour(GLUtesselator *tess)
     * }
     */
    public static MemorySegment gluTessBeginContour$address() {
        return gluTessBeginContour.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gluTessBeginContour(GLUtesselator *tess)
     * }
     */
    public static void gluTessBeginContour(MemorySegment tess) {
        var mh$ = gluTessBeginContour.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluTessBeginContour", tess);
            }
            mh$.invokeExact(tess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluTessBeginPolygon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluTessBeginPolygon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gluTessBeginPolygon(GLUtesselator *tess, GLvoid *data)
     * }
     */
    public static FunctionDescriptor gluTessBeginPolygon$descriptor() {
        return gluTessBeginPolygon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gluTessBeginPolygon(GLUtesselator *tess, GLvoid *data)
     * }
     */
    public static MethodHandle gluTessBeginPolygon$handle() {
        return gluTessBeginPolygon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gluTessBeginPolygon(GLUtesselator *tess, GLvoid *data)
     * }
     */
    public static MemorySegment gluTessBeginPolygon$address() {
        return gluTessBeginPolygon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gluTessBeginPolygon(GLUtesselator *tess, GLvoid *data)
     * }
     */
    public static void gluTessBeginPolygon(MemorySegment tess, MemorySegment data) {
        var mh$ = gluTessBeginPolygon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluTessBeginPolygon", tess, data);
            }
            mh$.invokeExact(tess, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluTessCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluTessCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gluTessCallback(GLUtesselator *tess, GLenum which, GLvoid (*CallBackFunc)())
     * }
     */
    public static FunctionDescriptor gluTessCallback$descriptor() {
        return gluTessCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gluTessCallback(GLUtesselator *tess, GLenum which, GLvoid (*CallBackFunc)())
     * }
     */
    public static MethodHandle gluTessCallback$handle() {
        return gluTessCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gluTessCallback(GLUtesselator *tess, GLenum which, GLvoid (*CallBackFunc)())
     * }
     */
    public static MemorySegment gluTessCallback$address() {
        return gluTessCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gluTessCallback(GLUtesselator *tess, GLenum which, GLvoid (*CallBackFunc)())
     * }
     */
    public static void gluTessCallback(MemorySegment tess, int which, MemorySegment CallBackFunc) {
        var mh$ = gluTessCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluTessCallback", tess, which, CallBackFunc);
            }
            mh$.invokeExact(tess, which, CallBackFunc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluTessEndContour {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluTessEndContour");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gluTessEndContour(GLUtesselator *tess)
     * }
     */
    public static FunctionDescriptor gluTessEndContour$descriptor() {
        return gluTessEndContour.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gluTessEndContour(GLUtesselator *tess)
     * }
     */
    public static MethodHandle gluTessEndContour$handle() {
        return gluTessEndContour.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gluTessEndContour(GLUtesselator *tess)
     * }
     */
    public static MemorySegment gluTessEndContour$address() {
        return gluTessEndContour.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gluTessEndContour(GLUtesselator *tess)
     * }
     */
    public static void gluTessEndContour(MemorySegment tess) {
        var mh$ = gluTessEndContour.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluTessEndContour", tess);
            }
            mh$.invokeExact(tess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluTessEndPolygon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluTessEndPolygon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gluTessEndPolygon(GLUtesselator *tess)
     * }
     */
    public static FunctionDescriptor gluTessEndPolygon$descriptor() {
        return gluTessEndPolygon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gluTessEndPolygon(GLUtesselator *tess)
     * }
     */
    public static MethodHandle gluTessEndPolygon$handle() {
        return gluTessEndPolygon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gluTessEndPolygon(GLUtesselator *tess)
     * }
     */
    public static MemorySegment gluTessEndPolygon$address() {
        return gluTessEndPolygon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gluTessEndPolygon(GLUtesselator *tess)
     * }
     */
    public static void gluTessEndPolygon(MemorySegment tess) {
        var mh$ = gluTessEndPolygon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluTessEndPolygon", tess);
            }
            mh$.invokeExact(tess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluTessNormal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluTessNormal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gluTessNormal(GLUtesselator *tess, GLdouble valueX, GLdouble valueY, GLdouble valueZ)
     * }
     */
    public static FunctionDescriptor gluTessNormal$descriptor() {
        return gluTessNormal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gluTessNormal(GLUtesselator *tess, GLdouble valueX, GLdouble valueY, GLdouble valueZ)
     * }
     */
    public static MethodHandle gluTessNormal$handle() {
        return gluTessNormal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gluTessNormal(GLUtesselator *tess, GLdouble valueX, GLdouble valueY, GLdouble valueZ)
     * }
     */
    public static MemorySegment gluTessNormal$address() {
        return gluTessNormal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gluTessNormal(GLUtesselator *tess, GLdouble valueX, GLdouble valueY, GLdouble valueZ)
     * }
     */
    public static void gluTessNormal(MemorySegment tess, double valueX, double valueY, double valueZ) {
        var mh$ = gluTessNormal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluTessNormal", tess, valueX, valueY, valueZ);
            }
            mh$.invokeExact(tess, valueX, valueY, valueZ);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluTessProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluTessProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gluTessProperty(GLUtesselator *tess, GLenum which, GLdouble data)
     * }
     */
    public static FunctionDescriptor gluTessProperty$descriptor() {
        return gluTessProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gluTessProperty(GLUtesselator *tess, GLenum which, GLdouble data)
     * }
     */
    public static MethodHandle gluTessProperty$handle() {
        return gluTessProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gluTessProperty(GLUtesselator *tess, GLenum which, GLdouble data)
     * }
     */
    public static MemorySegment gluTessProperty$address() {
        return gluTessProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gluTessProperty(GLUtesselator *tess, GLenum which, GLdouble data)
     * }
     */
    public static void gluTessProperty(MemorySegment tess, int which, double data) {
        var mh$ = gluTessProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluTessProperty", tess, which, data);
            }
            mh$.invokeExact(tess, which, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluTessVertex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluTessVertex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void gluTessVertex(GLUtesselator *tess, GLdouble *location, GLvoid *data)
     * }
     */
    public static FunctionDescriptor gluTessVertex$descriptor() {
        return gluTessVertex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void gluTessVertex(GLUtesselator *tess, GLdouble *location, GLvoid *data)
     * }
     */
    public static MethodHandle gluTessVertex$handle() {
        return gluTessVertex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void gluTessVertex(GLUtesselator *tess, GLdouble *location, GLvoid *data)
     * }
     */
    public static MemorySegment gluTessVertex$address() {
        return gluTessVertex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void gluTessVertex(GLUtesselator *tess, GLdouble *location, GLvoid *data)
     * }
     */
    public static void gluTessVertex(MemorySegment tess, MemorySegment location, MemorySegment data) {
        var mh$ = gluTessVertex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluTessVertex", tess, location, data);
            }
            mh$.invokeExact(tess, location, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluUnProject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluUnProject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLint gluUnProject(GLdouble winX, GLdouble winY, GLdouble winZ, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble *objX, GLdouble *objY, GLdouble *objZ)
     * }
     */
    public static FunctionDescriptor gluUnProject$descriptor() {
        return gluUnProject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLint gluUnProject(GLdouble winX, GLdouble winY, GLdouble winZ, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble *objX, GLdouble *objY, GLdouble *objZ)
     * }
     */
    public static MethodHandle gluUnProject$handle() {
        return gluUnProject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLint gluUnProject(GLdouble winX, GLdouble winY, GLdouble winZ, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble *objX, GLdouble *objY, GLdouble *objZ)
     * }
     */
    public static MemorySegment gluUnProject$address() {
        return gluUnProject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLint gluUnProject(GLdouble winX, GLdouble winY, GLdouble winZ, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble *objX, GLdouble *objY, GLdouble *objZ)
     * }
     */
    public static int gluUnProject(double winX, double winY, double winZ, MemorySegment model, MemorySegment proj, MemorySegment view, MemorySegment objX, MemorySegment objY, MemorySegment objZ) {
        var mh$ = gluUnProject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluUnProject", winX, winY, winZ, model, proj, view, objX, objY, objZ);
            }
            return (int)mh$.invokeExact(winX, winY, winZ, model, proj, view, objX, objY, objZ);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gluUnProject4 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gluUnProject4");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern GLint gluUnProject4(GLdouble winX, GLdouble winY, GLdouble winZ, GLdouble clipW, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble nearPlane, GLdouble farPlane, GLdouble *objX, GLdouble *objY, GLdouble *objZ, GLdouble *objW)
     * }
     */
    public static FunctionDescriptor gluUnProject4$descriptor() {
        return gluUnProject4.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern GLint gluUnProject4(GLdouble winX, GLdouble winY, GLdouble winZ, GLdouble clipW, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble nearPlane, GLdouble farPlane, GLdouble *objX, GLdouble *objY, GLdouble *objZ, GLdouble *objW)
     * }
     */
    public static MethodHandle gluUnProject4$handle() {
        return gluUnProject4.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern GLint gluUnProject4(GLdouble winX, GLdouble winY, GLdouble winZ, GLdouble clipW, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble nearPlane, GLdouble farPlane, GLdouble *objX, GLdouble *objY, GLdouble *objZ, GLdouble *objW)
     * }
     */
    public static MemorySegment gluUnProject4$address() {
        return gluUnProject4.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern GLint gluUnProject4(GLdouble winX, GLdouble winY, GLdouble winZ, GLdouble clipW, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble nearPlane, GLdouble farPlane, GLdouble *objX, GLdouble *objY, GLdouble *objZ, GLdouble *objW)
     * }
     */
    public static int gluUnProject4(double winX, double winY, double winZ, double clipW, MemorySegment model, MemorySegment proj, MemorySegment view, double nearPlane, double farPlane, MemorySegment objX, MemorySegment objY, MemorySegment objZ, MemorySegment objW) {
        var mh$ = gluUnProject4.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gluUnProject4", winX, winY, winZ, clipW, model, proj, view, nearPlane, farPlane, objX, objY, objZ, objW);
            }
            return (int)mh$.invokeExact(winX, winY, winZ, clipW, model, proj, view, nearPlane, farPlane, objX, objY, objZ, objW);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutStrokeRoman$constants {
        public static final AddressLayout LAYOUT = freeglut_h.C_POINTER;
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("glutStrokeRoman").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern void *glutStrokeRoman
     * }
     */
    public static AddressLayout glutStrokeRoman$layout() {
        return glutStrokeRoman$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern void *glutStrokeRoman
     * }
     */
    public static MemorySegment glutStrokeRoman$segment() {
        return glutStrokeRoman$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern void *glutStrokeRoman
     * }
     */
    public static MemorySegment glutStrokeRoman() {
        return glutStrokeRoman$constants.SEGMENT.get(glutStrokeRoman$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern void *glutStrokeRoman
     * }
     */
    public static void glutStrokeRoman(MemorySegment varValue) {
        glutStrokeRoman$constants.SEGMENT.set(glutStrokeRoman$constants.LAYOUT, 0L, varValue);
    }

    private static class glutStrokeMonoRoman$constants {
        public static final AddressLayout LAYOUT = freeglut_h.C_POINTER;
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("glutStrokeMonoRoman").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern void *glutStrokeMonoRoman
     * }
     */
    public static AddressLayout glutStrokeMonoRoman$layout() {
        return glutStrokeMonoRoman$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern void *glutStrokeMonoRoman
     * }
     */
    public static MemorySegment glutStrokeMonoRoman$segment() {
        return glutStrokeMonoRoman$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern void *glutStrokeMonoRoman
     * }
     */
    public static MemorySegment glutStrokeMonoRoman() {
        return glutStrokeMonoRoman$constants.SEGMENT.get(glutStrokeMonoRoman$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern void *glutStrokeMonoRoman
     * }
     */
    public static void glutStrokeMonoRoman(MemorySegment varValue) {
        glutStrokeMonoRoman$constants.SEGMENT.set(glutStrokeMonoRoman$constants.LAYOUT, 0L, varValue);
    }

    private static class glutBitmap9By15$constants {
        public static final AddressLayout LAYOUT = freeglut_h.C_POINTER;
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("glutBitmap9By15").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern void *glutBitmap9By15
     * }
     */
    public static AddressLayout glutBitmap9By15$layout() {
        return glutBitmap9By15$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern void *glutBitmap9By15
     * }
     */
    public static MemorySegment glutBitmap9By15$segment() {
        return glutBitmap9By15$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern void *glutBitmap9By15
     * }
     */
    public static MemorySegment glutBitmap9By15() {
        return glutBitmap9By15$constants.SEGMENT.get(glutBitmap9By15$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern void *glutBitmap9By15
     * }
     */
    public static void glutBitmap9By15(MemorySegment varValue) {
        glutBitmap9By15$constants.SEGMENT.set(glutBitmap9By15$constants.LAYOUT, 0L, varValue);
    }

    private static class glutBitmap8By13$constants {
        public static final AddressLayout LAYOUT = freeglut_h.C_POINTER;
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("glutBitmap8By13").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern void *glutBitmap8By13
     * }
     */
    public static AddressLayout glutBitmap8By13$layout() {
        return glutBitmap8By13$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern void *glutBitmap8By13
     * }
     */
    public static MemorySegment glutBitmap8By13$segment() {
        return glutBitmap8By13$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern void *glutBitmap8By13
     * }
     */
    public static MemorySegment glutBitmap8By13() {
        return glutBitmap8By13$constants.SEGMENT.get(glutBitmap8By13$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern void *glutBitmap8By13
     * }
     */
    public static void glutBitmap8By13(MemorySegment varValue) {
        glutBitmap8By13$constants.SEGMENT.set(glutBitmap8By13$constants.LAYOUT, 0L, varValue);
    }

    private static class glutBitmapTimesRoman10$constants {
        public static final AddressLayout LAYOUT = freeglut_h.C_POINTER;
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("glutBitmapTimesRoman10").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern void *glutBitmapTimesRoman10
     * }
     */
    public static AddressLayout glutBitmapTimesRoman10$layout() {
        return glutBitmapTimesRoman10$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern void *glutBitmapTimesRoman10
     * }
     */
    public static MemorySegment glutBitmapTimesRoman10$segment() {
        return glutBitmapTimesRoman10$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern void *glutBitmapTimesRoman10
     * }
     */
    public static MemorySegment glutBitmapTimesRoman10() {
        return glutBitmapTimesRoman10$constants.SEGMENT.get(glutBitmapTimesRoman10$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern void *glutBitmapTimesRoman10
     * }
     */
    public static void glutBitmapTimesRoman10(MemorySegment varValue) {
        glutBitmapTimesRoman10$constants.SEGMENT.set(glutBitmapTimesRoman10$constants.LAYOUT, 0L, varValue);
    }

    private static class glutBitmapTimesRoman24$constants {
        public static final AddressLayout LAYOUT = freeglut_h.C_POINTER;
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("glutBitmapTimesRoman24").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern void *glutBitmapTimesRoman24
     * }
     */
    public static AddressLayout glutBitmapTimesRoman24$layout() {
        return glutBitmapTimesRoman24$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern void *glutBitmapTimesRoman24
     * }
     */
    public static MemorySegment glutBitmapTimesRoman24$segment() {
        return glutBitmapTimesRoman24$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern void *glutBitmapTimesRoman24
     * }
     */
    public static MemorySegment glutBitmapTimesRoman24() {
        return glutBitmapTimesRoman24$constants.SEGMENT.get(glutBitmapTimesRoman24$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern void *glutBitmapTimesRoman24
     * }
     */
    public static void glutBitmapTimesRoman24(MemorySegment varValue) {
        glutBitmapTimesRoman24$constants.SEGMENT.set(glutBitmapTimesRoman24$constants.LAYOUT, 0L, varValue);
    }

    private static class glutBitmapHelvetica10$constants {
        public static final AddressLayout LAYOUT = freeglut_h.C_POINTER;
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("glutBitmapHelvetica10").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern void *glutBitmapHelvetica10
     * }
     */
    public static AddressLayout glutBitmapHelvetica10$layout() {
        return glutBitmapHelvetica10$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern void *glutBitmapHelvetica10
     * }
     */
    public static MemorySegment glutBitmapHelvetica10$segment() {
        return glutBitmapHelvetica10$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern void *glutBitmapHelvetica10
     * }
     */
    public static MemorySegment glutBitmapHelvetica10() {
        return glutBitmapHelvetica10$constants.SEGMENT.get(glutBitmapHelvetica10$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern void *glutBitmapHelvetica10
     * }
     */
    public static void glutBitmapHelvetica10(MemorySegment varValue) {
        glutBitmapHelvetica10$constants.SEGMENT.set(glutBitmapHelvetica10$constants.LAYOUT, 0L, varValue);
    }

    private static class glutBitmapHelvetica12$constants {
        public static final AddressLayout LAYOUT = freeglut_h.C_POINTER;
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("glutBitmapHelvetica12").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern void *glutBitmapHelvetica12
     * }
     */
    public static AddressLayout glutBitmapHelvetica12$layout() {
        return glutBitmapHelvetica12$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern void *glutBitmapHelvetica12
     * }
     */
    public static MemorySegment glutBitmapHelvetica12$segment() {
        return glutBitmapHelvetica12$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern void *glutBitmapHelvetica12
     * }
     */
    public static MemorySegment glutBitmapHelvetica12() {
        return glutBitmapHelvetica12$constants.SEGMENT.get(glutBitmapHelvetica12$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern void *glutBitmapHelvetica12
     * }
     */
    public static void glutBitmapHelvetica12(MemorySegment varValue) {
        glutBitmapHelvetica12$constants.SEGMENT.set(glutBitmapHelvetica12$constants.LAYOUT, 0L, varValue);
    }

    private static class glutBitmapHelvetica18$constants {
        public static final AddressLayout LAYOUT = freeglut_h.C_POINTER;
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("glutBitmapHelvetica18").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern void *glutBitmapHelvetica18
     * }
     */
    public static AddressLayout glutBitmapHelvetica18$layout() {
        return glutBitmapHelvetica18$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern void *glutBitmapHelvetica18
     * }
     */
    public static MemorySegment glutBitmapHelvetica18$segment() {
        return glutBitmapHelvetica18$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern void *glutBitmapHelvetica18
     * }
     */
    public static MemorySegment glutBitmapHelvetica18() {
        return glutBitmapHelvetica18$constants.SEGMENT.get(glutBitmapHelvetica18$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern void *glutBitmapHelvetica18
     * }
     */
    public static void glutBitmapHelvetica18(MemorySegment varValue) {
        glutBitmapHelvetica18$constants.SEGMENT.set(glutBitmapHelvetica18$constants.LAYOUT, 0L, varValue);
    }

    private static class glutInit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutInit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutInit(int *pargc, char **argv)
     * }
     */
    public static FunctionDescriptor glutInit$descriptor() {
        return glutInit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutInit(int *pargc, char **argv)
     * }
     */
    public static MethodHandle glutInit$handle() {
        return glutInit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutInit(int *pargc, char **argv)
     * }
     */
    public static MemorySegment glutInit$address() {
        return glutInit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutInit(int *pargc, char **argv)
     * }
     */
    public static void glutInit(MemorySegment pargc, MemorySegment argv) {
        var mh$ = glutInit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutInit", pargc, argv);
            }
            mh$.invokeExact(pargc, argv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutInitWindowPosition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutInitWindowPosition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutInitWindowPosition(int x, int y)
     * }
     */
    public static FunctionDescriptor glutInitWindowPosition$descriptor() {
        return glutInitWindowPosition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutInitWindowPosition(int x, int y)
     * }
     */
    public static MethodHandle glutInitWindowPosition$handle() {
        return glutInitWindowPosition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutInitWindowPosition(int x, int y)
     * }
     */
    public static MemorySegment glutInitWindowPosition$address() {
        return glutInitWindowPosition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutInitWindowPosition(int x, int y)
     * }
     */
    public static void glutInitWindowPosition(int x, int y) {
        var mh$ = glutInitWindowPosition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutInitWindowPosition", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutInitWindowSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutInitWindowSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutInitWindowSize(int width, int height)
     * }
     */
    public static FunctionDescriptor glutInitWindowSize$descriptor() {
        return glutInitWindowSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutInitWindowSize(int width, int height)
     * }
     */
    public static MethodHandle glutInitWindowSize$handle() {
        return glutInitWindowSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutInitWindowSize(int width, int height)
     * }
     */
    public static MemorySegment glutInitWindowSize$address() {
        return glutInitWindowSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutInitWindowSize(int width, int height)
     * }
     */
    public static void glutInitWindowSize(int width, int height) {
        var mh$ = glutInitWindowSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutInitWindowSize", width, height);
            }
            mh$.invokeExact(width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutInitDisplayMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutInitDisplayMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutInitDisplayMode(unsigned int displayMode)
     * }
     */
    public static FunctionDescriptor glutInitDisplayMode$descriptor() {
        return glutInitDisplayMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutInitDisplayMode(unsigned int displayMode)
     * }
     */
    public static MethodHandle glutInitDisplayMode$handle() {
        return glutInitDisplayMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutInitDisplayMode(unsigned int displayMode)
     * }
     */
    public static MemorySegment glutInitDisplayMode$address() {
        return glutInitDisplayMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutInitDisplayMode(unsigned int displayMode)
     * }
     */
    public static void glutInitDisplayMode(int displayMode) {
        var mh$ = glutInitDisplayMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutInitDisplayMode", displayMode);
            }
            mh$.invokeExact(displayMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutInitDisplayString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutInitDisplayString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutInitDisplayString(const char *displayMode)
     * }
     */
    public static FunctionDescriptor glutInitDisplayString$descriptor() {
        return glutInitDisplayString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutInitDisplayString(const char *displayMode)
     * }
     */
    public static MethodHandle glutInitDisplayString$handle() {
        return glutInitDisplayString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutInitDisplayString(const char *displayMode)
     * }
     */
    public static MemorySegment glutInitDisplayString$address() {
        return glutInitDisplayString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutInitDisplayString(const char *displayMode)
     * }
     */
    public static void glutInitDisplayString(MemorySegment displayMode) {
        var mh$ = glutInitDisplayString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutInitDisplayString", displayMode);
            }
            mh$.invokeExact(displayMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutMainLoop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutMainLoop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMainLoop()
     * }
     */
    public static FunctionDescriptor glutMainLoop$descriptor() {
        return glutMainLoop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMainLoop()
     * }
     */
    public static MethodHandle glutMainLoop$handle() {
        return glutMainLoop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMainLoop()
     * }
     */
    public static MemorySegment glutMainLoop$address() {
        return glutMainLoop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMainLoop()
     * }
     */
    public static void glutMainLoop() {
        var mh$ = glutMainLoop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMainLoop");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutCreateWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutCreateWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutCreateWindow(const char *title)
     * }
     */
    public static FunctionDescriptor glutCreateWindow$descriptor() {
        return glutCreateWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutCreateWindow(const char *title)
     * }
     */
    public static MethodHandle glutCreateWindow$handle() {
        return glutCreateWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutCreateWindow(const char *title)
     * }
     */
    public static MemorySegment glutCreateWindow$address() {
        return glutCreateWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutCreateWindow(const char *title)
     * }
     */
    public static int glutCreateWindow(MemorySegment title) {
        var mh$ = glutCreateWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutCreateWindow", title);
            }
            return (int)mh$.invokeExact(title);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutCreateSubWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutCreateSubWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutCreateSubWindow(int window, int x, int y, int width, int height)
     * }
     */
    public static FunctionDescriptor glutCreateSubWindow$descriptor() {
        return glutCreateSubWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutCreateSubWindow(int window, int x, int y, int width, int height)
     * }
     */
    public static MethodHandle glutCreateSubWindow$handle() {
        return glutCreateSubWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutCreateSubWindow(int window, int x, int y, int width, int height)
     * }
     */
    public static MemorySegment glutCreateSubWindow$address() {
        return glutCreateSubWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutCreateSubWindow(int window, int x, int y, int width, int height)
     * }
     */
    public static int glutCreateSubWindow(int window, int x, int y, int width, int height) {
        var mh$ = glutCreateSubWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutCreateSubWindow", window, x, y, width, height);
            }
            return (int)mh$.invokeExact(window, x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutDestroyWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutDestroyWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutDestroyWindow(int window)
     * }
     */
    public static FunctionDescriptor glutDestroyWindow$descriptor() {
        return glutDestroyWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutDestroyWindow(int window)
     * }
     */
    public static MethodHandle glutDestroyWindow$handle() {
        return glutDestroyWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutDestroyWindow(int window)
     * }
     */
    public static MemorySegment glutDestroyWindow$address() {
        return glutDestroyWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutDestroyWindow(int window)
     * }
     */
    public static void glutDestroyWindow(int window) {
        var mh$ = glutDestroyWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutDestroyWindow", window);
            }
            mh$.invokeExact(window);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSetWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSetWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSetWindow(int window)
     * }
     */
    public static FunctionDescriptor glutSetWindow$descriptor() {
        return glutSetWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSetWindow(int window)
     * }
     */
    public static MethodHandle glutSetWindow$handle() {
        return glutSetWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSetWindow(int window)
     * }
     */
    public static MemorySegment glutSetWindow$address() {
        return glutSetWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSetWindow(int window)
     * }
     */
    public static void glutSetWindow(int window) {
        var mh$ = glutSetWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSetWindow", window);
            }
            mh$.invokeExact(window);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutGetWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutGetWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutGetWindow()
     * }
     */
    public static FunctionDescriptor glutGetWindow$descriptor() {
        return glutGetWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutGetWindow()
     * }
     */
    public static MethodHandle glutGetWindow$handle() {
        return glutGetWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutGetWindow()
     * }
     */
    public static MemorySegment glutGetWindow$address() {
        return glutGetWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutGetWindow()
     * }
     */
    public static int glutGetWindow() {
        var mh$ = glutGetWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutGetWindow");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSetWindowTitle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSetWindowTitle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSetWindowTitle(const char *title)
     * }
     */
    public static FunctionDescriptor glutSetWindowTitle$descriptor() {
        return glutSetWindowTitle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSetWindowTitle(const char *title)
     * }
     */
    public static MethodHandle glutSetWindowTitle$handle() {
        return glutSetWindowTitle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSetWindowTitle(const char *title)
     * }
     */
    public static MemorySegment glutSetWindowTitle$address() {
        return glutSetWindowTitle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSetWindowTitle(const char *title)
     * }
     */
    public static void glutSetWindowTitle(MemorySegment title) {
        var mh$ = glutSetWindowTitle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSetWindowTitle", title);
            }
            mh$.invokeExact(title);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSetIconTitle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSetIconTitle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSetIconTitle(const char *title)
     * }
     */
    public static FunctionDescriptor glutSetIconTitle$descriptor() {
        return glutSetIconTitle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSetIconTitle(const char *title)
     * }
     */
    public static MethodHandle glutSetIconTitle$handle() {
        return glutSetIconTitle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSetIconTitle(const char *title)
     * }
     */
    public static MemorySegment glutSetIconTitle$address() {
        return glutSetIconTitle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSetIconTitle(const char *title)
     * }
     */
    public static void glutSetIconTitle(MemorySegment title) {
        var mh$ = glutSetIconTitle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSetIconTitle", title);
            }
            mh$.invokeExact(title);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutReshapeWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutReshapeWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutReshapeWindow(int width, int height)
     * }
     */
    public static FunctionDescriptor glutReshapeWindow$descriptor() {
        return glutReshapeWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutReshapeWindow(int width, int height)
     * }
     */
    public static MethodHandle glutReshapeWindow$handle() {
        return glutReshapeWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutReshapeWindow(int width, int height)
     * }
     */
    public static MemorySegment glutReshapeWindow$address() {
        return glutReshapeWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutReshapeWindow(int width, int height)
     * }
     */
    public static void glutReshapeWindow(int width, int height) {
        var mh$ = glutReshapeWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutReshapeWindow", width, height);
            }
            mh$.invokeExact(width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutPositionWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutPositionWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutPositionWindow(int x, int y)
     * }
     */
    public static FunctionDescriptor glutPositionWindow$descriptor() {
        return glutPositionWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutPositionWindow(int x, int y)
     * }
     */
    public static MethodHandle glutPositionWindow$handle() {
        return glutPositionWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutPositionWindow(int x, int y)
     * }
     */
    public static MemorySegment glutPositionWindow$address() {
        return glutPositionWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutPositionWindow(int x, int y)
     * }
     */
    public static void glutPositionWindow(int x, int y) {
        var mh$ = glutPositionWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutPositionWindow", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutShowWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutShowWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutShowWindow()
     * }
     */
    public static FunctionDescriptor glutShowWindow$descriptor() {
        return glutShowWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutShowWindow()
     * }
     */
    public static MethodHandle glutShowWindow$handle() {
        return glutShowWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutShowWindow()
     * }
     */
    public static MemorySegment glutShowWindow$address() {
        return glutShowWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutShowWindow()
     * }
     */
    public static void glutShowWindow() {
        var mh$ = glutShowWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutShowWindow");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutHideWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutHideWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutHideWindow()
     * }
     */
    public static FunctionDescriptor glutHideWindow$descriptor() {
        return glutHideWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutHideWindow()
     * }
     */
    public static MethodHandle glutHideWindow$handle() {
        return glutHideWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutHideWindow()
     * }
     */
    public static MemorySegment glutHideWindow$address() {
        return glutHideWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutHideWindow()
     * }
     */
    public static void glutHideWindow() {
        var mh$ = glutHideWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutHideWindow");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutIconifyWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutIconifyWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutIconifyWindow()
     * }
     */
    public static FunctionDescriptor glutIconifyWindow$descriptor() {
        return glutIconifyWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutIconifyWindow()
     * }
     */
    public static MethodHandle glutIconifyWindow$handle() {
        return glutIconifyWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutIconifyWindow()
     * }
     */
    public static MemorySegment glutIconifyWindow$address() {
        return glutIconifyWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutIconifyWindow()
     * }
     */
    public static void glutIconifyWindow() {
        var mh$ = glutIconifyWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutIconifyWindow");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutPushWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutPushWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutPushWindow()
     * }
     */
    public static FunctionDescriptor glutPushWindow$descriptor() {
        return glutPushWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutPushWindow()
     * }
     */
    public static MethodHandle glutPushWindow$handle() {
        return glutPushWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutPushWindow()
     * }
     */
    public static MemorySegment glutPushWindow$address() {
        return glutPushWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutPushWindow()
     * }
     */
    public static void glutPushWindow() {
        var mh$ = glutPushWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutPushWindow");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutPopWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutPopWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutPopWindow()
     * }
     */
    public static FunctionDescriptor glutPopWindow$descriptor() {
        return glutPopWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutPopWindow()
     * }
     */
    public static MethodHandle glutPopWindow$handle() {
        return glutPopWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutPopWindow()
     * }
     */
    public static MemorySegment glutPopWindow$address() {
        return glutPopWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutPopWindow()
     * }
     */
    public static void glutPopWindow() {
        var mh$ = glutPopWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutPopWindow");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutFullScreen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutFullScreen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutFullScreen()
     * }
     */
    public static FunctionDescriptor glutFullScreen$descriptor() {
        return glutFullScreen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutFullScreen()
     * }
     */
    public static MethodHandle glutFullScreen$handle() {
        return glutFullScreen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutFullScreen()
     * }
     */
    public static MemorySegment glutFullScreen$address() {
        return glutFullScreen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutFullScreen()
     * }
     */
    public static void glutFullScreen() {
        var mh$ = glutFullScreen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutFullScreen");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutPostWindowRedisplay {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutPostWindowRedisplay");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutPostWindowRedisplay(int window)
     * }
     */
    public static FunctionDescriptor glutPostWindowRedisplay$descriptor() {
        return glutPostWindowRedisplay.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutPostWindowRedisplay(int window)
     * }
     */
    public static MethodHandle glutPostWindowRedisplay$handle() {
        return glutPostWindowRedisplay.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutPostWindowRedisplay(int window)
     * }
     */
    public static MemorySegment glutPostWindowRedisplay$address() {
        return glutPostWindowRedisplay.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutPostWindowRedisplay(int window)
     * }
     */
    public static void glutPostWindowRedisplay(int window) {
        var mh$ = glutPostWindowRedisplay.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutPostWindowRedisplay", window);
            }
            mh$.invokeExact(window);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutPostRedisplay {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutPostRedisplay");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutPostRedisplay()
     * }
     */
    public static FunctionDescriptor glutPostRedisplay$descriptor() {
        return glutPostRedisplay.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutPostRedisplay()
     * }
     */
    public static MethodHandle glutPostRedisplay$handle() {
        return glutPostRedisplay.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutPostRedisplay()
     * }
     */
    public static MemorySegment glutPostRedisplay$address() {
        return glutPostRedisplay.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutPostRedisplay()
     * }
     */
    public static void glutPostRedisplay() {
        var mh$ = glutPostRedisplay.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutPostRedisplay");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSwapBuffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSwapBuffers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSwapBuffers()
     * }
     */
    public static FunctionDescriptor glutSwapBuffers$descriptor() {
        return glutSwapBuffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSwapBuffers()
     * }
     */
    public static MethodHandle glutSwapBuffers$handle() {
        return glutSwapBuffers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSwapBuffers()
     * }
     */
    public static MemorySegment glutSwapBuffers$address() {
        return glutSwapBuffers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSwapBuffers()
     * }
     */
    public static void glutSwapBuffers() {
        var mh$ = glutSwapBuffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSwapBuffers");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWarpPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutWarpPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWarpPointer(int x, int y)
     * }
     */
    public static FunctionDescriptor glutWarpPointer$descriptor() {
        return glutWarpPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWarpPointer(int x, int y)
     * }
     */
    public static MethodHandle glutWarpPointer$handle() {
        return glutWarpPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWarpPointer(int x, int y)
     * }
     */
    public static MemorySegment glutWarpPointer$address() {
        return glutWarpPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWarpPointer(int x, int y)
     * }
     */
    public static void glutWarpPointer(int x, int y) {
        var mh$ = glutWarpPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWarpPointer", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSetCursor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSetCursor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSetCursor(int cursor)
     * }
     */
    public static FunctionDescriptor glutSetCursor$descriptor() {
        return glutSetCursor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSetCursor(int cursor)
     * }
     */
    public static MethodHandle glutSetCursor$handle() {
        return glutSetCursor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSetCursor(int cursor)
     * }
     */
    public static MemorySegment glutSetCursor$address() {
        return glutSetCursor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSetCursor(int cursor)
     * }
     */
    public static void glutSetCursor(int cursor) {
        var mh$ = glutSetCursor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSetCursor", cursor);
            }
            mh$.invokeExact(cursor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutEstablishOverlay {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutEstablishOverlay");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutEstablishOverlay()
     * }
     */
    public static FunctionDescriptor glutEstablishOverlay$descriptor() {
        return glutEstablishOverlay.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutEstablishOverlay()
     * }
     */
    public static MethodHandle glutEstablishOverlay$handle() {
        return glutEstablishOverlay.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutEstablishOverlay()
     * }
     */
    public static MemorySegment glutEstablishOverlay$address() {
        return glutEstablishOverlay.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutEstablishOverlay()
     * }
     */
    public static void glutEstablishOverlay() {
        var mh$ = glutEstablishOverlay.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutEstablishOverlay");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutRemoveOverlay {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutRemoveOverlay");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutRemoveOverlay()
     * }
     */
    public static FunctionDescriptor glutRemoveOverlay$descriptor() {
        return glutRemoveOverlay.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutRemoveOverlay()
     * }
     */
    public static MethodHandle glutRemoveOverlay$handle() {
        return glutRemoveOverlay.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutRemoveOverlay()
     * }
     */
    public static MemorySegment glutRemoveOverlay$address() {
        return glutRemoveOverlay.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutRemoveOverlay()
     * }
     */
    public static void glutRemoveOverlay() {
        var mh$ = glutRemoveOverlay.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutRemoveOverlay");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutUseLayer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutUseLayer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutUseLayer(GLenum layer)
     * }
     */
    public static FunctionDescriptor glutUseLayer$descriptor() {
        return glutUseLayer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutUseLayer(GLenum layer)
     * }
     */
    public static MethodHandle glutUseLayer$handle() {
        return glutUseLayer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutUseLayer(GLenum layer)
     * }
     */
    public static MemorySegment glutUseLayer$address() {
        return glutUseLayer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutUseLayer(GLenum layer)
     * }
     */
    public static void glutUseLayer(int layer) {
        var mh$ = glutUseLayer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutUseLayer", layer);
            }
            mh$.invokeExact(layer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutPostOverlayRedisplay {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutPostOverlayRedisplay");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutPostOverlayRedisplay()
     * }
     */
    public static FunctionDescriptor glutPostOverlayRedisplay$descriptor() {
        return glutPostOverlayRedisplay.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutPostOverlayRedisplay()
     * }
     */
    public static MethodHandle glutPostOverlayRedisplay$handle() {
        return glutPostOverlayRedisplay.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutPostOverlayRedisplay()
     * }
     */
    public static MemorySegment glutPostOverlayRedisplay$address() {
        return glutPostOverlayRedisplay.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutPostOverlayRedisplay()
     * }
     */
    public static void glutPostOverlayRedisplay() {
        var mh$ = glutPostOverlayRedisplay.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutPostOverlayRedisplay");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutPostWindowOverlayRedisplay {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutPostWindowOverlayRedisplay");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutPostWindowOverlayRedisplay(int window)
     * }
     */
    public static FunctionDescriptor glutPostWindowOverlayRedisplay$descriptor() {
        return glutPostWindowOverlayRedisplay.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutPostWindowOverlayRedisplay(int window)
     * }
     */
    public static MethodHandle glutPostWindowOverlayRedisplay$handle() {
        return glutPostWindowOverlayRedisplay.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutPostWindowOverlayRedisplay(int window)
     * }
     */
    public static MemorySegment glutPostWindowOverlayRedisplay$address() {
        return glutPostWindowOverlayRedisplay.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutPostWindowOverlayRedisplay(int window)
     * }
     */
    public static void glutPostWindowOverlayRedisplay(int window) {
        var mh$ = glutPostWindowOverlayRedisplay.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutPostWindowOverlayRedisplay", window);
            }
            mh$.invokeExact(window);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutShowOverlay {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutShowOverlay");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutShowOverlay()
     * }
     */
    public static FunctionDescriptor glutShowOverlay$descriptor() {
        return glutShowOverlay.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutShowOverlay()
     * }
     */
    public static MethodHandle glutShowOverlay$handle() {
        return glutShowOverlay.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutShowOverlay()
     * }
     */
    public static MemorySegment glutShowOverlay$address() {
        return glutShowOverlay.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutShowOverlay()
     * }
     */
    public static void glutShowOverlay() {
        var mh$ = glutShowOverlay.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutShowOverlay");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutHideOverlay {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutHideOverlay");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutHideOverlay()
     * }
     */
    public static FunctionDescriptor glutHideOverlay$descriptor() {
        return glutHideOverlay.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutHideOverlay()
     * }
     */
    public static MethodHandle glutHideOverlay$handle() {
        return glutHideOverlay.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutHideOverlay()
     * }
     */
    public static MemorySegment glutHideOverlay$address() {
        return glutHideOverlay.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutHideOverlay()
     * }
     */
    public static void glutHideOverlay() {
        var mh$ = glutHideOverlay.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutHideOverlay");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutCreateMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutCreateMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutCreateMenu(void (*callback)(int))
     * }
     */
    public static FunctionDescriptor glutCreateMenu$descriptor() {
        return glutCreateMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutCreateMenu(void (*callback)(int))
     * }
     */
    public static MethodHandle glutCreateMenu$handle() {
        return glutCreateMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutCreateMenu(void (*callback)(int))
     * }
     */
    public static MemorySegment glutCreateMenu$address() {
        return glutCreateMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutCreateMenu(void (*callback)(int))
     * }
     */
    public static int glutCreateMenu(MemorySegment callback) {
        var mh$ = glutCreateMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutCreateMenu", callback);
            }
            return (int)mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutDestroyMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutDestroyMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutDestroyMenu(int menu)
     * }
     */
    public static FunctionDescriptor glutDestroyMenu$descriptor() {
        return glutDestroyMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutDestroyMenu(int menu)
     * }
     */
    public static MethodHandle glutDestroyMenu$handle() {
        return glutDestroyMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutDestroyMenu(int menu)
     * }
     */
    public static MemorySegment glutDestroyMenu$address() {
        return glutDestroyMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutDestroyMenu(int menu)
     * }
     */
    public static void glutDestroyMenu(int menu) {
        var mh$ = glutDestroyMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutDestroyMenu", menu);
            }
            mh$.invokeExact(menu);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutGetMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutGetMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutGetMenu()
     * }
     */
    public static FunctionDescriptor glutGetMenu$descriptor() {
        return glutGetMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutGetMenu()
     * }
     */
    public static MethodHandle glutGetMenu$handle() {
        return glutGetMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutGetMenu()
     * }
     */
    public static MemorySegment glutGetMenu$address() {
        return glutGetMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutGetMenu()
     * }
     */
    public static int glutGetMenu() {
        var mh$ = glutGetMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutGetMenu");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSetMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSetMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSetMenu(int menu)
     * }
     */
    public static FunctionDescriptor glutSetMenu$descriptor() {
        return glutSetMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSetMenu(int menu)
     * }
     */
    public static MethodHandle glutSetMenu$handle() {
        return glutSetMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSetMenu(int menu)
     * }
     */
    public static MemorySegment glutSetMenu$address() {
        return glutSetMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSetMenu(int menu)
     * }
     */
    public static void glutSetMenu(int menu) {
        var mh$ = glutSetMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSetMenu", menu);
            }
            mh$.invokeExact(menu);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutAddMenuEntry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutAddMenuEntry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutAddMenuEntry(const char *label, int value)
     * }
     */
    public static FunctionDescriptor glutAddMenuEntry$descriptor() {
        return glutAddMenuEntry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutAddMenuEntry(const char *label, int value)
     * }
     */
    public static MethodHandle glutAddMenuEntry$handle() {
        return glutAddMenuEntry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutAddMenuEntry(const char *label, int value)
     * }
     */
    public static MemorySegment glutAddMenuEntry$address() {
        return glutAddMenuEntry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutAddMenuEntry(const char *label, int value)
     * }
     */
    public static void glutAddMenuEntry(MemorySegment label, int value) {
        var mh$ = glutAddMenuEntry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutAddMenuEntry", label, value);
            }
            mh$.invokeExact(label, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutAddSubMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutAddSubMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutAddSubMenu(const char *label, int subMenu)
     * }
     */
    public static FunctionDescriptor glutAddSubMenu$descriptor() {
        return glutAddSubMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutAddSubMenu(const char *label, int subMenu)
     * }
     */
    public static MethodHandle glutAddSubMenu$handle() {
        return glutAddSubMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutAddSubMenu(const char *label, int subMenu)
     * }
     */
    public static MemorySegment glutAddSubMenu$address() {
        return glutAddSubMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutAddSubMenu(const char *label, int subMenu)
     * }
     */
    public static void glutAddSubMenu(MemorySegment label, int subMenu) {
        var mh$ = glutAddSubMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutAddSubMenu", label, subMenu);
            }
            mh$.invokeExact(label, subMenu);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutChangeToMenuEntry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutChangeToMenuEntry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutChangeToMenuEntry(int item, const char *label, int value)
     * }
     */
    public static FunctionDescriptor glutChangeToMenuEntry$descriptor() {
        return glutChangeToMenuEntry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutChangeToMenuEntry(int item, const char *label, int value)
     * }
     */
    public static MethodHandle glutChangeToMenuEntry$handle() {
        return glutChangeToMenuEntry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutChangeToMenuEntry(int item, const char *label, int value)
     * }
     */
    public static MemorySegment glutChangeToMenuEntry$address() {
        return glutChangeToMenuEntry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutChangeToMenuEntry(int item, const char *label, int value)
     * }
     */
    public static void glutChangeToMenuEntry(int item, MemorySegment label, int value) {
        var mh$ = glutChangeToMenuEntry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutChangeToMenuEntry", item, label, value);
            }
            mh$.invokeExact(item, label, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutChangeToSubMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutChangeToSubMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutChangeToSubMenu(int item, const char *label, int value)
     * }
     */
    public static FunctionDescriptor glutChangeToSubMenu$descriptor() {
        return glutChangeToSubMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutChangeToSubMenu(int item, const char *label, int value)
     * }
     */
    public static MethodHandle glutChangeToSubMenu$handle() {
        return glutChangeToSubMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutChangeToSubMenu(int item, const char *label, int value)
     * }
     */
    public static MemorySegment glutChangeToSubMenu$address() {
        return glutChangeToSubMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutChangeToSubMenu(int item, const char *label, int value)
     * }
     */
    public static void glutChangeToSubMenu(int item, MemorySegment label, int value) {
        var mh$ = glutChangeToSubMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutChangeToSubMenu", item, label, value);
            }
            mh$.invokeExact(item, label, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutRemoveMenuItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutRemoveMenuItem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutRemoveMenuItem(int item)
     * }
     */
    public static FunctionDescriptor glutRemoveMenuItem$descriptor() {
        return glutRemoveMenuItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutRemoveMenuItem(int item)
     * }
     */
    public static MethodHandle glutRemoveMenuItem$handle() {
        return glutRemoveMenuItem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutRemoveMenuItem(int item)
     * }
     */
    public static MemorySegment glutRemoveMenuItem$address() {
        return glutRemoveMenuItem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutRemoveMenuItem(int item)
     * }
     */
    public static void glutRemoveMenuItem(int item) {
        var mh$ = glutRemoveMenuItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutRemoveMenuItem", item);
            }
            mh$.invokeExact(item);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutAttachMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutAttachMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutAttachMenu(int button)
     * }
     */
    public static FunctionDescriptor glutAttachMenu$descriptor() {
        return glutAttachMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutAttachMenu(int button)
     * }
     */
    public static MethodHandle glutAttachMenu$handle() {
        return glutAttachMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutAttachMenu(int button)
     * }
     */
    public static MemorySegment glutAttachMenu$address() {
        return glutAttachMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutAttachMenu(int button)
     * }
     */
    public static void glutAttachMenu(int button) {
        var mh$ = glutAttachMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutAttachMenu", button);
            }
            mh$.invokeExact(button);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutDetachMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutDetachMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutDetachMenu(int button)
     * }
     */
    public static FunctionDescriptor glutDetachMenu$descriptor() {
        return glutDetachMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutDetachMenu(int button)
     * }
     */
    public static MethodHandle glutDetachMenu$handle() {
        return glutDetachMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutDetachMenu(int button)
     * }
     */
    public static MemorySegment glutDetachMenu$address() {
        return glutDetachMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutDetachMenu(int button)
     * }
     */
    public static void glutDetachMenu(int button) {
        var mh$ = glutDetachMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutDetachMenu", button);
            }
            mh$.invokeExact(button);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutTimerFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutTimerFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutTimerFunc(unsigned int time, void (*callback)(int), int value)
     * }
     */
    public static FunctionDescriptor glutTimerFunc$descriptor() {
        return glutTimerFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutTimerFunc(unsigned int time, void (*callback)(int), int value)
     * }
     */
    public static MethodHandle glutTimerFunc$handle() {
        return glutTimerFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutTimerFunc(unsigned int time, void (*callback)(int), int value)
     * }
     */
    public static MemorySegment glutTimerFunc$address() {
        return glutTimerFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutTimerFunc(unsigned int time, void (*callback)(int), int value)
     * }
     */
    public static void glutTimerFunc(int time, MemorySegment callback, int value) {
        var mh$ = glutTimerFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutTimerFunc", time, callback, value);
            }
            mh$.invokeExact(time, callback, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutIdleFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutIdleFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutIdleFunc(void (*callback)(void))
     * }
     */
    public static FunctionDescriptor glutIdleFunc$descriptor() {
        return glutIdleFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutIdleFunc(void (*callback)(void))
     * }
     */
    public static MethodHandle glutIdleFunc$handle() {
        return glutIdleFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutIdleFunc(void (*callback)(void))
     * }
     */
    public static MemorySegment glutIdleFunc$address() {
        return glutIdleFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutIdleFunc(void (*callback)(void))
     * }
     */
    public static void glutIdleFunc(MemorySegment callback) {
        var mh$ = glutIdleFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutIdleFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutKeyboardFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutKeyboardFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutKeyboardFunc(void (*callback)(unsigned char, int, int))
     * }
     */
    public static FunctionDescriptor glutKeyboardFunc$descriptor() {
        return glutKeyboardFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutKeyboardFunc(void (*callback)(unsigned char, int, int))
     * }
     */
    public static MethodHandle glutKeyboardFunc$handle() {
        return glutKeyboardFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutKeyboardFunc(void (*callback)(unsigned char, int, int))
     * }
     */
    public static MemorySegment glutKeyboardFunc$address() {
        return glutKeyboardFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutKeyboardFunc(void (*callback)(unsigned char, int, int))
     * }
     */
    public static void glutKeyboardFunc(MemorySegment callback) {
        var mh$ = glutKeyboardFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutKeyboardFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSpecialFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSpecialFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSpecialFunc(void (*callback)(int, int, int))
     * }
     */
    public static FunctionDescriptor glutSpecialFunc$descriptor() {
        return glutSpecialFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSpecialFunc(void (*callback)(int, int, int))
     * }
     */
    public static MethodHandle glutSpecialFunc$handle() {
        return glutSpecialFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSpecialFunc(void (*callback)(int, int, int))
     * }
     */
    public static MemorySegment glutSpecialFunc$address() {
        return glutSpecialFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSpecialFunc(void (*callback)(int, int, int))
     * }
     */
    public static void glutSpecialFunc(MemorySegment callback) {
        var mh$ = glutSpecialFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSpecialFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutReshapeFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutReshapeFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutReshapeFunc(void (*callback)(int, int))
     * }
     */
    public static FunctionDescriptor glutReshapeFunc$descriptor() {
        return glutReshapeFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutReshapeFunc(void (*callback)(int, int))
     * }
     */
    public static MethodHandle glutReshapeFunc$handle() {
        return glutReshapeFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutReshapeFunc(void (*callback)(int, int))
     * }
     */
    public static MemorySegment glutReshapeFunc$address() {
        return glutReshapeFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutReshapeFunc(void (*callback)(int, int))
     * }
     */
    public static void glutReshapeFunc(MemorySegment callback) {
        var mh$ = glutReshapeFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutReshapeFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutVisibilityFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutVisibilityFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutVisibilityFunc(void (*callback)(int))
     * }
     */
    public static FunctionDescriptor glutVisibilityFunc$descriptor() {
        return glutVisibilityFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutVisibilityFunc(void (*callback)(int))
     * }
     */
    public static MethodHandle glutVisibilityFunc$handle() {
        return glutVisibilityFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutVisibilityFunc(void (*callback)(int))
     * }
     */
    public static MemorySegment glutVisibilityFunc$address() {
        return glutVisibilityFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutVisibilityFunc(void (*callback)(int))
     * }
     */
    public static void glutVisibilityFunc(MemorySegment callback) {
        var mh$ = glutVisibilityFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutVisibilityFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutDisplayFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutDisplayFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutDisplayFunc(void (*callback)(void))
     * }
     */
    public static FunctionDescriptor glutDisplayFunc$descriptor() {
        return glutDisplayFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutDisplayFunc(void (*callback)(void))
     * }
     */
    public static MethodHandle glutDisplayFunc$handle() {
        return glutDisplayFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutDisplayFunc(void (*callback)(void))
     * }
     */
    public static MemorySegment glutDisplayFunc$address() {
        return glutDisplayFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutDisplayFunc(void (*callback)(void))
     * }
     */
    public static void glutDisplayFunc(MemorySegment callback) {
        var mh$ = glutDisplayFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutDisplayFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutMouseFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutMouseFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMouseFunc(void (*callback)(int, int, int, int))
     * }
     */
    public static FunctionDescriptor glutMouseFunc$descriptor() {
        return glutMouseFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMouseFunc(void (*callback)(int, int, int, int))
     * }
     */
    public static MethodHandle glutMouseFunc$handle() {
        return glutMouseFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMouseFunc(void (*callback)(int, int, int, int))
     * }
     */
    public static MemorySegment glutMouseFunc$address() {
        return glutMouseFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMouseFunc(void (*callback)(int, int, int, int))
     * }
     */
    public static void glutMouseFunc(MemorySegment callback) {
        var mh$ = glutMouseFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMouseFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutMotionFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutMotionFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMotionFunc(void (*callback)(int, int))
     * }
     */
    public static FunctionDescriptor glutMotionFunc$descriptor() {
        return glutMotionFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMotionFunc(void (*callback)(int, int))
     * }
     */
    public static MethodHandle glutMotionFunc$handle() {
        return glutMotionFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMotionFunc(void (*callback)(int, int))
     * }
     */
    public static MemorySegment glutMotionFunc$address() {
        return glutMotionFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMotionFunc(void (*callback)(int, int))
     * }
     */
    public static void glutMotionFunc(MemorySegment callback) {
        var mh$ = glutMotionFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMotionFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutPassiveMotionFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutPassiveMotionFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutPassiveMotionFunc(void (*callback)(int, int))
     * }
     */
    public static FunctionDescriptor glutPassiveMotionFunc$descriptor() {
        return glutPassiveMotionFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutPassiveMotionFunc(void (*callback)(int, int))
     * }
     */
    public static MethodHandle glutPassiveMotionFunc$handle() {
        return glutPassiveMotionFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutPassiveMotionFunc(void (*callback)(int, int))
     * }
     */
    public static MemorySegment glutPassiveMotionFunc$address() {
        return glutPassiveMotionFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutPassiveMotionFunc(void (*callback)(int, int))
     * }
     */
    public static void glutPassiveMotionFunc(MemorySegment callback) {
        var mh$ = glutPassiveMotionFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutPassiveMotionFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutEntryFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutEntryFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutEntryFunc(void (*callback)(int))
     * }
     */
    public static FunctionDescriptor glutEntryFunc$descriptor() {
        return glutEntryFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutEntryFunc(void (*callback)(int))
     * }
     */
    public static MethodHandle glutEntryFunc$handle() {
        return glutEntryFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutEntryFunc(void (*callback)(int))
     * }
     */
    public static MemorySegment glutEntryFunc$address() {
        return glutEntryFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutEntryFunc(void (*callback)(int))
     * }
     */
    public static void glutEntryFunc(MemorySegment callback) {
        var mh$ = glutEntryFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutEntryFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutKeyboardUpFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutKeyboardUpFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutKeyboardUpFunc(void (*callback)(unsigned char, int, int))
     * }
     */
    public static FunctionDescriptor glutKeyboardUpFunc$descriptor() {
        return glutKeyboardUpFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutKeyboardUpFunc(void (*callback)(unsigned char, int, int))
     * }
     */
    public static MethodHandle glutKeyboardUpFunc$handle() {
        return glutKeyboardUpFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutKeyboardUpFunc(void (*callback)(unsigned char, int, int))
     * }
     */
    public static MemorySegment glutKeyboardUpFunc$address() {
        return glutKeyboardUpFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutKeyboardUpFunc(void (*callback)(unsigned char, int, int))
     * }
     */
    public static void glutKeyboardUpFunc(MemorySegment callback) {
        var mh$ = glutKeyboardUpFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutKeyboardUpFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSpecialUpFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSpecialUpFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSpecialUpFunc(void (*callback)(int, int, int))
     * }
     */
    public static FunctionDescriptor glutSpecialUpFunc$descriptor() {
        return glutSpecialUpFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSpecialUpFunc(void (*callback)(int, int, int))
     * }
     */
    public static MethodHandle glutSpecialUpFunc$handle() {
        return glutSpecialUpFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSpecialUpFunc(void (*callback)(int, int, int))
     * }
     */
    public static MemorySegment glutSpecialUpFunc$address() {
        return glutSpecialUpFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSpecialUpFunc(void (*callback)(int, int, int))
     * }
     */
    public static void glutSpecialUpFunc(MemorySegment callback) {
        var mh$ = glutSpecialUpFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSpecialUpFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutJoystickFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutJoystickFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutJoystickFunc(void (*callback)(unsigned int, int, int, int), int pollInterval)
     * }
     */
    public static FunctionDescriptor glutJoystickFunc$descriptor() {
        return glutJoystickFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutJoystickFunc(void (*callback)(unsigned int, int, int, int), int pollInterval)
     * }
     */
    public static MethodHandle glutJoystickFunc$handle() {
        return glutJoystickFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutJoystickFunc(void (*callback)(unsigned int, int, int, int), int pollInterval)
     * }
     */
    public static MemorySegment glutJoystickFunc$address() {
        return glutJoystickFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutJoystickFunc(void (*callback)(unsigned int, int, int, int), int pollInterval)
     * }
     */
    public static void glutJoystickFunc(MemorySegment callback, int pollInterval) {
        var mh$ = glutJoystickFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutJoystickFunc", callback, pollInterval);
            }
            mh$.invokeExact(callback, pollInterval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutMenuStateFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutMenuStateFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMenuStateFunc(void (*callback)(int))
     * }
     */
    public static FunctionDescriptor glutMenuStateFunc$descriptor() {
        return glutMenuStateFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMenuStateFunc(void (*callback)(int))
     * }
     */
    public static MethodHandle glutMenuStateFunc$handle() {
        return glutMenuStateFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMenuStateFunc(void (*callback)(int))
     * }
     */
    public static MemorySegment glutMenuStateFunc$address() {
        return glutMenuStateFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMenuStateFunc(void (*callback)(int))
     * }
     */
    public static void glutMenuStateFunc(MemorySegment callback) {
        var mh$ = glutMenuStateFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMenuStateFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutMenuStatusFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutMenuStatusFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMenuStatusFunc(void (*callback)(int, int, int))
     * }
     */
    public static FunctionDescriptor glutMenuStatusFunc$descriptor() {
        return glutMenuStatusFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMenuStatusFunc(void (*callback)(int, int, int))
     * }
     */
    public static MethodHandle glutMenuStatusFunc$handle() {
        return glutMenuStatusFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMenuStatusFunc(void (*callback)(int, int, int))
     * }
     */
    public static MemorySegment glutMenuStatusFunc$address() {
        return glutMenuStatusFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMenuStatusFunc(void (*callback)(int, int, int))
     * }
     */
    public static void glutMenuStatusFunc(MemorySegment callback) {
        var mh$ = glutMenuStatusFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMenuStatusFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutOverlayDisplayFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutOverlayDisplayFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutOverlayDisplayFunc(void (*callback)(void))
     * }
     */
    public static FunctionDescriptor glutOverlayDisplayFunc$descriptor() {
        return glutOverlayDisplayFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutOverlayDisplayFunc(void (*callback)(void))
     * }
     */
    public static MethodHandle glutOverlayDisplayFunc$handle() {
        return glutOverlayDisplayFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutOverlayDisplayFunc(void (*callback)(void))
     * }
     */
    public static MemorySegment glutOverlayDisplayFunc$address() {
        return glutOverlayDisplayFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutOverlayDisplayFunc(void (*callback)(void))
     * }
     */
    public static void glutOverlayDisplayFunc(MemorySegment callback) {
        var mh$ = glutOverlayDisplayFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutOverlayDisplayFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWindowStatusFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutWindowStatusFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWindowStatusFunc(void (*callback)(int))
     * }
     */
    public static FunctionDescriptor glutWindowStatusFunc$descriptor() {
        return glutWindowStatusFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWindowStatusFunc(void (*callback)(int))
     * }
     */
    public static MethodHandle glutWindowStatusFunc$handle() {
        return glutWindowStatusFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWindowStatusFunc(void (*callback)(int))
     * }
     */
    public static MemorySegment glutWindowStatusFunc$address() {
        return glutWindowStatusFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWindowStatusFunc(void (*callback)(int))
     * }
     */
    public static void glutWindowStatusFunc(MemorySegment callback) {
        var mh$ = glutWindowStatusFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWindowStatusFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSpaceballMotionFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSpaceballMotionFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSpaceballMotionFunc(void (*callback)(int, int, int))
     * }
     */
    public static FunctionDescriptor glutSpaceballMotionFunc$descriptor() {
        return glutSpaceballMotionFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSpaceballMotionFunc(void (*callback)(int, int, int))
     * }
     */
    public static MethodHandle glutSpaceballMotionFunc$handle() {
        return glutSpaceballMotionFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSpaceballMotionFunc(void (*callback)(int, int, int))
     * }
     */
    public static MemorySegment glutSpaceballMotionFunc$address() {
        return glutSpaceballMotionFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSpaceballMotionFunc(void (*callback)(int, int, int))
     * }
     */
    public static void glutSpaceballMotionFunc(MemorySegment callback) {
        var mh$ = glutSpaceballMotionFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSpaceballMotionFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSpaceballRotateFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSpaceballRotateFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSpaceballRotateFunc(void (*callback)(int, int, int))
     * }
     */
    public static FunctionDescriptor glutSpaceballRotateFunc$descriptor() {
        return glutSpaceballRotateFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSpaceballRotateFunc(void (*callback)(int, int, int))
     * }
     */
    public static MethodHandle glutSpaceballRotateFunc$handle() {
        return glutSpaceballRotateFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSpaceballRotateFunc(void (*callback)(int, int, int))
     * }
     */
    public static MemorySegment glutSpaceballRotateFunc$address() {
        return glutSpaceballRotateFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSpaceballRotateFunc(void (*callback)(int, int, int))
     * }
     */
    public static void glutSpaceballRotateFunc(MemorySegment callback) {
        var mh$ = glutSpaceballRotateFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSpaceballRotateFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSpaceballButtonFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSpaceballButtonFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSpaceballButtonFunc(void (*callback)(int, int))
     * }
     */
    public static FunctionDescriptor glutSpaceballButtonFunc$descriptor() {
        return glutSpaceballButtonFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSpaceballButtonFunc(void (*callback)(int, int))
     * }
     */
    public static MethodHandle glutSpaceballButtonFunc$handle() {
        return glutSpaceballButtonFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSpaceballButtonFunc(void (*callback)(int, int))
     * }
     */
    public static MemorySegment glutSpaceballButtonFunc$address() {
        return glutSpaceballButtonFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSpaceballButtonFunc(void (*callback)(int, int))
     * }
     */
    public static void glutSpaceballButtonFunc(MemorySegment callback) {
        var mh$ = glutSpaceballButtonFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSpaceballButtonFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutButtonBoxFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutButtonBoxFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutButtonBoxFunc(void (*callback)(int, int))
     * }
     */
    public static FunctionDescriptor glutButtonBoxFunc$descriptor() {
        return glutButtonBoxFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutButtonBoxFunc(void (*callback)(int, int))
     * }
     */
    public static MethodHandle glutButtonBoxFunc$handle() {
        return glutButtonBoxFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutButtonBoxFunc(void (*callback)(int, int))
     * }
     */
    public static MemorySegment glutButtonBoxFunc$address() {
        return glutButtonBoxFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutButtonBoxFunc(void (*callback)(int, int))
     * }
     */
    public static void glutButtonBoxFunc(MemorySegment callback) {
        var mh$ = glutButtonBoxFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutButtonBoxFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutDialsFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutDialsFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutDialsFunc(void (*callback)(int, int))
     * }
     */
    public static FunctionDescriptor glutDialsFunc$descriptor() {
        return glutDialsFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutDialsFunc(void (*callback)(int, int))
     * }
     */
    public static MethodHandle glutDialsFunc$handle() {
        return glutDialsFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutDialsFunc(void (*callback)(int, int))
     * }
     */
    public static MemorySegment glutDialsFunc$address() {
        return glutDialsFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutDialsFunc(void (*callback)(int, int))
     * }
     */
    public static void glutDialsFunc(MemorySegment callback) {
        var mh$ = glutDialsFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutDialsFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutTabletMotionFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutTabletMotionFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutTabletMotionFunc(void (*callback)(int, int))
     * }
     */
    public static FunctionDescriptor glutTabletMotionFunc$descriptor() {
        return glutTabletMotionFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutTabletMotionFunc(void (*callback)(int, int))
     * }
     */
    public static MethodHandle glutTabletMotionFunc$handle() {
        return glutTabletMotionFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutTabletMotionFunc(void (*callback)(int, int))
     * }
     */
    public static MemorySegment glutTabletMotionFunc$address() {
        return glutTabletMotionFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutTabletMotionFunc(void (*callback)(int, int))
     * }
     */
    public static void glutTabletMotionFunc(MemorySegment callback) {
        var mh$ = glutTabletMotionFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutTabletMotionFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutTabletButtonFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutTabletButtonFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutTabletButtonFunc(void (*callback)(int, int, int, int))
     * }
     */
    public static FunctionDescriptor glutTabletButtonFunc$descriptor() {
        return glutTabletButtonFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutTabletButtonFunc(void (*callback)(int, int, int, int))
     * }
     */
    public static MethodHandle glutTabletButtonFunc$handle() {
        return glutTabletButtonFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutTabletButtonFunc(void (*callback)(int, int, int, int))
     * }
     */
    public static MemorySegment glutTabletButtonFunc$address() {
        return glutTabletButtonFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutTabletButtonFunc(void (*callback)(int, int, int, int))
     * }
     */
    public static void glutTabletButtonFunc(MemorySegment callback) {
        var mh$ = glutTabletButtonFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutTabletButtonFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutGet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutGet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutGet(GLenum query)
     * }
     */
    public static FunctionDescriptor glutGet$descriptor() {
        return glutGet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutGet(GLenum query)
     * }
     */
    public static MethodHandle glutGet$handle() {
        return glutGet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutGet(GLenum query)
     * }
     */
    public static MemorySegment glutGet$address() {
        return glutGet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutGet(GLenum query)
     * }
     */
    public static int glutGet(int query) {
        var mh$ = glutGet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutGet", query);
            }
            return (int)mh$.invokeExact(query);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutDeviceGet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutDeviceGet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutDeviceGet(GLenum query)
     * }
     */
    public static FunctionDescriptor glutDeviceGet$descriptor() {
        return glutDeviceGet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutDeviceGet(GLenum query)
     * }
     */
    public static MethodHandle glutDeviceGet$handle() {
        return glutDeviceGet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutDeviceGet(GLenum query)
     * }
     */
    public static MemorySegment glutDeviceGet$address() {
        return glutDeviceGet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutDeviceGet(GLenum query)
     * }
     */
    public static int glutDeviceGet(int query) {
        var mh$ = glutDeviceGet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutDeviceGet", query);
            }
            return (int)mh$.invokeExact(query);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutGetModifiers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutGetModifiers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutGetModifiers()
     * }
     */
    public static FunctionDescriptor glutGetModifiers$descriptor() {
        return glutGetModifiers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutGetModifiers()
     * }
     */
    public static MethodHandle glutGetModifiers$handle() {
        return glutGetModifiers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutGetModifiers()
     * }
     */
    public static MemorySegment glutGetModifiers$address() {
        return glutGetModifiers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutGetModifiers()
     * }
     */
    public static int glutGetModifiers() {
        var mh$ = glutGetModifiers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutGetModifiers");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutLayerGet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutLayerGet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutLayerGet(GLenum query)
     * }
     */
    public static FunctionDescriptor glutLayerGet$descriptor() {
        return glutLayerGet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutLayerGet(GLenum query)
     * }
     */
    public static MethodHandle glutLayerGet$handle() {
        return glutLayerGet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutLayerGet(GLenum query)
     * }
     */
    public static MemorySegment glutLayerGet$address() {
        return glutLayerGet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutLayerGet(GLenum query)
     * }
     */
    public static int glutLayerGet(int query) {
        var mh$ = glutLayerGet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutLayerGet", query);
            }
            return (int)mh$.invokeExact(query);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutBitmapCharacter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutBitmapCharacter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutBitmapCharacter(void *font, int character)
     * }
     */
    public static FunctionDescriptor glutBitmapCharacter$descriptor() {
        return glutBitmapCharacter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutBitmapCharacter(void *font, int character)
     * }
     */
    public static MethodHandle glutBitmapCharacter$handle() {
        return glutBitmapCharacter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutBitmapCharacter(void *font, int character)
     * }
     */
    public static MemorySegment glutBitmapCharacter$address() {
        return glutBitmapCharacter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutBitmapCharacter(void *font, int character)
     * }
     */
    public static void glutBitmapCharacter(MemorySegment font, int character) {
        var mh$ = glutBitmapCharacter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutBitmapCharacter", font, character);
            }
            mh$.invokeExact(font, character);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutBitmapWidth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutBitmapWidth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutBitmapWidth(void *font, int character)
     * }
     */
    public static FunctionDescriptor glutBitmapWidth$descriptor() {
        return glutBitmapWidth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutBitmapWidth(void *font, int character)
     * }
     */
    public static MethodHandle glutBitmapWidth$handle() {
        return glutBitmapWidth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutBitmapWidth(void *font, int character)
     * }
     */
    public static MemorySegment glutBitmapWidth$address() {
        return glutBitmapWidth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutBitmapWidth(void *font, int character)
     * }
     */
    public static int glutBitmapWidth(MemorySegment font, int character) {
        var mh$ = glutBitmapWidth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutBitmapWidth", font, character);
            }
            return (int)mh$.invokeExact(font, character);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutStrokeCharacter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutStrokeCharacter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutStrokeCharacter(void *font, int character)
     * }
     */
    public static FunctionDescriptor glutStrokeCharacter$descriptor() {
        return glutStrokeCharacter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutStrokeCharacter(void *font, int character)
     * }
     */
    public static MethodHandle glutStrokeCharacter$handle() {
        return glutStrokeCharacter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutStrokeCharacter(void *font, int character)
     * }
     */
    public static MemorySegment glutStrokeCharacter$address() {
        return glutStrokeCharacter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutStrokeCharacter(void *font, int character)
     * }
     */
    public static void glutStrokeCharacter(MemorySegment font, int character) {
        var mh$ = glutStrokeCharacter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutStrokeCharacter", font, character);
            }
            mh$.invokeExact(font, character);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutStrokeWidth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutStrokeWidth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutStrokeWidth(void *font, int character)
     * }
     */
    public static FunctionDescriptor glutStrokeWidth$descriptor() {
        return glutStrokeWidth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutStrokeWidth(void *font, int character)
     * }
     */
    public static MethodHandle glutStrokeWidth$handle() {
        return glutStrokeWidth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutStrokeWidth(void *font, int character)
     * }
     */
    public static MemorySegment glutStrokeWidth$address() {
        return glutStrokeWidth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutStrokeWidth(void *font, int character)
     * }
     */
    public static int glutStrokeWidth(MemorySegment font, int character) {
        var mh$ = glutStrokeWidth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutStrokeWidth", font, character);
            }
            return (int)mh$.invokeExact(font, character);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutStrokeWidthf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_FLOAT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutStrokeWidthf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLfloat glutStrokeWidthf(void *font, int character)
     * }
     */
    public static FunctionDescriptor glutStrokeWidthf$descriptor() {
        return glutStrokeWidthf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLfloat glutStrokeWidthf(void *font, int character)
     * }
     */
    public static MethodHandle glutStrokeWidthf$handle() {
        return glutStrokeWidthf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLfloat glutStrokeWidthf(void *font, int character)
     * }
     */
    public static MemorySegment glutStrokeWidthf$address() {
        return glutStrokeWidthf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLfloat glutStrokeWidthf(void *font, int character)
     * }
     */
    public static float glutStrokeWidthf(MemorySegment font, int character) {
        var mh$ = glutStrokeWidthf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutStrokeWidthf", font, character);
            }
            return (float)mh$.invokeExact(font, character);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutBitmapLength {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutBitmapLength");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutBitmapLength(void *font, const unsigned char *string)
     * }
     */
    public static FunctionDescriptor glutBitmapLength$descriptor() {
        return glutBitmapLength.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutBitmapLength(void *font, const unsigned char *string)
     * }
     */
    public static MethodHandle glutBitmapLength$handle() {
        return glutBitmapLength.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutBitmapLength(void *font, const unsigned char *string)
     * }
     */
    public static MemorySegment glutBitmapLength$address() {
        return glutBitmapLength.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutBitmapLength(void *font, const unsigned char *string)
     * }
     */
    public static int glutBitmapLength(MemorySegment font, MemorySegment string) {
        var mh$ = glutBitmapLength.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutBitmapLength", font, string);
            }
            return (int)mh$.invokeExact(font, string);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutStrokeLength {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutStrokeLength");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutStrokeLength(void *font, const unsigned char *string)
     * }
     */
    public static FunctionDescriptor glutStrokeLength$descriptor() {
        return glutStrokeLength.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutStrokeLength(void *font, const unsigned char *string)
     * }
     */
    public static MethodHandle glutStrokeLength$handle() {
        return glutStrokeLength.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutStrokeLength(void *font, const unsigned char *string)
     * }
     */
    public static MemorySegment glutStrokeLength$address() {
        return glutStrokeLength.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutStrokeLength(void *font, const unsigned char *string)
     * }
     */
    public static int glutStrokeLength(MemorySegment font, MemorySegment string) {
        var mh$ = glutStrokeLength.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutStrokeLength", font, string);
            }
            return (int)mh$.invokeExact(font, string);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutStrokeLengthf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_FLOAT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutStrokeLengthf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLfloat glutStrokeLengthf(void *font, const unsigned char *string)
     * }
     */
    public static FunctionDescriptor glutStrokeLengthf$descriptor() {
        return glutStrokeLengthf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLfloat glutStrokeLengthf(void *font, const unsigned char *string)
     * }
     */
    public static MethodHandle glutStrokeLengthf$handle() {
        return glutStrokeLengthf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLfloat glutStrokeLengthf(void *font, const unsigned char *string)
     * }
     */
    public static MemorySegment glutStrokeLengthf$address() {
        return glutStrokeLengthf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLfloat glutStrokeLengthf(void *font, const unsigned char *string)
     * }
     */
    public static float glutStrokeLengthf(MemorySegment font, MemorySegment string) {
        var mh$ = glutStrokeLengthf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutStrokeLengthf", font, string);
            }
            return (float)mh$.invokeExact(font, string);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWireCube {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutWireCube");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWireCube(double size)
     * }
     */
    public static FunctionDescriptor glutWireCube$descriptor() {
        return glutWireCube.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWireCube(double size)
     * }
     */
    public static MethodHandle glutWireCube$handle() {
        return glutWireCube.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWireCube(double size)
     * }
     */
    public static MemorySegment glutWireCube$address() {
        return glutWireCube.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWireCube(double size)
     * }
     */
    public static void glutWireCube(double size) {
        var mh$ = glutWireCube.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWireCube", size);
            }
            mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSolidCube {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSolidCube");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSolidCube(double size)
     * }
     */
    public static FunctionDescriptor glutSolidCube$descriptor() {
        return glutSolidCube.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSolidCube(double size)
     * }
     */
    public static MethodHandle glutSolidCube$handle() {
        return glutSolidCube.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSolidCube(double size)
     * }
     */
    public static MemorySegment glutSolidCube$address() {
        return glutSolidCube.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSolidCube(double size)
     * }
     */
    public static void glutSolidCube(double size) {
        var mh$ = glutSolidCube.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSolidCube", size);
            }
            mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWireSphere {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutWireSphere");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWireSphere(double radius, GLint slices, GLint stacks)
     * }
     */
    public static FunctionDescriptor glutWireSphere$descriptor() {
        return glutWireSphere.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWireSphere(double radius, GLint slices, GLint stacks)
     * }
     */
    public static MethodHandle glutWireSphere$handle() {
        return glutWireSphere.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWireSphere(double radius, GLint slices, GLint stacks)
     * }
     */
    public static MemorySegment glutWireSphere$address() {
        return glutWireSphere.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWireSphere(double radius, GLint slices, GLint stacks)
     * }
     */
    public static void glutWireSphere(double radius, int slices, int stacks) {
        var mh$ = glutWireSphere.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWireSphere", radius, slices, stacks);
            }
            mh$.invokeExact(radius, slices, stacks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSolidSphere {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSolidSphere");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSolidSphere(double radius, GLint slices, GLint stacks)
     * }
     */
    public static FunctionDescriptor glutSolidSphere$descriptor() {
        return glutSolidSphere.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSolidSphere(double radius, GLint slices, GLint stacks)
     * }
     */
    public static MethodHandle glutSolidSphere$handle() {
        return glutSolidSphere.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSolidSphere(double radius, GLint slices, GLint stacks)
     * }
     */
    public static MemorySegment glutSolidSphere$address() {
        return glutSolidSphere.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSolidSphere(double radius, GLint slices, GLint stacks)
     * }
     */
    public static void glutSolidSphere(double radius, int slices, int stacks) {
        var mh$ = glutSolidSphere.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSolidSphere", radius, slices, stacks);
            }
            mh$.invokeExact(radius, slices, stacks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWireCone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutWireCone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWireCone(double base, double height, GLint slices, GLint stacks)
     * }
     */
    public static FunctionDescriptor glutWireCone$descriptor() {
        return glutWireCone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWireCone(double base, double height, GLint slices, GLint stacks)
     * }
     */
    public static MethodHandle glutWireCone$handle() {
        return glutWireCone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWireCone(double base, double height, GLint slices, GLint stacks)
     * }
     */
    public static MemorySegment glutWireCone$address() {
        return glutWireCone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWireCone(double base, double height, GLint slices, GLint stacks)
     * }
     */
    public static void glutWireCone(double base, double height, int slices, int stacks) {
        var mh$ = glutWireCone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWireCone", base, height, slices, stacks);
            }
            mh$.invokeExact(base, height, slices, stacks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSolidCone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSolidCone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSolidCone(double base, double height, GLint slices, GLint stacks)
     * }
     */
    public static FunctionDescriptor glutSolidCone$descriptor() {
        return glutSolidCone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSolidCone(double base, double height, GLint slices, GLint stacks)
     * }
     */
    public static MethodHandle glutSolidCone$handle() {
        return glutSolidCone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSolidCone(double base, double height, GLint slices, GLint stacks)
     * }
     */
    public static MemorySegment glutSolidCone$address() {
        return glutSolidCone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSolidCone(double base, double height, GLint slices, GLint stacks)
     * }
     */
    public static void glutSolidCone(double base, double height, int slices, int stacks) {
        var mh$ = glutSolidCone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSolidCone", base, height, slices, stacks);
            }
            mh$.invokeExact(base, height, slices, stacks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWireTorus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutWireTorus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWireTorus(double innerRadius, double outerRadius, GLint sides, GLint rings)
     * }
     */
    public static FunctionDescriptor glutWireTorus$descriptor() {
        return glutWireTorus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWireTorus(double innerRadius, double outerRadius, GLint sides, GLint rings)
     * }
     */
    public static MethodHandle glutWireTorus$handle() {
        return glutWireTorus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWireTorus(double innerRadius, double outerRadius, GLint sides, GLint rings)
     * }
     */
    public static MemorySegment glutWireTorus$address() {
        return glutWireTorus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWireTorus(double innerRadius, double outerRadius, GLint sides, GLint rings)
     * }
     */
    public static void glutWireTorus(double innerRadius, double outerRadius, int sides, int rings) {
        var mh$ = glutWireTorus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWireTorus", innerRadius, outerRadius, sides, rings);
            }
            mh$.invokeExact(innerRadius, outerRadius, sides, rings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSolidTorus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSolidTorus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSolidTorus(double innerRadius, double outerRadius, GLint sides, GLint rings)
     * }
     */
    public static FunctionDescriptor glutSolidTorus$descriptor() {
        return glutSolidTorus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSolidTorus(double innerRadius, double outerRadius, GLint sides, GLint rings)
     * }
     */
    public static MethodHandle glutSolidTorus$handle() {
        return glutSolidTorus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSolidTorus(double innerRadius, double outerRadius, GLint sides, GLint rings)
     * }
     */
    public static MemorySegment glutSolidTorus$address() {
        return glutSolidTorus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSolidTorus(double innerRadius, double outerRadius, GLint sides, GLint rings)
     * }
     */
    public static void glutSolidTorus(double innerRadius, double outerRadius, int sides, int rings) {
        var mh$ = glutSolidTorus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSolidTorus", innerRadius, outerRadius, sides, rings);
            }
            mh$.invokeExact(innerRadius, outerRadius, sides, rings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWireDodecahedron {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutWireDodecahedron");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWireDodecahedron()
     * }
     */
    public static FunctionDescriptor glutWireDodecahedron$descriptor() {
        return glutWireDodecahedron.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWireDodecahedron()
     * }
     */
    public static MethodHandle glutWireDodecahedron$handle() {
        return glutWireDodecahedron.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWireDodecahedron()
     * }
     */
    public static MemorySegment glutWireDodecahedron$address() {
        return glutWireDodecahedron.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWireDodecahedron()
     * }
     */
    public static void glutWireDodecahedron() {
        var mh$ = glutWireDodecahedron.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWireDodecahedron");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSolidDodecahedron {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSolidDodecahedron");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSolidDodecahedron()
     * }
     */
    public static FunctionDescriptor glutSolidDodecahedron$descriptor() {
        return glutSolidDodecahedron.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSolidDodecahedron()
     * }
     */
    public static MethodHandle glutSolidDodecahedron$handle() {
        return glutSolidDodecahedron.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSolidDodecahedron()
     * }
     */
    public static MemorySegment glutSolidDodecahedron$address() {
        return glutSolidDodecahedron.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSolidDodecahedron()
     * }
     */
    public static void glutSolidDodecahedron() {
        var mh$ = glutSolidDodecahedron.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSolidDodecahedron");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWireOctahedron {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutWireOctahedron");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWireOctahedron()
     * }
     */
    public static FunctionDescriptor glutWireOctahedron$descriptor() {
        return glutWireOctahedron.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWireOctahedron()
     * }
     */
    public static MethodHandle glutWireOctahedron$handle() {
        return glutWireOctahedron.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWireOctahedron()
     * }
     */
    public static MemorySegment glutWireOctahedron$address() {
        return glutWireOctahedron.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWireOctahedron()
     * }
     */
    public static void glutWireOctahedron() {
        var mh$ = glutWireOctahedron.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWireOctahedron");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSolidOctahedron {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSolidOctahedron");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSolidOctahedron()
     * }
     */
    public static FunctionDescriptor glutSolidOctahedron$descriptor() {
        return glutSolidOctahedron.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSolidOctahedron()
     * }
     */
    public static MethodHandle glutSolidOctahedron$handle() {
        return glutSolidOctahedron.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSolidOctahedron()
     * }
     */
    public static MemorySegment glutSolidOctahedron$address() {
        return glutSolidOctahedron.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSolidOctahedron()
     * }
     */
    public static void glutSolidOctahedron() {
        var mh$ = glutSolidOctahedron.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSolidOctahedron");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWireTetrahedron {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutWireTetrahedron");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWireTetrahedron()
     * }
     */
    public static FunctionDescriptor glutWireTetrahedron$descriptor() {
        return glutWireTetrahedron.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWireTetrahedron()
     * }
     */
    public static MethodHandle glutWireTetrahedron$handle() {
        return glutWireTetrahedron.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWireTetrahedron()
     * }
     */
    public static MemorySegment glutWireTetrahedron$address() {
        return glutWireTetrahedron.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWireTetrahedron()
     * }
     */
    public static void glutWireTetrahedron() {
        var mh$ = glutWireTetrahedron.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWireTetrahedron");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSolidTetrahedron {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSolidTetrahedron");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSolidTetrahedron()
     * }
     */
    public static FunctionDescriptor glutSolidTetrahedron$descriptor() {
        return glutSolidTetrahedron.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSolidTetrahedron()
     * }
     */
    public static MethodHandle glutSolidTetrahedron$handle() {
        return glutSolidTetrahedron.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSolidTetrahedron()
     * }
     */
    public static MemorySegment glutSolidTetrahedron$address() {
        return glutSolidTetrahedron.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSolidTetrahedron()
     * }
     */
    public static void glutSolidTetrahedron() {
        var mh$ = glutSolidTetrahedron.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSolidTetrahedron");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWireIcosahedron {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutWireIcosahedron");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWireIcosahedron()
     * }
     */
    public static FunctionDescriptor glutWireIcosahedron$descriptor() {
        return glutWireIcosahedron.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWireIcosahedron()
     * }
     */
    public static MethodHandle glutWireIcosahedron$handle() {
        return glutWireIcosahedron.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWireIcosahedron()
     * }
     */
    public static MemorySegment glutWireIcosahedron$address() {
        return glutWireIcosahedron.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWireIcosahedron()
     * }
     */
    public static void glutWireIcosahedron() {
        var mh$ = glutWireIcosahedron.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWireIcosahedron");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSolidIcosahedron {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSolidIcosahedron");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSolidIcosahedron()
     * }
     */
    public static FunctionDescriptor glutSolidIcosahedron$descriptor() {
        return glutSolidIcosahedron.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSolidIcosahedron()
     * }
     */
    public static MethodHandle glutSolidIcosahedron$handle() {
        return glutSolidIcosahedron.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSolidIcosahedron()
     * }
     */
    public static MemorySegment glutSolidIcosahedron$address() {
        return glutSolidIcosahedron.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSolidIcosahedron()
     * }
     */
    public static void glutSolidIcosahedron() {
        var mh$ = glutSolidIcosahedron.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSolidIcosahedron");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWireTeapot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutWireTeapot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWireTeapot(double size)
     * }
     */
    public static FunctionDescriptor glutWireTeapot$descriptor() {
        return glutWireTeapot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWireTeapot(double size)
     * }
     */
    public static MethodHandle glutWireTeapot$handle() {
        return glutWireTeapot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWireTeapot(double size)
     * }
     */
    public static MemorySegment glutWireTeapot$address() {
        return glutWireTeapot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWireTeapot(double size)
     * }
     */
    public static void glutWireTeapot(double size) {
        var mh$ = glutWireTeapot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWireTeapot", size);
            }
            mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSolidTeapot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSolidTeapot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSolidTeapot(double size)
     * }
     */
    public static FunctionDescriptor glutSolidTeapot$descriptor() {
        return glutSolidTeapot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSolidTeapot(double size)
     * }
     */
    public static MethodHandle glutSolidTeapot$handle() {
        return glutSolidTeapot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSolidTeapot(double size)
     * }
     */
    public static MemorySegment glutSolidTeapot$address() {
        return glutSolidTeapot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSolidTeapot(double size)
     * }
     */
    public static void glutSolidTeapot(double size) {
        var mh$ = glutSolidTeapot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSolidTeapot", size);
            }
            mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutGameModeString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutGameModeString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutGameModeString(const char *string)
     * }
     */
    public static FunctionDescriptor glutGameModeString$descriptor() {
        return glutGameModeString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutGameModeString(const char *string)
     * }
     */
    public static MethodHandle glutGameModeString$handle() {
        return glutGameModeString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutGameModeString(const char *string)
     * }
     */
    public static MemorySegment glutGameModeString$address() {
        return glutGameModeString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutGameModeString(const char *string)
     * }
     */
    public static void glutGameModeString(MemorySegment string) {
        var mh$ = glutGameModeString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutGameModeString", string);
            }
            mh$.invokeExact(string);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutEnterGameMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutEnterGameMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutEnterGameMode()
     * }
     */
    public static FunctionDescriptor glutEnterGameMode$descriptor() {
        return glutEnterGameMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutEnterGameMode()
     * }
     */
    public static MethodHandle glutEnterGameMode$handle() {
        return glutEnterGameMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutEnterGameMode()
     * }
     */
    public static MemorySegment glutEnterGameMode$address() {
        return glutEnterGameMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutEnterGameMode()
     * }
     */
    public static int glutEnterGameMode() {
        var mh$ = glutEnterGameMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutEnterGameMode");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutLeaveGameMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutLeaveGameMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutLeaveGameMode()
     * }
     */
    public static FunctionDescriptor glutLeaveGameMode$descriptor() {
        return glutLeaveGameMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutLeaveGameMode()
     * }
     */
    public static MethodHandle glutLeaveGameMode$handle() {
        return glutLeaveGameMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutLeaveGameMode()
     * }
     */
    public static MemorySegment glutLeaveGameMode$address() {
        return glutLeaveGameMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutLeaveGameMode()
     * }
     */
    public static void glutLeaveGameMode() {
        var mh$ = glutLeaveGameMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutLeaveGameMode");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutGameModeGet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutGameModeGet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutGameModeGet(GLenum query)
     * }
     */
    public static FunctionDescriptor glutGameModeGet$descriptor() {
        return glutGameModeGet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutGameModeGet(GLenum query)
     * }
     */
    public static MethodHandle glutGameModeGet$handle() {
        return glutGameModeGet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutGameModeGet(GLenum query)
     * }
     */
    public static MemorySegment glutGameModeGet$address() {
        return glutGameModeGet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutGameModeGet(GLenum query)
     * }
     */
    public static int glutGameModeGet(int query) {
        var mh$ = glutGameModeGet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutGameModeGet", query);
            }
            return (int)mh$.invokeExact(query);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutVideoResizeGet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutVideoResizeGet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutVideoResizeGet(GLenum query)
     * }
     */
    public static FunctionDescriptor glutVideoResizeGet$descriptor() {
        return glutVideoResizeGet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutVideoResizeGet(GLenum query)
     * }
     */
    public static MethodHandle glutVideoResizeGet$handle() {
        return glutVideoResizeGet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutVideoResizeGet(GLenum query)
     * }
     */
    public static MemorySegment glutVideoResizeGet$address() {
        return glutVideoResizeGet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutVideoResizeGet(GLenum query)
     * }
     */
    public static int glutVideoResizeGet(int query) {
        var mh$ = glutVideoResizeGet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutVideoResizeGet", query);
            }
            return (int)mh$.invokeExact(query);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSetupVideoResizing {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSetupVideoResizing");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSetupVideoResizing()
     * }
     */
    public static FunctionDescriptor glutSetupVideoResizing$descriptor() {
        return glutSetupVideoResizing.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSetupVideoResizing()
     * }
     */
    public static MethodHandle glutSetupVideoResizing$handle() {
        return glutSetupVideoResizing.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSetupVideoResizing()
     * }
     */
    public static MemorySegment glutSetupVideoResizing$address() {
        return glutSetupVideoResizing.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSetupVideoResizing()
     * }
     */
    public static void glutSetupVideoResizing() {
        var mh$ = glutSetupVideoResizing.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSetupVideoResizing");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutStopVideoResizing {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutStopVideoResizing");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutStopVideoResizing()
     * }
     */
    public static FunctionDescriptor glutStopVideoResizing$descriptor() {
        return glutStopVideoResizing.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutStopVideoResizing()
     * }
     */
    public static MethodHandle glutStopVideoResizing$handle() {
        return glutStopVideoResizing.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutStopVideoResizing()
     * }
     */
    public static MemorySegment glutStopVideoResizing$address() {
        return glutStopVideoResizing.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutStopVideoResizing()
     * }
     */
    public static void glutStopVideoResizing() {
        var mh$ = glutStopVideoResizing.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutStopVideoResizing");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutVideoResize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutVideoResize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutVideoResize(int x, int y, int width, int height)
     * }
     */
    public static FunctionDescriptor glutVideoResize$descriptor() {
        return glutVideoResize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutVideoResize(int x, int y, int width, int height)
     * }
     */
    public static MethodHandle glutVideoResize$handle() {
        return glutVideoResize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutVideoResize(int x, int y, int width, int height)
     * }
     */
    public static MemorySegment glutVideoResize$address() {
        return glutVideoResize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutVideoResize(int x, int y, int width, int height)
     * }
     */
    public static void glutVideoResize(int x, int y, int width, int height) {
        var mh$ = glutVideoResize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutVideoResize", x, y, width, height);
            }
            mh$.invokeExact(x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutVideoPan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutVideoPan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutVideoPan(int x, int y, int width, int height)
     * }
     */
    public static FunctionDescriptor glutVideoPan$descriptor() {
        return glutVideoPan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutVideoPan(int x, int y, int width, int height)
     * }
     */
    public static MethodHandle glutVideoPan$handle() {
        return glutVideoPan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutVideoPan(int x, int y, int width, int height)
     * }
     */
    public static MemorySegment glutVideoPan$address() {
        return glutVideoPan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutVideoPan(int x, int y, int width, int height)
     * }
     */
    public static void glutVideoPan(int x, int y, int width, int height) {
        var mh$ = glutVideoPan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutVideoPan", x, y, width, height);
            }
            mh$.invokeExact(x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSetColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSetColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSetColor(int color, GLfloat red, GLfloat green, GLfloat blue)
     * }
     */
    public static FunctionDescriptor glutSetColor$descriptor() {
        return glutSetColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSetColor(int color, GLfloat red, GLfloat green, GLfloat blue)
     * }
     */
    public static MethodHandle glutSetColor$handle() {
        return glutSetColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSetColor(int color, GLfloat red, GLfloat green, GLfloat blue)
     * }
     */
    public static MemorySegment glutSetColor$address() {
        return glutSetColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSetColor(int color, GLfloat red, GLfloat green, GLfloat blue)
     * }
     */
    public static void glutSetColor(int color, float red, float green, float blue) {
        var mh$ = glutSetColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSetColor", color, red, green, blue);
            }
            mh$.invokeExact(color, red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutGetColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_FLOAT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutGetColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLfloat glutGetColor(int color, int component)
     * }
     */
    public static FunctionDescriptor glutGetColor$descriptor() {
        return glutGetColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLfloat glutGetColor(int color, int component)
     * }
     */
    public static MethodHandle glutGetColor$handle() {
        return glutGetColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLfloat glutGetColor(int color, int component)
     * }
     */
    public static MemorySegment glutGetColor$address() {
        return glutGetColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLfloat glutGetColor(int color, int component)
     * }
     */
    public static float glutGetColor(int color, int component) {
        var mh$ = glutGetColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutGetColor", color, component);
            }
            return (float)mh$.invokeExact(color, component);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutCopyColormap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutCopyColormap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutCopyColormap(int window)
     * }
     */
    public static FunctionDescriptor glutCopyColormap$descriptor() {
        return glutCopyColormap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutCopyColormap(int window)
     * }
     */
    public static MethodHandle glutCopyColormap$handle() {
        return glutCopyColormap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutCopyColormap(int window)
     * }
     */
    public static MemorySegment glutCopyColormap$address() {
        return glutCopyColormap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutCopyColormap(int window)
     * }
     */
    public static void glutCopyColormap(int window) {
        var mh$ = glutCopyColormap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutCopyColormap", window);
            }
            mh$.invokeExact(window);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutIgnoreKeyRepeat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutIgnoreKeyRepeat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutIgnoreKeyRepeat(int ignore)
     * }
     */
    public static FunctionDescriptor glutIgnoreKeyRepeat$descriptor() {
        return glutIgnoreKeyRepeat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutIgnoreKeyRepeat(int ignore)
     * }
     */
    public static MethodHandle glutIgnoreKeyRepeat$handle() {
        return glutIgnoreKeyRepeat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutIgnoreKeyRepeat(int ignore)
     * }
     */
    public static MemorySegment glutIgnoreKeyRepeat$address() {
        return glutIgnoreKeyRepeat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutIgnoreKeyRepeat(int ignore)
     * }
     */
    public static void glutIgnoreKeyRepeat(int ignore) {
        var mh$ = glutIgnoreKeyRepeat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutIgnoreKeyRepeat", ignore);
            }
            mh$.invokeExact(ignore);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSetKeyRepeat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSetKeyRepeat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSetKeyRepeat(int repeatMode)
     * }
     */
    public static FunctionDescriptor glutSetKeyRepeat$descriptor() {
        return glutSetKeyRepeat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSetKeyRepeat(int repeatMode)
     * }
     */
    public static MethodHandle glutSetKeyRepeat$handle() {
        return glutSetKeyRepeat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSetKeyRepeat(int repeatMode)
     * }
     */
    public static MemorySegment glutSetKeyRepeat$address() {
        return glutSetKeyRepeat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSetKeyRepeat(int repeatMode)
     * }
     */
    public static void glutSetKeyRepeat(int repeatMode) {
        var mh$ = glutSetKeyRepeat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSetKeyRepeat", repeatMode);
            }
            mh$.invokeExact(repeatMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutForceJoystickFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutForceJoystickFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutForceJoystickFunc()
     * }
     */
    public static FunctionDescriptor glutForceJoystickFunc$descriptor() {
        return glutForceJoystickFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutForceJoystickFunc()
     * }
     */
    public static MethodHandle glutForceJoystickFunc$handle() {
        return glutForceJoystickFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutForceJoystickFunc()
     * }
     */
    public static MemorySegment glutForceJoystickFunc$address() {
        return glutForceJoystickFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutForceJoystickFunc()
     * }
     */
    public static void glutForceJoystickFunc() {
        var mh$ = glutForceJoystickFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutForceJoystickFunc");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutExtensionSupported {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutExtensionSupported");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutExtensionSupported(const char *extension)
     * }
     */
    public static FunctionDescriptor glutExtensionSupported$descriptor() {
        return glutExtensionSupported.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutExtensionSupported(const char *extension)
     * }
     */
    public static MethodHandle glutExtensionSupported$handle() {
        return glutExtensionSupported.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutExtensionSupported(const char *extension)
     * }
     */
    public static MemorySegment glutExtensionSupported$address() {
        return glutExtensionSupported.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutExtensionSupported(const char *extension)
     * }
     */
    public static int glutExtensionSupported(MemorySegment extension) {
        var mh$ = glutExtensionSupported.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutExtensionSupported", extension);
            }
            return (int)mh$.invokeExact(extension);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutReportErrors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutReportErrors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutReportErrors()
     * }
     */
    public static FunctionDescriptor glutReportErrors$descriptor() {
        return glutReportErrors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutReportErrors()
     * }
     */
    public static MethodHandle glutReportErrors$handle() {
        return glutReportErrors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutReportErrors()
     * }
     */
    public static MemorySegment glutReportErrors$address() {
        return glutReportErrors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutReportErrors()
     * }
     */
    public static void glutReportErrors() {
        var mh$ = glutReportErrors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutReportErrors");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int __darwin_nl_item
     * }
     */
    public static final OfInt __darwin_nl_item = freeglut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_wctrans_t
     * }
     */
    public static final OfInt __darwin_wctrans_t = freeglut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_wctype_t
     * }
     */
    public static final OfInt __darwin_wctype_t = freeglut_h.C_INT;
    private static final int P_ALL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.P_ALL = 0
     * }
     */
    public static int P_ALL() {
        return P_ALL;
    }
    private static final int P_PID = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.P_PID = 1
     * }
     */
    public static int P_PID() {
        return P_PID;
    }
    private static final int P_PGID = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.P_PGID = 2
     * }
     */
    public static int P_PGID() {
        return P_PGID;
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_pid_t pid_t
     * }
     */
    public static final OfInt pid_t = freeglut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_id_t id_t
     * }
     */
    public static final OfInt id_t = freeglut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int sig_atomic_t
     * }
     */
    public static final OfInt sig_atomic_t = freeglut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef struct __darwin_mcontext64 {
     *     struct __darwin_arm_exception_state64 __es;
     *     struct __darwin_arm_thread_state64 __ss;
     *     struct __darwin_arm_neon_state64 __ns;
     * } *mcontext_t
     * }
     */
    public static final AddressLayout mcontext_t = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __darwin_sigset_t sigset_t
     * }
     */
    public static final OfInt sigset_t = freeglut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_size_t size_t
     * }
     */
    public static final OfLong size_t = freeglut_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_uid_t uid_t
     * }
     */
    public static final OfInt uid_t = freeglut_h.C_INT;

    private static class signal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("signal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static FunctionDescriptor signal$descriptor() {
        return signal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static MethodHandle signal$handle() {
        return signal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static MemorySegment signal$address() {
        return signal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static MemorySegment signal(int x0, MemorySegment x1) {
        var mh$ = signal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("signal", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __uint64_t rlim_t
     * }
     */
    public static final OfLong rlim_t = freeglut_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef void *rusage_info_t
     * }
     */
    public static final AddressLayout rusage_info_t = freeglut_h.C_POINTER;

    private static class getpriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("getpriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getpriority(int, id_t)
     * }
     */
    public static FunctionDescriptor getpriority$descriptor() {
        return getpriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getpriority(int, id_t)
     * }
     */
    public static MethodHandle getpriority$handle() {
        return getpriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getpriority(int, id_t)
     * }
     */
    public static MemorySegment getpriority$address() {
        return getpriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getpriority(int, id_t)
     * }
     */
    public static int getpriority(int x0, int x1) {
        var mh$ = getpriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpriority", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getiopolicy_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("getiopolicy_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getiopolicy_np(int, int)
     * }
     */
    public static FunctionDescriptor getiopolicy_np$descriptor() {
        return getiopolicy_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getiopolicy_np(int, int)
     * }
     */
    public static MethodHandle getiopolicy_np$handle() {
        return getiopolicy_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getiopolicy_np(int, int)
     * }
     */
    public static MemorySegment getiopolicy_np$address() {
        return getiopolicy_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getiopolicy_np(int, int)
     * }
     */
    public static int getiopolicy_np(int x0, int x1) {
        var mh$ = getiopolicy_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getiopolicy_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getrlimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("getrlimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getrlimit(int, struct rlimit *)
     * }
     */
    public static FunctionDescriptor getrlimit$descriptor() {
        return getrlimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getrlimit(int, struct rlimit *)
     * }
     */
    public static MethodHandle getrlimit$handle() {
        return getrlimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getrlimit(int, struct rlimit *)
     * }
     */
    public static MemorySegment getrlimit$address() {
        return getrlimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getrlimit(int, struct rlimit *)
     * }
     */
    public static int getrlimit(int x0, MemorySegment x1) {
        var mh$ = getrlimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getrlimit", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getrusage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("getrusage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getrusage(int, struct rusage *)
     * }
     */
    public static FunctionDescriptor getrusage$descriptor() {
        return getrusage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getrusage(int, struct rusage *)
     * }
     */
    public static MethodHandle getrusage$handle() {
        return getrusage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getrusage(int, struct rusage *)
     * }
     */
    public static MemorySegment getrusage$address() {
        return getrusage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getrusage(int, struct rusage *)
     * }
     */
    public static int getrusage(int x0, MemorySegment x1) {
        var mh$ = getrusage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getrusage", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setpriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("setpriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setpriority(int, id_t, int)
     * }
     */
    public static FunctionDescriptor setpriority$descriptor() {
        return setpriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setpriority(int, id_t, int)
     * }
     */
    public static MethodHandle setpriority$handle() {
        return setpriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setpriority(int, id_t, int)
     * }
     */
    public static MemorySegment setpriority$address() {
        return setpriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setpriority(int, id_t, int)
     * }
     */
    public static int setpriority(int x0, int x1, int x2) {
        var mh$ = setpriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setpriority", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setiopolicy_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("setiopolicy_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setiopolicy_np(int, int, int)
     * }
     */
    public static FunctionDescriptor setiopolicy_np$descriptor() {
        return setiopolicy_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setiopolicy_np(int, int, int)
     * }
     */
    public static MethodHandle setiopolicy_np$handle() {
        return setiopolicy_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setiopolicy_np(int, int, int)
     * }
     */
    public static MemorySegment setiopolicy_np$address() {
        return setiopolicy_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setiopolicy_np(int, int, int)
     * }
     */
    public static int setiopolicy_np(int x0, int x1, int x2) {
        var mh$ = setiopolicy_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setiopolicy_np", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setrlimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("setrlimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setrlimit(int, const struct rlimit *)
     * }
     */
    public static FunctionDescriptor setrlimit$descriptor() {
        return setrlimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setrlimit(int, const struct rlimit *)
     * }
     */
    public static MethodHandle setrlimit$handle() {
        return setrlimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setrlimit(int, const struct rlimit *)
     * }
     */
    public static MemorySegment setrlimit$address() {
        return setrlimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setrlimit(int, const struct rlimit *)
     * }
     */
    public static int setrlimit(int x0, MemorySegment x1) {
        var mh$ = setrlimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setrlimit", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waitpid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("waitpid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t waitpid(pid_t, int *, int)
     * }
     */
    public static FunctionDescriptor waitpid$descriptor() {
        return waitpid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t waitpid(pid_t, int *, int)
     * }
     */
    public static MethodHandle waitpid$handle() {
        return waitpid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t waitpid(pid_t, int *, int)
     * }
     */
    public static MemorySegment waitpid$address() {
        return waitpid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t waitpid(pid_t, int *, int)
     * }
     */
    public static int waitpid(int x0, MemorySegment x1, int x2) {
        var mh$ = waitpid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waitpid", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waitid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("waitid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int waitid(idtype_t, id_t, siginfo_t *, int)
     * }
     */
    public static FunctionDescriptor waitid$descriptor() {
        return waitid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int waitid(idtype_t, id_t, siginfo_t *, int)
     * }
     */
    public static MethodHandle waitid$handle() {
        return waitid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int waitid(idtype_t, id_t, siginfo_t *, int)
     * }
     */
    public static MemorySegment waitid$address() {
        return waitid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int waitid(idtype_t, id_t, siginfo_t *, int)
     * }
     */
    public static int waitid(int x0, int x1, MemorySegment x2, int x3) {
        var mh$ = waitid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waitid", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wait3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wait3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t wait3(int *, int, struct rusage *)
     * }
     */
    public static FunctionDescriptor wait3$descriptor() {
        return wait3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t wait3(int *, int, struct rusage *)
     * }
     */
    public static MethodHandle wait3$handle() {
        return wait3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t wait3(int *, int, struct rusage *)
     * }
     */
    public static MemorySegment wait3$address() {
        return wait3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t wait3(int *, int, struct rusage *)
     * }
     */
    public static int wait3(MemorySegment x0, int x1, MemorySegment x2) {
        var mh$ = wait3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wait3", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wait4 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wait4");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t wait4(pid_t, int *, int, struct rusage *)
     * }
     */
    public static FunctionDescriptor wait4$descriptor() {
        return wait4.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t wait4(pid_t, int *, int, struct rusage *)
     * }
     */
    public static MethodHandle wait4$handle() {
        return wait4.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t wait4(pid_t, int *, int, struct rusage *)
     * }
     */
    public static MemorySegment wait4$address() {
        return wait4.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t wait4(pid_t, int *, int, struct rusage *)
     * }
     */
    public static int wait4(int x0, MemorySegment x1, int x2, MemorySegment x3) {
        var mh$ = wait4.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wait4", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class alloca {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("alloca");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *alloca(size_t)
     * }
     */
    public static FunctionDescriptor alloca$descriptor() {
        return alloca.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *alloca(size_t)
     * }
     */
    public static MethodHandle alloca$handle() {
        return alloca.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *alloca(size_t)
     * }
     */
    public static MemorySegment alloca$address() {
        return alloca.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *alloca(size_t)
     * }
     */
    public static MemorySegment alloca(long x0) {
        var mh$ = alloca.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("alloca", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_ct_rune_t ct_rune_t
     * }
     */
    public static final OfInt ct_rune_t = freeglut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_rune_t rune_t
     * }
     */
    public static final OfInt rune_t = freeglut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_wchar_t wchar_t
     * }
     */
    public static final OfInt wchar_t = freeglut_h.C_INT;

    private static class __mb_cur_max$constants {
        public static final OfInt LAYOUT = freeglut_h.C_INT;
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("__mb_cur_max").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int __mb_cur_max
     * }
     */
    public static OfInt __mb_cur_max$layout() {
        return __mb_cur_max$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int __mb_cur_max
     * }
     */
    public static MemorySegment __mb_cur_max$segment() {
        return __mb_cur_max$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int __mb_cur_max
     * }
     */
    public static int __mb_cur_max() {
        return __mb_cur_max$constants.SEGMENT.get(__mb_cur_max$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int __mb_cur_max
     * }
     */
    public static void __mb_cur_max(int varValue) {
        __mb_cur_max$constants.SEGMENT.set(__mb_cur_max$constants.LAYOUT, 0L, varValue);
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned long long malloc_type_id_t
     * }
     */
    public static final OfLong malloc_type_id_t = freeglut_h.C_LONG_LONG;

    private static class malloc_type_malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("malloc_type_malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_malloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_malloc$descriptor() {
        return malloc_type_malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_malloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_malloc$handle() {
        return malloc_type_malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_malloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_malloc$address() {
        return malloc_type_malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_malloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_malloc(long size, long type_id) {
        var mh$ = malloc_type_malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_malloc", size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("malloc_type_calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_calloc$descriptor() {
        return malloc_type_calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_calloc$handle() {
        return malloc_type_calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_calloc$address() {
        return malloc_type_calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_calloc(long count, long size, long type_id) {
        var mh$ = malloc_type_calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_calloc", count, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(count, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("malloc_type_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void malloc_type_free(void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_free$descriptor() {
        return malloc_type_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void malloc_type_free(void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_free$handle() {
        return malloc_type_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void malloc_type_free(void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_free$address() {
        return malloc_type_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void malloc_type_free(void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static void malloc_type_free(MemorySegment ptr, long type_id) {
        var mh$ = malloc_type_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_free", ptr, type_id);
            }
            mh$.invokeExact(ptr, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("malloc_type_realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_realloc$descriptor() {
        return malloc_type_realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_realloc$handle() {
        return malloc_type_realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_realloc$address() {
        return malloc_type_realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_realloc(MemorySegment ptr, long size, long type_id) {
        var mh$ = malloc_type_realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_realloc", ptr, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(ptr, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_valloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("malloc_type_valloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_valloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_valloc$descriptor() {
        return malloc_type_valloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_valloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_valloc$handle() {
        return malloc_type_valloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_valloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_valloc$address() {
        return malloc_type_valloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_valloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_valloc(long size, long type_id) {
        var mh$ = malloc_type_valloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_valloc", size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_aligned_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("malloc_type_aligned_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_aligned_alloc(size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_aligned_alloc$descriptor() {
        return malloc_type_aligned_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_aligned_alloc(size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_aligned_alloc$handle() {
        return malloc_type_aligned_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_aligned_alloc(size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_aligned_alloc$address() {
        return malloc_type_aligned_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_aligned_alloc(size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_aligned_alloc(long alignment, long size, long type_id) {
        var mh$ = malloc_type_aligned_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_aligned_alloc", alignment, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(alignment, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_posix_memalign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("malloc_type_posix_memalign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_posix_memalign$descriptor() {
        return malloc_type_posix_memalign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_posix_memalign$handle() {
        return malloc_type_posix_memalign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_posix_memalign$address() {
        return malloc_type_posix_memalign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static int malloc_type_posix_memalign(MemorySegment memptr, long alignment, long size, long type_id) {
        var mh$ = malloc_type_posix_memalign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_posix_memalign", memptr, alignment, size, type_id);
            }
            return (int)mh$.invokeExact(memptr, alignment, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("malloc_type_zone_malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_zone_malloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_malloc$descriptor() {
        return malloc_type_zone_malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_zone_malloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_malloc$handle() {
        return malloc_type_zone_malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_zone_malloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_malloc$address() {
        return malloc_type_zone_malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_zone_malloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_malloc(MemorySegment zone, long size, long type_id) {
        var mh$ = malloc_type_zone_malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_malloc", zone, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(zone, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("malloc_type_zone_calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_zone_calloc(malloc_zone_t *zone, size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_calloc$descriptor() {
        return malloc_type_zone_calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_zone_calloc(malloc_zone_t *zone, size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_calloc$handle() {
        return malloc_type_zone_calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_zone_calloc(malloc_zone_t *zone, size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_calloc$address() {
        return malloc_type_zone_calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_zone_calloc(malloc_zone_t *zone, size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_calloc(MemorySegment zone, long count, long size, long type_id) {
        var mh$ = malloc_type_zone_calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_calloc", zone, count, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(zone, count, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("malloc_type_zone_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void malloc_type_zone_free(malloc_zone_t *zone, void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_free$descriptor() {
        return malloc_type_zone_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void malloc_type_zone_free(malloc_zone_t *zone, void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_free$handle() {
        return malloc_type_zone_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void malloc_type_zone_free(malloc_zone_t *zone, void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_free$address() {
        return malloc_type_zone_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void malloc_type_zone_free(malloc_zone_t *zone, void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static void malloc_type_zone_free(MemorySegment zone, MemorySegment ptr, long type_id) {
        var mh$ = malloc_type_zone_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_free", zone, ptr, type_id);
            }
            mh$.invokeExact(zone, ptr, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("malloc_type_zone_realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_zone_realloc(malloc_zone_t *zone, void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_realloc$descriptor() {
        return malloc_type_zone_realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_zone_realloc(malloc_zone_t *zone, void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_realloc$handle() {
        return malloc_type_zone_realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_zone_realloc(malloc_zone_t *zone, void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_realloc$address() {
        return malloc_type_zone_realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_zone_realloc(malloc_zone_t *zone, void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_realloc(MemorySegment zone, MemorySegment ptr, long size, long type_id) {
        var mh$ = malloc_type_zone_realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_realloc", zone, ptr, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(zone, ptr, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_valloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("malloc_type_zone_valloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_zone_valloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_valloc$descriptor() {
        return malloc_type_zone_valloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_zone_valloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_valloc$handle() {
        return malloc_type_zone_valloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_zone_valloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_valloc$address() {
        return malloc_type_zone_valloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_zone_valloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_valloc(MemorySegment zone, long size, long type_id) {
        var mh$ = malloc_type_zone_valloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_valloc", zone, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(zone, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_memalign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("malloc_type_zone_memalign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_memalign$descriptor() {
        return malloc_type_zone_memalign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_memalign$handle() {
        return malloc_type_zone_memalign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_memalign$address() {
        return malloc_type_zone_memalign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_memalign(MemorySegment zone, long alignment, long size, long type_id) {
        var mh$ = malloc_type_zone_memalign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_memalign", zone, alignment, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(zone, alignment, size, type_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc(size_t __size)
     * }
     */
    public static FunctionDescriptor malloc$descriptor() {
        return malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc(size_t __size)
     * }
     */
    public static MethodHandle malloc$handle() {
        return malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc(size_t __size)
     * }
     */
    public static MemorySegment malloc$address() {
        return malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc(size_t __size)
     * }
     */
    public static MemorySegment malloc(long __size) {
        var mh$ = malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *calloc(size_t __count, size_t __size)
     * }
     */
    public static FunctionDescriptor calloc$descriptor() {
        return calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *calloc(size_t __count, size_t __size)
     * }
     */
    public static MethodHandle calloc$handle() {
        return calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *calloc(size_t __count, size_t __size)
     * }
     */
    public static MemorySegment calloc$address() {
        return calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *calloc(size_t __count, size_t __size)
     * }
     */
    public static MemorySegment calloc(long __count, long __size) {
        var mh$ = calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("calloc", __count, __size);
            }
            return (MemorySegment)mh$.invokeExact(__count, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void free(void *)
     * }
     */
    public static FunctionDescriptor free$descriptor() {
        return free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void free(void *)
     * }
     */
    public static MethodHandle free$handle() {
        return free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void free(void *)
     * }
     */
    public static MemorySegment free$address() {
        return free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void free(void *)
     * }
     */
    public static void free(MemorySegment x0) {
        var mh$ = free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("free", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static FunctionDescriptor realloc$descriptor() {
        return realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MethodHandle realloc$handle() {
        return realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment realloc$address() {
        return realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment realloc(MemorySegment __ptr, long __size) {
        var mh$ = realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realloc", __ptr, __size);
            }
            return (MemorySegment)mh$.invokeExact(__ptr, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class reallocf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("reallocf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *reallocf(void *__ptr, size_t __size)
     * }
     */
    public static FunctionDescriptor reallocf$descriptor() {
        return reallocf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *reallocf(void *__ptr, size_t __size)
     * }
     */
    public static MethodHandle reallocf$handle() {
        return reallocf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *reallocf(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment reallocf$address() {
        return reallocf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *reallocf(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment reallocf(MemorySegment __ptr, long __size) {
        var mh$ = reallocf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("reallocf", __ptr, __size);
            }
            return (MemorySegment)mh$.invokeExact(__ptr, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class valloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("valloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *valloc(size_t)
     * }
     */
    public static FunctionDescriptor valloc$descriptor() {
        return valloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *valloc(size_t)
     * }
     */
    public static MethodHandle valloc$handle() {
        return valloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *valloc(size_t)
     * }
     */
    public static MemorySegment valloc$address() {
        return valloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *valloc(size_t)
     * }
     */
    public static MemorySegment valloc(long x0) {
        var mh$ = valloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("valloc", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class aligned_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("aligned_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static FunctionDescriptor aligned_alloc$descriptor() {
        return aligned_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MethodHandle aligned_alloc$handle() {
        return aligned_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment aligned_alloc$address() {
        return aligned_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment aligned_alloc(long __alignment, long __size) {
        var mh$ = aligned_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("aligned_alloc", __alignment, __size);
            }
            return (MemorySegment)mh$.invokeExact(__alignment, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class posix_memalign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("posix_memalign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static FunctionDescriptor posix_memalign$descriptor() {
        return posix_memalign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static MethodHandle posix_memalign$handle() {
        return posix_memalign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment posix_memalign$address() {
        return posix_memalign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static int posix_memalign(MemorySegment __memptr, long __alignment, long __size) {
        var mh$ = posix_memalign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("posix_memalign", __memptr, __alignment, __size);
            }
            return (int)mh$.invokeExact(__memptr, __alignment, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("abort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static FunctionDescriptor abort$descriptor() {
        return abort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static MethodHandle abort$handle() {
        return abort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static MemorySegment abort$address() {
        return abort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static void abort() {
        var mh$ = abort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abort");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("abs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int abs(int)
     * }
     */
    public static FunctionDescriptor abs$descriptor() {
        return abs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int abs(int)
     * }
     */
    public static MethodHandle abs$handle() {
        return abs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int abs(int)
     * }
     */
    public static MemorySegment abs$address() {
        return abs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int abs(int)
     * }
     */
    public static int abs(int x0) {
        var mh$ = abs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abs", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atexit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("atexit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int atexit(void (* _Nonnull)(void))
     * }
     */
    public static FunctionDescriptor atexit$descriptor() {
        return atexit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int atexit(void (* _Nonnull)(void))
     * }
     */
    public static MethodHandle atexit$handle() {
        return atexit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int atexit(void (* _Nonnull)(void))
     * }
     */
    public static MemorySegment atexit$address() {
        return atexit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int atexit(void (* _Nonnull)(void))
     * }
     */
    public static int atexit(MemorySegment x0) {
        var mh$ = atexit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atexit", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("atof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double atof(const char *)
     * }
     */
    public static FunctionDescriptor atof$descriptor() {
        return atof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double atof(const char *)
     * }
     */
    public static MethodHandle atof$handle() {
        return atof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double atof(const char *)
     * }
     */
    public static MemorySegment atof$address() {
        return atof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double atof(const char *)
     * }
     */
    public static double atof(MemorySegment x0) {
        var mh$ = atof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atof", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("atoi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int atoi(const char *)
     * }
     */
    public static FunctionDescriptor atoi$descriptor() {
        return atoi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int atoi(const char *)
     * }
     */
    public static MethodHandle atoi$handle() {
        return atoi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int atoi(const char *)
     * }
     */
    public static MemorySegment atoi$address() {
        return atoi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int atoi(const char *)
     * }
     */
    public static int atoi(MemorySegment x0) {
        var mh$ = atoi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoi", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("atol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long atol(const char *)
     * }
     */
    public static FunctionDescriptor atol$descriptor() {
        return atol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long atol(const char *)
     * }
     */
    public static MethodHandle atol$handle() {
        return atol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long atol(const char *)
     * }
     */
    public static MemorySegment atol$address() {
        return atol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long atol(const char *)
     * }
     */
    public static long atol(MemorySegment x0) {
        var mh$ = atol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atol", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("atoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long atoll(const char *)
     * }
     */
    public static FunctionDescriptor atoll$descriptor() {
        return atoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long atoll(const char *)
     * }
     */
    public static MethodHandle atoll$handle() {
        return atoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long atoll(const char *)
     * }
     */
    public static MemorySegment atoll$address() {
        return atoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long atoll(const char *)
     * }
     */
    public static long atoll(MemorySegment x0) {
        var mh$ = atoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoll", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bsearch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("bsearch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor bsearch$descriptor() {
        return bsearch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle bsearch$handle() {
        return bsearch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment bsearch$address() {
        return bsearch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment bsearch(MemorySegment __key, MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = bsearch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bsearch", __key, __base, __nel, __width, __compar);
            }
            return (MemorySegment)mh$.invokeExact(__key, __base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class div {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            div_t.layout(),
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("div");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * div_t div(int, int)
     * }
     */
    public static FunctionDescriptor div$descriptor() {
        return div.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * div_t div(int, int)
     * }
     */
    public static MethodHandle div$handle() {
        return div.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * div_t div(int, int)
     * }
     */
    public static MemorySegment div$address() {
        return div.ADDR;
    }

    /**
     * {@snippet lang=c :
     * div_t div(int, int)
     * }
     */
    public static MemorySegment div(SegmentAllocator allocator, int x0, int x1) {
        var mh$ = div.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("div", allocator, x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void exit(int)
     * }
     */
    public static FunctionDescriptor exit$descriptor() {
        return exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void exit(int)
     * }
     */
    public static MethodHandle exit$handle() {
        return exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void exit(int)
     * }
     */
    public static MemorySegment exit$address() {
        return exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void exit(int)
     * }
     */
    public static void exit(int x0) {
        var mh$ = exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exit", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("getenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getenv(const char *)
     * }
     */
    public static FunctionDescriptor getenv$descriptor() {
        return getenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getenv(const char *)
     * }
     */
    public static MethodHandle getenv$handle() {
        return getenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getenv(const char *)
     * }
     */
    public static MemorySegment getenv$address() {
        return getenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getenv(const char *)
     * }
     */
    public static MemorySegment getenv(MemorySegment x0) {
        var mh$ = getenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getenv", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class labs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("labs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long labs(long)
     * }
     */
    public static FunctionDescriptor labs$descriptor() {
        return labs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long labs(long)
     * }
     */
    public static MethodHandle labs$handle() {
        return labs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long labs(long)
     * }
     */
    public static MemorySegment labs$address() {
        return labs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long labs(long)
     * }
     */
    public static long labs(long x0) {
        var mh$ = labs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("labs", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ldiv_t.layout(),
            freeglut_h.C_LONG,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ldiv_t ldiv(long, long)
     * }
     */
    public static FunctionDescriptor ldiv$descriptor() {
        return ldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ldiv_t ldiv(long, long)
     * }
     */
    public static MethodHandle ldiv$handle() {
        return ldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ldiv_t ldiv(long, long)
     * }
     */
    public static MemorySegment ldiv$address() {
        return ldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ldiv_t ldiv(long, long)
     * }
     */
    public static MemorySegment ldiv(SegmentAllocator allocator, long x0, long x1) {
        var mh$ = ldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldiv", allocator, x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("llabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long llabs(long long)
     * }
     */
    public static FunctionDescriptor llabs$descriptor() {
        return llabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long llabs(long long)
     * }
     */
    public static MethodHandle llabs$handle() {
        return llabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long llabs(long long)
     * }
     */
    public static MemorySegment llabs$address() {
        return llabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long llabs(long long)
     * }
     */
    public static long llabs(long x0) {
        var mh$ = llabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llabs", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lldiv_t.layout(),
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("lldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lldiv_t lldiv(long long, long long)
     * }
     */
    public static FunctionDescriptor lldiv$descriptor() {
        return lldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lldiv_t lldiv(long long, long long)
     * }
     */
    public static MethodHandle lldiv$handle() {
        return lldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lldiv_t lldiv(long long, long long)
     * }
     */
    public static MemorySegment lldiv$address() {
        return lldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lldiv_t lldiv(long long, long long)
     * }
     */
    public static MemorySegment lldiv(SegmentAllocator allocator, long x0, long x1) {
        var mh$ = lldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lldiv", allocator, x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mblen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("mblen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mblen(const char *__s, size_t __n)
     * }
     */
    public static FunctionDescriptor mblen$descriptor() {
        return mblen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mblen(const char *__s, size_t __n)
     * }
     */
    public static MethodHandle mblen$handle() {
        return mblen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mblen(const char *__s, size_t __n)
     * }
     */
    public static MemorySegment mblen$address() {
        return mblen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mblen(const char *__s, size_t __n)
     * }
     */
    public static int mblen(MemorySegment __s, long __n) {
        var mh$ = mblen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mblen", __s, __n);
            }
            return (int)mh$.invokeExact(__s, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbstowcs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("mbstowcs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static FunctionDescriptor mbstowcs$descriptor() {
        return mbstowcs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static MethodHandle mbstowcs$handle() {
        return mbstowcs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static MemorySegment mbstowcs$address() {
        return mbstowcs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static long mbstowcs(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = mbstowcs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbstowcs", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbtowc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("mbtowc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static FunctionDescriptor mbtowc$descriptor() {
        return mbtowc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static MethodHandle mbtowc$handle() {
        return mbtowc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static MemorySegment mbtowc$address() {
        return mbtowc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mbtowc(wchar_t *restrict, const char *restrict, size_t)
     * }
     */
    public static int mbtowc(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = mbtowc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbtowc", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("qsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor qsort$descriptor() {
        return qsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle qsort$handle() {
        return qsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment qsort$address() {
        return qsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static void qsort(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = qsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort", __base, __nel, __width, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("rand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static FunctionDescriptor rand$descriptor() {
        return rand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static MethodHandle rand$handle() {
        return rand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static MemorySegment rand$address() {
        return rand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static int rand() {
        var mh$ = rand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("srand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srand(unsigned int)
     * }
     */
    public static FunctionDescriptor srand$descriptor() {
        return srand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srand(unsigned int)
     * }
     */
    public static MethodHandle srand$handle() {
        return srand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srand(unsigned int)
     * }
     */
    public static MemorySegment srand$address() {
        return srand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srand(unsigned int)
     * }
     */
    public static void srand(int x0) {
        var mh$ = srand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strtod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double strtod(const char *, char **)
     * }
     */
    public static FunctionDescriptor strtod$descriptor() {
        return strtod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double strtod(const char *, char **)
     * }
     */
    public static MethodHandle strtod$handle() {
        return strtod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double strtod(const char *, char **)
     * }
     */
    public static MemorySegment strtod$address() {
        return strtod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double strtod(const char *, char **)
     * }
     */
    public static double strtod(MemorySegment x0, MemorySegment x1) {
        var mh$ = strtod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtod", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_FLOAT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strtof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float strtof(const char *, char **)
     * }
     */
    public static FunctionDescriptor strtof$descriptor() {
        return strtof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float strtof(const char *, char **)
     * }
     */
    public static MethodHandle strtof$handle() {
        return strtof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float strtof(const char *, char **)
     * }
     */
    public static MemorySegment strtof$address() {
        return strtof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float strtof(const char *, char **)
     * }
     */
    public static float strtof(MemorySegment x0, MemorySegment x1) {
        var mh$ = strtof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtof", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strtol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long strtol(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtol$descriptor() {
        return strtol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long strtol(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtol$handle() {
        return strtol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long strtol(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtol$address() {
        return strtol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long strtol(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtol(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtol", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strtoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long strtoll(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoll$descriptor() {
        return strtoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long strtoll(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtoll$handle() {
        return strtoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long strtoll(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtoll$address() {
        return strtoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long strtoll(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtoll(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoll", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strtoul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strtoul(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoul$descriptor() {
        return strtoul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strtoul(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtoul$handle() {
        return strtoul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strtoul(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtoul$address() {
        return strtoul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strtoul(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtoul(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtoul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoul", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strtoull");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoull$descriptor() {
        return strtoull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtoull$handle() {
        return strtoull.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtoull$address() {
        return strtoull.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtoull(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtoull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoull", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class system {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("system");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int system(const char *)
     * }
     */
    public static FunctionDescriptor system$descriptor() {
        return system.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int system(const char *)
     * }
     */
    public static MethodHandle system$handle() {
        return system.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int system(const char *)
     * }
     */
    public static MemorySegment system$address() {
        return system.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int system(const char *)
     * }
     */
    public static int system(MemorySegment x0) {
        var mh$ = system.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("system", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstombs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wcstombs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcstombs(char *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static FunctionDescriptor wcstombs$descriptor() {
        return wcstombs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcstombs(char *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static MethodHandle wcstombs$handle() {
        return wcstombs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcstombs(char *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static MemorySegment wcstombs$address() {
        return wcstombs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcstombs(char *restrict, const wchar_t *restrict, size_t)
     * }
     */
    public static long wcstombs(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = wcstombs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstombs", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wctomb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("wctomb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wctomb(char *, wchar_t)
     * }
     */
    public static FunctionDescriptor wctomb$descriptor() {
        return wctomb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wctomb(char *, wchar_t)
     * }
     */
    public static MethodHandle wctomb$handle() {
        return wctomb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wctomb(char *, wchar_t)
     * }
     */
    public static MemorySegment wctomb$address() {
        return wctomb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wctomb(char *, wchar_t)
     * }
     */
    public static int wctomb(MemorySegment x0, int x1) {
        var mh$ = wctomb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wctomb", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("_Exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static FunctionDescriptor _Exit$descriptor() {
        return _Exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static MethodHandle _Exit$handle() {
        return _Exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static MemorySegment _Exit$address() {
        return _Exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static void _Exit(int x0) {
        var mh$ = _Exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Exit", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class a64l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("a64l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long a64l(const char *)
     * }
     */
    public static FunctionDescriptor a64l$descriptor() {
        return a64l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long a64l(const char *)
     * }
     */
    public static MethodHandle a64l$handle() {
        return a64l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long a64l(const char *)
     * }
     */
    public static MemorySegment a64l$address() {
        return a64l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long a64l(const char *)
     * }
     */
    public static long a64l(MemorySegment x0) {
        var mh$ = a64l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("a64l", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class drand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_DOUBLE    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("drand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double drand48()
     * }
     */
    public static FunctionDescriptor drand48$descriptor() {
        return drand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double drand48()
     * }
     */
    public static MethodHandle drand48$handle() {
        return drand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double drand48()
     * }
     */
    public static MemorySegment drand48$address() {
        return drand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double drand48()
     * }
     */
    public static double drand48() {
        var mh$ = drand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("drand48");
            }
            return (double)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ecvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static FunctionDescriptor ecvt$descriptor() {
        return ecvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MethodHandle ecvt$handle() {
        return ecvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MemorySegment ecvt$address() {
        return ecvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MemorySegment ecvt(double x0, int x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ecvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecvt", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("erand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double erand48(unsigned short [3])
     * }
     */
    public static FunctionDescriptor erand48$descriptor() {
        return erand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double erand48(unsigned short [3])
     * }
     */
    public static MethodHandle erand48$handle() {
        return erand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double erand48(unsigned short [3])
     * }
     */
    public static MemorySegment erand48$address() {
        return erand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double erand48(unsigned short [3])
     * }
     */
    public static double erand48(MemorySegment x0) {
        var mh$ = erand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erand48", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("fcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *fcvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static FunctionDescriptor fcvt$descriptor() {
        return fcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *fcvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MethodHandle fcvt$handle() {
        return fcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *fcvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MemorySegment fcvt$address() {
        return fcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *fcvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MemorySegment fcvt(double x0, int x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = fcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcvt", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("gcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *gcvt(double, int, char *)
     * }
     */
    public static FunctionDescriptor gcvt$descriptor() {
        return gcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *gcvt(double, int, char *)
     * }
     */
    public static MethodHandle gcvt$handle() {
        return gcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *gcvt(double, int, char *)
     * }
     */
    public static MemorySegment gcvt$address() {
        return gcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *gcvt(double, int, char *)
     * }
     */
    public static MemorySegment gcvt(double x0, int x1, MemorySegment x2) {
        var mh$ = gcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcvt", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsubopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("getsubopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static FunctionDescriptor getsubopt$descriptor() {
        return getsubopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static MethodHandle getsubopt$handle() {
        return getsubopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static MemorySegment getsubopt$address() {
        return getsubopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static int getsubopt(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = getsubopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsubopt", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class grantpt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("grantpt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int grantpt(int)
     * }
     */
    public static FunctionDescriptor grantpt$descriptor() {
        return grantpt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int grantpt(int)
     * }
     */
    public static MethodHandle grantpt$handle() {
        return grantpt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int grantpt(int)
     * }
     */
    public static MemorySegment grantpt$address() {
        return grantpt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int grantpt(int)
     * }
     */
    public static int grantpt(int x0) {
        var mh$ = grantpt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("grantpt", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class initstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("initstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *initstate(unsigned int, char *, size_t)
     * }
     */
    public static FunctionDescriptor initstate$descriptor() {
        return initstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *initstate(unsigned int, char *, size_t)
     * }
     */
    public static MethodHandle initstate$handle() {
        return initstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *initstate(unsigned int, char *, size_t)
     * }
     */
    public static MemorySegment initstate$address() {
        return initstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *initstate(unsigned int, char *, size_t)
     * }
     */
    public static MemorySegment initstate(int x0, MemorySegment x1, long x2) {
        var mh$ = initstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initstate", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("jrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long jrand48(unsigned short [3])
     * }
     */
    public static FunctionDescriptor jrand48$descriptor() {
        return jrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long jrand48(unsigned short [3])
     * }
     */
    public static MethodHandle jrand48$handle() {
        return jrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long jrand48(unsigned short [3])
     * }
     */
    public static MemorySegment jrand48$address() {
        return jrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long jrand48(unsigned short [3])
     * }
     */
    public static long jrand48(MemorySegment x0) {
        var mh$ = jrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jrand48", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class l64a {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("l64a");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *l64a(long)
     * }
     */
    public static FunctionDescriptor l64a$descriptor() {
        return l64a.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *l64a(long)
     * }
     */
    public static MethodHandle l64a$handle() {
        return l64a.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *l64a(long)
     * }
     */
    public static MemorySegment l64a$address() {
        return l64a.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *l64a(long)
     * }
     */
    public static MemorySegment l64a(long x0) {
        var mh$ = l64a.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("l64a", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lcong48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("lcong48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void lcong48(unsigned short [7])
     * }
     */
    public static FunctionDescriptor lcong48$descriptor() {
        return lcong48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void lcong48(unsigned short [7])
     * }
     */
    public static MethodHandle lcong48$handle() {
        return lcong48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void lcong48(unsigned short [7])
     * }
     */
    public static MemorySegment lcong48$address() {
        return lcong48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void lcong48(unsigned short [7])
     * }
     */
    public static void lcong48(MemorySegment x0) {
        var mh$ = lcong48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lcong48", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("lrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long lrand48()
     * }
     */
    public static FunctionDescriptor lrand48$descriptor() {
        return lrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long lrand48()
     * }
     */
    public static MethodHandle lrand48$handle() {
        return lrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long lrand48()
     * }
     */
    public static MemorySegment lrand48$address() {
        return lrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long lrand48()
     * }
     */
    public static long lrand48() {
        var mh$ = lrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrand48");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mktemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("mktemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static FunctionDescriptor mktemp$descriptor() {
        return mktemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static MethodHandle mktemp$handle() {
        return mktemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static MemorySegment mktemp$address() {
        return mktemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static MemorySegment mktemp(MemorySegment x0) {
        var mh$ = mktemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mktemp", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("mkstemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static FunctionDescriptor mkstemp$descriptor() {
        return mkstemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static MethodHandle mkstemp$handle() {
        return mkstemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static MemorySegment mkstemp$address() {
        return mkstemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static int mkstemp(MemorySegment x0) {
        var mh$ = mkstemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstemp", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("mrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long mrand48()
     * }
     */
    public static FunctionDescriptor mrand48$descriptor() {
        return mrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long mrand48()
     * }
     */
    public static MethodHandle mrand48$handle() {
        return mrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long mrand48()
     * }
     */
    public static MemorySegment mrand48$address() {
        return mrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long mrand48()
     * }
     */
    public static long mrand48() {
        var mh$ = mrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mrand48");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("nrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long nrand48(unsigned short [3])
     * }
     */
    public static FunctionDescriptor nrand48$descriptor() {
        return nrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long nrand48(unsigned short [3])
     * }
     */
    public static MethodHandle nrand48$handle() {
        return nrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long nrand48(unsigned short [3])
     * }
     */
    public static MemorySegment nrand48$address() {
        return nrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long nrand48(unsigned short [3])
     * }
     */
    public static long nrand48(MemorySegment x0) {
        var mh$ = nrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nrand48", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class posix_openpt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("posix_openpt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int posix_openpt(int)
     * }
     */
    public static FunctionDescriptor posix_openpt$descriptor() {
        return posix_openpt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int posix_openpt(int)
     * }
     */
    public static MethodHandle posix_openpt$handle() {
        return posix_openpt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int posix_openpt(int)
     * }
     */
    public static MemorySegment posix_openpt$address() {
        return posix_openpt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int posix_openpt(int)
     * }
     */
    public static int posix_openpt(int x0) {
        var mh$ = posix_openpt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("posix_openpt", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ptsname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ptsname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ptsname(int)
     * }
     */
    public static FunctionDescriptor ptsname$descriptor() {
        return ptsname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ptsname(int)
     * }
     */
    public static MethodHandle ptsname$handle() {
        return ptsname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ptsname(int)
     * }
     */
    public static MemorySegment ptsname$address() {
        return ptsname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ptsname(int)
     * }
     */
    public static MemorySegment ptsname(int x0) {
        var mh$ = ptsname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ptsname", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ptsname_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("ptsname_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ptsname_r(int fildes, char *buffer, size_t buflen)
     * }
     */
    public static FunctionDescriptor ptsname_r$descriptor() {
        return ptsname_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ptsname_r(int fildes, char *buffer, size_t buflen)
     * }
     */
    public static MethodHandle ptsname_r$handle() {
        return ptsname_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ptsname_r(int fildes, char *buffer, size_t buflen)
     * }
     */
    public static MemorySegment ptsname_r$address() {
        return ptsname_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ptsname_r(int fildes, char *buffer, size_t buflen)
     * }
     */
    public static int ptsname_r(int fildes, MemorySegment buffer, long buflen) {
        var mh$ = ptsname_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ptsname_r", fildes, buffer, buflen);
            }
            return (int)mh$.invokeExact(fildes, buffer, buflen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("putenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putenv(char *)
     * }
     */
    public static FunctionDescriptor putenv$descriptor() {
        return putenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putenv(char *)
     * }
     */
    public static MethodHandle putenv$handle() {
        return putenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putenv(char *)
     * }
     */
    public static MemorySegment putenv$address() {
        return putenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putenv(char *)
     * }
     */
    public static int putenv(MemorySegment x0) {
        var mh$ = putenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putenv", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class random {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("random");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long random()
     * }
     */
    public static FunctionDescriptor random$descriptor() {
        return random.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long random()
     * }
     */
    public static MethodHandle random$handle() {
        return random.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long random()
     * }
     */
    public static MemorySegment random$address() {
        return random.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long random()
     * }
     */
    public static long random() {
        var mh$ = random.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("random");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("rand_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rand_r(unsigned int *)
     * }
     */
    public static FunctionDescriptor rand_r$descriptor() {
        return rand_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rand_r(unsigned int *)
     * }
     */
    public static MethodHandle rand_r$handle() {
        return rand_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rand_r(unsigned int *)
     * }
     */
    public static MemorySegment rand_r$address() {
        return rand_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rand_r(unsigned int *)
     * }
     */
    public static int rand_r(MemorySegment x0) {
        var mh$ = rand_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand_r", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realpath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("realpath$DARWIN_EXTSN");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *realpath(const char *restrict, char *restrict)
     * }
     */
    public static FunctionDescriptor realpath$descriptor() {
        return realpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *realpath(const char *restrict, char *restrict)
     * }
     */
    public static MethodHandle realpath$handle() {
        return realpath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *realpath(const char *restrict, char *restrict)
     * }
     */
    public static MemorySegment realpath$address() {
        return realpath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *realpath(const char *restrict, char *restrict)
     * }
     */
    public static MemorySegment realpath(MemorySegment x0, MemorySegment x1) {
        var mh$ = realpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realpath", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class seed48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("seed48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned short *seed48(unsigned short [3])
     * }
     */
    public static FunctionDescriptor seed48$descriptor() {
        return seed48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned short *seed48(unsigned short [3])
     * }
     */
    public static MethodHandle seed48$handle() {
        return seed48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned short *seed48(unsigned short [3])
     * }
     */
    public static MemorySegment seed48$address() {
        return seed48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned short *seed48(unsigned short [3])
     * }
     */
    public static MemorySegment seed48(MemorySegment x0) {
        var mh$ = seed48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("seed48", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("setenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setenv(const char *__name, const char *__value, int __overwrite)
     * }
     */
    public static FunctionDescriptor setenv$descriptor() {
        return setenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setenv(const char *__name, const char *__value, int __overwrite)
     * }
     */
    public static MethodHandle setenv$handle() {
        return setenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setenv(const char *__name, const char *__value, int __overwrite)
     * }
     */
    public static MemorySegment setenv$address() {
        return setenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setenv(const char *__name, const char *__value, int __overwrite)
     * }
     */
    public static int setenv(MemorySegment __name, MemorySegment __value, int __overwrite) {
        var mh$ = setenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setenv", __name, __value, __overwrite);
            }
            return (int)mh$.invokeExact(__name, __value, __overwrite);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setkey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("setkey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setkey(const char *)
     * }
     */
    public static FunctionDescriptor setkey$descriptor() {
        return setkey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setkey(const char *)
     * }
     */
    public static MethodHandle setkey$handle() {
        return setkey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setkey(const char *)
     * }
     */
    public static MemorySegment setkey$address() {
        return setkey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setkey(const char *)
     * }
     */
    public static void setkey(MemorySegment x0) {
        var mh$ = setkey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setkey", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("setstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *setstate(const char *)
     * }
     */
    public static FunctionDescriptor setstate$descriptor() {
        return setstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *setstate(const char *)
     * }
     */
    public static MethodHandle setstate$handle() {
        return setstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *setstate(const char *)
     * }
     */
    public static MemorySegment setstate$address() {
        return setstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *setstate(const char *)
     * }
     */
    public static MemorySegment setstate(MemorySegment x0) {
        var mh$ = setstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setstate", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("srand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srand48(long)
     * }
     */
    public static FunctionDescriptor srand48$descriptor() {
        return srand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srand48(long)
     * }
     */
    public static MethodHandle srand48$handle() {
        return srand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srand48(long)
     * }
     */
    public static MemorySegment srand48$address() {
        return srand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srand48(long)
     * }
     */
    public static void srand48(long x0) {
        var mh$ = srand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand48", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srandom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("srandom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srandom(unsigned int)
     * }
     */
    public static FunctionDescriptor srandom$descriptor() {
        return srandom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srandom(unsigned int)
     * }
     */
    public static MethodHandle srandom$handle() {
        return srandom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srandom(unsigned int)
     * }
     */
    public static MemorySegment srandom$address() {
        return srandom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srandom(unsigned int)
     * }
     */
    public static void srandom(int x0) {
        var mh$ = srandom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srandom", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unlockpt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("unlockpt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int unlockpt(int)
     * }
     */
    public static FunctionDescriptor unlockpt$descriptor() {
        return unlockpt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int unlockpt(int)
     * }
     */
    public static MethodHandle unlockpt$handle() {
        return unlockpt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int unlockpt(int)
     * }
     */
    public static MemorySegment unlockpt$address() {
        return unlockpt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int unlockpt(int)
     * }
     */
    public static int unlockpt(int x0) {
        var mh$ = unlockpt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unlockpt", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unsetenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("unsetenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int unsetenv(const char *)
     * }
     */
    public static FunctionDescriptor unsetenv$descriptor() {
        return unsetenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int unsetenv(const char *)
     * }
     */
    public static MethodHandle unsetenv$handle() {
        return unsetenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int unsetenv(const char *)
     * }
     */
    public static MemorySegment unsetenv$address() {
        return unsetenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int unsetenv(const char *)
     * }
     */
    public static int unsetenv(MemorySegment x0) {
        var mh$ = unsetenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unsetenv", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_dev_t dev_t
     * }
     */
    public static final OfInt dev_t = freeglut_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_mode_t mode_t
     * }
     */
    public static final OfShort mode_t = freeglut_h.C_SHORT;

    private static class arc4random {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("arc4random");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t arc4random()
     * }
     */
    public static FunctionDescriptor arc4random$descriptor() {
        return arc4random.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t arc4random()
     * }
     */
    public static MethodHandle arc4random$handle() {
        return arc4random.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t arc4random()
     * }
     */
    public static MemorySegment arc4random$address() {
        return arc4random.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t arc4random()
     * }
     */
    public static int arc4random() {
        var mh$ = arc4random.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_addrandom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("arc4random_addrandom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void arc4random_addrandom(unsigned char *, int)
     * }
     */
    public static FunctionDescriptor arc4random_addrandom$descriptor() {
        return arc4random_addrandom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void arc4random_addrandom(unsigned char *, int)
     * }
     */
    public static MethodHandle arc4random_addrandom$handle() {
        return arc4random_addrandom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void arc4random_addrandom(unsigned char *, int)
     * }
     */
    public static MemorySegment arc4random_addrandom$address() {
        return arc4random_addrandom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void arc4random_addrandom(unsigned char *, int)
     * }
     */
    public static void arc4random_addrandom(MemorySegment x0, int x1) {
        var mh$ = arc4random_addrandom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_addrandom", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_buf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("arc4random_buf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void arc4random_buf(void *__buf, size_t __nbytes)
     * }
     */
    public static FunctionDescriptor arc4random_buf$descriptor() {
        return arc4random_buf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void arc4random_buf(void *__buf, size_t __nbytes)
     * }
     */
    public static MethodHandle arc4random_buf$handle() {
        return arc4random_buf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void arc4random_buf(void *__buf, size_t __nbytes)
     * }
     */
    public static MemorySegment arc4random_buf$address() {
        return arc4random_buf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void arc4random_buf(void *__buf, size_t __nbytes)
     * }
     */
    public static void arc4random_buf(MemorySegment __buf, long __nbytes) {
        var mh$ = arc4random_buf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_buf", __buf, __nbytes);
            }
            mh$.invokeExact(__buf, __nbytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_stir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("arc4random_stir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void arc4random_stir()
     * }
     */
    public static FunctionDescriptor arc4random_stir$descriptor() {
        return arc4random_stir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void arc4random_stir()
     * }
     */
    public static MethodHandle arc4random_stir$handle() {
        return arc4random_stir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void arc4random_stir()
     * }
     */
    public static MemorySegment arc4random_stir$address() {
        return arc4random_stir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void arc4random_stir()
     * }
     */
    public static void arc4random_stir() {
        var mh$ = arc4random_stir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_stir");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_uniform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("arc4random_uniform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t arc4random_uniform(uint32_t __upper_bound)
     * }
     */
    public static FunctionDescriptor arc4random_uniform$descriptor() {
        return arc4random_uniform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t arc4random_uniform(uint32_t __upper_bound)
     * }
     */
    public static MethodHandle arc4random_uniform$handle() {
        return arc4random_uniform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t arc4random_uniform(uint32_t __upper_bound)
     * }
     */
    public static MemorySegment arc4random_uniform$address() {
        return arc4random_uniform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t arc4random_uniform(uint32_t __upper_bound)
     * }
     */
    public static int arc4random_uniform(int __upper_bound) {
        var mh$ = arc4random_uniform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_uniform", __upper_bound);
            }
            return (int)mh$.invokeExact(__upper_bound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atexit_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("atexit_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int atexit_b(void (^ _Nonnull)(void))
     * }
     */
    public static FunctionDescriptor atexit_b$descriptor() {
        return atexit_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int atexit_b(void (^ _Nonnull)(void))
     * }
     */
    public static MethodHandle atexit_b$handle() {
        return atexit_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int atexit_b(void (^ _Nonnull)(void))
     * }
     */
    public static MemorySegment atexit_b$address() {
        return atexit_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int atexit_b(void (^ _Nonnull)(void))
     * }
     */
    public static int atexit_b(MemorySegment x0) {
        var mh$ = atexit_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atexit_b", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bsearch_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("bsearch_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, __bsearch_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor bsearch_b$descriptor() {
        return bsearch_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, __bsearch_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle bsearch_b$handle() {
        return bsearch_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, __bsearch_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment bsearch_b$address() {
        return bsearch_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, __bsearch_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment bsearch_b(MemorySegment __key, MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = bsearch_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bsearch_b", __key, __base, __nel, __width, __compar);
            }
            return (MemorySegment)mh$.invokeExact(__key, __base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetcap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("cgetcap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *cgetcap(char *, const char *, int)
     * }
     */
    public static FunctionDescriptor cgetcap$descriptor() {
        return cgetcap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *cgetcap(char *, const char *, int)
     * }
     */
    public static MethodHandle cgetcap$handle() {
        return cgetcap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *cgetcap(char *, const char *, int)
     * }
     */
    public static MemorySegment cgetcap$address() {
        return cgetcap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *cgetcap(char *, const char *, int)
     * }
     */
    public static MemorySegment cgetcap(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = cgetcap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetcap", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("cgetclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetclose()
     * }
     */
    public static FunctionDescriptor cgetclose$descriptor() {
        return cgetclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetclose()
     * }
     */
    public static MethodHandle cgetclose$handle() {
        return cgetclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetclose()
     * }
     */
    public static MemorySegment cgetclose$address() {
        return cgetclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetclose()
     * }
     */
    public static int cgetclose() {
        var mh$ = cgetclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetclose");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("cgetent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetent(char **, char **, const char *)
     * }
     */
    public static FunctionDescriptor cgetent$descriptor() {
        return cgetent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetent(char **, char **, const char *)
     * }
     */
    public static MethodHandle cgetent$handle() {
        return cgetent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetent(char **, char **, const char *)
     * }
     */
    public static MemorySegment cgetent$address() {
        return cgetent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetent(char **, char **, const char *)
     * }
     */
    public static int cgetent(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = cgetent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetent", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetfirst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("cgetfirst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetfirst(char **, char **)
     * }
     */
    public static FunctionDescriptor cgetfirst$descriptor() {
        return cgetfirst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetfirst(char **, char **)
     * }
     */
    public static MethodHandle cgetfirst$handle() {
        return cgetfirst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetfirst(char **, char **)
     * }
     */
    public static MemorySegment cgetfirst$address() {
        return cgetfirst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetfirst(char **, char **)
     * }
     */
    public static int cgetfirst(MemorySegment x0, MemorySegment x1) {
        var mh$ = cgetfirst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetfirst", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetmatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("cgetmatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetmatch(const char *, const char *)
     * }
     */
    public static FunctionDescriptor cgetmatch$descriptor() {
        return cgetmatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetmatch(const char *, const char *)
     * }
     */
    public static MethodHandle cgetmatch$handle() {
        return cgetmatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetmatch(const char *, const char *)
     * }
     */
    public static MemorySegment cgetmatch$address() {
        return cgetmatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetmatch(const char *, const char *)
     * }
     */
    public static int cgetmatch(MemorySegment x0, MemorySegment x1) {
        var mh$ = cgetmatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetmatch", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetnext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("cgetnext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetnext(char **, char **)
     * }
     */
    public static FunctionDescriptor cgetnext$descriptor() {
        return cgetnext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetnext(char **, char **)
     * }
     */
    public static MethodHandle cgetnext$handle() {
        return cgetnext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetnext(char **, char **)
     * }
     */
    public static MemorySegment cgetnext$address() {
        return cgetnext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetnext(char **, char **)
     * }
     */
    public static int cgetnext(MemorySegment x0, MemorySegment x1) {
        var mh$ = cgetnext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetnext", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetnum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("cgetnum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetnum(char *, const char *, long *)
     * }
     */
    public static FunctionDescriptor cgetnum$descriptor() {
        return cgetnum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetnum(char *, const char *, long *)
     * }
     */
    public static MethodHandle cgetnum$handle() {
        return cgetnum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetnum(char *, const char *, long *)
     * }
     */
    public static MemorySegment cgetnum$address() {
        return cgetnum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetnum(char *, const char *, long *)
     * }
     */
    public static int cgetnum(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = cgetnum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetnum", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("cgetset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetset(const char *)
     * }
     */
    public static FunctionDescriptor cgetset$descriptor() {
        return cgetset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetset(const char *)
     * }
     */
    public static MethodHandle cgetset$handle() {
        return cgetset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetset(const char *)
     * }
     */
    public static MemorySegment cgetset$address() {
        return cgetset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetset(const char *)
     * }
     */
    public static int cgetset(MemorySegment x0) {
        var mh$ = cgetset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetset", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("cgetstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetstr(char *, const char *, char **)
     * }
     */
    public static FunctionDescriptor cgetstr$descriptor() {
        return cgetstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetstr(char *, const char *, char **)
     * }
     */
    public static MethodHandle cgetstr$handle() {
        return cgetstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetstr(char *, const char *, char **)
     * }
     */
    public static MemorySegment cgetstr$address() {
        return cgetstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetstr(char *, const char *, char **)
     * }
     */
    public static int cgetstr(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = cgetstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetstr", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetustr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("cgetustr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetustr(char *, const char *, char **)
     * }
     */
    public static FunctionDescriptor cgetustr$descriptor() {
        return cgetustr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetustr(char *, const char *, char **)
     * }
     */
    public static MethodHandle cgetustr$handle() {
        return cgetustr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetustr(char *, const char *, char **)
     * }
     */
    public static MemorySegment cgetustr$address() {
        return cgetustr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetustr(char *, const char *, char **)
     * }
     */
    public static int cgetustr(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = cgetustr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetustr", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class daemon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("daemon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int daemon(int, int)
     * }
     */
    public static FunctionDescriptor daemon$descriptor() {
        return daemon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int daemon(int, int)
     * }
     */
    public static MethodHandle daemon$handle() {
        return daemon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int daemon(int, int)
     * }
     */
    public static MemorySegment daemon$address() {
        return daemon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int daemon(int, int)
     * }
     */
    public static int daemon(int x0, int x1) {
        var mh$ = daemon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("daemon", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class devname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_SHORT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("devname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *devname(dev_t, mode_t)
     * }
     */
    public static FunctionDescriptor devname$descriptor() {
        return devname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *devname(dev_t, mode_t)
     * }
     */
    public static MethodHandle devname$handle() {
        return devname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *devname(dev_t, mode_t)
     * }
     */
    public static MemorySegment devname$address() {
        return devname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *devname(dev_t, mode_t)
     * }
     */
    public static MemorySegment devname(int x0, short x1) {
        var mh$ = devname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("devname", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class devname_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_SHORT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("devname_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *devname_r(dev_t, mode_t, char *buf, int len)
     * }
     */
    public static FunctionDescriptor devname_r$descriptor() {
        return devname_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *devname_r(dev_t, mode_t, char *buf, int len)
     * }
     */
    public static MethodHandle devname_r$handle() {
        return devname_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *devname_r(dev_t, mode_t, char *buf, int len)
     * }
     */
    public static MemorySegment devname_r$address() {
        return devname_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *devname_r(dev_t, mode_t, char *buf, int len)
     * }
     */
    public static MemorySegment devname_r(int x0, short x1, MemorySegment buf, int len) {
        var mh$ = devname_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("devname_r", x0, x1, buf, len);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, buf, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getbsize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("getbsize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getbsize(int *, long *)
     * }
     */
    public static FunctionDescriptor getbsize$descriptor() {
        return getbsize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getbsize(int *, long *)
     * }
     */
    public static MethodHandle getbsize$handle() {
        return getbsize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getbsize(int *, long *)
     * }
     */
    public static MemorySegment getbsize$address() {
        return getbsize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getbsize(int *, long *)
     * }
     */
    public static MemorySegment getbsize(MemorySegment x0, MemorySegment x1) {
        var mh$ = getbsize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getbsize", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getloadavg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("getloadavg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getloadavg(double [], int)
     * }
     */
    public static FunctionDescriptor getloadavg$descriptor() {
        return getloadavg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getloadavg(double [], int)
     * }
     */
    public static MethodHandle getloadavg$handle() {
        return getloadavg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getloadavg(double [], int)
     * }
     */
    public static MemorySegment getloadavg$address() {
        return getloadavg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getloadavg(double [], int)
     * }
     */
    public static int getloadavg(MemorySegment x0, int x1) {
        var mh$ = getloadavg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getloadavg", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getprogname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("getprogname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *getprogname()
     * }
     */
    public static FunctionDescriptor getprogname$descriptor() {
        return getprogname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *getprogname()
     * }
     */
    public static MethodHandle getprogname$handle() {
        return getprogname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *getprogname()
     * }
     */
    public static MemorySegment getprogname$address() {
        return getprogname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *getprogname()
     * }
     */
    public static MemorySegment getprogname() {
        var mh$ = getprogname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getprogname");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setprogname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("setprogname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setprogname(const char *)
     * }
     */
    public static FunctionDescriptor setprogname$descriptor() {
        return setprogname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setprogname(const char *)
     * }
     */
    public static MethodHandle setprogname$handle() {
        return setprogname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setprogname(const char *)
     * }
     */
    public static MemorySegment setprogname$address() {
        return setprogname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setprogname(const char *)
     * }
     */
    public static void setprogname(MemorySegment x0) {
        var mh$ = setprogname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setprogname", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heapsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("heapsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heapsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor heapsort$descriptor() {
        return heapsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heapsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle heapsort$handle() {
        return heapsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heapsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment heapsort$address() {
        return heapsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heapsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static int heapsort(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = heapsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heapsort", __base, __nel, __width, __compar);
            }
            return (int)mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heapsort_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("heapsort_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heapsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor heapsort_b$descriptor() {
        return heapsort_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heapsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle heapsort_b$handle() {
        return heapsort_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heapsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment heapsort_b$address() {
        return heapsort_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heapsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static int heapsort_b(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = heapsort_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heapsort_b", __base, __nel, __width, __compar);
            }
            return (int)mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mergesort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("mergesort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mergesort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor mergesort$descriptor() {
        return mergesort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mergesort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle mergesort$handle() {
        return mergesort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mergesort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment mergesort$address() {
        return mergesort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mergesort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static int mergesort(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = mergesort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mergesort", __base, __nel, __width, __compar);
            }
            return (int)mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mergesort_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("mergesort_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mergesort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor mergesort_b$descriptor() {
        return mergesort_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mergesort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle mergesort_b$handle() {
        return mergesort_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mergesort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment mergesort_b$address() {
        return mergesort_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mergesort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static int mergesort_b(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = mergesort_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mergesort_b", __base, __nel, __width, __compar);
            }
            return (int)mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class psort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("psort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void psort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor psort$descriptor() {
        return psort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void psort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle psort$handle() {
        return psort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void psort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment psort$address() {
        return psort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void psort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static void psort(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = psort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("psort", __base, __nel, __width, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class psort_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("psort_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void psort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor psort_b$descriptor() {
        return psort_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void psort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle psort_b$handle() {
        return psort_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void psort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment psort_b$address() {
        return psort_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void psort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static void psort_b(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = psort_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("psort_b", __base, __nel, __width, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class psort_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("psort_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void psort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static FunctionDescriptor psort_r$descriptor() {
        return psort_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void psort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static MethodHandle psort_r$handle() {
        return psort_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void psort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static MemorySegment psort_r$address() {
        return psort_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void psort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static void psort_r(MemorySegment __base, long __nel, long __width, MemorySegment x3, MemorySegment __compar) {
        var mh$ = psort_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("psort_r", __base, __nel, __width, x3, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, x3, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("qsort_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor qsort_b$descriptor() {
        return qsort_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle qsort_b$handle() {
        return qsort_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment qsort_b$address() {
        return qsort_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static void qsort_b(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = qsort_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort_b", __base, __nel, __width, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG,
            freeglut_h.C_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("qsort_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static FunctionDescriptor qsort_r$descriptor() {
        return qsort_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static MethodHandle qsort_r$handle() {
        return qsort_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static MemorySegment qsort_r$address() {
        return qsort_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static void qsort_r(MemorySegment __base, long __nel, long __width, MemorySegment x3, MemorySegment __compar) {
        var mh$ = qsort_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort_r", __base, __nel, __width, x3, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, x3, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class radixsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("radixsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static FunctionDescriptor radixsort$descriptor() {
        return radixsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static MethodHandle radixsort$handle() {
        return radixsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static MemorySegment radixsort$address() {
        return radixsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static int radixsort(MemorySegment __base, int __nel, MemorySegment __table, int __endbyte) {
        var mh$ = radixsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("radixsort", __base, __nel, __table, __endbyte);
            }
            return (int)mh$.invokeExact(__base, __nel, __table, __endbyte);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rpmatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("rpmatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rpmatch(const char *)
     * }
     */
    public static FunctionDescriptor rpmatch$descriptor() {
        return rpmatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rpmatch(const char *)
     * }
     */
    public static MethodHandle rpmatch$handle() {
        return rpmatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rpmatch(const char *)
     * }
     */
    public static MemorySegment rpmatch$address() {
        return rpmatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rpmatch(const char *)
     * }
     */
    public static int rpmatch(MemorySegment x0) {
        var mh$ = rpmatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rpmatch", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sradixsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("sradixsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static FunctionDescriptor sradixsort$descriptor() {
        return sradixsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static MethodHandle sradixsort$handle() {
        return sradixsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static MemorySegment sradixsort$address() {
        return sradixsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static int sradixsort(MemorySegment __base, int __nel, MemorySegment __table, int __endbyte) {
        var mh$ = sradixsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sradixsort", __base, __nel, __table, __endbyte);
            }
            return (int)mh$.invokeExact(__base, __nel, __table, __endbyte);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sranddev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("sranddev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sranddev()
     * }
     */
    public static FunctionDescriptor sranddev$descriptor() {
        return sranddev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sranddev()
     * }
     */
    public static MethodHandle sranddev$handle() {
        return sranddev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sranddev()
     * }
     */
    public static MemorySegment sranddev$address() {
        return sranddev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sranddev()
     * }
     */
    public static void sranddev() {
        var mh$ = sranddev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sranddev");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srandomdev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("srandomdev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srandomdev()
     * }
     */
    public static FunctionDescriptor srandomdev$descriptor() {
        return srandomdev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srandomdev()
     * }
     */
    public static MethodHandle srandomdev$handle() {
        return srandomdev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srandomdev()
     * }
     */
    public static MemorySegment srandomdev$address() {
        return srandomdev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srandomdev()
     * }
     */
    public static void srandomdev() {
        var mh$ = srandomdev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srandomdev");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtonum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strtonum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
     * }
     */
    public static FunctionDescriptor strtonum$descriptor() {
        return strtonum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
     * }
     */
    public static MethodHandle strtonum$handle() {
        return strtonum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
     * }
     */
    public static MemorySegment strtonum$address() {
        return strtonum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
     * }
     */
    public static long strtonum(MemorySegment __numstr, long __minval, long __maxval, MemorySegment __errstrp) {
        var mh$ = strtonum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtonum", __numstr, __minval, __maxval, __errstrp);
            }
            return (long)mh$.invokeExact(__numstr, __minval, __maxval, __errstrp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strtoq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long strtoq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoq$descriptor() {
        return strtoq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long strtoq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtoq$handle() {
        return strtoq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long strtoq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtoq$address() {
        return strtoq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long strtoq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtoq(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtoq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoq", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtouq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_LONG_LONG,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("strtouq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long strtouq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtouq$descriptor() {
        return strtouq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long strtouq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtouq$handle() {
        return strtouq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long strtouq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtouq$address() {
        return strtouq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long strtouq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtouq(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtouq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtouq", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class suboptarg$constants {
        public static final AddressLayout LAYOUT = freeglut_h.C_POINTER;
        public static final MemorySegment SEGMENT = freeglut_h.findOrThrow("suboptarg").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static AddressLayout suboptarg$layout() {
        return suboptarg$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static MemorySegment suboptarg$segment() {
        return suboptarg$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static MemorySegment suboptarg() {
        return suboptarg$constants.SEGMENT.get(suboptarg$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static void suboptarg(MemorySegment varValue) {
        suboptarg$constants.SEGMENT.set(suboptarg$constants.LAYOUT, 0L, varValue);
    }

    private static class glutMainLoopEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutMainLoopEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMainLoopEvent()
     * }
     */
    public static FunctionDescriptor glutMainLoopEvent$descriptor() {
        return glutMainLoopEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMainLoopEvent()
     * }
     */
    public static MethodHandle glutMainLoopEvent$handle() {
        return glutMainLoopEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMainLoopEvent()
     * }
     */
    public static MemorySegment glutMainLoopEvent$address() {
        return glutMainLoopEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMainLoopEvent()
     * }
     */
    public static void glutMainLoopEvent() {
        var mh$ = glutMainLoopEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMainLoopEvent");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutLeaveMainLoop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutLeaveMainLoop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutLeaveMainLoop()
     * }
     */
    public static FunctionDescriptor glutLeaveMainLoop$descriptor() {
        return glutLeaveMainLoop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutLeaveMainLoop()
     * }
     */
    public static MethodHandle glutLeaveMainLoop$handle() {
        return glutLeaveMainLoop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutLeaveMainLoop()
     * }
     */
    public static MemorySegment glutLeaveMainLoop$address() {
        return glutLeaveMainLoop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutLeaveMainLoop()
     * }
     */
    public static void glutLeaveMainLoop() {
        var mh$ = glutLeaveMainLoop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutLeaveMainLoop");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutExit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutExit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutExit()
     * }
     */
    public static FunctionDescriptor glutExit$descriptor() {
        return glutExit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutExit()
     * }
     */
    public static MethodHandle glutExit$handle() {
        return glutExit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutExit()
     * }
     */
    public static MemorySegment glutExit$address() {
        return glutExit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutExit()
     * }
     */
    public static void glutExit() {
        var mh$ = glutExit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutExit");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutFullScreenToggle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutFullScreenToggle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutFullScreenToggle()
     * }
     */
    public static FunctionDescriptor glutFullScreenToggle$descriptor() {
        return glutFullScreenToggle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutFullScreenToggle()
     * }
     */
    public static MethodHandle glutFullScreenToggle$handle() {
        return glutFullScreenToggle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutFullScreenToggle()
     * }
     */
    public static MemorySegment glutFullScreenToggle$address() {
        return glutFullScreenToggle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutFullScreenToggle()
     * }
     */
    public static void glutFullScreenToggle() {
        var mh$ = glutFullScreenToggle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutFullScreenToggle");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutLeaveFullScreen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutLeaveFullScreen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutLeaveFullScreen()
     * }
     */
    public static FunctionDescriptor glutLeaveFullScreen$descriptor() {
        return glutLeaveFullScreen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutLeaveFullScreen()
     * }
     */
    public static MethodHandle glutLeaveFullScreen$handle() {
        return glutLeaveFullScreen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutLeaveFullScreen()
     * }
     */
    public static MemorySegment glutLeaveFullScreen$address() {
        return glutLeaveFullScreen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutLeaveFullScreen()
     * }
     */
    public static void glutLeaveFullScreen() {
        var mh$ = glutLeaveFullScreen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutLeaveFullScreen");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSetMenuFont {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSetMenuFont");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSetMenuFont(int menuID, void *font)
     * }
     */
    public static FunctionDescriptor glutSetMenuFont$descriptor() {
        return glutSetMenuFont.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSetMenuFont(int menuID, void *font)
     * }
     */
    public static MethodHandle glutSetMenuFont$handle() {
        return glutSetMenuFont.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSetMenuFont(int menuID, void *font)
     * }
     */
    public static MemorySegment glutSetMenuFont$address() {
        return glutSetMenuFont.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSetMenuFont(int menuID, void *font)
     * }
     */
    public static void glutSetMenuFont(int menuID, MemorySegment font) {
        var mh$ = glutSetMenuFont.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSetMenuFont", menuID, font);
            }
            mh$.invokeExact(menuID, font);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutMouseWheelFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutMouseWheelFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMouseWheelFunc(void (*callback)(int, int, int, int))
     * }
     */
    public static FunctionDescriptor glutMouseWheelFunc$descriptor() {
        return glutMouseWheelFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMouseWheelFunc(void (*callback)(int, int, int, int))
     * }
     */
    public static MethodHandle glutMouseWheelFunc$handle() {
        return glutMouseWheelFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMouseWheelFunc(void (*callback)(int, int, int, int))
     * }
     */
    public static MemorySegment glutMouseWheelFunc$address() {
        return glutMouseWheelFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMouseWheelFunc(void (*callback)(int, int, int, int))
     * }
     */
    public static void glutMouseWheelFunc(MemorySegment callback) {
        var mh$ = glutMouseWheelFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMouseWheelFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutPositionFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutPositionFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutPositionFunc(void (*callback)(int, int))
     * }
     */
    public static FunctionDescriptor glutPositionFunc$descriptor() {
        return glutPositionFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutPositionFunc(void (*callback)(int, int))
     * }
     */
    public static MethodHandle glutPositionFunc$handle() {
        return glutPositionFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutPositionFunc(void (*callback)(int, int))
     * }
     */
    public static MemorySegment glutPositionFunc$address() {
        return glutPositionFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutPositionFunc(void (*callback)(int, int))
     * }
     */
    public static void glutPositionFunc(MemorySegment callback) {
        var mh$ = glutPositionFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutPositionFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutCloseFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutCloseFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutCloseFunc(void (*callback)(void))
     * }
     */
    public static FunctionDescriptor glutCloseFunc$descriptor() {
        return glutCloseFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutCloseFunc(void (*callback)(void))
     * }
     */
    public static MethodHandle glutCloseFunc$handle() {
        return glutCloseFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutCloseFunc(void (*callback)(void))
     * }
     */
    public static MemorySegment glutCloseFunc$address() {
        return glutCloseFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutCloseFunc(void (*callback)(void))
     * }
     */
    public static void glutCloseFunc(MemorySegment callback) {
        var mh$ = glutCloseFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutCloseFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWMCloseFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutWMCloseFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWMCloseFunc(void (*callback)(void))
     * }
     */
    public static FunctionDescriptor glutWMCloseFunc$descriptor() {
        return glutWMCloseFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWMCloseFunc(void (*callback)(void))
     * }
     */
    public static MethodHandle glutWMCloseFunc$handle() {
        return glutWMCloseFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWMCloseFunc(void (*callback)(void))
     * }
     */
    public static MemorySegment glutWMCloseFunc$address() {
        return glutWMCloseFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWMCloseFunc(void (*callback)(void))
     * }
     */
    public static void glutWMCloseFunc(MemorySegment callback) {
        var mh$ = glutWMCloseFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWMCloseFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutMenuDestroyFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutMenuDestroyFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMenuDestroyFunc(void (*callback)(void))
     * }
     */
    public static FunctionDescriptor glutMenuDestroyFunc$descriptor() {
        return glutMenuDestroyFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMenuDestroyFunc(void (*callback)(void))
     * }
     */
    public static MethodHandle glutMenuDestroyFunc$handle() {
        return glutMenuDestroyFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMenuDestroyFunc(void (*callback)(void))
     * }
     */
    public static MemorySegment glutMenuDestroyFunc$address() {
        return glutMenuDestroyFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMenuDestroyFunc(void (*callback)(void))
     * }
     */
    public static void glutMenuDestroyFunc(MemorySegment callback) {
        var mh$ = glutMenuDestroyFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMenuDestroyFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSetOption {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSetOption");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSetOption(GLenum option_flag, int value)
     * }
     */
    public static FunctionDescriptor glutSetOption$descriptor() {
        return glutSetOption.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSetOption(GLenum option_flag, int value)
     * }
     */
    public static MethodHandle glutSetOption$handle() {
        return glutSetOption.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSetOption(GLenum option_flag, int value)
     * }
     */
    public static MemorySegment glutSetOption$address() {
        return glutSetOption.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSetOption(GLenum option_flag, int value)
     * }
     */
    public static void glutSetOption(int option_flag, int value) {
        var mh$ = glutSetOption.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSetOption", option_flag, value);
            }
            mh$.invokeExact(option_flag, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutGetModeValues {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutGetModeValues");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *glutGetModeValues(GLenum mode, int *size)
     * }
     */
    public static FunctionDescriptor glutGetModeValues$descriptor() {
        return glutGetModeValues.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *glutGetModeValues(GLenum mode, int *size)
     * }
     */
    public static MethodHandle glutGetModeValues$handle() {
        return glutGetModeValues.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *glutGetModeValues(GLenum mode, int *size)
     * }
     */
    public static MemorySegment glutGetModeValues$address() {
        return glutGetModeValues.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *glutGetModeValues(GLenum mode, int *size)
     * }
     */
    public static MemorySegment glutGetModeValues(int mode, MemorySegment size) {
        var mh$ = glutGetModeValues.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutGetModeValues", mode, size);
            }
            return (MemorySegment)mh$.invokeExact(mode, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutGetWindowData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutGetWindowData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *glutGetWindowData()
     * }
     */
    public static FunctionDescriptor glutGetWindowData$descriptor() {
        return glutGetWindowData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *glutGetWindowData()
     * }
     */
    public static MethodHandle glutGetWindowData$handle() {
        return glutGetWindowData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *glutGetWindowData()
     * }
     */
    public static MemorySegment glutGetWindowData$address() {
        return glutGetWindowData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *glutGetWindowData()
     * }
     */
    public static MemorySegment glutGetWindowData() {
        var mh$ = glutGetWindowData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutGetWindowData");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSetWindowData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSetWindowData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSetWindowData(void *data)
     * }
     */
    public static FunctionDescriptor glutSetWindowData$descriptor() {
        return glutSetWindowData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSetWindowData(void *data)
     * }
     */
    public static MethodHandle glutSetWindowData$handle() {
        return glutSetWindowData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSetWindowData(void *data)
     * }
     */
    public static MemorySegment glutSetWindowData$address() {
        return glutSetWindowData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSetWindowData(void *data)
     * }
     */
    public static void glutSetWindowData(MemorySegment data) {
        var mh$ = glutSetWindowData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSetWindowData", data);
            }
            mh$.invokeExact(data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutGetMenuData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutGetMenuData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *glutGetMenuData()
     * }
     */
    public static FunctionDescriptor glutGetMenuData$descriptor() {
        return glutGetMenuData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *glutGetMenuData()
     * }
     */
    public static MethodHandle glutGetMenuData$handle() {
        return glutGetMenuData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *glutGetMenuData()
     * }
     */
    public static MemorySegment glutGetMenuData$address() {
        return glutGetMenuData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *glutGetMenuData()
     * }
     */
    public static MemorySegment glutGetMenuData() {
        var mh$ = glutGetMenuData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutGetMenuData");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSetMenuData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSetMenuData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSetMenuData(void *data)
     * }
     */
    public static FunctionDescriptor glutSetMenuData$descriptor() {
        return glutSetMenuData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSetMenuData(void *data)
     * }
     */
    public static MethodHandle glutSetMenuData$handle() {
        return glutSetMenuData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSetMenuData(void *data)
     * }
     */
    public static MemorySegment glutSetMenuData$address() {
        return glutSetMenuData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSetMenuData(void *data)
     * }
     */
    public static void glutSetMenuData(MemorySegment data) {
        var mh$ = glutSetMenuData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSetMenuData", data);
            }
            mh$.invokeExact(data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutBitmapHeight {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutBitmapHeight");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutBitmapHeight(void *font)
     * }
     */
    public static FunctionDescriptor glutBitmapHeight$descriptor() {
        return glutBitmapHeight.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutBitmapHeight(void *font)
     * }
     */
    public static MethodHandle glutBitmapHeight$handle() {
        return glutBitmapHeight.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutBitmapHeight(void *font)
     * }
     */
    public static MemorySegment glutBitmapHeight$address() {
        return glutBitmapHeight.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutBitmapHeight(void *font)
     * }
     */
    public static int glutBitmapHeight(MemorySegment font) {
        var mh$ = glutBitmapHeight.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutBitmapHeight", font);
            }
            return (int)mh$.invokeExact(font);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutStrokeHeight {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_FLOAT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutStrokeHeight");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLfloat glutStrokeHeight(void *font)
     * }
     */
    public static FunctionDescriptor glutStrokeHeight$descriptor() {
        return glutStrokeHeight.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLfloat glutStrokeHeight(void *font)
     * }
     */
    public static MethodHandle glutStrokeHeight$handle() {
        return glutStrokeHeight.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLfloat glutStrokeHeight(void *font)
     * }
     */
    public static MemorySegment glutStrokeHeight$address() {
        return glutStrokeHeight.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLfloat glutStrokeHeight(void *font)
     * }
     */
    public static float glutStrokeHeight(MemorySegment font) {
        var mh$ = glutStrokeHeight.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutStrokeHeight", font);
            }
            return (float)mh$.invokeExact(font);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutBitmapString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutBitmapString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutBitmapString(void *font, const unsigned char *string)
     * }
     */
    public static FunctionDescriptor glutBitmapString$descriptor() {
        return glutBitmapString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutBitmapString(void *font, const unsigned char *string)
     * }
     */
    public static MethodHandle glutBitmapString$handle() {
        return glutBitmapString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutBitmapString(void *font, const unsigned char *string)
     * }
     */
    public static MemorySegment glutBitmapString$address() {
        return glutBitmapString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutBitmapString(void *font, const unsigned char *string)
     * }
     */
    public static void glutBitmapString(MemorySegment font, MemorySegment string) {
        var mh$ = glutBitmapString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutBitmapString", font, string);
            }
            mh$.invokeExact(font, string);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutStrokeString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutStrokeString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutStrokeString(void *font, const unsigned char *string)
     * }
     */
    public static FunctionDescriptor glutStrokeString$descriptor() {
        return glutStrokeString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutStrokeString(void *font, const unsigned char *string)
     * }
     */
    public static MethodHandle glutStrokeString$handle() {
        return glutStrokeString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutStrokeString(void *font, const unsigned char *string)
     * }
     */
    public static MemorySegment glutStrokeString$address() {
        return glutStrokeString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutStrokeString(void *font, const unsigned char *string)
     * }
     */
    public static void glutStrokeString(MemorySegment font, MemorySegment string) {
        var mh$ = glutStrokeString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutStrokeString", font, string);
            }
            mh$.invokeExact(font, string);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWireRhombicDodecahedron {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutWireRhombicDodecahedron");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWireRhombicDodecahedron()
     * }
     */
    public static FunctionDescriptor glutWireRhombicDodecahedron$descriptor() {
        return glutWireRhombicDodecahedron.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWireRhombicDodecahedron()
     * }
     */
    public static MethodHandle glutWireRhombicDodecahedron$handle() {
        return glutWireRhombicDodecahedron.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWireRhombicDodecahedron()
     * }
     */
    public static MemorySegment glutWireRhombicDodecahedron$address() {
        return glutWireRhombicDodecahedron.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWireRhombicDodecahedron()
     * }
     */
    public static void glutWireRhombicDodecahedron() {
        var mh$ = glutWireRhombicDodecahedron.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWireRhombicDodecahedron");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSolidRhombicDodecahedron {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSolidRhombicDodecahedron");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSolidRhombicDodecahedron()
     * }
     */
    public static FunctionDescriptor glutSolidRhombicDodecahedron$descriptor() {
        return glutSolidRhombicDodecahedron.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSolidRhombicDodecahedron()
     * }
     */
    public static MethodHandle glutSolidRhombicDodecahedron$handle() {
        return glutSolidRhombicDodecahedron.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSolidRhombicDodecahedron()
     * }
     */
    public static MemorySegment glutSolidRhombicDodecahedron$address() {
        return glutSolidRhombicDodecahedron.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSolidRhombicDodecahedron()
     * }
     */
    public static void glutSolidRhombicDodecahedron() {
        var mh$ = glutSolidRhombicDodecahedron.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSolidRhombicDodecahedron");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWireSierpinskiSponge {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutWireSierpinskiSponge");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWireSierpinskiSponge(int num_levels, double offset[3], double scale)
     * }
     */
    public static FunctionDescriptor glutWireSierpinskiSponge$descriptor() {
        return glutWireSierpinskiSponge.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWireSierpinskiSponge(int num_levels, double offset[3], double scale)
     * }
     */
    public static MethodHandle glutWireSierpinskiSponge$handle() {
        return glutWireSierpinskiSponge.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWireSierpinskiSponge(int num_levels, double offset[3], double scale)
     * }
     */
    public static MemorySegment glutWireSierpinskiSponge$address() {
        return glutWireSierpinskiSponge.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWireSierpinskiSponge(int num_levels, double offset[3], double scale)
     * }
     */
    public static void glutWireSierpinskiSponge(int num_levels, MemorySegment offset, double scale) {
        var mh$ = glutWireSierpinskiSponge.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWireSierpinskiSponge", num_levels, offset, scale);
            }
            mh$.invokeExact(num_levels, offset, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSolidSierpinskiSponge {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSolidSierpinskiSponge");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSolidSierpinskiSponge(int num_levels, double offset[3], double scale)
     * }
     */
    public static FunctionDescriptor glutSolidSierpinskiSponge$descriptor() {
        return glutSolidSierpinskiSponge.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSolidSierpinskiSponge(int num_levels, double offset[3], double scale)
     * }
     */
    public static MethodHandle glutSolidSierpinskiSponge$handle() {
        return glutSolidSierpinskiSponge.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSolidSierpinskiSponge(int num_levels, double offset[3], double scale)
     * }
     */
    public static MemorySegment glutSolidSierpinskiSponge$address() {
        return glutSolidSierpinskiSponge.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSolidSierpinskiSponge(int num_levels, double offset[3], double scale)
     * }
     */
    public static void glutSolidSierpinskiSponge(int num_levels, MemorySegment offset, double scale) {
        var mh$ = glutSolidSierpinskiSponge.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSolidSierpinskiSponge", num_levels, offset, scale);
            }
            mh$.invokeExact(num_levels, offset, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWireCylinder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutWireCylinder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWireCylinder(double radius, double height, GLint slices, GLint stacks)
     * }
     */
    public static FunctionDescriptor glutWireCylinder$descriptor() {
        return glutWireCylinder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWireCylinder(double radius, double height, GLint slices, GLint stacks)
     * }
     */
    public static MethodHandle glutWireCylinder$handle() {
        return glutWireCylinder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWireCylinder(double radius, double height, GLint slices, GLint stacks)
     * }
     */
    public static MemorySegment glutWireCylinder$address() {
        return glutWireCylinder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWireCylinder(double radius, double height, GLint slices, GLint stacks)
     * }
     */
    public static void glutWireCylinder(double radius, double height, int slices, int stacks) {
        var mh$ = glutWireCylinder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWireCylinder", radius, height, slices, stacks);
            }
            mh$.invokeExact(radius, height, slices, stacks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSolidCylinder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE,
            freeglut_h.C_DOUBLE,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSolidCylinder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSolidCylinder(double radius, double height, GLint slices, GLint stacks)
     * }
     */
    public static FunctionDescriptor glutSolidCylinder$descriptor() {
        return glutSolidCylinder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSolidCylinder(double radius, double height, GLint slices, GLint stacks)
     * }
     */
    public static MethodHandle glutSolidCylinder$handle() {
        return glutSolidCylinder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSolidCylinder(double radius, double height, GLint slices, GLint stacks)
     * }
     */
    public static MemorySegment glutSolidCylinder$address() {
        return glutSolidCylinder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSolidCylinder(double radius, double height, GLint slices, GLint stacks)
     * }
     */
    public static void glutSolidCylinder(double radius, double height, int slices, int stacks) {
        var mh$ = glutSolidCylinder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSolidCylinder", radius, height, slices, stacks);
            }
            mh$.invokeExact(radius, height, slices, stacks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWireTeacup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutWireTeacup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWireTeacup(double size)
     * }
     */
    public static FunctionDescriptor glutWireTeacup$descriptor() {
        return glutWireTeacup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWireTeacup(double size)
     * }
     */
    public static MethodHandle glutWireTeacup$handle() {
        return glutWireTeacup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWireTeacup(double size)
     * }
     */
    public static MemorySegment glutWireTeacup$address() {
        return glutWireTeacup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWireTeacup(double size)
     * }
     */
    public static void glutWireTeacup(double size) {
        var mh$ = glutWireTeacup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWireTeacup", size);
            }
            mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSolidTeacup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSolidTeacup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSolidTeacup(double size)
     * }
     */
    public static FunctionDescriptor glutSolidTeacup$descriptor() {
        return glutSolidTeacup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSolidTeacup(double size)
     * }
     */
    public static MethodHandle glutSolidTeacup$handle() {
        return glutSolidTeacup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSolidTeacup(double size)
     * }
     */
    public static MemorySegment glutSolidTeacup$address() {
        return glutSolidTeacup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSolidTeacup(double size)
     * }
     */
    public static void glutSolidTeacup(double size) {
        var mh$ = glutSolidTeacup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSolidTeacup", size);
            }
            mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWireTeaspoon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutWireTeaspoon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWireTeaspoon(double size)
     * }
     */
    public static FunctionDescriptor glutWireTeaspoon$descriptor() {
        return glutWireTeaspoon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWireTeaspoon(double size)
     * }
     */
    public static MethodHandle glutWireTeaspoon$handle() {
        return glutWireTeaspoon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWireTeaspoon(double size)
     * }
     */
    public static MemorySegment glutWireTeaspoon$address() {
        return glutWireTeaspoon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWireTeaspoon(double size)
     * }
     */
    public static void glutWireTeaspoon(double size) {
        var mh$ = glutWireTeaspoon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWireTeaspoon", size);
            }
            mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSolidTeaspoon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSolidTeaspoon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSolidTeaspoon(double size)
     * }
     */
    public static FunctionDescriptor glutSolidTeaspoon$descriptor() {
        return glutSolidTeaspoon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSolidTeaspoon(double size)
     * }
     */
    public static MethodHandle glutSolidTeaspoon$handle() {
        return glutSolidTeaspoon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSolidTeaspoon(double size)
     * }
     */
    public static MemorySegment glutSolidTeaspoon$address() {
        return glutSolidTeaspoon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSolidTeaspoon(double size)
     * }
     */
    public static void glutSolidTeaspoon(double size) {
        var mh$ = glutSolidTeaspoon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSolidTeaspoon", size);
            }
            mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutGetProcAddress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutGetProcAddress");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLUTproc glutGetProcAddress(const char *procName)
     * }
     */
    public static FunctionDescriptor glutGetProcAddress$descriptor() {
        return glutGetProcAddress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLUTproc glutGetProcAddress(const char *procName)
     * }
     */
    public static MethodHandle glutGetProcAddress$handle() {
        return glutGetProcAddress.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLUTproc glutGetProcAddress(const char *procName)
     * }
     */
    public static MemorySegment glutGetProcAddress$address() {
        return glutGetProcAddress.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLUTproc glutGetProcAddress(const char *procName)
     * }
     */
    public static MemorySegment glutGetProcAddress(MemorySegment procName) {
        var mh$ = glutGetProcAddress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutGetProcAddress", procName);
            }
            return (MemorySegment)mh$.invokeExact(procName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutMultiEntryFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutMultiEntryFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMultiEntryFunc(void (*callback)(int, int))
     * }
     */
    public static FunctionDescriptor glutMultiEntryFunc$descriptor() {
        return glutMultiEntryFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMultiEntryFunc(void (*callback)(int, int))
     * }
     */
    public static MethodHandle glutMultiEntryFunc$handle() {
        return glutMultiEntryFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMultiEntryFunc(void (*callback)(int, int))
     * }
     */
    public static MemorySegment glutMultiEntryFunc$address() {
        return glutMultiEntryFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMultiEntryFunc(void (*callback)(int, int))
     * }
     */
    public static void glutMultiEntryFunc(MemorySegment callback) {
        var mh$ = glutMultiEntryFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMultiEntryFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutMultiButtonFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutMultiButtonFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMultiButtonFunc(void (*callback)(int, int, int, int, int))
     * }
     */
    public static FunctionDescriptor glutMultiButtonFunc$descriptor() {
        return glutMultiButtonFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMultiButtonFunc(void (*callback)(int, int, int, int, int))
     * }
     */
    public static MethodHandle glutMultiButtonFunc$handle() {
        return glutMultiButtonFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMultiButtonFunc(void (*callback)(int, int, int, int, int))
     * }
     */
    public static MemorySegment glutMultiButtonFunc$address() {
        return glutMultiButtonFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMultiButtonFunc(void (*callback)(int, int, int, int, int))
     * }
     */
    public static void glutMultiButtonFunc(MemorySegment callback) {
        var mh$ = glutMultiButtonFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMultiButtonFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutMultiMotionFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutMultiMotionFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMultiMotionFunc(void (*callback)(int, int, int))
     * }
     */
    public static FunctionDescriptor glutMultiMotionFunc$descriptor() {
        return glutMultiMotionFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMultiMotionFunc(void (*callback)(int, int, int))
     * }
     */
    public static MethodHandle glutMultiMotionFunc$handle() {
        return glutMultiMotionFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMultiMotionFunc(void (*callback)(int, int, int))
     * }
     */
    public static MemorySegment glutMultiMotionFunc$address() {
        return glutMultiMotionFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMultiMotionFunc(void (*callback)(int, int, int))
     * }
     */
    public static void glutMultiMotionFunc(MemorySegment callback) {
        var mh$ = glutMultiMotionFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMultiMotionFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutMultiPassiveFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutMultiPassiveFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMultiPassiveFunc(void (*callback)(int, int, int))
     * }
     */
    public static FunctionDescriptor glutMultiPassiveFunc$descriptor() {
        return glutMultiPassiveFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMultiPassiveFunc(void (*callback)(int, int, int))
     * }
     */
    public static MethodHandle glutMultiPassiveFunc$handle() {
        return glutMultiPassiveFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMultiPassiveFunc(void (*callback)(int, int, int))
     * }
     */
    public static MemorySegment glutMultiPassiveFunc$address() {
        return glutMultiPassiveFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMultiPassiveFunc(void (*callback)(int, int, int))
     * }
     */
    public static void glutMultiPassiveFunc(MemorySegment callback) {
        var mh$ = glutMultiPassiveFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMultiPassiveFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutJoystickGetNumAxes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutJoystickGetNumAxes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutJoystickGetNumAxes(int ident)
     * }
     */
    public static FunctionDescriptor glutJoystickGetNumAxes$descriptor() {
        return glutJoystickGetNumAxes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutJoystickGetNumAxes(int ident)
     * }
     */
    public static MethodHandle glutJoystickGetNumAxes$handle() {
        return glutJoystickGetNumAxes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutJoystickGetNumAxes(int ident)
     * }
     */
    public static MemorySegment glutJoystickGetNumAxes$address() {
        return glutJoystickGetNumAxes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutJoystickGetNumAxes(int ident)
     * }
     */
    public static int glutJoystickGetNumAxes(int ident) {
        var mh$ = glutJoystickGetNumAxes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutJoystickGetNumAxes", ident);
            }
            return (int)mh$.invokeExact(ident);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutJoystickGetNumButtons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutJoystickGetNumButtons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutJoystickGetNumButtons(int ident)
     * }
     */
    public static FunctionDescriptor glutJoystickGetNumButtons$descriptor() {
        return glutJoystickGetNumButtons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutJoystickGetNumButtons(int ident)
     * }
     */
    public static MethodHandle glutJoystickGetNumButtons$handle() {
        return glutJoystickGetNumButtons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutJoystickGetNumButtons(int ident)
     * }
     */
    public static MemorySegment glutJoystickGetNumButtons$address() {
        return glutJoystickGetNumButtons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutJoystickGetNumButtons(int ident)
     * }
     */
    public static int glutJoystickGetNumButtons(int ident) {
        var mh$ = glutJoystickGetNumButtons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutJoystickGetNumButtons", ident);
            }
            return (int)mh$.invokeExact(ident);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutJoystickNotWorking {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutJoystickNotWorking");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutJoystickNotWorking(int ident)
     * }
     */
    public static FunctionDescriptor glutJoystickNotWorking$descriptor() {
        return glutJoystickNotWorking.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutJoystickNotWorking(int ident)
     * }
     */
    public static MethodHandle glutJoystickNotWorking$handle() {
        return glutJoystickNotWorking.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutJoystickNotWorking(int ident)
     * }
     */
    public static MemorySegment glutJoystickNotWorking$address() {
        return glutJoystickNotWorking.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutJoystickNotWorking(int ident)
     * }
     */
    public static int glutJoystickNotWorking(int ident) {
        var mh$ = glutJoystickNotWorking.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutJoystickNotWorking", ident);
            }
            return (int)mh$.invokeExact(ident);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutJoystickGetDeadBand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_FLOAT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutJoystickGetDeadBand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float glutJoystickGetDeadBand(int ident, int axis)
     * }
     */
    public static FunctionDescriptor glutJoystickGetDeadBand$descriptor() {
        return glutJoystickGetDeadBand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float glutJoystickGetDeadBand(int ident, int axis)
     * }
     */
    public static MethodHandle glutJoystickGetDeadBand$handle() {
        return glutJoystickGetDeadBand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float glutJoystickGetDeadBand(int ident, int axis)
     * }
     */
    public static MemorySegment glutJoystickGetDeadBand$address() {
        return glutJoystickGetDeadBand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float glutJoystickGetDeadBand(int ident, int axis)
     * }
     */
    public static float glutJoystickGetDeadBand(int ident, int axis) {
        var mh$ = glutJoystickGetDeadBand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutJoystickGetDeadBand", ident, axis);
            }
            return (float)mh$.invokeExact(ident, axis);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutJoystickSetDeadBand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutJoystickSetDeadBand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutJoystickSetDeadBand(int ident, int axis, float db)
     * }
     */
    public static FunctionDescriptor glutJoystickSetDeadBand$descriptor() {
        return glutJoystickSetDeadBand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutJoystickSetDeadBand(int ident, int axis, float db)
     * }
     */
    public static MethodHandle glutJoystickSetDeadBand$handle() {
        return glutJoystickSetDeadBand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutJoystickSetDeadBand(int ident, int axis, float db)
     * }
     */
    public static MemorySegment glutJoystickSetDeadBand$address() {
        return glutJoystickSetDeadBand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutJoystickSetDeadBand(int ident, int axis, float db)
     * }
     */
    public static void glutJoystickSetDeadBand(int ident, int axis, float db) {
        var mh$ = glutJoystickSetDeadBand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutJoystickSetDeadBand", ident, axis, db);
            }
            mh$.invokeExact(ident, axis, db);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutJoystickGetSaturation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_FLOAT,
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutJoystickGetSaturation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float glutJoystickGetSaturation(int ident, int axis)
     * }
     */
    public static FunctionDescriptor glutJoystickGetSaturation$descriptor() {
        return glutJoystickGetSaturation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float glutJoystickGetSaturation(int ident, int axis)
     * }
     */
    public static MethodHandle glutJoystickGetSaturation$handle() {
        return glutJoystickGetSaturation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float glutJoystickGetSaturation(int ident, int axis)
     * }
     */
    public static MemorySegment glutJoystickGetSaturation$address() {
        return glutJoystickGetSaturation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float glutJoystickGetSaturation(int ident, int axis)
     * }
     */
    public static float glutJoystickGetSaturation(int ident, int axis) {
        var mh$ = glutJoystickGetSaturation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutJoystickGetSaturation", ident, axis);
            }
            return (float)mh$.invokeExact(ident, axis);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutJoystickSetSaturation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT,
            freeglut_h.C_FLOAT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutJoystickSetSaturation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutJoystickSetSaturation(int ident, int axis, float st)
     * }
     */
    public static FunctionDescriptor glutJoystickSetSaturation$descriptor() {
        return glutJoystickSetSaturation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutJoystickSetSaturation(int ident, int axis, float st)
     * }
     */
    public static MethodHandle glutJoystickSetSaturation$handle() {
        return glutJoystickSetSaturation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutJoystickSetSaturation(int ident, int axis, float st)
     * }
     */
    public static MemorySegment glutJoystickSetSaturation$address() {
        return glutJoystickSetSaturation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutJoystickSetSaturation(int ident, int axis, float st)
     * }
     */
    public static void glutJoystickSetSaturation(int ident, int axis, float st) {
        var mh$ = glutJoystickSetSaturation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutJoystickSetSaturation", ident, axis, st);
            }
            mh$.invokeExact(ident, axis, st);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutJoystickSetMinRange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutJoystickSetMinRange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutJoystickSetMinRange(int ident, float *axes)
     * }
     */
    public static FunctionDescriptor glutJoystickSetMinRange$descriptor() {
        return glutJoystickSetMinRange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutJoystickSetMinRange(int ident, float *axes)
     * }
     */
    public static MethodHandle glutJoystickSetMinRange$handle() {
        return glutJoystickSetMinRange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutJoystickSetMinRange(int ident, float *axes)
     * }
     */
    public static MemorySegment glutJoystickSetMinRange$address() {
        return glutJoystickSetMinRange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutJoystickSetMinRange(int ident, float *axes)
     * }
     */
    public static void glutJoystickSetMinRange(int ident, MemorySegment axes) {
        var mh$ = glutJoystickSetMinRange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutJoystickSetMinRange", ident, axes);
            }
            mh$.invokeExact(ident, axes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutJoystickSetMaxRange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutJoystickSetMaxRange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutJoystickSetMaxRange(int ident, float *axes)
     * }
     */
    public static FunctionDescriptor glutJoystickSetMaxRange$descriptor() {
        return glutJoystickSetMaxRange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutJoystickSetMaxRange(int ident, float *axes)
     * }
     */
    public static MethodHandle glutJoystickSetMaxRange$handle() {
        return glutJoystickSetMaxRange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutJoystickSetMaxRange(int ident, float *axes)
     * }
     */
    public static MemorySegment glutJoystickSetMaxRange$address() {
        return glutJoystickSetMaxRange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutJoystickSetMaxRange(int ident, float *axes)
     * }
     */
    public static void glutJoystickSetMaxRange(int ident, MemorySegment axes) {
        var mh$ = glutJoystickSetMaxRange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutJoystickSetMaxRange", ident, axes);
            }
            mh$.invokeExact(ident, axes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutJoystickSetCenter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutJoystickSetCenter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutJoystickSetCenter(int ident, float *axes)
     * }
     */
    public static FunctionDescriptor glutJoystickSetCenter$descriptor() {
        return glutJoystickSetCenter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutJoystickSetCenter(int ident, float *axes)
     * }
     */
    public static MethodHandle glutJoystickSetCenter$handle() {
        return glutJoystickSetCenter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutJoystickSetCenter(int ident, float *axes)
     * }
     */
    public static MemorySegment glutJoystickSetCenter$address() {
        return glutJoystickSetCenter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutJoystickSetCenter(int ident, float *axes)
     * }
     */
    public static void glutJoystickSetCenter(int ident, MemorySegment axes) {
        var mh$ = glutJoystickSetCenter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutJoystickSetCenter", ident, axes);
            }
            mh$.invokeExact(ident, axes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutJoystickGetMinRange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutJoystickGetMinRange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutJoystickGetMinRange(int ident, float *axes)
     * }
     */
    public static FunctionDescriptor glutJoystickGetMinRange$descriptor() {
        return glutJoystickGetMinRange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutJoystickGetMinRange(int ident, float *axes)
     * }
     */
    public static MethodHandle glutJoystickGetMinRange$handle() {
        return glutJoystickGetMinRange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutJoystickGetMinRange(int ident, float *axes)
     * }
     */
    public static MemorySegment glutJoystickGetMinRange$address() {
        return glutJoystickGetMinRange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutJoystickGetMinRange(int ident, float *axes)
     * }
     */
    public static void glutJoystickGetMinRange(int ident, MemorySegment axes) {
        var mh$ = glutJoystickGetMinRange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutJoystickGetMinRange", ident, axes);
            }
            mh$.invokeExact(ident, axes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutJoystickGetMaxRange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutJoystickGetMaxRange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutJoystickGetMaxRange(int ident, float *axes)
     * }
     */
    public static FunctionDescriptor glutJoystickGetMaxRange$descriptor() {
        return glutJoystickGetMaxRange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutJoystickGetMaxRange(int ident, float *axes)
     * }
     */
    public static MethodHandle glutJoystickGetMaxRange$handle() {
        return glutJoystickGetMaxRange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutJoystickGetMaxRange(int ident, float *axes)
     * }
     */
    public static MemorySegment glutJoystickGetMaxRange$address() {
        return glutJoystickGetMaxRange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutJoystickGetMaxRange(int ident, float *axes)
     * }
     */
    public static void glutJoystickGetMaxRange(int ident, MemorySegment axes) {
        var mh$ = glutJoystickGetMaxRange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutJoystickGetMaxRange", ident, axes);
            }
            mh$.invokeExact(ident, axes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutJoystickGetCenter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutJoystickGetCenter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutJoystickGetCenter(int ident, float *axes)
     * }
     */
    public static FunctionDescriptor glutJoystickGetCenter$descriptor() {
        return glutJoystickGetCenter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutJoystickGetCenter(int ident, float *axes)
     * }
     */
    public static MethodHandle glutJoystickGetCenter$handle() {
        return glutJoystickGetCenter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutJoystickGetCenter(int ident, float *axes)
     * }
     */
    public static MemorySegment glutJoystickGetCenter$address() {
        return glutJoystickGetCenter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutJoystickGetCenter(int ident, float *axes)
     * }
     */
    public static void glutJoystickGetCenter(int ident, MemorySegment axes) {
        var mh$ = glutJoystickGetCenter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutJoystickGetCenter", ident, axes);
            }
            mh$.invokeExact(ident, axes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __builtin_va_list va_list
     * }
     */
    public static final AddressLayout va_list = freeglut_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __builtin_va_list __gnuc_va_list
     * }
     */
    public static final AddressLayout __gnuc_va_list = freeglut_h.C_POINTER;

    private static class glutInitContextVersion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutInitContextVersion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutInitContextVersion(int majorVersion, int minorVersion)
     * }
     */
    public static FunctionDescriptor glutInitContextVersion$descriptor() {
        return glutInitContextVersion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutInitContextVersion(int majorVersion, int minorVersion)
     * }
     */
    public static MethodHandle glutInitContextVersion$handle() {
        return glutInitContextVersion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutInitContextVersion(int majorVersion, int minorVersion)
     * }
     */
    public static MemorySegment glutInitContextVersion$address() {
        return glutInitContextVersion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutInitContextVersion(int majorVersion, int minorVersion)
     * }
     */
    public static void glutInitContextVersion(int majorVersion, int minorVersion) {
        var mh$ = glutInitContextVersion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutInitContextVersion", majorVersion, minorVersion);
            }
            mh$.invokeExact(majorVersion, minorVersion);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutInitContextFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutInitContextFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutInitContextFlags(int flags)
     * }
     */
    public static FunctionDescriptor glutInitContextFlags$descriptor() {
        return glutInitContextFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutInitContextFlags(int flags)
     * }
     */
    public static MethodHandle glutInitContextFlags$handle() {
        return glutInitContextFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutInitContextFlags(int flags)
     * }
     */
    public static MemorySegment glutInitContextFlags$address() {
        return glutInitContextFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutInitContextFlags(int flags)
     * }
     */
    public static void glutInitContextFlags(int flags) {
        var mh$ = glutInitContextFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutInitContextFlags", flags);
            }
            mh$.invokeExact(flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutInitContextProfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutInitContextProfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutInitContextProfile(int profile)
     * }
     */
    public static FunctionDescriptor glutInitContextProfile$descriptor() {
        return glutInitContextProfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutInitContextProfile(int profile)
     * }
     */
    public static MethodHandle glutInitContextProfile$handle() {
        return glutInitContextProfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutInitContextProfile(int profile)
     * }
     */
    public static MemorySegment glutInitContextProfile$address() {
        return glutInitContextProfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutInitContextProfile(int profile)
     * }
     */
    public static void glutInitContextProfile(int profile) {
        var mh$ = glutInitContextProfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutInitContextProfile", profile);
            }
            mh$.invokeExact(profile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutInitErrorFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutInitErrorFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutInitErrorFunc(void (*callback)(const char *, va_list))
     * }
     */
    public static FunctionDescriptor glutInitErrorFunc$descriptor() {
        return glutInitErrorFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutInitErrorFunc(void (*callback)(const char *, va_list))
     * }
     */
    public static MethodHandle glutInitErrorFunc$handle() {
        return glutInitErrorFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutInitErrorFunc(void (*callback)(const char *, va_list))
     * }
     */
    public static MemorySegment glutInitErrorFunc$address() {
        return glutInitErrorFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutInitErrorFunc(void (*callback)(const char *, va_list))
     * }
     */
    public static void glutInitErrorFunc(MemorySegment callback) {
        var mh$ = glutInitErrorFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutInitErrorFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutInitWarningFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutInitWarningFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutInitWarningFunc(void (*callback)(const char *, va_list))
     * }
     */
    public static FunctionDescriptor glutInitWarningFunc$descriptor() {
        return glutInitWarningFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutInitWarningFunc(void (*callback)(const char *, va_list))
     * }
     */
    public static MethodHandle glutInitWarningFunc$handle() {
        return glutInitWarningFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutInitWarningFunc(void (*callback)(const char *, va_list))
     * }
     */
    public static MemorySegment glutInitWarningFunc$address() {
        return glutInitWarningFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutInitWarningFunc(void (*callback)(const char *, va_list))
     * }
     */
    public static void glutInitWarningFunc(MemorySegment callback) {
        var mh$ = glutInitWarningFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutInitWarningFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSetVertexAttribCoord3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSetVertexAttribCoord3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSetVertexAttribCoord3(GLint attrib)
     * }
     */
    public static FunctionDescriptor glutSetVertexAttribCoord3$descriptor() {
        return glutSetVertexAttribCoord3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSetVertexAttribCoord3(GLint attrib)
     * }
     */
    public static MethodHandle glutSetVertexAttribCoord3$handle() {
        return glutSetVertexAttribCoord3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSetVertexAttribCoord3(GLint attrib)
     * }
     */
    public static MemorySegment glutSetVertexAttribCoord3$address() {
        return glutSetVertexAttribCoord3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSetVertexAttribCoord3(GLint attrib)
     * }
     */
    public static void glutSetVertexAttribCoord3(int attrib) {
        var mh$ = glutSetVertexAttribCoord3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSetVertexAttribCoord3", attrib);
            }
            mh$.invokeExact(attrib);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSetVertexAttribNormal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSetVertexAttribNormal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSetVertexAttribNormal(GLint attrib)
     * }
     */
    public static FunctionDescriptor glutSetVertexAttribNormal$descriptor() {
        return glutSetVertexAttribNormal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSetVertexAttribNormal(GLint attrib)
     * }
     */
    public static MethodHandle glutSetVertexAttribNormal$handle() {
        return glutSetVertexAttribNormal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSetVertexAttribNormal(GLint attrib)
     * }
     */
    public static MemorySegment glutSetVertexAttribNormal$address() {
        return glutSetVertexAttribNormal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSetVertexAttribNormal(GLint attrib)
     * }
     */
    public static void glutSetVertexAttribNormal(int attrib) {
        var mh$ = glutSetVertexAttribNormal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSetVertexAttribNormal", attrib);
            }
            mh$.invokeExact(attrib);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSetVertexAttribTexCoord2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSetVertexAttribTexCoord2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSetVertexAttribTexCoord2(GLint attrib)
     * }
     */
    public static FunctionDescriptor glutSetVertexAttribTexCoord2$descriptor() {
        return glutSetVertexAttribTexCoord2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSetVertexAttribTexCoord2(GLint attrib)
     * }
     */
    public static MethodHandle glutSetVertexAttribTexCoord2$handle() {
        return glutSetVertexAttribTexCoord2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSetVertexAttribTexCoord2(GLint attrib)
     * }
     */
    public static MemorySegment glutSetVertexAttribTexCoord2$address() {
        return glutSetVertexAttribTexCoord2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSetVertexAttribTexCoord2(GLint attrib)
     * }
     */
    public static void glutSetVertexAttribTexCoord2(int attrib) {
        var mh$ = glutSetVertexAttribTexCoord2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSetVertexAttribTexCoord2", attrib);
            }
            mh$.invokeExact(attrib);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutInitContextFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutInitContextFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutInitContextFunc(void (*callback)(void))
     * }
     */
    public static FunctionDescriptor glutInitContextFunc$descriptor() {
        return glutInitContextFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutInitContextFunc(void (*callback)(void))
     * }
     */
    public static MethodHandle glutInitContextFunc$handle() {
        return glutInitContextFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutInitContextFunc(void (*callback)(void))
     * }
     */
    public static MemorySegment glutInitContextFunc$address() {
        return glutInitContextFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutInitContextFunc(void (*callback)(void))
     * }
     */
    public static void glutInitContextFunc(MemorySegment callback) {
        var mh$ = glutInitContextFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutInitContextFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutAppStatusFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutAppStatusFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutAppStatusFunc(void (*callback)(int))
     * }
     */
    public static FunctionDescriptor glutAppStatusFunc$descriptor() {
        return glutAppStatusFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutAppStatusFunc(void (*callback)(int))
     * }
     */
    public static MethodHandle glutAppStatusFunc$handle() {
        return glutAppStatusFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutAppStatusFunc(void (*callback)(int))
     * }
     */
    public static MemorySegment glutAppStatusFunc$address() {
        return glutAppStatusFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutAppStatusFunc(void (*callback)(int))
     * }
     */
    public static void glutAppStatusFunc(MemorySegment callback) {
        var mh$ = glutAppStatusFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutAppStatusFunc", callback);
            }
            mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutCreateMenuUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutCreateMenuUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glutCreateMenuUcall(void (*callback)(int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutCreateMenuUcall$descriptor() {
        return glutCreateMenuUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glutCreateMenuUcall(void (*callback)(int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutCreateMenuUcall$handle() {
        return glutCreateMenuUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glutCreateMenuUcall(void (*callback)(int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutCreateMenuUcall$address() {
        return glutCreateMenuUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glutCreateMenuUcall(void (*callback)(int, void *), void *user_data)
     * }
     */
    public static int glutCreateMenuUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutCreateMenuUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutCreateMenuUcall", callback, user_data);
            }
            return (int)mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutTimerFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_INT,
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutTimerFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutTimerFuncUcall(unsigned int time, void (*callback)(int, void *), int value, void *user_data)
     * }
     */
    public static FunctionDescriptor glutTimerFuncUcall$descriptor() {
        return glutTimerFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutTimerFuncUcall(unsigned int time, void (*callback)(int, void *), int value, void *user_data)
     * }
     */
    public static MethodHandle glutTimerFuncUcall$handle() {
        return glutTimerFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutTimerFuncUcall(unsigned int time, void (*callback)(int, void *), int value, void *user_data)
     * }
     */
    public static MemorySegment glutTimerFuncUcall$address() {
        return glutTimerFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutTimerFuncUcall(unsigned int time, void (*callback)(int, void *), int value, void *user_data)
     * }
     */
    public static void glutTimerFuncUcall(int time, MemorySegment callback, int value, MemorySegment user_data) {
        var mh$ = glutTimerFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutTimerFuncUcall", time, callback, value, user_data);
            }
            mh$.invokeExact(time, callback, value, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutIdleFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutIdleFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutIdleFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutIdleFuncUcall$descriptor() {
        return glutIdleFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutIdleFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static MethodHandle glutIdleFuncUcall$handle() {
        return glutIdleFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutIdleFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static MemorySegment glutIdleFuncUcall$address() {
        return glutIdleFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutIdleFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static void glutIdleFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutIdleFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutIdleFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutKeyboardFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutKeyboardFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutKeyboardFuncUcall(void (*callback)(unsigned char, int, int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutKeyboardFuncUcall$descriptor() {
        return glutKeyboardFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutKeyboardFuncUcall(void (*callback)(unsigned char, int, int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutKeyboardFuncUcall$handle() {
        return glutKeyboardFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutKeyboardFuncUcall(void (*callback)(unsigned char, int, int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutKeyboardFuncUcall$address() {
        return glutKeyboardFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutKeyboardFuncUcall(void (*callback)(unsigned char, int, int, void *), void *user_data)
     * }
     */
    public static void glutKeyboardFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutKeyboardFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutKeyboardFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSpecialFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSpecialFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSpecialFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutSpecialFuncUcall$descriptor() {
        return glutSpecialFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSpecialFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutSpecialFuncUcall$handle() {
        return glutSpecialFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSpecialFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutSpecialFuncUcall$address() {
        return glutSpecialFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSpecialFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static void glutSpecialFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutSpecialFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSpecialFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutReshapeFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutReshapeFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutReshapeFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutReshapeFuncUcall$descriptor() {
        return glutReshapeFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutReshapeFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutReshapeFuncUcall$handle() {
        return glutReshapeFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutReshapeFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutReshapeFuncUcall$address() {
        return glutReshapeFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutReshapeFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static void glutReshapeFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutReshapeFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutReshapeFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutVisibilityFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutVisibilityFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutVisibilityFuncUcall(void (*callback)(int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutVisibilityFuncUcall$descriptor() {
        return glutVisibilityFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutVisibilityFuncUcall(void (*callback)(int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutVisibilityFuncUcall$handle() {
        return glutVisibilityFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutVisibilityFuncUcall(void (*callback)(int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutVisibilityFuncUcall$address() {
        return glutVisibilityFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutVisibilityFuncUcall(void (*callback)(int, void *), void *user_data)
     * }
     */
    public static void glutVisibilityFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutVisibilityFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutVisibilityFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutDisplayFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutDisplayFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutDisplayFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutDisplayFuncUcall$descriptor() {
        return glutDisplayFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutDisplayFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static MethodHandle glutDisplayFuncUcall$handle() {
        return glutDisplayFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutDisplayFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static MemorySegment glutDisplayFuncUcall$address() {
        return glutDisplayFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutDisplayFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static void glutDisplayFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutDisplayFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutDisplayFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutMouseFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutMouseFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMouseFuncUcall(void (*callback)(int, int, int, int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutMouseFuncUcall$descriptor() {
        return glutMouseFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMouseFuncUcall(void (*callback)(int, int, int, int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutMouseFuncUcall$handle() {
        return glutMouseFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMouseFuncUcall(void (*callback)(int, int, int, int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutMouseFuncUcall$address() {
        return glutMouseFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMouseFuncUcall(void (*callback)(int, int, int, int, void *), void *user_data)
     * }
     */
    public static void glutMouseFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutMouseFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMouseFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutMotionFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutMotionFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMotionFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutMotionFuncUcall$descriptor() {
        return glutMotionFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMotionFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutMotionFuncUcall$handle() {
        return glutMotionFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMotionFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutMotionFuncUcall$address() {
        return glutMotionFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMotionFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static void glutMotionFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutMotionFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMotionFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutPassiveMotionFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutPassiveMotionFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutPassiveMotionFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutPassiveMotionFuncUcall$descriptor() {
        return glutPassiveMotionFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutPassiveMotionFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutPassiveMotionFuncUcall$handle() {
        return glutPassiveMotionFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutPassiveMotionFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutPassiveMotionFuncUcall$address() {
        return glutPassiveMotionFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutPassiveMotionFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static void glutPassiveMotionFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutPassiveMotionFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutPassiveMotionFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutEntryFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutEntryFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutEntryFuncUcall(void (*callback)(int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutEntryFuncUcall$descriptor() {
        return glutEntryFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutEntryFuncUcall(void (*callback)(int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutEntryFuncUcall$handle() {
        return glutEntryFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutEntryFuncUcall(void (*callback)(int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutEntryFuncUcall$address() {
        return glutEntryFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutEntryFuncUcall(void (*callback)(int, void *), void *user_data)
     * }
     */
    public static void glutEntryFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutEntryFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutEntryFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutKeyboardUpFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutKeyboardUpFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutKeyboardUpFuncUcall(void (*callback)(unsigned char, int, int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutKeyboardUpFuncUcall$descriptor() {
        return glutKeyboardUpFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutKeyboardUpFuncUcall(void (*callback)(unsigned char, int, int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutKeyboardUpFuncUcall$handle() {
        return glutKeyboardUpFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutKeyboardUpFuncUcall(void (*callback)(unsigned char, int, int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutKeyboardUpFuncUcall$address() {
        return glutKeyboardUpFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutKeyboardUpFuncUcall(void (*callback)(unsigned char, int, int, void *), void *user_data)
     * }
     */
    public static void glutKeyboardUpFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutKeyboardUpFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutKeyboardUpFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSpecialUpFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSpecialUpFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSpecialUpFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutSpecialUpFuncUcall$descriptor() {
        return glutSpecialUpFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSpecialUpFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutSpecialUpFuncUcall$handle() {
        return glutSpecialUpFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSpecialUpFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutSpecialUpFuncUcall$address() {
        return glutSpecialUpFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSpecialUpFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static void glutSpecialUpFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutSpecialUpFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSpecialUpFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutJoystickFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_INT,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutJoystickFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutJoystickFuncUcall(void (*callback)(unsigned int, int, int, int, void *), int pollInterval, void *user_data)
     * }
     */
    public static FunctionDescriptor glutJoystickFuncUcall$descriptor() {
        return glutJoystickFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutJoystickFuncUcall(void (*callback)(unsigned int, int, int, int, void *), int pollInterval, void *user_data)
     * }
     */
    public static MethodHandle glutJoystickFuncUcall$handle() {
        return glutJoystickFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutJoystickFuncUcall(void (*callback)(unsigned int, int, int, int, void *), int pollInterval, void *user_data)
     * }
     */
    public static MemorySegment glutJoystickFuncUcall$address() {
        return glutJoystickFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutJoystickFuncUcall(void (*callback)(unsigned int, int, int, int, void *), int pollInterval, void *user_data)
     * }
     */
    public static void glutJoystickFuncUcall(MemorySegment callback, int pollInterval, MemorySegment user_data) {
        var mh$ = glutJoystickFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutJoystickFuncUcall", callback, pollInterval, user_data);
            }
            mh$.invokeExact(callback, pollInterval, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutMenuStatusFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutMenuStatusFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMenuStatusFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutMenuStatusFuncUcall$descriptor() {
        return glutMenuStatusFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMenuStatusFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutMenuStatusFuncUcall$handle() {
        return glutMenuStatusFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMenuStatusFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutMenuStatusFuncUcall$address() {
        return glutMenuStatusFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMenuStatusFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static void glutMenuStatusFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutMenuStatusFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMenuStatusFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutOverlayDisplayFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutOverlayDisplayFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutOverlayDisplayFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutOverlayDisplayFuncUcall$descriptor() {
        return glutOverlayDisplayFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutOverlayDisplayFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static MethodHandle glutOverlayDisplayFuncUcall$handle() {
        return glutOverlayDisplayFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutOverlayDisplayFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static MemorySegment glutOverlayDisplayFuncUcall$address() {
        return glutOverlayDisplayFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutOverlayDisplayFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static void glutOverlayDisplayFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutOverlayDisplayFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutOverlayDisplayFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWindowStatusFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutWindowStatusFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWindowStatusFuncUcall(void (*callback)(int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutWindowStatusFuncUcall$descriptor() {
        return glutWindowStatusFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWindowStatusFuncUcall(void (*callback)(int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutWindowStatusFuncUcall$handle() {
        return glutWindowStatusFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWindowStatusFuncUcall(void (*callback)(int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutWindowStatusFuncUcall$address() {
        return glutWindowStatusFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWindowStatusFuncUcall(void (*callback)(int, void *), void *user_data)
     * }
     */
    public static void glutWindowStatusFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutWindowStatusFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWindowStatusFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSpaceballMotionFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSpaceballMotionFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSpaceballMotionFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutSpaceballMotionFuncUcall$descriptor() {
        return glutSpaceballMotionFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSpaceballMotionFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutSpaceballMotionFuncUcall$handle() {
        return glutSpaceballMotionFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSpaceballMotionFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutSpaceballMotionFuncUcall$address() {
        return glutSpaceballMotionFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSpaceballMotionFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static void glutSpaceballMotionFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutSpaceballMotionFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSpaceballMotionFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSpaceballRotateFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSpaceballRotateFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSpaceballRotateFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutSpaceballRotateFuncUcall$descriptor() {
        return glutSpaceballRotateFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSpaceballRotateFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutSpaceballRotateFuncUcall$handle() {
        return glutSpaceballRotateFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSpaceballRotateFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutSpaceballRotateFuncUcall$address() {
        return glutSpaceballRotateFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSpaceballRotateFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static void glutSpaceballRotateFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutSpaceballRotateFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSpaceballRotateFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutSpaceballButtonFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutSpaceballButtonFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutSpaceballButtonFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutSpaceballButtonFuncUcall$descriptor() {
        return glutSpaceballButtonFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutSpaceballButtonFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutSpaceballButtonFuncUcall$handle() {
        return glutSpaceballButtonFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutSpaceballButtonFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutSpaceballButtonFuncUcall$address() {
        return glutSpaceballButtonFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutSpaceballButtonFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static void glutSpaceballButtonFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutSpaceballButtonFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutSpaceballButtonFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutButtonBoxFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutButtonBoxFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutButtonBoxFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutButtonBoxFuncUcall$descriptor() {
        return glutButtonBoxFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutButtonBoxFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutButtonBoxFuncUcall$handle() {
        return glutButtonBoxFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutButtonBoxFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutButtonBoxFuncUcall$address() {
        return glutButtonBoxFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutButtonBoxFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static void glutButtonBoxFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutButtonBoxFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutButtonBoxFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutDialsFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutDialsFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutDialsFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutDialsFuncUcall$descriptor() {
        return glutDialsFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutDialsFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutDialsFuncUcall$handle() {
        return glutDialsFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutDialsFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutDialsFuncUcall$address() {
        return glutDialsFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutDialsFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static void glutDialsFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutDialsFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutDialsFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutTabletMotionFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutTabletMotionFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutTabletMotionFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutTabletMotionFuncUcall$descriptor() {
        return glutTabletMotionFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutTabletMotionFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutTabletMotionFuncUcall$handle() {
        return glutTabletMotionFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutTabletMotionFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutTabletMotionFuncUcall$address() {
        return glutTabletMotionFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutTabletMotionFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static void glutTabletMotionFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutTabletMotionFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutTabletMotionFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutTabletButtonFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutTabletButtonFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutTabletButtonFuncUcall(void (*callback)(int, int, int, int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutTabletButtonFuncUcall$descriptor() {
        return glutTabletButtonFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutTabletButtonFuncUcall(void (*callback)(int, int, int, int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutTabletButtonFuncUcall$handle() {
        return glutTabletButtonFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutTabletButtonFuncUcall(void (*callback)(int, int, int, int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutTabletButtonFuncUcall$address() {
        return glutTabletButtonFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutTabletButtonFuncUcall(void (*callback)(int, int, int, int, void *), void *user_data)
     * }
     */
    public static void glutTabletButtonFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutTabletButtonFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutTabletButtonFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutMouseWheelFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutMouseWheelFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMouseWheelFuncUcall(void (*callback)(int, int, int, int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutMouseWheelFuncUcall$descriptor() {
        return glutMouseWheelFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMouseWheelFuncUcall(void (*callback)(int, int, int, int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutMouseWheelFuncUcall$handle() {
        return glutMouseWheelFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMouseWheelFuncUcall(void (*callback)(int, int, int, int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutMouseWheelFuncUcall$address() {
        return glutMouseWheelFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMouseWheelFuncUcall(void (*callback)(int, int, int, int, void *), void *user_data)
     * }
     */
    public static void glutMouseWheelFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutMouseWheelFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMouseWheelFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutPositionFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutPositionFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutPositionFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutPositionFuncUcall$descriptor() {
        return glutPositionFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutPositionFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutPositionFuncUcall$handle() {
        return glutPositionFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutPositionFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutPositionFuncUcall$address() {
        return glutPositionFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutPositionFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static void glutPositionFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutPositionFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutPositionFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutCloseFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutCloseFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutCloseFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutCloseFuncUcall$descriptor() {
        return glutCloseFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutCloseFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static MethodHandle glutCloseFuncUcall$handle() {
        return glutCloseFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutCloseFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static MemorySegment glutCloseFuncUcall$address() {
        return glutCloseFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutCloseFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static void glutCloseFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutCloseFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutCloseFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutWMCloseFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutWMCloseFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutWMCloseFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutWMCloseFuncUcall$descriptor() {
        return glutWMCloseFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutWMCloseFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static MethodHandle glutWMCloseFuncUcall$handle() {
        return glutWMCloseFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutWMCloseFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static MemorySegment glutWMCloseFuncUcall$address() {
        return glutWMCloseFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutWMCloseFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static void glutWMCloseFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutWMCloseFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutWMCloseFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutMenuDestroyFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutMenuDestroyFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMenuDestroyFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutMenuDestroyFuncUcall$descriptor() {
        return glutMenuDestroyFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMenuDestroyFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static MethodHandle glutMenuDestroyFuncUcall$handle() {
        return glutMenuDestroyFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMenuDestroyFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static MemorySegment glutMenuDestroyFuncUcall$address() {
        return glutMenuDestroyFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMenuDestroyFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static void glutMenuDestroyFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutMenuDestroyFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMenuDestroyFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutMultiEntryFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutMultiEntryFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMultiEntryFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutMultiEntryFuncUcall$descriptor() {
        return glutMultiEntryFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMultiEntryFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutMultiEntryFuncUcall$handle() {
        return glutMultiEntryFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMultiEntryFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutMultiEntryFuncUcall$address() {
        return glutMultiEntryFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMultiEntryFuncUcall(void (*callback)(int, int, void *), void *user_data)
     * }
     */
    public static void glutMultiEntryFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutMultiEntryFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMultiEntryFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutMultiButtonFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutMultiButtonFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMultiButtonFuncUcall(void (*callback)(int, int, int, int, int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutMultiButtonFuncUcall$descriptor() {
        return glutMultiButtonFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMultiButtonFuncUcall(void (*callback)(int, int, int, int, int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutMultiButtonFuncUcall$handle() {
        return glutMultiButtonFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMultiButtonFuncUcall(void (*callback)(int, int, int, int, int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutMultiButtonFuncUcall$address() {
        return glutMultiButtonFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMultiButtonFuncUcall(void (*callback)(int, int, int, int, int, void *), void *user_data)
     * }
     */
    public static void glutMultiButtonFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutMultiButtonFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMultiButtonFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutMultiMotionFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutMultiMotionFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMultiMotionFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutMultiMotionFuncUcall$descriptor() {
        return glutMultiMotionFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMultiMotionFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutMultiMotionFuncUcall$handle() {
        return glutMultiMotionFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMultiMotionFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutMultiMotionFuncUcall$address() {
        return glutMultiMotionFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMultiMotionFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static void glutMultiMotionFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutMultiMotionFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMultiMotionFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutMultiPassiveFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutMultiPassiveFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutMultiPassiveFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutMultiPassiveFuncUcall$descriptor() {
        return glutMultiPassiveFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutMultiPassiveFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutMultiPassiveFuncUcall$handle() {
        return glutMultiPassiveFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutMultiPassiveFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutMultiPassiveFuncUcall$address() {
        return glutMultiPassiveFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutMultiPassiveFuncUcall(void (*callback)(int, int, int, void *), void *user_data)
     * }
     */
    public static void glutMultiPassiveFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutMultiPassiveFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutMultiPassiveFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutInitErrorFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutInitErrorFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutInitErrorFuncUcall(void (*callback)(const char *, va_list, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutInitErrorFuncUcall$descriptor() {
        return glutInitErrorFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutInitErrorFuncUcall(void (*callback)(const char *, va_list, void *), void *user_data)
     * }
     */
    public static MethodHandle glutInitErrorFuncUcall$handle() {
        return glutInitErrorFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutInitErrorFuncUcall(void (*callback)(const char *, va_list, void *), void *user_data)
     * }
     */
    public static MemorySegment glutInitErrorFuncUcall$address() {
        return glutInitErrorFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutInitErrorFuncUcall(void (*callback)(const char *, va_list, void *), void *user_data)
     * }
     */
    public static void glutInitErrorFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutInitErrorFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutInitErrorFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutInitWarningFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutInitWarningFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutInitWarningFuncUcall(void (*callback)(const char *, va_list, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutInitWarningFuncUcall$descriptor() {
        return glutInitWarningFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutInitWarningFuncUcall(void (*callback)(const char *, va_list, void *), void *user_data)
     * }
     */
    public static MethodHandle glutInitWarningFuncUcall$handle() {
        return glutInitWarningFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutInitWarningFuncUcall(void (*callback)(const char *, va_list, void *), void *user_data)
     * }
     */
    public static MemorySegment glutInitWarningFuncUcall$address() {
        return glutInitWarningFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutInitWarningFuncUcall(void (*callback)(const char *, va_list, void *), void *user_data)
     * }
     */
    public static void glutInitWarningFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutInitWarningFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutInitWarningFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutInitContextFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutInitContextFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutInitContextFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutInitContextFuncUcall$descriptor() {
        return glutInitContextFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutInitContextFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static MethodHandle glutInitContextFuncUcall$handle() {
        return glutInitContextFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutInitContextFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static MemorySegment glutInitContextFuncUcall$address() {
        return glutInitContextFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutInitContextFuncUcall(void (*callback)(void *), void *user_data)
     * }
     */
    public static void glutInitContextFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutInitContextFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutInitContextFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glutAppStatusFuncUcall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            freeglut_h.C_POINTER,
            freeglut_h.C_POINTER
        );

        public static final MemorySegment ADDR = freeglut_h.findOrThrow("glutAppStatusFuncUcall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glutAppStatusFuncUcall(void (*callback)(int, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor glutAppStatusFuncUcall$descriptor() {
        return glutAppStatusFuncUcall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glutAppStatusFuncUcall(void (*callback)(int, void *), void *user_data)
     * }
     */
    public static MethodHandle glutAppStatusFuncUcall$handle() {
        return glutAppStatusFuncUcall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glutAppStatusFuncUcall(void (*callback)(int, void *), void *user_data)
     * }
     */
    public static MemorySegment glutAppStatusFuncUcall$address() {
        return glutAppStatusFuncUcall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glutAppStatusFuncUcall(void (*callback)(int, void *), void *user_data)
     * }
     */
    public static void glutAppStatusFuncUcall(MemorySegment callback, MemorySegment user_data) {
        var mh$ = glutAppStatusFuncUcall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glutAppStatusFuncUcall", callback, user_data);
            }
            mh$.invokeExact(callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * #define __DARWIN_SUF_EXTSN "$DARWIN_EXTSN"
     * }
     */
    public static MemorySegment __DARWIN_SUF_EXTSN() {
        class Holder {
            static final MemorySegment __DARWIN_SUF_EXTSN
                = freeglut_h.LIBRARY_ARENA.allocateFrom("$DARWIN_EXTSN");
        }
        return Holder.__DARWIN_SUF_EXTSN;
    }
    private static final long __DARWIN_C_ANSI = 4096L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_ANSI 4096
     * }
     */
    public static long __DARWIN_C_ANSI() {
        return __DARWIN_C_ANSI;
    }
    private static final long __DARWIN_C_FULL = 900000L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_FULL 900000
     * }
     */
    public static long __DARWIN_C_FULL() {
        return __DARWIN_C_FULL;
    }
    private static final long __DARWIN_C_LEVEL = 900000L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_LEVEL 900000
     * }
     */
    public static long __DARWIN_C_LEVEL() {
        return __DARWIN_C_LEVEL;
    }
    private static final MemorySegment __DARWIN_NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NULL (void*) 0
     * }
     */
    public static MemorySegment __DARWIN_NULL() {
        return __DARWIN_NULL;
    }
    private static final long USER_ADDR_NULL = 0L;
    /**
     * {@snippet lang=c :
     * #define USER_ADDR_NULL 0
     * }
     */
    public static long USER_ADDR_NULL() {
        return USER_ADDR_NULL;
    }
    private static final long INT64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT64_MAX 9223372036854775807
     * }
     */
    public static long INT64_MAX() {
        return INT64_MAX;
    }
    private static final int INT8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT8_MIN -128
     * }
     */
    public static int INT8_MIN() {
        return INT8_MIN;
    }
    private static final int INT16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT16_MIN -32768
     * }
     */
    public static int INT16_MIN() {
        return INT16_MIN;
    }
    private static final int INT32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT32_MIN -2147483648
     * }
     */
    public static int INT32_MIN() {
        return INT32_MIN;
    }
    private static final long INT64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT64_MIN -9223372036854775808
     * }
     */
    public static long INT64_MIN() {
        return INT64_MIN;
    }
    private static final int UINT32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT32_MAX 4294967295
     * }
     */
    public static int UINT32_MAX() {
        return UINT32_MAX;
    }
    private static final long UINT64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT64_MAX -1
     * }
     */
    public static long UINT64_MAX() {
        return UINT64_MAX;
    }
    private static final int INT_LEAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MIN -128
     * }
     */
    public static int INT_LEAST8_MIN() {
        return INT_LEAST8_MIN;
    }
    private static final int INT_LEAST16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MIN -32768
     * }
     */
    public static int INT_LEAST16_MIN() {
        return INT_LEAST16_MIN;
    }
    private static final int INT_LEAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MIN -2147483648
     * }
     */
    public static int INT_LEAST32_MIN() {
        return INT_LEAST32_MIN;
    }
    private static final long INT_LEAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_LEAST64_MIN() {
        return INT_LEAST64_MIN;
    }
    private static final int INT_LEAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MAX 127
     * }
     */
    public static int INT_LEAST8_MAX() {
        return INT_LEAST8_MAX;
    }
    private static final int INT_LEAST16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MAX 32767
     * }
     */
    public static int INT_LEAST16_MAX() {
        return INT_LEAST16_MAX;
    }
    private static final int INT_LEAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MAX 2147483647
     * }
     */
    public static int INT_LEAST32_MAX() {
        return INT_LEAST32_MAX;
    }
    private static final long INT_LEAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_LEAST64_MAX() {
        return INT_LEAST64_MAX;
    }
    private static final int UINT_LEAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST8_MAX 255
     * }
     */
    public static int UINT_LEAST8_MAX() {
        return UINT_LEAST8_MAX;
    }
    private static final int UINT_LEAST16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST16_MAX 65535
     * }
     */
    public static int UINT_LEAST16_MAX() {
        return UINT_LEAST16_MAX;
    }
    private static final int UINT_LEAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST32_MAX 4294967295
     * }
     */
    public static int UINT_LEAST32_MAX() {
        return UINT_LEAST32_MAX;
    }
    private static final long UINT_LEAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST64_MAX -1
     * }
     */
    public static long UINT_LEAST64_MAX() {
        return UINT_LEAST64_MAX;
    }
    private static final int INT_FAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MIN -128
     * }
     */
    public static int INT_FAST8_MIN() {
        return INT_FAST8_MIN;
    }
    private static final int INT_FAST16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MIN -32768
     * }
     */
    public static int INT_FAST16_MIN() {
        return INT_FAST16_MIN;
    }
    private static final int INT_FAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MIN -2147483648
     * }
     */
    public static int INT_FAST32_MIN() {
        return INT_FAST32_MIN;
    }
    private static final long INT_FAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST64_MIN() {
        return INT_FAST64_MIN;
    }
    private static final int INT_FAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MAX 127
     * }
     */
    public static int INT_FAST8_MAX() {
        return INT_FAST8_MAX;
    }
    private static final int INT_FAST16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MAX 32767
     * }
     */
    public static int INT_FAST16_MAX() {
        return INT_FAST16_MAX;
    }
    private static final int INT_FAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MAX 2147483647
     * }
     */
    public static int INT_FAST32_MAX() {
        return INT_FAST32_MAX;
    }
    private static final long INT_FAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST64_MAX() {
        return INT_FAST64_MAX;
    }
    private static final int UINT_FAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST8_MAX 255
     * }
     */
    public static int UINT_FAST8_MAX() {
        return UINT_FAST8_MAX;
    }
    private static final int UINT_FAST16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST16_MAX 65535
     * }
     */
    public static int UINT_FAST16_MAX() {
        return UINT_FAST16_MAX;
    }
    private static final int UINT_FAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST32_MAX 4294967295
     * }
     */
    public static int UINT_FAST32_MAX() {
        return UINT_FAST32_MAX;
    }
    private static final long UINT_FAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST64_MAX -1
     * }
     */
    public static long UINT_FAST64_MAX() {
        return UINT_FAST64_MAX;
    }
    private static final long INTPTR_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MAX 9223372036854775807
     * }
     */
    public static long INTPTR_MAX() {
        return INTPTR_MAX;
    }
    private static final long INTPTR_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MIN -9223372036854775808
     * }
     */
    public static long INTPTR_MIN() {
        return INTPTR_MIN;
    }
    private static final long UINTPTR_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTPTR_MAX -1
     * }
     */
    public static long UINTPTR_MAX() {
        return UINTPTR_MAX;
    }
    private static final long INTMAX_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MAX 9223372036854775807
     * }
     */
    public static long INTMAX_MAX() {
        return INTMAX_MAX;
    }
    private static final long UINTMAX_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTMAX_MAX -1
     * }
     */
    public static long UINTMAX_MAX() {
        return UINTMAX_MAX;
    }
    private static final long INTMAX_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MIN -9223372036854775808
     * }
     */
    public static long INTMAX_MIN() {
        return INTMAX_MIN;
    }
    private static final long PTRDIFF_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MIN -9223372036854775808
     * }
     */
    public static long PTRDIFF_MIN() {
        return PTRDIFF_MIN;
    }
    private static final long PTRDIFF_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MAX 9223372036854775807
     * }
     */
    public static long PTRDIFF_MAX() {
        return PTRDIFF_MAX;
    }
    private static final long SIZE_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define SIZE_MAX -1
     * }
     */
    public static long SIZE_MAX() {
        return SIZE_MAX;
    }
    private static final long RSIZE_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define RSIZE_MAX 9223372036854775807
     * }
     */
    public static long RSIZE_MAX() {
        return RSIZE_MAX;
    }
    private static final int WCHAR_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MAX 2147483647
     * }
     */
    public static int WCHAR_MAX() {
        return WCHAR_MAX;
    }
    private static final int WCHAR_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MIN -2147483648
     * }
     */
    public static int WCHAR_MIN() {
        return WCHAR_MIN;
    }
    private static final int WINT_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define WINT_MIN -2147483648
     * }
     */
    public static int WINT_MIN() {
        return WINT_MIN;
    }
    private static final int WINT_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define WINT_MAX 2147483647
     * }
     */
    public static int WINT_MAX() {
        return WINT_MAX;
    }
    private static final int SIG_ATOMIC_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MIN -2147483648
     * }
     */
    public static int SIG_ATOMIC_MIN() {
        return SIG_ATOMIC_MIN;
    }
    private static final int SIG_ATOMIC_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MAX 2147483647
     * }
     */
    public static int SIG_ATOMIC_MAX() {
        return SIG_ATOMIC_MAX;
    }
    private static final int GL_DRAW_FRAMEBUFFER_BINDING = (int)36006L;
    /**
     * {@snippet lang=c :
     * #define GL_DRAW_FRAMEBUFFER_BINDING 36006
     * }
     */
    public static int GL_DRAW_FRAMEBUFFER_BINDING() {
        return GL_DRAW_FRAMEBUFFER_BINDING;
    }
    private static final long GL_TIMEOUT_IGNORED = -1L;
    /**
     * {@snippet lang=c :
     * #define GL_TIMEOUT_IGNORED -1
     * }
     */
    public static long GL_TIMEOUT_IGNORED() {
        return GL_TIMEOUT_IGNORED;
    }
    private static final int __MAC_OS_X_VERSION_MAX_ALLOWED = (int)140400L;
    /**
     * {@snippet lang=c :
     * #define __MAC_OS_X_VERSION_MAX_ALLOWED 140400
     * }
     */
    public static int __MAC_OS_X_VERSION_MAX_ALLOWED() {
        return __MAC_OS_X_VERSION_MAX_ALLOWED;
    }
    private static final int GL_LOGIC_OP = (int)3057L;
    /**
     * {@snippet lang=c :
     * #define GL_LOGIC_OP 3057
     * }
     */
    public static int GL_LOGIC_OP() {
        return GL_LOGIC_OP;
    }
    private static final int GL_TEXTURE_COMPONENTS = (int)4099L;
    /**
     * {@snippet lang=c :
     * #define GL_TEXTURE_COMPONENTS 4099
     * }
     */
    public static int GL_TEXTURE_COMPONENTS() {
        return GL_TEXTURE_COMPONENTS;
    }
    private static final int GL_CLIENT_ALL_ATTRIB_BITS = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define GL_CLIENT_ALL_ATTRIB_BITS 4294967295
     * }
     */
    public static int GL_CLIENT_ALL_ATTRIB_BITS() {
        return GL_CLIENT_ALL_ATTRIB_BITS;
    }
    private static final double GLU_TESS_MAX_COORD = 1.0E150d;
    /**
     * {@snippet lang=c :
     * #define GLU_TESS_MAX_COORD 1.0E150
     * }
     */
    public static double GLU_TESS_MAX_COORD() {
        return GLU_TESS_MAX_COORD;
    }
    private static final int MAC_OS_X_VERSION_10_0 = (int)1000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_0 1000
     * }
     */
    public static int MAC_OS_X_VERSION_10_0() {
        return MAC_OS_X_VERSION_10_0;
    }
    private static final int MAC_OS_X_VERSION_10_1 = (int)1010L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_1 1010
     * }
     */
    public static int MAC_OS_X_VERSION_10_1() {
        return MAC_OS_X_VERSION_10_1;
    }
    private static final int MAC_OS_X_VERSION_10_2 = (int)1020L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_2 1020
     * }
     */
    public static int MAC_OS_X_VERSION_10_2() {
        return MAC_OS_X_VERSION_10_2;
    }
    private static final int MAC_OS_X_VERSION_10_3 = (int)1030L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_3 1030
     * }
     */
    public static int MAC_OS_X_VERSION_10_3() {
        return MAC_OS_X_VERSION_10_3;
    }
    private static final int MAC_OS_X_VERSION_10_4 = (int)1040L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_4 1040
     * }
     */
    public static int MAC_OS_X_VERSION_10_4() {
        return MAC_OS_X_VERSION_10_4;
    }
    private static final int MAC_OS_X_VERSION_10_5 = (int)1050L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_5 1050
     * }
     */
    public static int MAC_OS_X_VERSION_10_5() {
        return MAC_OS_X_VERSION_10_5;
    }
    private static final int MAC_OS_X_VERSION_10_6 = (int)1060L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_6 1060
     * }
     */
    public static int MAC_OS_X_VERSION_10_6() {
        return MAC_OS_X_VERSION_10_6;
    }
    private static final int MAC_OS_X_VERSION_10_7 = (int)1070L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_7 1070
     * }
     */
    public static int MAC_OS_X_VERSION_10_7() {
        return MAC_OS_X_VERSION_10_7;
    }
    private static final int MAC_OS_X_VERSION_10_8 = (int)1080L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_8 1080
     * }
     */
    public static int MAC_OS_X_VERSION_10_8() {
        return MAC_OS_X_VERSION_10_8;
    }
    private static final int MAC_OS_X_VERSION_10_9 = (int)1090L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_9 1090
     * }
     */
    public static int MAC_OS_X_VERSION_10_9() {
        return MAC_OS_X_VERSION_10_9;
    }
    private static final int MAC_OS_X_VERSION_10_10 = (int)101000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_10 101000
     * }
     */
    public static int MAC_OS_X_VERSION_10_10() {
        return MAC_OS_X_VERSION_10_10;
    }
    private static final int MAC_OS_X_VERSION_10_10_2 = (int)101002L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_10_2 101002
     * }
     */
    public static int MAC_OS_X_VERSION_10_10_2() {
        return MAC_OS_X_VERSION_10_10_2;
    }
    private static final int MAC_OS_X_VERSION_10_10_3 = (int)101003L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_10_3 101003
     * }
     */
    public static int MAC_OS_X_VERSION_10_10_3() {
        return MAC_OS_X_VERSION_10_10_3;
    }
    private static final int MAC_OS_X_VERSION_10_11 = (int)101100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11 101100
     * }
     */
    public static int MAC_OS_X_VERSION_10_11() {
        return MAC_OS_X_VERSION_10_11;
    }
    private static final int MAC_OS_X_VERSION_10_11_2 = (int)101102L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11_2 101102
     * }
     */
    public static int MAC_OS_X_VERSION_10_11_2() {
        return MAC_OS_X_VERSION_10_11_2;
    }
    private static final int MAC_OS_X_VERSION_10_11_3 = (int)101103L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11_3 101103
     * }
     */
    public static int MAC_OS_X_VERSION_10_11_3() {
        return MAC_OS_X_VERSION_10_11_3;
    }
    private static final int MAC_OS_X_VERSION_10_11_4 = (int)101104L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11_4 101104
     * }
     */
    public static int MAC_OS_X_VERSION_10_11_4() {
        return MAC_OS_X_VERSION_10_11_4;
    }
    private static final int MAC_OS_X_VERSION_10_12 = (int)101200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12 101200
     * }
     */
    public static int MAC_OS_X_VERSION_10_12() {
        return MAC_OS_X_VERSION_10_12;
    }
    private static final int MAC_OS_X_VERSION_10_12_1 = (int)101201L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12_1 101201
     * }
     */
    public static int MAC_OS_X_VERSION_10_12_1() {
        return MAC_OS_X_VERSION_10_12_1;
    }
    private static final int MAC_OS_X_VERSION_10_12_2 = (int)101202L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12_2 101202
     * }
     */
    public static int MAC_OS_X_VERSION_10_12_2() {
        return MAC_OS_X_VERSION_10_12_2;
    }
    private static final int MAC_OS_X_VERSION_10_12_4 = (int)101204L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12_4 101204
     * }
     */
    public static int MAC_OS_X_VERSION_10_12_4() {
        return MAC_OS_X_VERSION_10_12_4;
    }
    private static final int MAC_OS_X_VERSION_10_13 = (int)101300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13 101300
     * }
     */
    public static int MAC_OS_X_VERSION_10_13() {
        return MAC_OS_X_VERSION_10_13;
    }
    private static final int MAC_OS_X_VERSION_10_13_1 = (int)101301L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13_1 101301
     * }
     */
    public static int MAC_OS_X_VERSION_10_13_1() {
        return MAC_OS_X_VERSION_10_13_1;
    }
    private static final int MAC_OS_X_VERSION_10_13_2 = (int)101302L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13_2 101302
     * }
     */
    public static int MAC_OS_X_VERSION_10_13_2() {
        return MAC_OS_X_VERSION_10_13_2;
    }
    private static final int MAC_OS_X_VERSION_10_13_4 = (int)101304L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13_4 101304
     * }
     */
    public static int MAC_OS_X_VERSION_10_13_4() {
        return MAC_OS_X_VERSION_10_13_4;
    }
    private static final int MAC_OS_X_VERSION_10_14 = (int)101400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14 101400
     * }
     */
    public static int MAC_OS_X_VERSION_10_14() {
        return MAC_OS_X_VERSION_10_14;
    }
    private static final int MAC_OS_X_VERSION_10_14_1 = (int)101401L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_1 101401
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_1() {
        return MAC_OS_X_VERSION_10_14_1;
    }
    private static final int MAC_OS_X_VERSION_10_14_4 = (int)101404L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_4 101404
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_4() {
        return MAC_OS_X_VERSION_10_14_4;
    }
    private static final int MAC_OS_X_VERSION_10_14_5 = (int)101405L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_5 101405
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_5() {
        return MAC_OS_X_VERSION_10_14_5;
    }
    private static final int MAC_OS_X_VERSION_10_14_6 = (int)101406L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_6 101406
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_6() {
        return MAC_OS_X_VERSION_10_14_6;
    }
    private static final int MAC_OS_X_VERSION_10_15 = (int)101500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_15 101500
     * }
     */
    public static int MAC_OS_X_VERSION_10_15() {
        return MAC_OS_X_VERSION_10_15;
    }
    private static final int MAC_OS_X_VERSION_10_15_1 = (int)101501L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_15_1 101501
     * }
     */
    public static int MAC_OS_X_VERSION_10_15_1() {
        return MAC_OS_X_VERSION_10_15_1;
    }
    private static final int MAC_OS_X_VERSION_10_15_4 = (int)101504L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_15_4 101504
     * }
     */
    public static int MAC_OS_X_VERSION_10_15_4() {
        return MAC_OS_X_VERSION_10_15_4;
    }
    private static final int MAC_OS_X_VERSION_10_16 = (int)101600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_16 101600
     * }
     */
    public static int MAC_OS_X_VERSION_10_16() {
        return MAC_OS_X_VERSION_10_16;
    }
    private static final int MAC_OS_VERSION_11_0 = (int)110000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_0 110000
     * }
     */
    public static int MAC_OS_VERSION_11_0() {
        return MAC_OS_VERSION_11_0;
    }
    private static final int MAC_OS_VERSION_11_1 = (int)110100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_1 110100
     * }
     */
    public static int MAC_OS_VERSION_11_1() {
        return MAC_OS_VERSION_11_1;
    }
    private static final int MAC_OS_VERSION_11_3 = (int)110300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_3 110300
     * }
     */
    public static int MAC_OS_VERSION_11_3() {
        return MAC_OS_VERSION_11_3;
    }
    private static final int MAC_OS_VERSION_11_4 = (int)110400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_4 110400
     * }
     */
    public static int MAC_OS_VERSION_11_4() {
        return MAC_OS_VERSION_11_4;
    }
    private static final int MAC_OS_VERSION_11_5 = (int)110500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_5 110500
     * }
     */
    public static int MAC_OS_VERSION_11_5() {
        return MAC_OS_VERSION_11_5;
    }
    private static final int MAC_OS_VERSION_11_6 = (int)110600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_6 110600
     * }
     */
    public static int MAC_OS_VERSION_11_6() {
        return MAC_OS_VERSION_11_6;
    }
    private static final int MAC_OS_VERSION_12_0 = (int)120000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_0 120000
     * }
     */
    public static int MAC_OS_VERSION_12_0() {
        return MAC_OS_VERSION_12_0;
    }
    private static final int MAC_OS_VERSION_12_1 = (int)120100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_1 120100
     * }
     */
    public static int MAC_OS_VERSION_12_1() {
        return MAC_OS_VERSION_12_1;
    }
    private static final int MAC_OS_VERSION_12_2 = (int)120200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_2 120200
     * }
     */
    public static int MAC_OS_VERSION_12_2() {
        return MAC_OS_VERSION_12_2;
    }
    private static final int MAC_OS_VERSION_12_3 = (int)120300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_3 120300
     * }
     */
    public static int MAC_OS_VERSION_12_3() {
        return MAC_OS_VERSION_12_3;
    }
    private static final int MAC_OS_VERSION_12_4 = (int)120400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_4 120400
     * }
     */
    public static int MAC_OS_VERSION_12_4() {
        return MAC_OS_VERSION_12_4;
    }
    private static final int MAC_OS_VERSION_12_5 = (int)120500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_5 120500
     * }
     */
    public static int MAC_OS_VERSION_12_5() {
        return MAC_OS_VERSION_12_5;
    }
    private static final int MAC_OS_VERSION_12_6 = (int)120600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_6 120600
     * }
     */
    public static int MAC_OS_VERSION_12_6() {
        return MAC_OS_VERSION_12_6;
    }
    private static final int MAC_OS_VERSION_12_7 = (int)120700L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_7 120700
     * }
     */
    public static int MAC_OS_VERSION_12_7() {
        return MAC_OS_VERSION_12_7;
    }
    private static final int MAC_OS_VERSION_13_0 = (int)130000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_0 130000
     * }
     */
    public static int MAC_OS_VERSION_13_0() {
        return MAC_OS_VERSION_13_0;
    }
    private static final int MAC_OS_VERSION_13_1 = (int)130100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_1 130100
     * }
     */
    public static int MAC_OS_VERSION_13_1() {
        return MAC_OS_VERSION_13_1;
    }
    private static final int MAC_OS_VERSION_13_2 = (int)130200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_2 130200
     * }
     */
    public static int MAC_OS_VERSION_13_2() {
        return MAC_OS_VERSION_13_2;
    }
    private static final int MAC_OS_VERSION_13_3 = (int)130300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_3 130300
     * }
     */
    public static int MAC_OS_VERSION_13_3() {
        return MAC_OS_VERSION_13_3;
    }
    private static final int MAC_OS_VERSION_13_4 = (int)130400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_4 130400
     * }
     */
    public static int MAC_OS_VERSION_13_4() {
        return MAC_OS_VERSION_13_4;
    }
    private static final int MAC_OS_VERSION_13_5 = (int)130500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_5 130500
     * }
     */
    public static int MAC_OS_VERSION_13_5() {
        return MAC_OS_VERSION_13_5;
    }
    private static final int MAC_OS_VERSION_13_6 = (int)130600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_6 130600
     * }
     */
    public static int MAC_OS_VERSION_13_6() {
        return MAC_OS_VERSION_13_6;
    }
    private static final int MAC_OS_VERSION_14_0 = (int)140000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_0 140000
     * }
     */
    public static int MAC_OS_VERSION_14_0() {
        return MAC_OS_VERSION_14_0;
    }
    private static final int MAC_OS_VERSION_14_1 = (int)140100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_1 140100
     * }
     */
    public static int MAC_OS_VERSION_14_1() {
        return MAC_OS_VERSION_14_1;
    }
    private static final int MAC_OS_VERSION_14_2 = (int)140200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_2 140200
     * }
     */
    public static int MAC_OS_VERSION_14_2() {
        return MAC_OS_VERSION_14_2;
    }
    private static final int MAC_OS_VERSION_14_3 = (int)140300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_3 140300
     * }
     */
    public static int MAC_OS_VERSION_14_3() {
        return MAC_OS_VERSION_14_3;
    }
    private static final int MAC_OS_VERSION_14_4 = (int)140400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_4 140400
     * }
     */
    public static int MAC_OS_VERSION_14_4() {
        return MAC_OS_VERSION_14_4;
    }
    private static final int __DARWIN_WCHAR_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_WCHAR_MAX 2147483647
     * }
     */
    public static int __DARWIN_WCHAR_MAX() {
        return __DARWIN_WCHAR_MAX;
    }
    private static final int __DARWIN_WCHAR_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_WCHAR_MIN -2147483648
     * }
     */
    public static int __DARWIN_WCHAR_MIN() {
        return __DARWIN_WCHAR_MIN;
    }
    private static final int __DARWIN_WEOF = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_WEOF -1
     * }
     */
    public static int __DARWIN_WEOF() {
        return __DARWIN_WEOF;
    }
    private static final int NSIG = (int)32L;
    /**
     * {@snippet lang=c :
     * #define NSIG 32
     * }
     */
    public static int NSIG() {
        return NSIG;
    }
    private static final int SIGIOT = (int)6L;
    /**
     * {@snippet lang=c :
     * #define SIGIOT 6
     * }
     */
    public static int SIGIOT() {
        return SIGIOT;
    }
    private static final MemorySegment SIG_DFL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define SIG_DFL (void*) 0
     * }
     */
    public static MemorySegment SIG_DFL() {
        return SIG_DFL;
    }
    private static final MemorySegment SIG_IGN = MemorySegment.ofAddress(1L);
    /**
     * {@snippet lang=c :
     * #define SIG_IGN (void*) 1
     * }
     */
    public static MemorySegment SIG_IGN() {
        return SIG_IGN;
    }
    private static final MemorySegment SIG_HOLD = MemorySegment.ofAddress(5L);
    /**
     * {@snippet lang=c :
     * #define SIG_HOLD (void*) 5
     * }
     */
    public static MemorySegment SIG_HOLD() {
        return SIG_HOLD;
    }
    private static final MemorySegment SIG_ERR = MemorySegment.ofAddress(-1L);
    /**
     * {@snippet lang=c :
     * #define SIG_ERR (void*) -1
     * }
     */
    public static MemorySegment SIG_ERR() {
        return SIG_ERR;
    }
    private static final int SA_USERSPACE_MASK = (int)127L;
    /**
     * {@snippet lang=c :
     * #define SA_USERSPACE_MASK 127
     * }
     */
    public static int SA_USERSPACE_MASK() {
        return SA_USERSPACE_MASK;
    }
    private static final int SV_ONSTACK = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SV_ONSTACK 1
     * }
     */
    public static int SV_ONSTACK() {
        return SV_ONSTACK;
    }
    private static final int SV_INTERRUPT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SV_INTERRUPT 2
     * }
     */
    public static int SV_INTERRUPT() {
        return SV_INTERRUPT;
    }
    private static final int SV_RESETHAND = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SV_RESETHAND 4
     * }
     */
    public static int SV_RESETHAND() {
        return SV_RESETHAND;
    }
    private static final int SV_NODEFER = (int)16L;
    /**
     * {@snippet lang=c :
     * #define SV_NODEFER 16
     * }
     */
    public static int SV_NODEFER() {
        return SV_NODEFER;
    }
    private static final int SV_NOCLDSTOP = (int)8L;
    /**
     * {@snippet lang=c :
     * #define SV_NOCLDSTOP 8
     * }
     */
    public static int SV_NOCLDSTOP() {
        return SV_NOCLDSTOP;
    }
    private static final int SV_SIGINFO = (int)64L;
    /**
     * {@snippet lang=c :
     * #define SV_SIGINFO 64
     * }
     */
    public static int SV_SIGINFO() {
        return SV_SIGINFO;
    }
    private static final MemorySegment BADSIG = MemorySegment.ofAddress(-1L);
    /**
     * {@snippet lang=c :
     * #define BADSIG (void*) -1
     * }
     */
    public static MemorySegment BADSIG() {
        return BADSIG;
    }
    private static final int PRIO_MIN = (int)-20L;
    /**
     * {@snippet lang=c :
     * #define PRIO_MIN -20
     * }
     */
    public static int PRIO_MIN() {
        return PRIO_MIN;
    }
    private static final int RUSAGE_CHILDREN = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_CHILDREN -1
     * }
     */
    public static int RUSAGE_CHILDREN() {
        return RUSAGE_CHILDREN;
    }
    private static final int RUSAGE_INFO_CURRENT = (int)6L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_INFO_CURRENT 6
     * }
     */
    public static int RUSAGE_INFO_CURRENT() {
        return RUSAGE_INFO_CURRENT;
    }
    private static final long RLIM_INFINITY = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define RLIM_INFINITY 9223372036854775807
     * }
     */
    public static long RLIM_INFINITY() {
        return RLIM_INFINITY;
    }
    private static final long RLIM_SAVED_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define RLIM_SAVED_MAX 9223372036854775807
     * }
     */
    public static long RLIM_SAVED_MAX() {
        return RLIM_SAVED_MAX;
    }
    private static final long RLIM_SAVED_CUR = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define RLIM_SAVED_CUR 9223372036854775807
     * }
     */
    public static long RLIM_SAVED_CUR() {
        return RLIM_SAVED_CUR;
    }
    private static final int RLIMIT_RSS = (int)5L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_RSS 5
     * }
     */
    public static int RLIMIT_RSS() {
        return RLIMIT_RSS;
    }
    private static final int IOPOL_APPLICATION = (int)5L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_APPLICATION 5
     * }
     */
    public static int IOPOL_APPLICATION() {
        return IOPOL_APPLICATION;
    }
    private static final int IOPOL_NORMAL = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_NORMAL 1
     * }
     */
    public static int IOPOL_NORMAL() {
        return IOPOL_NORMAL;
    }
    private static final int WAIT_ANY = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define WAIT_ANY -1
     * }
     */
    public static int WAIT_ANY() {
        return WAIT_ANY;
    }
    private static final int __DARWIN_BYTE_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_BYTE_ORDER 1234
     * }
     */
    public static int __DARWIN_BYTE_ORDER() {
        return __DARWIN_BYTE_ORDER;
    }
    private static final int LITTLE_ENDIAN = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define LITTLE_ENDIAN 1234
     * }
     */
    public static int LITTLE_ENDIAN() {
        return LITTLE_ENDIAN;
    }
    private static final int BIG_ENDIAN = (int)4321L;
    /**
     * {@snippet lang=c :
     * #define BIG_ENDIAN 4321
     * }
     */
    public static int BIG_ENDIAN() {
        return BIG_ENDIAN;
    }
    private static final int PDP_ENDIAN = (int)3412L;
    /**
     * {@snippet lang=c :
     * #define PDP_ENDIAN 3412
     * }
     */
    public static int PDP_ENDIAN() {
        return PDP_ENDIAN;
    }
    private static final int BYTE_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define BYTE_ORDER 1234
     * }
     */
    public static int BYTE_ORDER() {
        return BYTE_ORDER;
    }
    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NULL (void*) 0
     * }
     */
    public static MemorySegment NULL() {
        return NULL;
    }
}

